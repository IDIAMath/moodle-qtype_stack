/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 66);
/******/ })
/************************************************************************/
/******/ ([
/* 0 */
/***/ (function(module, exports, __webpack_require__) {

	exports.Axis = __webpack_require__(72);

	exports.Data = __webpack_require__(73);
	
	exports.Ease = __webpack_require__(74);
	
	exports.GLSL = __webpack_require__(75);
	
	exports.JS = __webpack_require__(76);
	
	exports.Pretty = __webpack_require__(77);
	
	exports.Three = __webpack_require__(78);
	
	exports.Ticks = __webpack_require__(79);
	
	exports.VDOM = __webpack_require__(80);
	
	
	/***/ }),
	/* 1 */
	/***/ (function(module, __webpack_exports__, __webpack_require__) {
	
	"use strict";
	__webpack_require__.r(__webpack_exports__);
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLMultisampleRenderTarget", function() { return WebGLMultisampleRenderTarget; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTargetCube", function() { return WebGLRenderTargetCube; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderTarget", function() { return WebGLRenderTarget; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLRenderer", function() { return WebGLRenderer; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderLib", function() { return ShaderLib; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsLib", function() { return UniformsLib; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UniformsUtils", function() { return UniformsUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderChunk", function() { return ShaderChunk; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FogExp2", function() { return FogExp2; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Fog", function() { return Fog; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Scene", function() { return Scene; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sprite", function() { return Sprite; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LOD", function() { return LOD; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkinnedMesh", function() { return SkinnedMesh; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Skeleton", function() { return Skeleton; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Bone", function() { return Bone; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Mesh", function() { return Mesh; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineSegments", function() { return LineSegments; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineLoop", function() { return LineLoop; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line", function() { return Line; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Points", function() { return Points; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Group", function() { return Group; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VideoTexture", function() { return VideoTexture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture", function() { return DataTexture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTexture3D", function() { return DataTexture3D; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTexture", function() { return CompressedTexture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTexture", function() { return CubeTexture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasTexture", function() { return CanvasTexture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthTexture", function() { return DepthTexture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Texture", function() { return Texture; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationLoader", function() { return AnimationLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CompressedTextureLoader", function() { return CompressedTextureLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DataTextureLoader", function() { return DataTextureLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeTextureLoader", function() { return CubeTextureLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextureLoader", function() { return TextureLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectLoader", function() { return ObjectLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaterialLoader", function() { return MaterialLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometryLoader", function() { return BufferGeometryLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DefaultLoadingManager", function() { return DefaultLoadingManager; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoadingManager", function() { return LoadingManager; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageLoader", function() { return ImageLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageBitmapLoader", function() { return ImageBitmapLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FontLoader", function() { return FontLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FileLoader", function() { return FileLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Loader", function() { return Loader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoaderUtils", function() { return LoaderUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cache", function() { return Cache; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioLoader", function() { return AudioLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightShadow", function() { return SpotLightShadow; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLight", function() { return SpotLight; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLight", function() { return PointLight; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLight", function() { return RectAreaLight; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLight", function() { return HemisphereLight; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightShadow", function() { return DirectionalLightShadow; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLight", function() { return DirectionalLight; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AmbientLight", function() { return AmbientLight; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LightShadow", function() { return LightShadow; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Light", function() { return Light; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StereoCamera", function() { return StereoCamera; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PerspectiveCamera", function() { return PerspectiveCamera; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OrthographicCamera", function() { return OrthographicCamera; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeCamera", function() { return CubeCamera; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrayCamera", function() { return ArrayCamera; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Camera", function() { return Camera; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioListener", function() { return AudioListener; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PositionalAudio", function() { return PositionalAudio; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioContext", function() { return AudioContext; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AudioAnalyser", function() { return AudioAnalyser; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Audio", function() { return Audio; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VectorKeyframeTrack", function() { return VectorKeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "StringKeyframeTrack", function() { return StringKeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionKeyframeTrack", function() { return QuaternionKeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NumberKeyframeTrack", function() { return NumberKeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ColorKeyframeTrack", function() { return ColorKeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BooleanKeyframeTrack", function() { return BooleanKeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyMixer", function() { return PropertyMixer; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PropertyBinding", function() { return PropertyBinding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "KeyframeTrack", function() { return KeyframeTrack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationUtils", function() { return AnimationUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationObjectGroup", function() { return AnimationObjectGroup; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationMixer", function() { return AnimationMixer; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AnimationClip", function() { return AnimationClip; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uniform", function() { return Uniform; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferGeometry", function() { return InstancedBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferGeometry", function() { return BufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Geometry", function() { return Geometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBufferAttribute", function() { return InterleavedBufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedInterleavedBuffer", function() { return InstancedInterleavedBuffer; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterleavedBuffer", function() { return InterleavedBuffer; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InstancedBufferAttribute", function() { return InstancedBufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face3", function() { return Face3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Object3D", function() { return Object3D; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Raycaster", function() { return Raycaster; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Layers", function() { return Layers; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EventDispatcher", function() { return EventDispatcher; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Clock", function() { return Clock; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuaternionLinearInterpolant", function() { return QuaternionLinearInterpolant; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearInterpolant", function() { return LinearInterpolant; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DiscreteInterpolant", function() { return DiscreteInterpolant; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicInterpolant", function() { return CubicInterpolant; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Interpolant", function() { return Interpolant; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Triangle", function() { return Triangle; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Math", function() { return _Math; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spherical", function() { return Spherical; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Cylindrical", function() { return Cylindrical; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Plane", function() { return Plane; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Frustum", function() { return Frustum; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Sphere", function() { return Sphere; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Ray", function() { return Ray; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix4", function() { return Matrix4; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Matrix3", function() { return Matrix3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3", function() { return Box3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box2", function() { return Box2; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Line3", function() { return Line3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Euler", function() { return Euler; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector4", function() { return Vector4; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector3", function() { return Vector3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vector2", function() { return Vector2; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Quaternion", function() { return Quaternion; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Color", function() { return Color; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImmediateRenderObject", function() { return ImmediateRenderObject; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexNormalsHelper", function() { return VertexNormalsHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpotLightHelper", function() { return SpotLightHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SkeletonHelper", function() { return SkeletonHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointLightHelper", function() { return PointLightHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RectAreaLightHelper", function() { return RectAreaLightHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HemisphereLightHelper", function() { return HemisphereLightHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GridHelper", function() { return GridHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolarGridHelper", function() { return PolarGridHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceNormalsHelper", function() { return FaceNormalsHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DirectionalLightHelper", function() { return DirectionalLightHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CameraHelper", function() { return CameraHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxHelper", function() { return BoxHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Box3Helper", function() { return Box3Helper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneHelper", function() { return PlaneHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArrowHelper", function() { return ArrowHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxesHelper", function() { return AxesHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Shape", function() { return Shape; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Path", function() { return Path; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapePath", function() { return ShapePath; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Font", function() { return Font; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CurvePath", function() { return CurvePath; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Curve", function() { return Curve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ImageUtils", function() { return ImageUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeUtils", function() { return ShapeUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WebGLUtils", function() { return WebGLUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeGeometry", function() { return WireframeGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricGeometry", function() { return ParametricGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParametricBufferGeometry", function() { return ParametricBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronGeometry", function() { return TetrahedronGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TetrahedronBufferGeometry", function() { return TetrahedronBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronGeometry", function() { return OctahedronGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OctahedronBufferGeometry", function() { return OctahedronBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronGeometry", function() { return IcosahedronGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IcosahedronBufferGeometry", function() { return IcosahedronBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronGeometry", function() { return DodecahedronGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DodecahedronBufferGeometry", function() { return DodecahedronBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronGeometry", function() { return PolyhedronGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PolyhedronBufferGeometry", function() { return PolyhedronBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeGeometry", function() { return TubeGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TubeBufferGeometry", function() { return TubeBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotGeometry", function() { return TorusKnotGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusKnotBufferGeometry", function() { return TorusKnotBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusGeometry", function() { return TorusGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TorusBufferGeometry", function() { return TorusBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextGeometry", function() { return TextGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TextBufferGeometry", function() { return TextBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereGeometry", function() { return SphereGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphereBufferGeometry", function() { return SphereBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingGeometry", function() { return RingGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RingBufferGeometry", function() { return RingBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneGeometry", function() { return PlaneGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PlaneBufferGeometry", function() { return PlaneBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheGeometry", function() { return LatheGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LatheBufferGeometry", function() { return LatheBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeGeometry", function() { return ShapeGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShapeBufferGeometry", function() { return ShapeBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeGeometry", function() { return ExtrudeGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ExtrudeBufferGeometry", function() { return ExtrudeBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesGeometry", function() { return EdgesGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeGeometry", function() { return ConeGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ConeBufferGeometry", function() { return ConeBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderGeometry", function() { return CylinderGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CylinderBufferGeometry", function() { return CylinderBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleGeometry", function() { return CircleGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CircleBufferGeometry", function() { return CircleBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxGeometry", function() { return BoxGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoxBufferGeometry", function() { return BoxBufferGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShadowMaterial", function() { return ShadowMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SpriteMaterial", function() { return SpriteMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RawShaderMaterial", function() { return RawShaderMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShaderMaterial", function() { return ShaderMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointsMaterial", function() { return PointsMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhysicalMaterial", function() { return MeshPhysicalMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshStandardMaterial", function() { return MeshStandardMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshPhongMaterial", function() { return MeshPhongMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshToonMaterial", function() { return MeshToonMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshNormalMaterial", function() { return MeshNormalMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshLambertMaterial", function() { return MeshLambertMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDepthMaterial", function() { return MeshDepthMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshDistanceMaterial", function() { return MeshDistanceMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshBasicMaterial", function() { return MeshBasicMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshMatcapMaterial", function() { return MeshMatcapMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineDashedMaterial", function() { return LineDashedMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineBasicMaterial", function() { return LineBasicMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Material", function() { return Material; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64BufferAttribute", function() { return Float64BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32BufferAttribute", function() { return Float32BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32BufferAttribute", function() { return Uint32BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32BufferAttribute", function() { return Int32BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16BufferAttribute", function() { return Uint16BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16BufferAttribute", function() { return Int16BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedBufferAttribute", function() { return Uint8ClampedBufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8BufferAttribute", function() { return Uint8BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8BufferAttribute", function() { return Int8BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BufferAttribute", function() { return BufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ArcCurve", function() { return ArcCurve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CatmullRomCurve3", function() { return CatmullRomCurve3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve", function() { return CubicBezierCurve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubicBezierCurve3", function() { return CubicBezierCurve3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EllipseCurve", function() { return EllipseCurve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve", function() { return LineCurve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineCurve3", function() { return LineCurve3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve", function() { return QuadraticBezierCurve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "QuadraticBezierCurve3", function() { return QuadraticBezierCurve3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve", function() { return SplineCurve; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "REVISION", function() { return REVISION; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MOUSE", function() { return MOUSE; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceNone", function() { return CullFaceNone; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceBack", function() { return CullFaceBack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFront", function() { return CullFaceFront; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CullFaceFrontBack", function() { return CullFaceFrontBack; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCW", function() { return FrontFaceDirectionCW; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontFaceDirectionCCW", function() { return FrontFaceDirectionCCW; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicShadowMap", function() { return BasicShadowMap; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFShadowMap", function() { return PCFShadowMap; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PCFSoftShadowMap", function() { return PCFSoftShadowMap; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FrontSide", function() { return FrontSide; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BackSide", function() { return BackSide; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DoubleSide", function() { return DoubleSide; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FlatShading", function() { return FlatShading; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SmoothShading", function() { return SmoothShading; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoColors", function() { return NoColors; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FaceColors", function() { return FaceColors; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "VertexColors", function() { return VertexColors; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoBlending", function() { return NoBlending; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NormalBlending", function() { return NormalBlending; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AdditiveBlending", function() { return AdditiveBlending; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractiveBlending", function() { return SubtractiveBlending; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyBlending", function() { return MultiplyBlending; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CustomBlending", function() { return CustomBlending; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddEquation", function() { return AddEquation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SubtractEquation", function() { return SubtractEquation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReverseSubtractEquation", function() { return ReverseSubtractEquation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MinEquation", function() { return MinEquation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MaxEquation", function() { return MaxEquation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroFactor", function() { return ZeroFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneFactor", function() { return OneFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcColorFactor", function() { return SrcColorFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcColorFactor", function() { return OneMinusSrcColorFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaFactor", function() { return SrcAlphaFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusSrcAlphaFactor", function() { return OneMinusSrcAlphaFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstAlphaFactor", function() { return DstAlphaFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstAlphaFactor", function() { return OneMinusDstAlphaFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DstColorFactor", function() { return DstColorFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "OneMinusDstColorFactor", function() { return OneMinusDstColorFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SrcAlphaSaturateFactor", function() { return SrcAlphaSaturateFactor; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NeverDepth", function() { return NeverDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlwaysDepth", function() { return AlwaysDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessDepth", function() { return LessDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LessEqualDepth", function() { return LessEqualDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EqualDepth", function() { return EqualDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterEqualDepth", function() { return GreaterEqualDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GreaterDepth", function() { return GreaterDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NotEqualDepth", function() { return NotEqualDepth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiplyOperation", function() { return MultiplyOperation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MixOperation", function() { return MixOperation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AddOperation", function() { return AddOperation; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NoToneMapping", function() { return NoToneMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearToneMapping", function() { return LinearToneMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ReinhardToneMapping", function() { return ReinhardToneMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uncharted2ToneMapping", function() { return Uncharted2ToneMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CineonToneMapping", function() { return CineonToneMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ACESFilmicToneMapping", function() { return ACESFilmicToneMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UVMapping", function() { return UVMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeReflectionMapping", function() { return CubeReflectionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeRefractionMapping", function() { return CubeRefractionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularReflectionMapping", function() { return EquirectangularReflectionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EquirectangularRefractionMapping", function() { return EquirectangularRefractionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SphericalReflectionMapping", function() { return SphericalReflectionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVReflectionMapping", function() { return CubeUVReflectionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeUVRefractionMapping", function() { return CubeUVRefractionMapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RepeatWrapping", function() { return RepeatWrapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClampToEdgeWrapping", function() { return ClampToEdgeWrapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MirroredRepeatWrapping", function() { return MirroredRepeatWrapping; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestFilter", function() { return NearestFilter; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapNearestFilter", function() { return NearestMipMapNearestFilter; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "NearestMipMapLinearFilter", function() { return NearestMipMapLinearFilter; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearFilter", function() { return LinearFilter; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapNearestFilter", function() { return LinearMipMapNearestFilter; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearMipMapLinearFilter", function() { return LinearMipMapLinearFilter; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedByteType", function() { return UnsignedByteType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ByteType", function() { return ByteType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ShortType", function() { return ShortType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShortType", function() { return UnsignedShortType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "IntType", function() { return IntType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedIntType", function() { return UnsignedIntType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "FloatType", function() { return FloatType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "HalfFloatType", function() { return HalfFloatType; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort4444Type", function() { return UnsignedShort4444Type; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort5551Type", function() { return UnsignedShort5551Type; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedShort565Type", function() { return UnsignedShort565Type; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "UnsignedInt248Type", function() { return UnsignedInt248Type; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AlphaFormat", function() { return AlphaFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBFormat", function() { return RGBFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBAFormat", function() { return RGBAFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceFormat", function() { return LuminanceFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LuminanceAlphaFormat", function() { return LuminanceAlphaFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEFormat", function() { return RGBEFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthFormat", function() { return DepthFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DepthStencilFormat", function() { return DepthStencilFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RedFormat", function() { return RedFormat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_S3TC_DXT1_Format", function() { return RGB_S3TC_DXT1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT1_Format", function() { return RGBA_S3TC_DXT1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT3_Format", function() { return RGBA_S3TC_DXT3_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_S3TC_DXT5_Format", function() { return RGBA_S3TC_DXT5_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_4BPPV1_Format", function() { return RGB_PVRTC_4BPPV1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_PVRTC_2BPPV1_Format", function() { return RGB_PVRTC_2BPPV1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_4BPPV1_Format", function() { return RGBA_PVRTC_4BPPV1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_PVRTC_2BPPV1_Format", function() { return RGBA_PVRTC_2BPPV1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGB_ETC1_Format", function() { return RGB_ETC1_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_4x4_Format", function() { return RGBA_ASTC_4x4_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x4_Format", function() { return RGBA_ASTC_5x4_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_5x5_Format", function() { return RGBA_ASTC_5x5_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x5_Format", function() { return RGBA_ASTC_6x5_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_6x6_Format", function() { return RGBA_ASTC_6x6_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x5_Format", function() { return RGBA_ASTC_8x5_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x6_Format", function() { return RGBA_ASTC_8x6_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_8x8_Format", function() { return RGBA_ASTC_8x8_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x5_Format", function() { return RGBA_ASTC_10x5_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x6_Format", function() { return RGBA_ASTC_10x6_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x8_Format", function() { return RGBA_ASTC_10x8_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_10x10_Format", function() { return RGBA_ASTC_10x10_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x10_Format", function() { return RGBA_ASTC_12x10_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBA_ASTC_12x12_Format", function() { return RGBA_ASTC_12x12_Format; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopOnce", function() { return LoopOnce; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopRepeat", function() { return LoopRepeat; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LoopPingPong", function() { return LoopPingPong; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateDiscrete", function() { return InterpolateDiscrete; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateLinear", function() { return InterpolateLinear; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "InterpolateSmooth", function() { return InterpolateSmooth; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroCurvatureEnding", function() { return ZeroCurvatureEnding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ZeroSlopeEnding", function() { return ZeroSlopeEnding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WrapAroundEnding", function() { return WrapAroundEnding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TrianglesDrawMode", function() { return TrianglesDrawMode; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleStripDrawMode", function() { return TriangleStripDrawMode; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TriangleFanDrawMode", function() { return TriangleFanDrawMode; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinearEncoding", function() { return LinearEncoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "sRGBEncoding", function() { return sRGBEncoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GammaEncoding", function() { return GammaEncoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBEEncoding", function() { return RGBEEncoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LogLuvEncoding", function() { return LogLuvEncoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM7Encoding", function() { return RGBM7Encoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBM16Encoding", function() { return RGBM16Encoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBDEncoding", function() { return RGBDEncoding; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BasicDepthPacking", function() { return BasicDepthPacking; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "RGBADepthPacking", function() { return RGBADepthPacking; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TangentSpaceNormalMap", function() { return TangentSpaceNormalMap; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ObjectSpaceNormalMap", function() { return ObjectSpaceNormalMap; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CubeGeometry", function() { return BoxGeometry; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Face4", function() { return Face4; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LineStrip", function() { return LineStrip; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LinePieces", function() { return LinePieces; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MeshFaceMaterial", function() { return MeshFaceMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "MultiMaterial", function() { return MultiMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloud", function() { return PointCloud; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Particle", function() { return Particle; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystem", function() { return ParticleSystem; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PointCloudMaterial", function() { return PointCloudMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleBasicMaterial", function() { return ParticleBasicMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ParticleSystemMaterial", function() { return ParticleSystemMaterial; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Vertex", function() { return Vertex; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "DynamicBufferAttribute", function() { return DynamicBufferAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int8Attribute", function() { return Int8Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8Attribute", function() { return Uint8Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint8ClampedAttribute", function() { return Uint8ClampedAttribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int16Attribute", function() { return Int16Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint16Attribute", function() { return Uint16Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Int32Attribute", function() { return Int32Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Uint32Attribute", function() { return Uint32Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float32Attribute", function() { return Float32Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Float64Attribute", function() { return Float64Attribute; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "ClosedSplineCurve3", function() { return ClosedSplineCurve3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SplineCurve3", function() { return SplineCurve3; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Spline", function() { return Spline; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "AxisHelper", function() { return AxisHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BoundingBoxHelper", function() { return BoundingBoxHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "EdgesHelper", function() { return EdgesHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "WireframeHelper", function() { return WireframeHelper; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "XHRLoader", function() { return XHRLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "BinaryTextureLoader", function() { return BinaryTextureLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GeometryUtils", function() { return GeometryUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Projector", function() { return Projector; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "CanvasRenderer", function() { return CanvasRenderer; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "JSONLoader", function() { return JSONLoader; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "SceneUtils", function() { return SceneUtils; });
	/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "LensFlare", function() { return LensFlare; });
	// Polyfills
	
	if ( Number.EPSILON === undefined ) {
	
		Number.EPSILON = Math.pow( 2, - 52 );
	
	}
	
	if ( Number.isInteger === undefined ) {
	
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isInteger
	
		Number.isInteger = function ( value ) {
	
			return typeof value === 'number' && isFinite( value ) && Math.floor( value ) === value;
	
		};
	
	}
	
	//
	
	if ( Math.sign === undefined ) {
	
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/sign
	
		Math.sign = function ( x ) {
	
			return ( x < 0 ) ? - 1 : ( x > 0 ) ? 1 : + x;
	
		};
	
	}
	
	if ( 'name' in Function.prototype === false ) {
	
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name
	
		Object.defineProperty( Function.prototype, 'name', {
	
			get: function () {
	
				return this.toString().match( /^\s*function\s*([^\(\s]*)/ )[ 1 ];
	
			}
	
		} );
	
	}
	
	if ( Object.assign === undefined ) {
	
		// Missing in IE
		// https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/assign
	
		( function () {
	
			Object.assign = function ( target ) {
	
				if ( target === undefined || target === null ) {
	
					throw new TypeError( 'Cannot convert undefined or null to object' );
	
				}
	
				var output = Object( target );
	
				for ( var index = 1; index < arguments.length; index ++ ) {
	
					var source = arguments[ index ];
	
					if ( source !== undefined && source !== null ) {
	
						for ( var nextKey in source ) {
	
							if ( Object.prototype.hasOwnProperty.call( source, nextKey ) ) {
	
								output[ nextKey ] = source[ nextKey ];
	
							}
	
						}
	
					}
	
				}
	
				return output;
	
			};
	
		} )();
	
	}
	
	/**
	 * https://github.com/mrdoob/eventdispatcher.js/
	 */
	
	function EventDispatcher() {}
	
	Object.assign( EventDispatcher.prototype, {
	
		addEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) this._listeners = {};
	
			var listeners = this._listeners;
	
			if ( listeners[ type ] === undefined ) {
	
				listeners[ type ] = [];
	
			}
	
			if ( listeners[ type ].indexOf( listener ) === - 1 ) {
	
				listeners[ type ].push( listener );
	
			}
	
		},
	
		hasEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return false;
	
			var listeners = this._listeners;
	
			return listeners[ type ] !== undefined && listeners[ type ].indexOf( listener ) !== - 1;
	
		},
	
		removeEventListener: function ( type, listener ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ type ];
	
			if ( listenerArray !== undefined ) {
	
				var index = listenerArray.indexOf( listener );
	
				if ( index !== - 1 ) {
	
					listenerArray.splice( index, 1 );
	
				}
	
			}
	
		},
	
		dispatchEvent: function ( event ) {
	
			if ( this._listeners === undefined ) return;
	
			var listeners = this._listeners;
			var listenerArray = listeners[ event.type ];
	
			if ( listenerArray !== undefined ) {
	
				event.target = this;
	
				var array = listenerArray.slice( 0 );
	
				for ( var i = 0, l = array.length; i < l; i ++ ) {
	
					array[ i ].call( this, event );
	
				}
	
			}
	
		}
	
	} );
	
	var REVISION = '101';
	var MOUSE = { LEFT: 0, MIDDLE: 1, RIGHT: 2 };
	var CullFaceNone = 0;
	var CullFaceBack = 1;
	var CullFaceFront = 2;
	var CullFaceFrontBack = 3;
	var FrontFaceDirectionCW = 0;
	var FrontFaceDirectionCCW = 1;
	var BasicShadowMap = 0;
	var PCFShadowMap = 1;
	var PCFSoftShadowMap = 2;
	var FrontSide = 0;
	var BackSide = 1;
	var DoubleSide = 2;
	var FlatShading = 1;
	var SmoothShading = 2;
	var NoColors = 0;
	var FaceColors = 1;
	var VertexColors = 2;
	var NoBlending = 0;
	var NormalBlending = 1;
	var AdditiveBlending = 2;
	var SubtractiveBlending = 3;
	var MultiplyBlending = 4;
	var CustomBlending = 5;
	var AddEquation = 100;
	var SubtractEquation = 101;
	var ReverseSubtractEquation = 102;
	var MinEquation = 103;
	var MaxEquation = 104;
	var ZeroFactor = 200;
	var OneFactor = 201;
	var SrcColorFactor = 202;
	var OneMinusSrcColorFactor = 203;
	var SrcAlphaFactor = 204;
	var OneMinusSrcAlphaFactor = 205;
	var DstAlphaFactor = 206;
	var OneMinusDstAlphaFactor = 207;
	var DstColorFactor = 208;
	var OneMinusDstColorFactor = 209;
	var SrcAlphaSaturateFactor = 210;
	var NeverDepth = 0;
	var AlwaysDepth = 1;
	var LessDepth = 2;
	var LessEqualDepth = 3;
	var EqualDepth = 4;
	var GreaterEqualDepth = 5;
	var GreaterDepth = 6;
	var NotEqualDepth = 7;
	var MultiplyOperation = 0;
	var MixOperation = 1;
	var AddOperation = 2;
	var NoToneMapping = 0;
	var LinearToneMapping = 1;
	var ReinhardToneMapping = 2;
	var Uncharted2ToneMapping = 3;
	var CineonToneMapping = 4;
	var ACESFilmicToneMapping = 5;
	
	var UVMapping = 300;
	var CubeReflectionMapping = 301;
	var CubeRefractionMapping = 302;
	var EquirectangularReflectionMapping = 303;
	var EquirectangularRefractionMapping = 304;
	var SphericalReflectionMapping = 305;
	var CubeUVReflectionMapping = 306;
	var CubeUVRefractionMapping = 307;
	var RepeatWrapping = 1000;
	var ClampToEdgeWrapping = 1001;
	var MirroredRepeatWrapping = 1002;
	var NearestFilter = 1003;
	var NearestMipMapNearestFilter = 1004;
	var NearestMipMapLinearFilter = 1005;
	var LinearFilter = 1006;
	var LinearMipMapNearestFilter = 1007;
	var LinearMipMapLinearFilter = 1008;
	var UnsignedByteType = 1009;
	var ByteType = 1010;
	var ShortType = 1011;
	var UnsignedShortType = 1012;
	var IntType = 1013;
	var UnsignedIntType = 1014;
	var FloatType = 1015;
	var HalfFloatType = 1016;
	var UnsignedShort4444Type = 1017;
	var UnsignedShort5551Type = 1018;
	var UnsignedShort565Type = 1019;
	var UnsignedInt248Type = 1020;
	var AlphaFormat = 1021;
	var RGBFormat = 1022;
	var RGBAFormat = 1023;
	var LuminanceFormat = 1024;
	var LuminanceAlphaFormat = 1025;
	var RGBEFormat = RGBAFormat;
	var DepthFormat = 1026;
	var DepthStencilFormat = 1027;
	var RedFormat = 1028;
	var RGB_S3TC_DXT1_Format = 33776;
	var RGBA_S3TC_DXT1_Format = 33777;
	var RGBA_S3TC_DXT3_Format = 33778;
	var RGBA_S3TC_DXT5_Format = 33779;
	var RGB_PVRTC_4BPPV1_Format = 35840;
	var RGB_PVRTC_2BPPV1_Format = 35841;
	var RGBA_PVRTC_4BPPV1_Format = 35842;
	var RGBA_PVRTC_2BPPV1_Format = 35843;
	var RGB_ETC1_Format = 36196;
	var RGBA_ASTC_4x4_Format = 37808;
	var RGBA_ASTC_5x4_Format = 37809;
	var RGBA_ASTC_5x5_Format = 37810;
	var RGBA_ASTC_6x5_Format = 37811;
	var RGBA_ASTC_6x6_Format = 37812;
	var RGBA_ASTC_8x5_Format = 37813;
	var RGBA_ASTC_8x6_Format = 37814;
	var RGBA_ASTC_8x8_Format = 37815;
	var RGBA_ASTC_10x5_Format = 37816;
	var RGBA_ASTC_10x6_Format = 37817;
	var RGBA_ASTC_10x8_Format = 37818;
	var RGBA_ASTC_10x10_Format = 37819;
	var RGBA_ASTC_12x10_Format = 37820;
	var RGBA_ASTC_12x12_Format = 37821;
	var LoopOnce = 2200;
	var LoopRepeat = 2201;
	var LoopPingPong = 2202;
	var InterpolateDiscrete = 2300;
	var InterpolateLinear = 2301;
	var InterpolateSmooth = 2302;
	var ZeroCurvatureEnding = 2400;
	var ZeroSlopeEnding = 2401;
	var WrapAroundEnding = 2402;
	var TrianglesDrawMode = 0;
	var TriangleStripDrawMode = 1;
	var TriangleFanDrawMode = 2;
	var LinearEncoding = 3000;
	var sRGBEncoding = 3001;
	var GammaEncoding = 3007;
	var RGBEEncoding = 3002;
	var LogLuvEncoding = 3003;
	var RGBM7Encoding = 3004;
	var RGBM16Encoding = 3005;
	var RGBDEncoding = 3006;
	var BasicDepthPacking = 3200;
	var RGBADepthPacking = 3201;
	var TangentSpaceNormalMap = 0;
	var ObjectSpaceNormalMap = 1;
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var _Math = {
	
		DEG2RAD: Math.PI / 180,
		RAD2DEG: 180 / Math.PI,
	
		generateUUID: ( function () {
	
			// http://stackoverflow.com/questions/105034/how-to-create-a-guid-uuid-in-javascript/21963136#21963136
	
			var lut = [];
	
			for ( var i = 0; i < 256; i ++ ) {
	
				lut[ i ] = ( i < 16 ? '0' : '' ) + ( i ).toString( 16 );
	
			}
	
			return function generateUUID() {
	
				var d0 = Math.random() * 0xffffffff | 0;
				var d1 = Math.random() * 0xffffffff | 0;
				var d2 = Math.random() * 0xffffffff | 0;
				var d3 = Math.random() * 0xffffffff | 0;
				var uuid = lut[ d0 & 0xff ] + lut[ d0 >> 8 & 0xff ] + lut[ d0 >> 16 & 0xff ] + lut[ d0 >> 24 & 0xff ] + '-' +
					lut[ d1 & 0xff ] + lut[ d1 >> 8 & 0xff ] + '-' + lut[ d1 >> 16 & 0x0f | 0x40 ] + lut[ d1 >> 24 & 0xff ] + '-' +
					lut[ d2 & 0x3f | 0x80 ] + lut[ d2 >> 8 & 0xff ] + '-' + lut[ d2 >> 16 & 0xff ] + lut[ d2 >> 24 & 0xff ] +
					lut[ d3 & 0xff ] + lut[ d3 >> 8 & 0xff ] + lut[ d3 >> 16 & 0xff ] + lut[ d3 >> 24 & 0xff ];
	
				// .toUpperCase() here flattens concatenated strings to save heap memory space.
				return uuid.toUpperCase();
	
			};
	
		} )(),
	
		clamp: function ( value, min, max ) {
	
			return Math.max( min, Math.min( max, value ) );
	
		},
	
		// compute euclidian modulo of m % n
		// https://en.wikipedia.org/wiki/Modulo_operation
	
		euclideanModulo: function ( n, m ) {
	
			return ( ( n % m ) + m ) % m;
	
		},
	
		// Linear mapping from range <a1, a2> to range <b1, b2>
	
		mapLinear: function ( x, a1, a2, b1, b2 ) {
	
			return b1 + ( x - a1 ) * ( b2 - b1 ) / ( a2 - a1 );
	
		},
	
		// https://en.wikipedia.org/wiki/Linear_interpolation
	
		lerp: function ( x, y, t ) {
	
			return ( 1 - t ) * x + t * y;
	
		},
	
		// http://en.wikipedia.org/wiki/Smoothstep
	
		smoothstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * ( 3 - 2 * x );
	
		},
	
		smootherstep: function ( x, min, max ) {
	
			if ( x <= min ) return 0;
			if ( x >= max ) return 1;
	
			x = ( x - min ) / ( max - min );
	
			return x * x * x * ( x * ( x * 6 - 15 ) + 10 );
	
		},
	
		// Random integer from <low, high> interval
	
		randInt: function ( low, high ) {
	
			return low + Math.floor( Math.random() * ( high - low + 1 ) );
	
		},
	
		// Random float from <low, high> interval
	
		randFloat: function ( low, high ) {
	
			return low + Math.random() * ( high - low );
	
		},
	
		// Random float from <-range/2, range/2> interval
	
		randFloatSpread: function ( range ) {
	
			return range * ( 0.5 - Math.random() );
	
		},
	
		degToRad: function ( degrees ) {
	
			return degrees * _Math.DEG2RAD;
	
		},
	
		radToDeg: function ( radians ) {
	
			return radians * _Math.RAD2DEG;
	
		},
	
		isPowerOfTwo: function ( value ) {
	
			return ( value & ( value - 1 ) ) === 0 && value !== 0;
	
		},
	
		ceilPowerOfTwo: function ( value ) {
	
			return Math.pow( 2, Math.ceil( Math.log( value ) / Math.LN2 ) );
	
		},
	
		floorPowerOfTwo: function ( value ) {
	
			return Math.pow( 2, Math.floor( Math.log( value ) / Math.LN2 ) );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author philogb / http://blog.thejit.org/
	 * @author egraether / http://egraether.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	function Vector2( x, y ) {
	
		this.x = x || 0;
		this.y = y || 0;
	
	}
	
	Object.defineProperties( Vector2.prototype, {
	
		"width": {
	
			get: function () {
	
				return this.x;
	
			},
	
			set: function ( value ) {
	
				this.x = value;
	
			}
	
		},
	
		"height": {
	
			get: function () {
	
				return this.y;
	
			},
	
			set: function ( value ) {
	
				this.y = value;
	
			}
	
		}
	
	} );
	
	Object.assign( Vector2.prototype, {
	
		isVector2: true,
	
		set: function ( x, y ) {
	
			this.x = x;
			this.y = y;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
			return this;
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector2: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
	
			return this;
	
		},
	
		multiply: function ( v ) {
	
			this.x *= v.x;
			this.y *= v.y;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
	
			return this;
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		applyMatrix3: function ( m ) {
	
			var x = this.x, y = this.y;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ];
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ];
	
			return this;
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// assumes min < max, componentwise
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min = new Vector2();
			var max = new Vector2();
	
			return function clampScalar( minVal, maxVal ) {
	
				min.set( minVal, minVal );
				max.set( maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y;
	
		},
	
		cross: function ( v ) {
	
			return this.x * v.y - this.y * v.x;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y );
	
		},
	
		manhattanLength: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() || 1 );
	
		},
	
		angle: function () {
	
			// computes the angle in radians with respect to the positive x-axis
	
			var angle = Math.atan2( this.y, this.x );
	
			if ( angle < 0 ) angle += 2 * Math.PI;
	
			return angle;
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y;
			return dx * dx + dy * dy;
	
		},
	
		manhattanDistanceTo: function ( v ) {
	
			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y );
	
		},
	
		setLength: function ( length ) {
	
			return this.normalize().multiplyScalar( length );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
	
			return array;
	
		},
	
		fromBufferAttribute: function ( attribute, index, offset ) {
	
			if ( offset !== undefined ) {
	
				console.warn( 'THREE.Vector2: offset has been removed from .fromBufferAttribute().' );
	
			}
	
			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
	
			return this;
	
		},
	
		rotateAround: function ( center, angle ) {
	
			var c = Math.cos( angle ), s = Math.sin( angle );
	
			var x = this.x - center.x;
			var y = this.y - center.y;
	
			this.x = x * c - y * s + center.x;
			this.y = x * s + y * c + center.y;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author jordi_ros / http://plattsoft.com
	 * @author D1plo1d / http://github.com/D1plo1d
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author timknip / http://www.floorplanner.com/
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function Matrix4() {
	
		this.elements = [
	
			1, 0, 0, 0,
			0, 1, 0, 0,
			0, 0, 1, 0,
			0, 0, 0, 1
	
		];
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix4: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	}
	
	Object.assign( Matrix4.prototype, {
	
		isMatrix4: true,
	
		set: function ( n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 4 ] = n12; te[ 8 ] = n13; te[ 12 ] = n14;
			te[ 1 ] = n21; te[ 5 ] = n22; te[ 9 ] = n23; te[ 13 ] = n24;
			te[ 2 ] = n31; te[ 6 ] = n32; te[ 10 ] = n33; te[ 14 ] = n34;
			te[ 3 ] = n41; te[ 7 ] = n42; te[ 11 ] = n43; te[ 15 ] = n44;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0, 0,
				0, 1, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new Matrix4().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ]; te[ 3 ] = me[ 3 ];
			te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ]; te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ];
			te[ 8 ] = me[ 8 ]; te[ 9 ] = me[ 9 ]; te[ 10 ] = me[ 10 ]; te[ 11 ] = me[ 11 ];
			te[ 12 ] = me[ 12 ]; te[ 13 ] = me[ 13 ]; te[ 14 ] = me[ 14 ]; te[ 15 ] = me[ 15 ];
	
			return this;
	
		},
	
		copyPosition: function ( m ) {
	
			var te = this.elements, me = m.elements;
	
			te[ 12 ] = me[ 12 ];
			te[ 13 ] = me[ 13 ];
			te[ 14 ] = me[ 14 ];
	
			return this;
	
		},
	
		extractBasis: function ( xAxis, yAxis, zAxis ) {
	
			xAxis.setFromMatrixColumn( this, 0 );
			yAxis.setFromMatrixColumn( this, 1 );
			zAxis.setFromMatrixColumn( this, 2 );
	
			return this;
	
		},
	
		makeBasis: function ( xAxis, yAxis, zAxis ) {
	
			this.set(
				xAxis.x, yAxis.x, zAxis.x, 0,
				xAxis.y, yAxis.y, zAxis.y, 0,
				xAxis.z, yAxis.z, zAxis.z, 0,
				0, 0, 0, 1
			);
	
			return this;
	
		},
	
		extractRotation: function () {
	
			var v1 = new Vector3();
	
			return function extractRotation( m ) {
	
				// this method does not support reflection matrices
	
				var te = this.elements;
				var me = m.elements;
	
				var scaleX = 1 / v1.setFromMatrixColumn( m, 0 ).length();
				var scaleY = 1 / v1.setFromMatrixColumn( m, 1 ).length();
				var scaleZ = 1 / v1.setFromMatrixColumn( m, 2 ).length();
	
				te[ 0 ] = me[ 0 ] * scaleX;
				te[ 1 ] = me[ 1 ] * scaleX;
				te[ 2 ] = me[ 2 ] * scaleX;
				te[ 3 ] = 0;
	
				te[ 4 ] = me[ 4 ] * scaleY;
				te[ 5 ] = me[ 5 ] * scaleY;
				te[ 6 ] = me[ 6 ] * scaleY;
				te[ 7 ] = 0;
	
				te[ 8 ] = me[ 8 ] * scaleZ;
				te[ 9 ] = me[ 9 ] * scaleZ;
				te[ 10 ] = me[ 10 ] * scaleZ;
				te[ 11 ] = 0;
	
				te[ 12 ] = 0;
				te[ 13 ] = 0;
				te[ 14 ] = 0;
				te[ 15 ] = 1;
	
				return this;
	
			};
	
		}(),
	
		makeRotationFromEuler: function ( euler ) {
	
			if ( ! ( euler && euler.isEuler ) ) {
	
				console.error( 'THREE.Matrix4: .makeRotationFromEuler() now expects a Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var te = this.elements;
	
			var x = euler.x, y = euler.y, z = euler.z;
			var a = Math.cos( x ), b = Math.sin( x );
			var c = Math.cos( y ), d = Math.sin( y );
			var e = Math.cos( z ), f = Math.sin( z );
	
			if ( euler.order === 'XYZ' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - c * f;
				te[ 8 ] = d;
	
				te[ 1 ] = af + be * d;
				te[ 5 ] = ae - bf * d;
				te[ 9 ] = - b * c;
	
				te[ 2 ] = bf - ae * d;
				te[ 6 ] = be + af * d;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YXZ' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce + df * b;
				te[ 4 ] = de * b - cf;
				te[ 8 ] = a * d;
	
				te[ 1 ] = a * f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b;
	
				te[ 2 ] = cf * b - de;
				te[ 6 ] = df + ce * b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZXY' ) {
	
				var ce = c * e, cf = c * f, de = d * e, df = d * f;
	
				te[ 0 ] = ce - df * b;
				te[ 4 ] = - a * f;
				te[ 8 ] = de + cf * b;
	
				te[ 1 ] = cf + de * b;
				te[ 5 ] = a * e;
				te[ 9 ] = df - ce * b;
	
				te[ 2 ] = - a * d;
				te[ 6 ] = b;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'ZYX' ) {
	
				var ae = a * e, af = a * f, be = b * e, bf = b * f;
	
				te[ 0 ] = c * e;
				te[ 4 ] = be * d - af;
				te[ 8 ] = ae * d + bf;
	
				te[ 1 ] = c * f;
				te[ 5 ] = bf * d + ae;
				te[ 9 ] = af * d - be;
	
				te[ 2 ] = - d;
				te[ 6 ] = b * c;
				te[ 10 ] = a * c;
	
			} else if ( euler.order === 'YZX' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = bd - ac * f;
				te[ 8 ] = bc * f + ad;
	
				te[ 1 ] = f;
				te[ 5 ] = a * e;
				te[ 9 ] = - b * e;
	
				te[ 2 ] = - d * e;
				te[ 6 ] = ad * f + bc;
				te[ 10 ] = ac - bd * f;
	
			} else if ( euler.order === 'XZY' ) {
	
				var ac = a * c, ad = a * d, bc = b * c, bd = b * d;
	
				te[ 0 ] = c * e;
				te[ 4 ] = - f;
				te[ 8 ] = d * e;
	
				te[ 1 ] = ac * f + bd;
				te[ 5 ] = a * e;
				te[ 9 ] = ad * f - bc;
	
				te[ 2 ] = bc * f - ad;
				te[ 6 ] = b * e;
				te[ 10 ] = bd * f + ac;
	
			}
	
			// bottom row
			te[ 3 ] = 0;
			te[ 7 ] = 0;
			te[ 11 ] = 0;
	
			// last column
			te[ 12 ] = 0;
			te[ 13 ] = 0;
			te[ 14 ] = 0;
			te[ 15 ] = 1;
	
			return this;
	
		},
	
		makeRotationFromQuaternion: function () {
	
			var zero = new Vector3( 0, 0, 0 );
			var one = new Vector3( 1, 1, 1 );
	
			return function makeRotationFromQuaternion( q ) {
	
				return this.compose( zero, q, one );
	
			};
	
		}(),
	
		lookAt: function () {
	
			var x = new Vector3();
			var y = new Vector3();
			var z = new Vector3();
	
			return function lookAt( eye, target, up ) {
	
				var te = this.elements;
	
				z.subVectors( eye, target );
	
				if ( z.lengthSq() === 0 ) {
	
					// eye and target are in the same position
	
					z.z = 1;
	
				}
	
				z.normalize();
				x.crossVectors( up, z );
	
				if ( x.lengthSq() === 0 ) {
	
					// up and z are parallel
	
					if ( Math.abs( up.z ) === 1 ) {
	
						z.x += 0.0001;
	
					} else {
	
						z.z += 0.0001;
	
					}
	
					z.normalize();
					x.crossVectors( up, z );
	
				}
	
				x.normalize();
				y.crossVectors( z, x );
	
				te[ 0 ] = x.x; te[ 4 ] = y.x; te[ 8 ] = z.x;
				te[ 1 ] = x.y; te[ 5 ] = y.y; te[ 9 ] = z.y;
				te[ 2 ] = x.z; te[ 6 ] = y.z; te[ 10 ] = z.z;
	
				return this;
	
			};
	
		}(),
	
		multiply: function ( m, n ) {
	
			if ( n !== undefined ) {
	
				console.warn( 'THREE.Matrix4: .multiply() now only accepts one argument. Use .multiplyMatrices( a, b ) instead.' );
				return this.multiplyMatrices( m, n );
	
			}
	
			return this.multiplyMatrices( this, m );
	
		},
	
		premultiply: function ( m ) {
	
			return this.multiplyMatrices( m, this );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 4 ], a13 = ae[ 8 ], a14 = ae[ 12 ];
			var a21 = ae[ 1 ], a22 = ae[ 5 ], a23 = ae[ 9 ], a24 = ae[ 13 ];
			var a31 = ae[ 2 ], a32 = ae[ 6 ], a33 = ae[ 10 ], a34 = ae[ 14 ];
			var a41 = ae[ 3 ], a42 = ae[ 7 ], a43 = ae[ 11 ], a44 = ae[ 15 ];
	
			var b11 = be[ 0 ], b12 = be[ 4 ], b13 = be[ 8 ], b14 = be[ 12 ];
			var b21 = be[ 1 ], b22 = be[ 5 ], b23 = be[ 9 ], b24 = be[ 13 ];
			var b31 = be[ 2 ], b32 = be[ 6 ], b33 = be[ 10 ], b34 = be[ 14 ];
			var b41 = be[ 3 ], b42 = be[ 7 ], b43 = be[ 11 ], b44 = be[ 15 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31 + a14 * b41;
			te[ 4 ] = a11 * b12 + a12 * b22 + a13 * b32 + a14 * b42;
			te[ 8 ] = a11 * b13 + a12 * b23 + a13 * b33 + a14 * b43;
			te[ 12 ] = a11 * b14 + a12 * b24 + a13 * b34 + a14 * b44;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31 + a24 * b41;
			te[ 5 ] = a21 * b12 + a22 * b22 + a23 * b32 + a24 * b42;
			te[ 9 ] = a21 * b13 + a22 * b23 + a23 * b33 + a24 * b43;
			te[ 13 ] = a21 * b14 + a22 * b24 + a23 * b34 + a24 * b44;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31 + a34 * b41;
			te[ 6 ] = a31 * b12 + a32 * b22 + a33 * b32 + a34 * b42;
			te[ 10 ] = a31 * b13 + a32 * b23 + a33 * b33 + a34 * b43;
			te[ 14 ] = a31 * b14 + a32 * b24 + a33 * b34 + a34 * b44;
	
			te[ 3 ] = a41 * b11 + a42 * b21 + a43 * b31 + a44 * b41;
			te[ 7 ] = a41 * b12 + a42 * b22 + a43 * b32 + a44 * b42;
			te[ 11 ] = a41 * b13 + a42 * b23 + a43 * b33 + a44 * b43;
			te[ 15 ] = a41 * b14 + a42 * b24 + a43 * b34 + a44 * b44;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 4 ] *= s; te[ 8 ] *= s; te[ 12 ] *= s;
			te[ 1 ] *= s; te[ 5 ] *= s; te[ 9 ] *= s; te[ 13 ] *= s;
			te[ 2 ] *= s; te[ 6 ] *= s; te[ 10 ] *= s; te[ 14 ] *= s;
			te[ 3 ] *= s; te[ 7 ] *= s; te[ 11 ] *= s; te[ 15 ] *= s;
	
			return this;
	
		},
	
		applyToBufferAttribute: function () {
	
			var v1 = new Vector3();
	
			return function applyToBufferAttribute( attribute ) {
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );
	
					v1.applyMatrix4( this );
	
					attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
				}
	
				return attribute;
	
			};
	
		}(),
	
		determinant: function () {
	
			var te = this.elements;
	
			var n11 = te[ 0 ], n12 = te[ 4 ], n13 = te[ 8 ], n14 = te[ 12 ];
			var n21 = te[ 1 ], n22 = te[ 5 ], n23 = te[ 9 ], n24 = te[ 13 ];
			var n31 = te[ 2 ], n32 = te[ 6 ], n33 = te[ 10 ], n34 = te[ 14 ];
			var n41 = te[ 3 ], n42 = te[ 7 ], n43 = te[ 11 ], n44 = te[ 15 ];
	
			//TODO: make this more efficient
			//( based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm )
	
			return (
				n41 * (
					+ n14 * n23 * n32
					 - n13 * n24 * n32
					 - n14 * n22 * n33
					 + n12 * n24 * n33
					 + n13 * n22 * n34
					 - n12 * n23 * n34
				) +
				n42 * (
					+ n11 * n23 * n34
					 - n11 * n24 * n33
					 + n14 * n21 * n33
					 - n13 * n21 * n34
					 + n13 * n24 * n31
					 - n14 * n23 * n31
				) +
				n43 * (
					+ n11 * n24 * n32
					 - n11 * n22 * n34
					 - n14 * n21 * n32
					 + n12 * n21 * n34
					 + n14 * n22 * n31
					 - n12 * n24 * n31
				) +
				n44 * (
					- n13 * n22 * n31
					 - n11 * n23 * n32
					 + n11 * n22 * n33
					 + n13 * n21 * n32
					 - n12 * n21 * n33
					 + n12 * n23 * n31
				)
	
			);
	
		},
	
		transpose: function () {
	
			var te = this.elements;
			var tmp;
	
			tmp = te[ 1 ]; te[ 1 ] = te[ 4 ]; te[ 4 ] = tmp;
			tmp = te[ 2 ]; te[ 2 ] = te[ 8 ]; te[ 8 ] = tmp;
			tmp = te[ 6 ]; te[ 6 ] = te[ 9 ]; te[ 9 ] = tmp;
	
			tmp = te[ 3 ]; te[ 3 ] = te[ 12 ]; te[ 12 ] = tmp;
			tmp = te[ 7 ]; te[ 7 ] = te[ 13 ]; te[ 13 ] = tmp;
			tmp = te[ 11 ]; te[ 11 ] = te[ 14 ]; te[ 14 ] = tmp;
	
			return this;
	
		},
	
		setPosition: function ( v ) {
	
			var te = this.elements;
	
			te[ 12 ] = v.x;
			te[ 13 ] = v.y;
			te[ 14 ] = v.z;
	
			return this;
	
		},
	
		getInverse: function ( m, throwOnDegenerate ) {
	
			// based on http://www.euclideanspace.com/maths/algebra/matrix/functions/inverse/fourD/index.htm
			var te = this.elements,
				me = m.elements,
	
				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ], n41 = me[ 3 ],
				n12 = me[ 4 ], n22 = me[ 5 ], n32 = me[ 6 ], n42 = me[ 7 ],
				n13 = me[ 8 ], n23 = me[ 9 ], n33 = me[ 10 ], n43 = me[ 11 ],
				n14 = me[ 12 ], n24 = me[ 13 ], n34 = me[ 14 ], n44 = me[ 15 ],
	
				t11 = n23 * n34 * n42 - n24 * n33 * n42 + n24 * n32 * n43 - n22 * n34 * n43 - n23 * n32 * n44 + n22 * n33 * n44,
				t12 = n14 * n33 * n42 - n13 * n34 * n42 - n14 * n32 * n43 + n12 * n34 * n43 + n13 * n32 * n44 - n12 * n33 * n44,
				t13 = n13 * n24 * n42 - n14 * n23 * n42 + n14 * n22 * n43 - n12 * n24 * n43 - n13 * n22 * n44 + n12 * n23 * n44,
				t14 = n14 * n23 * n32 - n13 * n24 * n32 - n14 * n22 * n33 + n12 * n24 * n33 + n13 * n22 * n34 - n12 * n23 * n34;
	
			var det = n11 * t11 + n21 * t12 + n31 * t13 + n41 * t14;
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix4: .getInverse() can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate === true ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				return this.identity();
	
			}
	
			var detInv = 1 / det;
	
			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n24 * n33 * n41 - n23 * n34 * n41 - n24 * n31 * n43 + n21 * n34 * n43 + n23 * n31 * n44 - n21 * n33 * n44 ) * detInv;
			te[ 2 ] = ( n22 * n34 * n41 - n24 * n32 * n41 + n24 * n31 * n42 - n21 * n34 * n42 - n22 * n31 * n44 + n21 * n32 * n44 ) * detInv;
			te[ 3 ] = ( n23 * n32 * n41 - n22 * n33 * n41 - n23 * n31 * n42 + n21 * n33 * n42 + n22 * n31 * n43 - n21 * n32 * n43 ) * detInv;
	
			te[ 4 ] = t12 * detInv;
			te[ 5 ] = ( n13 * n34 * n41 - n14 * n33 * n41 + n14 * n31 * n43 - n11 * n34 * n43 - n13 * n31 * n44 + n11 * n33 * n44 ) * detInv;
			te[ 6 ] = ( n14 * n32 * n41 - n12 * n34 * n41 - n14 * n31 * n42 + n11 * n34 * n42 + n12 * n31 * n44 - n11 * n32 * n44 ) * detInv;
			te[ 7 ] = ( n12 * n33 * n41 - n13 * n32 * n41 + n13 * n31 * n42 - n11 * n33 * n42 - n12 * n31 * n43 + n11 * n32 * n43 ) * detInv;
	
			te[ 8 ] = t13 * detInv;
			te[ 9 ] = ( n14 * n23 * n41 - n13 * n24 * n41 - n14 * n21 * n43 + n11 * n24 * n43 + n13 * n21 * n44 - n11 * n23 * n44 ) * detInv;
			te[ 10 ] = ( n12 * n24 * n41 - n14 * n22 * n41 + n14 * n21 * n42 - n11 * n24 * n42 - n12 * n21 * n44 + n11 * n22 * n44 ) * detInv;
			te[ 11 ] = ( n13 * n22 * n41 - n12 * n23 * n41 - n13 * n21 * n42 + n11 * n23 * n42 + n12 * n21 * n43 - n11 * n22 * n43 ) * detInv;
	
			te[ 12 ] = t14 * detInv;
			te[ 13 ] = ( n13 * n24 * n31 - n14 * n23 * n31 + n14 * n21 * n33 - n11 * n24 * n33 - n13 * n21 * n34 + n11 * n23 * n34 ) * detInv;
			te[ 14 ] = ( n14 * n22 * n31 - n12 * n24 * n31 - n14 * n21 * n32 + n11 * n24 * n32 + n12 * n21 * n34 - n11 * n22 * n34 ) * detInv;
			te[ 15 ] = ( n12 * n23 * n31 - n13 * n22 * n31 + n13 * n21 * n32 - n11 * n23 * n32 - n12 * n21 * n33 + n11 * n22 * n33 ) * detInv;
	
			return this;
	
		},
	
		scale: function ( v ) {
	
			var te = this.elements;
			var x = v.x, y = v.y, z = v.z;
	
			te[ 0 ] *= x; te[ 4 ] *= y; te[ 8 ] *= z;
			te[ 1 ] *= x; te[ 5 ] *= y; te[ 9 ] *= z;
			te[ 2 ] *= x; te[ 6 ] *= y; te[ 10 ] *= z;
			te[ 3 ] *= x; te[ 7 ] *= y; te[ 11 ] *= z;
	
			return this;
	
		},
	
		getMaxScaleOnAxis: function () {
	
			var te = this.elements;
	
			var scaleXSq = te[ 0 ] * te[ 0 ] + te[ 1 ] * te[ 1 ] + te[ 2 ] * te[ 2 ];
			var scaleYSq = te[ 4 ] * te[ 4 ] + te[ 5 ] * te[ 5 ] + te[ 6 ] * te[ 6 ];
			var scaleZSq = te[ 8 ] * te[ 8 ] + te[ 9 ] * te[ 9 ] + te[ 10 ] * te[ 10 ];
	
			return Math.sqrt( Math.max( scaleXSq, scaleYSq, scaleZSq ) );
	
		},
	
		makeTranslation: function ( x, y, z ) {
	
			this.set(
	
				1, 0, 0, x,
				0, 1, 0, y,
				0, 0, 1, z,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationX: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				1, 0, 0, 0,
				0, c, - s, 0,
				0, s, c, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationY: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				 c, 0, s, 0,
				 0, 1, 0, 0,
				- s, 0, c, 0,
				 0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationZ: function ( theta ) {
	
			var c = Math.cos( theta ), s = Math.sin( theta );
	
			this.set(
	
				c, - s, 0, 0,
				s, c, 0, 0,
				0, 0, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeRotationAxis: function ( axis, angle ) {
	
			// Based on http://www.gamedev.net/reference/articles/article1199.asp
	
			var c = Math.cos( angle );
			var s = Math.sin( angle );
			var t = 1 - c;
			var x = axis.x, y = axis.y, z = axis.z;
			var tx = t * x, ty = t * y;
	
			this.set(
	
				tx * x + c, tx * y - s * z, tx * z + s * y, 0,
				tx * y + s * z, ty * y + c, ty * z - s * x, 0,
				tx * z - s * y, ty * z + s * x, t * z * z + c, 0,
				0, 0, 0, 1
	
			);
	
			 return this;
	
		},
	
		makeScale: function ( x, y, z ) {
	
			this.set(
	
				x, 0, 0, 0,
				0, y, 0, 0,
				0, 0, z, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		makeShear: function ( x, y, z ) {
	
			this.set(
	
				1, y, z, 0,
				x, 1, z, 0,
				x, y, 1, 0,
				0, 0, 0, 1
	
			);
	
			return this;
	
		},
	
		compose: function ( position, quaternion, scale ) {
	
			var te = this.elements;
	
			var x = quaternion._x, y = quaternion._y, z = quaternion._z, w = quaternion._w;
			var x2 = x + x,	y2 = y + y, z2 = z + z;
			var xx = x * x2, xy = x * y2, xz = x * z2;
			var yy = y * y2, yz = y * z2, zz = z * z2;
			var wx = w * x2, wy = w * y2, wz = w * z2;
	
			var sx = scale.x, sy = scale.y, sz = scale.z;
	
						te[ 0 ] = ( 1 - ( yy + zz ) ) * sx;
						te[ 1 ] = ( xy + wz ) * sx;
						te[ 2 ] = ( xz - wy ) * sx;
						te[ 3 ] = 0;
	
						te[ 4 ] = ( xy - wz ) * sy;
						te[ 5 ] = ( 1 - ( xx + zz ) ) * sy;
						te[ 6 ] = ( yz + wx ) * sy;
						te[ 7 ] = 0;
	
						te[ 8 ] = ( xz + wy ) * sz;
						te[ 9 ] = ( yz - wx ) * sz;
						te[ 10 ] = ( 1 - ( xx + yy ) ) * sz;
						te[ 11 ] = 0;
	
						te[ 12 ] = position.x;
						te[ 13 ] = position.y;
						te[ 14 ] = position.z;
						te[ 15 ] = 1;
	
						return this;
	
		},
	
		decompose: function () {
	
			var vector = new Vector3();
			var matrix = new Matrix4();
	
			return function decompose( position, quaternion, scale ) {
	
				var te = this.elements;
	
				var sx = vector.set( te[ 0 ], te[ 1 ], te[ 2 ] ).length();
				var sy = vector.set( te[ 4 ], te[ 5 ], te[ 6 ] ).length();
				var sz = vector.set( te[ 8 ], te[ 9 ], te[ 10 ] ).length();
	
				// if determine is negative, we need to invert one scale
				var det = this.determinant();
				if ( det < 0 ) sx = - sx;
	
				position.x = te[ 12 ];
				position.y = te[ 13 ];
				position.z = te[ 14 ];
	
				// scale the rotation part
				matrix.copy( this );
	
				var invSX = 1 / sx;
				var invSY = 1 / sy;
				var invSZ = 1 / sz;
	
				matrix.elements[ 0 ] *= invSX;
				matrix.elements[ 1 ] *= invSX;
				matrix.elements[ 2 ] *= invSX;
	
				matrix.elements[ 4 ] *= invSY;
				matrix.elements[ 5 ] *= invSY;
				matrix.elements[ 6 ] *= invSY;
	
				matrix.elements[ 8 ] *= invSZ;
				matrix.elements[ 9 ] *= invSZ;
				matrix.elements[ 10 ] *= invSZ;
	
				quaternion.setFromRotationMatrix( matrix );
	
				scale.x = sx;
				scale.y = sy;
				scale.z = sz;
	
				return this;
	
			};
	
		}(),
	
		makePerspective: function ( left, right, top, bottom, near, far ) {
	
			if ( far === undefined ) {
	
				console.warn( 'THREE.Matrix4: .makePerspective() has been redefined and has a new signature. Please check the docs.' );
	
			}
	
			var te = this.elements;
			var x = 2 * near / ( right - left );
			var y = 2 * near / ( top - bottom );
	
			var a = ( right + left ) / ( right - left );
			var b = ( top + bottom ) / ( top - bottom );
			var c = - ( far + near ) / ( far - near );
			var d = - 2 * far * near / ( far - near );
	
			te[ 0 ] = x;	te[ 4 ] = 0;	te[ 8 ] = a;	te[ 12 ] = 0;
			te[ 1 ] = 0;	te[ 5 ] = y;	te[ 9 ] = b;	te[ 13 ] = 0;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = c;	te[ 14 ] = d;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = - 1;	te[ 15 ] = 0;
	
			return this;
	
		},
	
		makeOrthographic: function ( left, right, top, bottom, near, far ) {
	
			var te = this.elements;
			var w = 1.0 / ( right - left );
			var h = 1.0 / ( top - bottom );
			var p = 1.0 / ( far - near );
	
			var x = ( right + left ) * w;
			var y = ( top + bottom ) * h;
			var z = ( far + near ) * p;
	
			te[ 0 ] = 2 * w;	te[ 4 ] = 0;	te[ 8 ] = 0;	te[ 12 ] = - x;
			te[ 1 ] = 0;	te[ 5 ] = 2 * h;	te[ 9 ] = 0;	te[ 13 ] = - y;
			te[ 2 ] = 0;	te[ 6 ] = 0;	te[ 10 ] = - 2 * p;	te[ 14 ] = - z;
			te[ 3 ] = 0;	te[ 7 ] = 0;	te[ 11 ] = 0;	te[ 15 ] = 1;
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			for ( var i = 0; i < 16; i ++ ) {
	
				this.elements[ i ] = array[ i + offset ];
	
			}
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
			array[ offset + 3 ] = te[ 3 ];
	
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
	
			array[ offset + 8 ] = te[ 8 ];
			array[ offset + 9 ] = te[ 9 ];
			array[ offset + 10 ] = te[ 10 ];
			array[ offset + 11 ] = te[ 11 ];
	
			array[ offset + 12 ] = te[ 12 ];
			array[ offset + 13 ] = te[ 13 ];
			array[ offset + 14 ] = te[ 14 ];
			array[ offset + 15 ] = te[ 15 ];
	
			return array;
	
		}
	
	} );
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	function Quaternion( x, y, z, w ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._w = ( w !== undefined ) ? w : 1;
	
	}
	
	Object.assign( Quaternion, {
	
		slerp: function ( qa, qb, qm, t ) {
	
			return qm.copy( qa ).slerp( qb, t );
	
		},
	
		slerpFlat: function ( dst, dstOffset, src0, srcOffset0, src1, srcOffset1, t ) {
	
			// fuzz-free, array-based Quaternion SLERP operation
	
			var x0 = src0[ srcOffset0 + 0 ],
				y0 = src0[ srcOffset0 + 1 ],
				z0 = src0[ srcOffset0 + 2 ],
				w0 = src0[ srcOffset0 + 3 ],
	
				x1 = src1[ srcOffset1 + 0 ],
				y1 = src1[ srcOffset1 + 1 ],
				z1 = src1[ srcOffset1 + 2 ],
				w1 = src1[ srcOffset1 + 3 ];
	
			if ( w0 !== w1 || x0 !== x1 || y0 !== y1 || z0 !== z1 ) {
	
				var s = 1 - t,
	
					cos = x0 * x1 + y0 * y1 + z0 * z1 + w0 * w1,
	
					dir = ( cos >= 0 ? 1 : - 1 ),
					sqrSin = 1 - cos * cos;
	
				// Skip the Slerp for tiny steps to avoid numeric problems:
				if ( sqrSin > Number.EPSILON ) {
	
					var sin = Math.sqrt( sqrSin ),
						len = Math.atan2( sin, cos * dir );
	
					s = Math.sin( s * len ) / sin;
					t = Math.sin( t * len ) / sin;
	
				}
	
				var tDir = t * dir;
	
				x0 = x0 * s + x1 * tDir;
				y0 = y0 * s + y1 * tDir;
				z0 = z0 * s + z1 * tDir;
				w0 = w0 * s + w1 * tDir;
	
				// Normalize in case we just did a lerp:
				if ( s === 1 - t ) {
	
					var f = 1 / Math.sqrt( x0 * x0 + y0 * y0 + z0 * z0 + w0 * w0 );
	
					x0 *= f;
					y0 *= f;
					z0 *= f;
					w0 *= f;
	
				}
	
			}
	
			dst[ dstOffset ] = x0;
			dst[ dstOffset + 1 ] = y0;
			dst[ dstOffset + 2 ] = z0;
			dst[ dstOffset + 3 ] = w0;
	
		}
	
	} );
	
	Object.defineProperties( Quaternion.prototype, {
	
		x: {
	
			get: function () {
	
				return this._x;
	
			},
	
			set: function ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			}
	
		},
	
		y: {
	
			get: function () {
	
				return this._y;
	
			},
	
			set: function ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			}
	
		},
	
		z: {
	
			get: function () {
	
				return this._z;
	
			},
	
			set: function ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			}
	
		},
	
		w: {
	
			get: function () {
	
				return this._w;
	
			},
	
			set: function ( value ) {
	
				this._w = value;
				this.onChangeCallback();
	
			}
	
		}
	
	} );
	
	Object.assign( Quaternion.prototype, {
	
		isQuaternion: true,
	
		set: function ( x, y, z, w ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._w = w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._w );
	
		},
	
		copy: function ( quaternion ) {
	
			this._x = quaternion.x;
			this._y = quaternion.y;
			this._z = quaternion.z;
			this._w = quaternion.w;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromEuler: function ( euler, update ) {
	
			if ( ! ( euler && euler.isEuler ) ) {
	
				throw new Error( 'THREE.Quaternion: .setFromEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
			}
	
			var x = euler._x, y = euler._y, z = euler._z, order = euler.order;
	
			// http://www.mathworks.com/matlabcentral/fileexchange/
			// 	20696-function-to-convert-between-dcm-euler-angles-quaternions-and-euler-vectors/
			//	content/SpinCalc.m
	
			var cos = Math.cos;
			var sin = Math.sin;
	
			var c1 = cos( x / 2 );
			var c2 = cos( y / 2 );
			var c3 = cos( z / 2 );
	
			var s1 = sin( x / 2 );
			var s2 = sin( y / 2 );
			var s3 = sin( z / 2 );
	
			if ( order === 'XYZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'YXZ' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'ZXY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'ZYX' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			} else if ( order === 'YZX' ) {
	
				this._x = s1 * c2 * c3 + c1 * s2 * s3;
				this._y = c1 * s2 * c3 + s1 * c2 * s3;
				this._z = c1 * c2 * s3 - s1 * s2 * c3;
				this._w = c1 * c2 * c3 - s1 * s2 * s3;
	
			} else if ( order === 'XZY' ) {
	
				this._x = s1 * c2 * c3 - c1 * s2 * s3;
				this._y = c1 * s2 * c3 - s1 * c2 * s3;
				this._z = c1 * c2 * s3 + s1 * s2 * c3;
				this._w = c1 * c2 * c3 + s1 * s2 * s3;
	
			}
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromAxisAngle: function ( axis, angle ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/angleToQuaternion/index.htm
	
			// assumes axis is normalized
	
			var halfAngle = angle / 2, s = Math.sin( halfAngle );
	
			this._x = axis.x * s;
			this._y = axis.y * s;
			this._z = axis.z * s;
			this._w = Math.cos( halfAngle );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToQuaternion/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ],
	
				trace = m11 + m22 + m33,
				s;
	
			if ( trace > 0 ) {
	
				s = 0.5 / Math.sqrt( trace + 1.0 );
	
				this._w = 0.25 / s;
				this._x = ( m32 - m23 ) * s;
				this._y = ( m13 - m31 ) * s;
				this._z = ( m21 - m12 ) * s;
	
			} else if ( m11 > m22 && m11 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m11 - m22 - m33 );
	
				this._w = ( m32 - m23 ) / s;
				this._x = 0.25 * s;
				this._y = ( m12 + m21 ) / s;
				this._z = ( m13 + m31 ) / s;
	
			} else if ( m22 > m33 ) {
	
				s = 2.0 * Math.sqrt( 1.0 + m22 - m11 - m33 );
	
				this._w = ( m13 - m31 ) / s;
				this._x = ( m12 + m21 ) / s;
				this._y = 0.25 * s;
				this._z = ( m23 + m32 ) / s;
	
			} else {
	
				s = 2.0 * Math.sqrt( 1.0 + m33 - m11 - m22 );
	
				this._w = ( m21 - m12 ) / s;
				this._x = ( m13 + m31 ) / s;
				this._y = ( m23 + m32 ) / s;
				this._z = 0.25 * s;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromUnitVectors: function () {
	
			// assumes direction vectors vFrom and vTo are normalized
	
			var v1 = new Vector3();
			var r;
	
			var EPS = 0.000001;
	
			return function setFromUnitVectors( vFrom, vTo ) {
	
				if ( v1 === undefined ) v1 = new Vector3();
	
				r = vFrom.dot( vTo ) + 1;
	
				if ( r < EPS ) {
	
					r = 0;
	
					if ( Math.abs( vFrom.x ) > Math.abs( vFrom.z ) ) {
	
						v1.set( - vFrom.y, vFrom.x, 0 );
	
					} else {
	
						v1.set( 0, - vFrom.z, vFrom.y );
	
					}
	
				} else {
	
					v1.crossVectors( vFrom, vTo );
	
				}
	
				this._x = v1.x;
				this._y = v1.y;
				this._z = v1.z;
				this._w = r;
	
				return this.normalize();
	
			};
	
		}(),
	
		angleTo: function ( q ) {
	
			return 2 * Math.acos( Math.abs( _Math.clamp( this.dot( q ), - 1, 1 ) ) );
	
		},
	
		rotateTowards: function ( q, step ) {
	
			var angle = this.angleTo( q );
	
			if ( angle === 0 ) return this;
	
			var t = Math.min( 1, step / angle );
	
			this.slerp( q, t );
	
			return this;
	
		},
	
		inverse: function () {
	
			// quaternion is assumed to have unit length
	
			return this.conjugate();
	
		},
	
		conjugate: function () {
	
			this._x *= - 1;
			this._y *= - 1;
			this._z *= - 1;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this._x * v._x + this._y * v._y + this._z * v._z + this._w * v._w;
	
		},
	
		lengthSq: function () {
	
			return this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this._x * this._x + this._y * this._y + this._z * this._z + this._w * this._w );
	
		},
	
		normalize: function () {
	
			var l = this.length();
	
			if ( l === 0 ) {
	
				this._x = 0;
				this._y = 0;
				this._z = 0;
				this._w = 1;
	
			} else {
	
				l = 1 / l;
	
				this._x = this._x * l;
				this._y = this._y * l;
				this._z = this._z * l;
				this._w = this._w * l;
	
			}
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		multiply: function ( q, p ) {
	
			if ( p !== undefined ) {
	
				console.warn( 'THREE.Quaternion: .multiply() now only accepts one argument. Use .multiplyQuaternions( a, b ) instead.' );
				return this.multiplyQuaternions( q, p );
	
			}
	
			return this.multiplyQuaternions( this, q );
	
		},
	
		premultiply: function ( q ) {
	
			return this.multiplyQuaternions( q, this );
	
		},
	
		multiplyQuaternions: function ( a, b ) {
	
			// from http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/code/index.htm
	
			var qax = a._x, qay = a._y, qaz = a._z, qaw = a._w;
			var qbx = b._x, qby = b._y, qbz = b._z, qbw = b._w;
	
			this._x = qax * qbw + qaw * qbx + qay * qbz - qaz * qby;
			this._y = qay * qbw + qaw * qby + qaz * qbx - qax * qbz;
			this._z = qaz * qbw + qaw * qbz + qax * qby - qay * qbx;
			this._w = qaw * qbw - qax * qbx - qay * qby - qaz * qbz;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		slerp: function ( qb, t ) {
	
			if ( t === 0 ) return this;
			if ( t === 1 ) return this.copy( qb );
	
			var x = this._x, y = this._y, z = this._z, w = this._w;
	
			// http://www.euclideanspace.com/maths/algebra/realNormedAlgebra/quaternions/slerp/
	
			var cosHalfTheta = w * qb._w + x * qb._x + y * qb._y + z * qb._z;
	
			if ( cosHalfTheta < 0 ) {
	
				this._w = - qb._w;
				this._x = - qb._x;
				this._y = - qb._y;
				this._z = - qb._z;
	
				cosHalfTheta = - cosHalfTheta;
	
			} else {
	
				this.copy( qb );
	
			}
	
			if ( cosHalfTheta >= 1.0 ) {
	
				this._w = w;
				this._x = x;
				this._y = y;
				this._z = z;
	
				return this;
	
			}
	
			var sqrSinHalfTheta = 1.0 - cosHalfTheta * cosHalfTheta;
	
			if ( sqrSinHalfTheta <= Number.EPSILON ) {
	
				var s = 1 - t;
				this._w = s * w + t * this._w;
				this._x = s * x + t * this._x;
				this._y = s * y + t * this._y;
				this._z = s * z + t * this._z;
	
				return this.normalize();
	
			}
	
			var sinHalfTheta = Math.sqrt( sqrSinHalfTheta );
			var halfTheta = Math.atan2( sinHalfTheta, cosHalfTheta );
			var ratioA = Math.sin( ( 1 - t ) * halfTheta ) / sinHalfTheta,
				ratioB = Math.sin( t * halfTheta ) / sinHalfTheta;
	
			this._w = ( w * ratioA + this._w * ratioB );
			this._x = ( x * ratioA + this._x * ratioB );
			this._y = ( y * ratioA + this._y * ratioB );
			this._z = ( z * ratioA + this._z * ratioB );
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		equals: function ( quaternion ) {
	
			return ( quaternion._x === this._x ) && ( quaternion._y === this._y ) && ( quaternion._z === this._z ) && ( quaternion._w === this._w );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this._x = array[ offset ];
			this._y = array[ offset + 1 ];
			this._z = array[ offset + 2 ];
			this._w = array[ offset + 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._w;
	
			return array;
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function Vector3( x, y, z ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
	
	}
	
	Object.assign( Vector3.prototype, {
	
		isVector3: true,
	
		set: function ( x, y, z ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
			return this;
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
	
			return this;
	
		},
	
		multiply: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .multiply() now only accepts one argument. Use .multiplyVectors( a, b ) instead.' );
				return this.multiplyVectors( v, w );
	
			}
	
			this.x *= v.x;
			this.y *= v.y;
			this.z *= v.z;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
	
			return this;
	
		},
	
		multiplyVectors: function ( a, b ) {
	
			this.x = a.x * b.x;
			this.y = a.y * b.y;
			this.z = a.z * b.z;
	
			return this;
	
		},
	
		applyEuler: function () {
	
			var quaternion = new Quaternion();
	
			return function applyEuler( euler ) {
	
				if ( ! ( euler && euler.isEuler ) ) {
	
					console.error( 'THREE.Vector3: .applyEuler() now expects an Euler rotation rather than a Vector3 and order.' );
	
				}
	
				return this.applyQuaternion( quaternion.setFromEuler( euler ) );
	
			};
	
		}(),
	
		applyAxisAngle: function () {
	
			var quaternion = new Quaternion();
	
			return function applyAxisAngle( axis, angle ) {
	
				return this.applyQuaternion( quaternion.setFromAxisAngle( axis, angle ) );
	
			};
	
		}(),
	
		applyMatrix3: function ( m ) {
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 3 ] * y + e[ 6 ] * z;
			this.y = e[ 1 ] * x + e[ 4 ] * y + e[ 7 ] * z;
			this.z = e[ 2 ] * x + e[ 5 ] * y + e[ 8 ] * z;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
	
			var w = 1 / ( e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] );
	
			this.x = ( e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] ) * w;
			this.y = ( e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] ) * w;
			this.z = ( e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] ) * w;
	
			return this;
	
		},
	
		applyQuaternion: function ( q ) {
	
			var x = this.x, y = this.y, z = this.z;
			var qx = q.x, qy = q.y, qz = q.z, qw = q.w;
	
			// calculate quat * vector
	
			var ix = qw * x + qy * z - qz * y;
			var iy = qw * y + qz * x - qx * z;
			var iz = qw * z + qx * y - qy * x;
			var iw = - qx * x - qy * y - qz * z;
	
			// calculate result * inverse quat
	
			this.x = ix * qw + iw * - qx + iy * - qz - iz * - qy;
			this.y = iy * qw + iw * - qy + iz * - qx - ix * - qz;
			this.z = iz * qw + iw * - qz + ix * - qy - iy * - qx;
	
			return this;
	
		},
	
		project: function ( camera ) {
	
			return this.applyMatrix4( camera.matrixWorldInverse ).applyMatrix4( camera.projectionMatrix );
	
		},
	
		unproject: function () {
	
			var matrix = new Matrix4();
	
			return function unproject( camera ) {
	
				return this.applyMatrix4( matrix.getInverse( camera.projectionMatrix ) ).applyMatrix4( camera.matrixWorld );
	
			};
	
		}(),
	
		transformDirection: function ( m ) {
	
			// input: THREE.Matrix4 affine matrix
			// vector interpreted as a direction
	
			var x = this.x, y = this.y, z = this.z;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z;
	
			return this.normalize();
	
		},
	
		divide: function ( v ) {
	
			this.x /= v.x;
			this.y /= v.y;
			this.z /= v.z;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// assumes min < max, componentwise
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min = new Vector3();
			var max = new Vector3();
	
			return function clampScalar( minVal, maxVal ) {
	
				min.set( minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z;
	
		},
	
		// TODO lengthSquared?
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z );
	
		},
	
		manhattanLength: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() || 1 );
	
		},
	
		setLength: function ( length ) {
	
			return this.normalize().multiplyScalar( length );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
		},
	
		cross: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector3: .cross() now only accepts one argument. Use .crossVectors( a, b ) instead.' );
				return this.crossVectors( v, w );
	
			}
	
			return this.crossVectors( this, v );
	
		},
	
		crossVectors: function ( a, b ) {
	
			var ax = a.x, ay = a.y, az = a.z;
			var bx = b.x, by = b.y, bz = b.z;
	
			this.x = ay * bz - az * by;
			this.y = az * bx - ax * bz;
			this.z = ax * by - ay * bx;
	
			return this;
	
		},
	
		projectOnVector: function ( vector ) {
	
			var scalar = vector.dot( this ) / vector.lengthSq();
	
			return this.copy( vector ).multiplyScalar( scalar );
	
		},
	
		projectOnPlane: function () {
	
			var v1 = new Vector3();
	
			return function projectOnPlane( planeNormal ) {
	
				v1.copy( this ).projectOnVector( planeNormal );
	
				return this.sub( v1 );
	
			};
	
		}(),
	
		reflect: function () {
	
			// reflect incident vector off plane orthogonal to normal
			// normal is assumed to have unit length
	
			var v1 = new Vector3();
	
			return function reflect( normal ) {
	
				return this.sub( v1.copy( normal ).multiplyScalar( 2 * this.dot( normal ) ) );
	
			};
	
		}(),
	
		angleTo: function ( v ) {
	
			var theta = this.dot( v ) / ( Math.sqrt( this.lengthSq() * v.lengthSq() ) );
	
			// clamp, to handle numerical problems
	
			return Math.acos( _Math.clamp( theta, - 1, 1 ) );
	
		},
	
		distanceTo: function ( v ) {
	
			return Math.sqrt( this.distanceToSquared( v ) );
	
		},
	
		distanceToSquared: function ( v ) {
	
			var dx = this.x - v.x, dy = this.y - v.y, dz = this.z - v.z;
	
			return dx * dx + dy * dy + dz * dz;
	
		},
	
		manhattanDistanceTo: function ( v ) {
	
			return Math.abs( this.x - v.x ) + Math.abs( this.y - v.y ) + Math.abs( this.z - v.z );
	
		},
	
		setFromSpherical: function ( s ) {
	
			return this.setFromSphericalCoords( s.radius, s.phi, s.theta );
	
		},
	
		setFromSphericalCoords: function ( radius, phi, theta ) {
	
			var sinPhiRadius = Math.sin( phi ) * radius;
	
			this.x = sinPhiRadius * Math.sin( theta );
			this.y = Math.cos( phi ) * radius;
			this.z = sinPhiRadius * Math.cos( theta );
	
			return this;
	
		},
	
		setFromCylindrical: function ( c ) {
	
			return this.setFromCylindricalCoords( c.radius, c.theta, c.y );
	
		},
	
		setFromCylindricalCoords: function ( radius, theta, y ) {
	
			this.x = radius * Math.sin( theta );
			this.y = y;
			this.z = radius * Math.cos( theta );
	
			return this;
	
		},
	
		setFromMatrixPosition: function ( m ) {
	
			var e = m.elements;
	
			this.x = e[ 12 ];
			this.y = e[ 13 ];
			this.z = e[ 14 ];
	
			return this;
	
		},
	
		setFromMatrixScale: function ( m ) {
	
			var sx = this.setFromMatrixColumn( m, 0 ).length();
			var sy = this.setFromMatrixColumn( m, 1 ).length();
			var sz = this.setFromMatrixColumn( m, 2 ).length();
	
			this.x = sx;
			this.y = sy;
			this.z = sz;
	
			return this;
	
		},
	
		setFromMatrixColumn: function ( m, index ) {
	
			return this.fromArray( m.elements, index * 4 );
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
	
			return array;
	
		},
	
		fromBufferAttribute: function ( attribute, index, offset ) {
	
			if ( offset !== undefined ) {
	
				console.warn( 'THREE.Vector3: offset has been removed from .fromBufferAttribute().' );
	
			}
	
			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 * @author tschw
	 */
	
	function Matrix3() {
	
		this.elements = [
	
			1, 0, 0,
			0, 1, 0,
			0, 0, 1
	
		];
	
		if ( arguments.length > 0 ) {
	
			console.error( 'THREE.Matrix3: the constructor no longer reads arguments. use .set() instead.' );
	
		}
	
	}
	
	Object.assign( Matrix3.prototype, {
	
		isMatrix3: true,
	
		set: function ( n11, n12, n13, n21, n22, n23, n31, n32, n33 ) {
	
			var te = this.elements;
	
			te[ 0 ] = n11; te[ 1 ] = n21; te[ 2 ] = n31;
			te[ 3 ] = n12; te[ 4 ] = n22; te[ 5 ] = n32;
			te[ 6 ] = n13; te[ 7 ] = n23; te[ 8 ] = n33;
	
			return this;
	
		},
	
		identity: function () {
	
			this.set(
	
				1, 0, 0,
				0, 1, 0,
				0, 0, 1
	
			);
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().fromArray( this.elements );
	
		},
	
		copy: function ( m ) {
	
			var te = this.elements;
			var me = m.elements;
	
			te[ 0 ] = me[ 0 ]; te[ 1 ] = me[ 1 ]; te[ 2 ] = me[ 2 ];
			te[ 3 ] = me[ 3 ]; te[ 4 ] = me[ 4 ]; te[ 5 ] = me[ 5 ];
			te[ 6 ] = me[ 6 ]; te[ 7 ] = me[ 7 ]; te[ 8 ] = me[ 8 ];
	
			return this;
	
		},
	
		setFromMatrix4: function ( m ) {
	
			var me = m.elements;
	
			this.set(
	
				me[ 0 ], me[ 4 ], me[ 8 ],
				me[ 1 ], me[ 5 ], me[ 9 ],
				me[ 2 ], me[ 6 ], me[ 10 ]
	
			);
	
			return this;
	
		},
	
		applyToBufferAttribute: function () {
	
			var v1 = new Vector3();
	
			return function applyToBufferAttribute( attribute ) {
	
				for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
					v1.x = attribute.getX( i );
					v1.y = attribute.getY( i );
					v1.z = attribute.getZ( i );
	
					v1.applyMatrix3( this );
	
					attribute.setXYZ( i, v1.x, v1.y, v1.z );
	
				}
	
				return attribute;
	
			};
	
		}(),
	
		multiply: function ( m ) {
	
			return this.multiplyMatrices( this, m );
	
		},
	
		premultiply: function ( m ) {
	
			return this.multiplyMatrices( m, this );
	
		},
	
		multiplyMatrices: function ( a, b ) {
	
			var ae = a.elements;
			var be = b.elements;
			var te = this.elements;
	
			var a11 = ae[ 0 ], a12 = ae[ 3 ], a13 = ae[ 6 ];
			var a21 = ae[ 1 ], a22 = ae[ 4 ], a23 = ae[ 7 ];
			var a31 = ae[ 2 ], a32 = ae[ 5 ], a33 = ae[ 8 ];
	
			var b11 = be[ 0 ], b12 = be[ 3 ], b13 = be[ 6 ];
			var b21 = be[ 1 ], b22 = be[ 4 ], b23 = be[ 7 ];
			var b31 = be[ 2 ], b32 = be[ 5 ], b33 = be[ 8 ];
	
			te[ 0 ] = a11 * b11 + a12 * b21 + a13 * b31;
			te[ 3 ] = a11 * b12 + a12 * b22 + a13 * b32;
			te[ 6 ] = a11 * b13 + a12 * b23 + a13 * b33;
	
			te[ 1 ] = a21 * b11 + a22 * b21 + a23 * b31;
			te[ 4 ] = a21 * b12 + a22 * b22 + a23 * b32;
			te[ 7 ] = a21 * b13 + a22 * b23 + a23 * b33;
	
			te[ 2 ] = a31 * b11 + a32 * b21 + a33 * b31;
			te[ 5 ] = a31 * b12 + a32 * b22 + a33 * b32;
			te[ 8 ] = a31 * b13 + a32 * b23 + a33 * b33;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			var te = this.elements;
	
			te[ 0 ] *= s; te[ 3 ] *= s; te[ 6 ] *= s;
			te[ 1 ] *= s; te[ 4 ] *= s; te[ 7 ] *= s;
			te[ 2 ] *= s; te[ 5 ] *= s; te[ 8 ] *= s;
	
			return this;
	
		},
	
		determinant: function () {
	
			var te = this.elements;
	
			var a = te[ 0 ], b = te[ 1 ], c = te[ 2 ],
				d = te[ 3 ], e = te[ 4 ], f = te[ 5 ],
				g = te[ 6 ], h = te[ 7 ], i = te[ 8 ];
	
			return a * e * i - a * f * h - b * d * i + b * f * g + c * d * h - c * e * g;
	
		},
	
		getInverse: function ( matrix, throwOnDegenerate ) {
	
			if ( matrix && matrix.isMatrix4 ) {
	
				console.error( "THREE.Matrix3: .getInverse() no longer takes a Matrix4 argument." );
	
			}
	
			var me = matrix.elements,
				te = this.elements,
	
				n11 = me[ 0 ], n21 = me[ 1 ], n31 = me[ 2 ],
				n12 = me[ 3 ], n22 = me[ 4 ], n32 = me[ 5 ],
				n13 = me[ 6 ], n23 = me[ 7 ], n33 = me[ 8 ],
	
				t11 = n33 * n22 - n32 * n23,
				t12 = n32 * n13 - n33 * n12,
				t13 = n23 * n12 - n22 * n13,
	
				det = n11 * t11 + n21 * t12 + n31 * t13;
	
			if ( det === 0 ) {
	
				var msg = "THREE.Matrix3: .getInverse() can't invert matrix, determinant is 0";
	
				if ( throwOnDegenerate === true ) {
	
					throw new Error( msg );
	
				} else {
	
					console.warn( msg );
	
				}
	
				return this.identity();
	
			}
	
			var detInv = 1 / det;
	
			te[ 0 ] = t11 * detInv;
			te[ 1 ] = ( n31 * n23 - n33 * n21 ) * detInv;
			te[ 2 ] = ( n32 * n21 - n31 * n22 ) * detInv;
	
			te[ 3 ] = t12 * detInv;
			te[ 4 ] = ( n33 * n11 - n31 * n13 ) * detInv;
			te[ 5 ] = ( n31 * n12 - n32 * n11 ) * detInv;
	
			te[ 6 ] = t13 * detInv;
			te[ 7 ] = ( n21 * n13 - n23 * n11 ) * detInv;
			te[ 8 ] = ( n22 * n11 - n21 * n12 ) * detInv;
	
			return this;
	
		},
	
		transpose: function () {
	
			var tmp, m = this.elements;
	
			tmp = m[ 1 ]; m[ 1 ] = m[ 3 ]; m[ 3 ] = tmp;
			tmp = m[ 2 ]; m[ 2 ] = m[ 6 ]; m[ 6 ] = tmp;
			tmp = m[ 5 ]; m[ 5 ] = m[ 7 ]; m[ 7 ] = tmp;
	
			return this;
	
		},
	
		getNormalMatrix: function ( matrix4 ) {
	
			return this.setFromMatrix4( matrix4 ).getInverse( this ).transpose();
	
		},
	
		transposeIntoArray: function ( r ) {
	
			var m = this.elements;
	
			r[ 0 ] = m[ 0 ];
			r[ 1 ] = m[ 3 ];
			r[ 2 ] = m[ 6 ];
			r[ 3 ] = m[ 1 ];
			r[ 4 ] = m[ 4 ];
			r[ 5 ] = m[ 7 ];
			r[ 6 ] = m[ 2 ];
			r[ 7 ] = m[ 5 ];
			r[ 8 ] = m[ 8 ];
	
			return this;
	
		},
	
		setUvTransform: function ( tx, ty, sx, sy, rotation, cx, cy ) {
	
			var c = Math.cos( rotation );
			var s = Math.sin( rotation );
	
			this.set(
				sx * c, sx * s, - sx * ( c * cx + s * cy ) + cx + tx,
				- sy * s, sy * c, - sy * ( - s * cx + c * cy ) + cy + ty,
				0, 0, 1
			);
	
		},
	
		scale: function ( sx, sy ) {
	
			var te = this.elements;
	
			te[ 0 ] *= sx; te[ 3 ] *= sx; te[ 6 ] *= sx;
			te[ 1 ] *= sy; te[ 4 ] *= sy; te[ 7 ] *= sy;
	
			return this;
	
		},
	
		rotate: function ( theta ) {
	
			var c = Math.cos( theta );
			var s = Math.sin( theta );
	
			var te = this.elements;
	
			var a11 = te[ 0 ], a12 = te[ 3 ], a13 = te[ 6 ];
			var a21 = te[ 1 ], a22 = te[ 4 ], a23 = te[ 7 ];
	
			te[ 0 ] = c * a11 + s * a21;
			te[ 3 ] = c * a12 + s * a22;
			te[ 6 ] = c * a13 + s * a23;
	
			te[ 1 ] = - s * a11 + c * a21;
			te[ 4 ] = - s * a12 + c * a22;
			te[ 7 ] = - s * a13 + c * a23;
	
			return this;
	
		},
	
		translate: function ( tx, ty ) {
	
			var te = this.elements;
	
			te[ 0 ] += tx * te[ 2 ]; te[ 3 ] += tx * te[ 5 ]; te[ 6 ] += tx * te[ 8 ];
			te[ 1 ] += ty * te[ 2 ]; te[ 4 ] += ty * te[ 5 ]; te[ 7 ] += ty * te[ 8 ];
	
			return this;
	
		},
	
		equals: function ( matrix ) {
	
			var te = this.elements;
			var me = matrix.elements;
	
			for ( var i = 0; i < 9; i ++ ) {
	
				if ( te[ i ] !== me[ i ] ) return false;
	
			}
	
			return true;
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			for ( var i = 0; i < 9; i ++ ) {
	
				this.elements[ i ] = array[ i + offset ];
	
			}
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			var te = this.elements;
	
			array[ offset ] = te[ 0 ];
			array[ offset + 1 ] = te[ 1 ];
			array[ offset + 2 ] = te[ 2 ];
	
			array[ offset + 3 ] = te[ 3 ];
			array[ offset + 4 ] = te[ 4 ];
			array[ offset + 5 ] = te[ 5 ];
	
			array[ offset + 6 ] = te[ 6 ];
			array[ offset + 7 ] = te[ 7 ];
			array[ offset + 8 ] = te[ 8 ];
	
			return array;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	var _canvas;
	
	var ImageUtils = {
	
		getDataURL: function ( image ) {
	
			var canvas;
	
			if ( typeof HTMLCanvasElement == 'undefined' ) {
	
				return image.src;
	
			} else if ( image instanceof HTMLCanvasElement ) {
	
				canvas = image;
	
			} else {
	
				if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	
				_canvas.width = image.width;
				_canvas.height = image.height;
	
				var context = _canvas.getContext( '2d' );
	
				if ( image instanceof ImageData ) {
	
					context.putImageData( image, 0, 0 );
	
				} else {
	
					context.drawImage( image, 0, 0, image.width, image.height );
	
				}
	
				canvas = _canvas;
	
			}
	
			if ( canvas.width > 2048 || canvas.height > 2048 ) {
	
				return canvas.toDataURL( 'image/jpeg', 0.6 );
	
			} else {
	
				return canvas.toDataURL( 'image/png' );
	
			}
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 */
	
	var textureId = 0;
	
	function Texture( image, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
		Object.defineProperty( this, 'id', { value: textureId ++ } );
	
		this.uuid = _Math.generateUUID();
	
		this.name = '';
	
		this.image = image !== undefined ? image : Texture.DEFAULT_IMAGE;
		this.mipmaps = [];
	
		this.mapping = mapping !== undefined ? mapping : Texture.DEFAULT_MAPPING;
	
		this.wrapS = wrapS !== undefined ? wrapS : ClampToEdgeWrapping;
		this.wrapT = wrapT !== undefined ? wrapT : ClampToEdgeWrapping;
	
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
		this.minFilter = minFilter !== undefined ? minFilter : LinearMipMapLinearFilter;
	
		this.anisotropy = anisotropy !== undefined ? anisotropy : 1;
	
		this.format = format !== undefined ? format : RGBAFormat;
		this.type = type !== undefined ? type : UnsignedByteType;
	
		this.offset = new Vector2( 0, 0 );
		this.repeat = new Vector2( 1, 1 );
		this.center = new Vector2( 0, 0 );
		this.rotation = 0;
	
		this.matrixAutoUpdate = true;
		this.matrix = new Matrix3();
	
		this.generateMipmaps = true;
		this.premultiplyAlpha = false;
		this.flipY = true;
		this.unpackAlignment = 4;	// valid values: 1, 2, 4, 8 (see http://www.khronos.org/opengles/sdk/docs/man/xhtml/glPixelStorei.xml)
	
		// Values of encoding !== THREE.LinearEncoding only supported on map, envMap and emissiveMap.
		//
		// Also changing the encoding after already used by a Material will not automatically make the Material
		// update.  You need to explicitly call Material.needsUpdate to trigger it to recompile.
		this.encoding = encoding !== undefined ? encoding : LinearEncoding;
	
		this.version = 0;
		this.onUpdate = null;
	
	}
	
	Texture.DEFAULT_IMAGE = undefined;
	Texture.DEFAULT_MAPPING = UVMapping;
	
	Texture.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: Texture,
	
		isTexture: true,
	
		updateMatrix: function () {
	
			this.matrix.setUvTransform( this.offset.x, this.offset.y, this.repeat.x, this.repeat.y, this.rotation, this.center.x, this.center.y );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
	
			this.image = source.image;
			this.mipmaps = source.mipmaps.slice( 0 );
	
			this.mapping = source.mapping;
	
			this.wrapS = source.wrapS;
			this.wrapT = source.wrapT;
	
			this.magFilter = source.magFilter;
			this.minFilter = source.minFilter;
	
			this.anisotropy = source.anisotropy;
	
			this.format = source.format;
			this.type = source.type;
	
			this.offset.copy( source.offset );
			this.repeat.copy( source.repeat );
			this.center.copy( source.center );
			this.rotation = source.rotation;
	
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrix.copy( source.matrix );
	
			this.generateMipmaps = source.generateMipmaps;
			this.premultiplyAlpha = source.premultiplyAlpha;
			this.flipY = source.flipY;
			this.unpackAlignment = source.unpackAlignment;
			this.encoding = source.encoding;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			var isRootObject = ( meta === undefined || typeof meta === 'string' );
	
			if ( ! isRootObject && meta.textures[ this.uuid ] !== undefined ) {
	
				return meta.textures[ this.uuid ];
	
			}
	
			var output = {
	
				metadata: {
					version: 4.5,
					type: 'Texture',
					generator: 'Texture.toJSON'
				},
	
				uuid: this.uuid,
				name: this.name,
	
				mapping: this.mapping,
	
				repeat: [ this.repeat.x, this.repeat.y ],
				offset: [ this.offset.x, this.offset.y ],
				center: [ this.center.x, this.center.y ],
				rotation: this.rotation,
	
				wrap: [ this.wrapS, this.wrapT ],
	
				format: this.format,
				type: this.type,
				encoding: this.encoding,
	
				minFilter: this.minFilter,
				magFilter: this.magFilter,
				anisotropy: this.anisotropy,
	
				flipY: this.flipY,
	
				premultiplyAlpha: this.premultiplyAlpha,
				unpackAlignment: this.unpackAlignment
	
			};
	
			if ( this.image !== undefined ) {
	
				// TODO: Move to THREE.Image
	
				var image = this.image;
	
				if ( image.uuid === undefined ) {
	
					image.uuid = _Math.generateUUID(); // UGH
	
				}
	
				if ( ! isRootObject && meta.images[ image.uuid ] === undefined ) {
	
					var url;
	
					if ( Array.isArray( image ) ) {
	
						// process array of images e.g. CubeTexture
	
						url = [];
	
						for ( var i = 0, l = image.length; i < l; i ++ ) {
	
							url.push( ImageUtils.getDataURL( image[ i ] ) );
	
						}
	
					} else {
	
						// process single image
	
						url = ImageUtils.getDataURL( image );
	
					}
	
					meta.images[ image.uuid ] = {
						uuid: image.uuid,
						url: url
					};
	
				}
	
				output.image = image.uuid;
	
			}
	
			if ( ! isRootObject ) {
	
				meta.textures[ this.uuid ] = output;
	
			}
	
			return output;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		},
	
		transformUv: function ( uv ) {
	
			if ( this.mapping !== UVMapping ) return uv;
	
			uv.applyMatrix3( this.matrix );
	
			if ( uv.x < 0 || uv.x > 1 ) {
	
				switch ( this.wrapS ) {
	
					case RepeatWrapping:
	
						uv.x = uv.x - Math.floor( uv.x );
						break;
	
					case ClampToEdgeWrapping:
	
						uv.x = uv.x < 0 ? 0 : 1;
						break;
	
					case MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.x ) % 2 ) === 1 ) {
	
							uv.x = Math.ceil( uv.x ) - uv.x;
	
						} else {
	
							uv.x = uv.x - Math.floor( uv.x );
	
						}
						break;
	
				}
	
			}
	
			if ( uv.y < 0 || uv.y > 1 ) {
	
				switch ( this.wrapT ) {
	
					case RepeatWrapping:
	
						uv.y = uv.y - Math.floor( uv.y );
						break;
	
					case ClampToEdgeWrapping:
	
						uv.y = uv.y < 0 ? 0 : 1;
						break;
	
					case MirroredRepeatWrapping:
	
						if ( Math.abs( Math.floor( uv.y ) % 2 ) === 1 ) {
	
							uv.y = Math.ceil( uv.y ) - uv.y;
	
						} else {
	
							uv.y = uv.y - Math.floor( uv.y );
	
						}
						break;
	
				}
	
			}
	
			if ( this.flipY ) {
	
				uv.y = 1 - uv.y;
	
			}
	
			return uv;
	
		}
	
	} );
	
	Object.defineProperty( Texture.prototype, "needsUpdate", {
	
		set: function ( value ) {
	
			if ( value === true ) this.version ++;
	
		}
	
	} );
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author philogb / http://blog.thejit.org/
	 * @author mikael emtinger / http://gomo.se/
	 * @author egraether / http://egraether.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function Vector4( x, y, z, w ) {
	
		this.x = x || 0;
		this.y = y || 0;
		this.z = z || 0;
		this.w = ( w !== undefined ) ? w : 1;
	
	}
	
	Object.assign( Vector4.prototype, {
	
		isVector4: true,
	
		set: function ( x, y, z, w ) {
	
			this.x = x;
			this.y = y;
			this.z = z;
			this.w = w;
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.x = scalar;
			this.y = scalar;
			this.z = scalar;
			this.w = scalar;
	
			return this;
	
		},
	
		setX: function ( x ) {
	
			this.x = x;
	
			return this;
	
		},
	
		setY: function ( y ) {
	
			this.y = y;
	
			return this;
	
		},
	
		setZ: function ( z ) {
	
			this.z = z;
	
			return this;
	
		},
	
		setW: function ( w ) {
	
			this.w = w;
	
			return this;
	
		},
	
		setComponent: function ( index, value ) {
	
			switch ( index ) {
	
				case 0: this.x = value; break;
				case 1: this.y = value; break;
				case 2: this.z = value; break;
				case 3: this.w = value; break;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
			return this;
	
		},
	
		getComponent: function ( index ) {
	
			switch ( index ) {
	
				case 0: return this.x;
				case 1: return this.y;
				case 2: return this.z;
				case 3: return this.w;
				default: throw new Error( 'index is out of range: ' + index );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.x, this.y, this.z, this.w );
	
		},
	
		copy: function ( v ) {
	
			this.x = v.x;
			this.y = v.y;
			this.z = v.z;
			this.w = ( v.w !== undefined ) ? v.w : 1;
	
			return this;
	
		},
	
		add: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .add() now only accepts one argument. Use .addVectors( a, b ) instead.' );
				return this.addVectors( v, w );
	
			}
	
			this.x += v.x;
			this.y += v.y;
			this.z += v.z;
			this.w += v.w;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.x += s;
			this.y += s;
			this.z += s;
			this.w += s;
	
			return this;
	
		},
	
		addVectors: function ( a, b ) {
	
			this.x = a.x + b.x;
			this.y = a.y + b.y;
			this.z = a.z + b.z;
			this.w = a.w + b.w;
	
			return this;
	
		},
	
		addScaledVector: function ( v, s ) {
	
			this.x += v.x * s;
			this.y += v.y * s;
			this.z += v.z * s;
			this.w += v.w * s;
	
			return this;
	
		},
	
		sub: function ( v, w ) {
	
			if ( w !== undefined ) {
	
				console.warn( 'THREE.Vector4: .sub() now only accepts one argument. Use .subVectors( a, b ) instead.' );
				return this.subVectors( v, w );
	
			}
	
			this.x -= v.x;
			this.y -= v.y;
			this.z -= v.z;
			this.w -= v.w;
	
			return this;
	
		},
	
		subScalar: function ( s ) {
	
			this.x -= s;
			this.y -= s;
			this.z -= s;
			this.w -= s;
	
			return this;
	
		},
	
		subVectors: function ( a, b ) {
	
			this.x = a.x - b.x;
			this.y = a.y - b.y;
			this.z = a.z - b.z;
			this.w = a.w - b.w;
	
			return this;
	
		},
	
		multiplyScalar: function ( scalar ) {
	
			this.x *= scalar;
			this.y *= scalar;
			this.z *= scalar;
			this.w *= scalar;
	
			return this;
	
		},
	
		applyMatrix4: function ( m ) {
	
			var x = this.x, y = this.y, z = this.z, w = this.w;
			var e = m.elements;
	
			this.x = e[ 0 ] * x + e[ 4 ] * y + e[ 8 ] * z + e[ 12 ] * w;
			this.y = e[ 1 ] * x + e[ 5 ] * y + e[ 9 ] * z + e[ 13 ] * w;
			this.z = e[ 2 ] * x + e[ 6 ] * y + e[ 10 ] * z + e[ 14 ] * w;
			this.w = e[ 3 ] * x + e[ 7 ] * y + e[ 11 ] * z + e[ 15 ] * w;
	
			return this;
	
		},
	
		divideScalar: function ( scalar ) {
	
			return this.multiplyScalar( 1 / scalar );
	
		},
	
		setAxisAngleFromQuaternion: function ( q ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/quaternionToAngle/index.htm
	
			// q is assumed to be normalized
	
			this.w = 2 * Math.acos( q.w );
	
			var s = Math.sqrt( 1 - q.w * q.w );
	
			if ( s < 0.0001 ) {
	
				this.x = 1;
				this.y = 0;
				this.z = 0;
	
			} else {
	
				this.x = q.x / s;
				this.y = q.y / s;
				this.z = q.z / s;
	
			}
	
			return this;
	
		},
	
		setAxisAngleFromRotationMatrix: function ( m ) {
	
			// http://www.euclideanspace.com/maths/geometry/rotations/conversions/matrixToAngle/index.htm
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var angle, x, y, z,		// variables for result
				epsilon = 0.01,		// margin to allow for rounding errors
				epsilon2 = 0.1,		// margin to distinguish between 0 and 180 degrees
	
				te = m.elements,
	
				m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ],
				m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ],
				m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			if ( ( Math.abs( m12 - m21 ) < epsilon ) &&
					 ( Math.abs( m13 - m31 ) < epsilon ) &&
					 ( Math.abs( m23 - m32 ) < epsilon ) ) {
	
				// singularity found
				// first check for identity matrix which must have +1 for all terms
				// in leading diagonal and zero in other terms
	
				if ( ( Math.abs( m12 + m21 ) < epsilon2 ) &&
						 ( Math.abs( m13 + m31 ) < epsilon2 ) &&
						 ( Math.abs( m23 + m32 ) < epsilon2 ) &&
						 ( Math.abs( m11 + m22 + m33 - 3 ) < epsilon2 ) ) {
	
					// this singularity is identity matrix so angle = 0
	
					this.set( 1, 0, 0, 0 );
	
					return this; // zero angle, arbitrary axis
	
				}
	
				// otherwise this singularity is angle = 180
	
				angle = Math.PI;
	
				var xx = ( m11 + 1 ) / 2;
				var yy = ( m22 + 1 ) / 2;
				var zz = ( m33 + 1 ) / 2;
				var xy = ( m12 + m21 ) / 4;
				var xz = ( m13 + m31 ) / 4;
				var yz = ( m23 + m32 ) / 4;
	
				if ( ( xx > yy ) && ( xx > zz ) ) {
	
					// m11 is the largest diagonal term
	
					if ( xx < epsilon ) {
	
						x = 0;
						y = 0.707106781;
						z = 0.707106781;
	
					} else {
	
						x = Math.sqrt( xx );
						y = xy / x;
						z = xz / x;
	
					}
	
				} else if ( yy > zz ) {
	
					// m22 is the largest diagonal term
	
					if ( yy < epsilon ) {
	
						x = 0.707106781;
						y = 0;
						z = 0.707106781;
	
					} else {
	
						y = Math.sqrt( yy );
						x = xy / y;
						z = yz / y;
	
					}
	
				} else {
	
					// m33 is the largest diagonal term so base result on this
	
					if ( zz < epsilon ) {
	
						x = 0.707106781;
						y = 0.707106781;
						z = 0;
	
					} else {
	
						z = Math.sqrt( zz );
						x = xz / z;
						y = yz / z;
	
					}
	
				}
	
				this.set( x, y, z, angle );
	
				return this; // return 180 deg rotation
	
			}
	
			// as we have reached here there are no singularities so we can handle normally
	
			var s = Math.sqrt( ( m32 - m23 ) * ( m32 - m23 ) +
												 ( m13 - m31 ) * ( m13 - m31 ) +
												 ( m21 - m12 ) * ( m21 - m12 ) ); // used to normalize
	
			if ( Math.abs( s ) < 0.001 ) s = 1;
	
			// prevent divide by zero, should not happen if matrix is orthogonal and should be
			// caught by singularity test above, but I've left it in just in case
	
			this.x = ( m32 - m23 ) / s;
			this.y = ( m13 - m31 ) / s;
			this.z = ( m21 - m12 ) / s;
			this.w = Math.acos( ( m11 + m22 + m33 - 1 ) / 2 );
	
			return this;
	
		},
	
		min: function ( v ) {
	
			this.x = Math.min( this.x, v.x );
			this.y = Math.min( this.y, v.y );
			this.z = Math.min( this.z, v.z );
			this.w = Math.min( this.w, v.w );
	
			return this;
	
		},
	
		max: function ( v ) {
	
			this.x = Math.max( this.x, v.x );
			this.y = Math.max( this.y, v.y );
			this.z = Math.max( this.z, v.z );
			this.w = Math.max( this.w, v.w );
	
			return this;
	
		},
	
		clamp: function ( min, max ) {
	
			// assumes min < max, componentwise
	
			this.x = Math.max( min.x, Math.min( max.x, this.x ) );
			this.y = Math.max( min.y, Math.min( max.y, this.y ) );
			this.z = Math.max( min.z, Math.min( max.z, this.z ) );
			this.w = Math.max( min.w, Math.min( max.w, this.w ) );
	
			return this;
	
		},
	
		clampScalar: function () {
	
			var min, max;
	
			return function clampScalar( minVal, maxVal ) {
	
				if ( min === undefined ) {
	
					min = new Vector4();
					max = new Vector4();
	
				}
	
				min.set( minVal, minVal, minVal, minVal );
				max.set( maxVal, maxVal, maxVal, maxVal );
	
				return this.clamp( min, max );
	
			};
	
		}(),
	
		clampLength: function ( min, max ) {
	
			var length = this.length();
	
			return this.divideScalar( length || 1 ).multiplyScalar( Math.max( min, Math.min( max, length ) ) );
	
		},
	
		floor: function () {
	
			this.x = Math.floor( this.x );
			this.y = Math.floor( this.y );
			this.z = Math.floor( this.z );
			this.w = Math.floor( this.w );
	
			return this;
	
		},
	
		ceil: function () {
	
			this.x = Math.ceil( this.x );
			this.y = Math.ceil( this.y );
			this.z = Math.ceil( this.z );
			this.w = Math.ceil( this.w );
	
			return this;
	
		},
	
		round: function () {
	
			this.x = Math.round( this.x );
			this.y = Math.round( this.y );
			this.z = Math.round( this.z );
			this.w = Math.round( this.w );
	
			return this;
	
		},
	
		roundToZero: function () {
	
			this.x = ( this.x < 0 ) ? Math.ceil( this.x ) : Math.floor( this.x );
			this.y = ( this.y < 0 ) ? Math.ceil( this.y ) : Math.floor( this.y );
			this.z = ( this.z < 0 ) ? Math.ceil( this.z ) : Math.floor( this.z );
			this.w = ( this.w < 0 ) ? Math.ceil( this.w ) : Math.floor( this.w );
	
			return this;
	
		},
	
		negate: function () {
	
			this.x = - this.x;
			this.y = - this.y;
			this.z = - this.z;
			this.w = - this.w;
	
			return this;
	
		},
	
		dot: function ( v ) {
	
			return this.x * v.x + this.y * v.y + this.z * v.z + this.w * v.w;
	
		},
	
		lengthSq: function () {
	
			return this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w;
	
		},
	
		length: function () {
	
			return Math.sqrt( this.x * this.x + this.y * this.y + this.z * this.z + this.w * this.w );
	
		},
	
		manhattanLength: function () {
	
			return Math.abs( this.x ) + Math.abs( this.y ) + Math.abs( this.z ) + Math.abs( this.w );
	
		},
	
		normalize: function () {
	
			return this.divideScalar( this.length() || 1 );
	
		},
	
		setLength: function ( length ) {
	
			return this.normalize().multiplyScalar( length );
	
		},
	
		lerp: function ( v, alpha ) {
	
			this.x += ( v.x - this.x ) * alpha;
			this.y += ( v.y - this.y ) * alpha;
			this.z += ( v.z - this.z ) * alpha;
			this.w += ( v.w - this.w ) * alpha;
	
			return this;
	
		},
	
		lerpVectors: function ( v1, v2, alpha ) {
	
			return this.subVectors( v2, v1 ).multiplyScalar( alpha ).add( v1 );
	
		},
	
		equals: function ( v ) {
	
			return ( ( v.x === this.x ) && ( v.y === this.y ) && ( v.z === this.z ) && ( v.w === this.w ) );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.x = array[ offset ];
			this.y = array[ offset + 1 ];
			this.z = array[ offset + 2 ];
			this.w = array[ offset + 3 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.x;
			array[ offset + 1 ] = this.y;
			array[ offset + 2 ] = this.z;
			array[ offset + 3 ] = this.w;
	
			return array;
	
		},
	
		fromBufferAttribute: function ( attribute, index, offset ) {
	
			if ( offset !== undefined ) {
	
				console.warn( 'THREE.Vector4: offset has been removed from .fromBufferAttribute().' );
	
			}
	
			this.x = attribute.getX( index );
			this.y = attribute.getY( index );
			this.z = attribute.getZ( index );
			this.w = attribute.getW( index );
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author szimek / https://github.com/szimek/
	 * @author alteredq / http://alteredqualia.com/
	 * @author Marius Kintel / https://github.com/kintel
	 */
	
	/*
	 In options, we can specify:
	 * Texture parameters for an auto-generated target texture
	 * depthBuffer/stencilBuffer: Booleans to indicate if we should generate these buffers
	*/
	function WebGLRenderTarget( width, height, options ) {
	
		this.width = width;
		this.height = height;
	
		this.scissor = new Vector4( 0, 0, width, height );
		this.scissorTest = false;
	
		this.viewport = new Vector4( 0, 0, width, height );
	
		options = options || {};
	
		this.texture = new Texture( undefined, undefined, options.wrapS, options.wrapT, options.magFilter, options.minFilter, options.format, options.type, options.anisotropy, options.encoding );
	
		this.texture.generateMipmaps = options.generateMipmaps !== undefined ? options.generateMipmaps : false;
		this.texture.minFilter = options.minFilter !== undefined ? options.minFilter : LinearFilter;
	
		this.depthBuffer = options.depthBuffer !== undefined ? options.depthBuffer : true;
		this.stencilBuffer = options.stencilBuffer !== undefined ? options.stencilBuffer : true;
		this.depthTexture = options.depthTexture !== undefined ? options.depthTexture : null;
	
	}
	
	WebGLRenderTarget.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: WebGLRenderTarget,
	
		isWebGLRenderTarget: true,
	
		setSize: function ( width, height ) {
	
			if ( this.width !== width || this.height !== height ) {
	
				this.width = width;
				this.height = height;
	
				this.dispose();
	
			}
	
			this.viewport.set( 0, 0, width, height );
			this.scissor.set( 0, 0, width, height );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.width = source.width;
			this.height = source.height;
	
			this.viewport.copy( source.viewport );
	
			this.texture = source.texture.clone();
	
			this.depthBuffer = source.depthBuffer;
			this.stencilBuffer = source.stencilBuffer;
			this.depthTexture = source.depthTexture;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author Matt DesLauriers / @mattdesl
	 */
	
	function WebGLMultisampleRenderTarget( width, height, options ) {
	
		WebGLRenderTarget.call( this, width, height, options );
	
		this.samples = 4;
	
	}
	
	WebGLMultisampleRenderTarget.prototype = Object.assign( Object.create( WebGLRenderTarget.prototype ), {
	
		constructor: WebGLMultisampleRenderTarget,
	
		isWebGLMultisampleRenderTarget: true,
	
		copy: function ( source ) {
	
			WebGLRenderTarget.prototype.copy.call( this, source );
	
			this.samples = source.samples;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com
	 */
	
	function WebGLRenderTargetCube( width, height, options ) {
	
		WebGLRenderTarget.call( this, width, height, options );
	
		this.activeCubeFace = 0; // PX 0, NX 1, PY 2, NY 3, PZ 4, NZ 5
		this.activeMipMapLevel = 0;
	
	}
	
	WebGLRenderTargetCube.prototype = Object.create( WebGLRenderTarget.prototype );
	WebGLRenderTargetCube.prototype.constructor = WebGLRenderTargetCube;
	
	WebGLRenderTargetCube.prototype.isWebGLRenderTargetCube = true;
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function DataTexture( data, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
		this.image = { data: data, width: width, height: height };
	
		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
		this.generateMipmaps = false;
		this.flipY = false;
		this.unpackAlignment = 1;
	
	}
	
	DataTexture.prototype = Object.create( Texture.prototype );
	DataTexture.prototype.constructor = DataTexture;
	
	DataTexture.prototype.isDataTexture = true;
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function Box3( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new Vector3( + Infinity, + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector3( - Infinity, - Infinity, - Infinity );
	
	}
	
	Object.assign( Box3.prototype, {
	
		isBox3: true,
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromArray: function ( array ) {
	
			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
	
			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
	
			for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
				var x = array[ i ];
				var y = array[ i + 1 ];
				var z = array[ i + 2 ];
	
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;
	
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;
	
			}
	
			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
	
			return this;
	
		},
	
		setFromBufferAttribute: function ( attribute ) {
	
			var minX = + Infinity;
			var minY = + Infinity;
			var minZ = + Infinity;
	
			var maxX = - Infinity;
			var maxY = - Infinity;
			var maxZ = - Infinity;
	
			for ( var i = 0, l = attribute.count; i < l; i ++ ) {
	
				var x = attribute.getX( i );
				var y = attribute.getY( i );
				var z = attribute.getZ( i );
	
				if ( x < minX ) minX = x;
				if ( y < minY ) minY = y;
				if ( z < minZ ) minZ = z;
	
				if ( x > maxX ) maxX = x;
				if ( y > maxY ) maxY = y;
				if ( z > maxZ ) maxZ = z;
	
			}
	
			this.min.set( minX, minY, minZ );
			this.max.set( maxX, maxY, maxZ );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new Vector3();
	
			return function setFromCenterAndSize( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
	
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function ( object ) {
	
			this.makeEmpty();
	
			return this.expandByObject( object );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = this.min.z = + Infinity;
			this.max.x = this.max.y = this.max.z = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y ) || ( this.max.z < this.min.z );
	
		},
	
		getCenter: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box3: .getCenter() target is now required' );
				target = new Vector3();
	
			}
	
			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		getSize: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box3: .getSize() target is now required' );
				target = new Vector3();
	
			}
	
			return this.isEmpty() ? target.set( 0, 0, 0 ) : target.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		expandByObject: function () {
	
			// Computes the world-axis-aligned bounding box of an object (including its children),
			// accounting for both the object's, and children's, world transforms
	
			var scope, i, l;
	
			var v1 = new Vector3();
	
			function traverse( node ) {
	
				var geometry = node.geometry;
	
				if ( geometry !== undefined ) {
	
					if ( geometry.isGeometry ) {
	
						var vertices = geometry.vertices;
	
						for ( i = 0, l = vertices.length; i < l; i ++ ) {
	
							v1.copy( vertices[ i ] );
							v1.applyMatrix4( node.matrixWorld );
	
							scope.expandByPoint( v1 );
	
						}
	
					} else if ( geometry.isBufferGeometry ) {
	
						var attribute = geometry.attributes.position;
	
						if ( attribute !== undefined ) {
	
							for ( i = 0, l = attribute.count; i < l; i ++ ) {
	
								v1.fromBufferAttribute( attribute, i ).applyMatrix4( node.matrixWorld );
	
								scope.expandByPoint( v1 );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			return function expandByObject( object ) {
	
				scope = this;
	
				object.updateMatrixWorld( true );
	
				object.traverse( traverse );
	
				return this;
	
			};
	
		}(),
	
		containsPoint: function ( point ) {
	
			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ||
				point.z < this.min.z || point.z > this.max.z ? false : true;
	
		},
	
		containsBox: function ( box ) {
	
			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y &&
				this.min.z <= box.min.z && box.max.z <= this.max.z;
	
		},
	
		getParameter: function ( point, target ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box3: .getParameter() target is now required' );
				target = new Vector3();
	
			}
	
			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y ),
				( point.z - this.min.z ) / ( this.max.z - this.min.z )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 6 splitting planes to rule out intersections.
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ||
				box.max.z < this.min.z || box.min.z > this.max.z ? false : true;
	
		},
	
		intersectsSphere: ( function () {
	
			var closestPoint = new Vector3();
	
			return function intersectsSphere( sphere ) {
	
				// Find the point on the AABB closest to the sphere center.
				this.clampPoint( sphere.center, closestPoint );
	
				// If that point is inside the sphere, the AABB and sphere intersect.
				return closestPoint.distanceToSquared( sphere.center ) <= ( sphere.radius * sphere.radius );
	
			};
	
		} )(),
	
		intersectsPlane: function ( plane ) {
	
			// We compute the minimum and maximum dot product values. If those values
			// are on the same side (back or front) of the plane, then there is no intersection.
	
			var min, max;
	
			if ( plane.normal.x > 0 ) {
	
				min = plane.normal.x * this.min.x;
				max = plane.normal.x * this.max.x;
	
			} else {
	
				min = plane.normal.x * this.max.x;
				max = plane.normal.x * this.min.x;
	
			}
	
			if ( plane.normal.y > 0 ) {
	
				min += plane.normal.y * this.min.y;
				max += plane.normal.y * this.max.y;
	
			} else {
	
				min += plane.normal.y * this.max.y;
				max += plane.normal.y * this.min.y;
	
			}
	
			if ( plane.normal.z > 0 ) {
	
				min += plane.normal.z * this.min.z;
				max += plane.normal.z * this.max.z;
	
			} else {
	
				min += plane.normal.z * this.max.z;
				max += plane.normal.z * this.min.z;
	
			}
	
			return ( min <= - plane.constant && max >= - plane.constant );
	
		},
	
		intersectsTriangle: ( function () {
	
			// triangle centered vertices
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			// triangle edge vectors
			var f0 = new Vector3();
			var f1 = new Vector3();
			var f2 = new Vector3();
	
			var testAxis = new Vector3();
	
			var center = new Vector3();
			var extents = new Vector3();
	
			var triangleNormal = new Vector3();
	
			function satForAxes( axes ) {
	
				var i, j;
	
				for ( i = 0, j = axes.length - 3; i <= j; i += 3 ) {
	
					testAxis.fromArray( axes, i );
					// project the aabb onto the seperating axis
					var r = extents.x * Math.abs( testAxis.x ) + extents.y * Math.abs( testAxis.y ) + extents.z * Math.abs( testAxis.z );
					// project all 3 vertices of the triangle onto the seperating axis
					var p0 = v0.dot( testAxis );
					var p1 = v1.dot( testAxis );
					var p2 = v2.dot( testAxis );
					// actual test, basically see if either of the most extreme of the triangle points intersects r
					if ( Math.max( - Math.max( p0, p1, p2 ), Math.min( p0, p1, p2 ) ) > r ) {
	
						// points of the projected triangle are outside the projected half-length of the aabb
						// the axis is seperating and we can exit
						return false;
	
					}
	
				}
	
				return true;
	
			}
	
			return function intersectsTriangle( triangle ) {
	
				if ( this.isEmpty() ) {
	
					return false;
	
				}
	
				// compute box center and extents
				this.getCenter( center );
				extents.subVectors( this.max, center );
	
				// translate triangle to aabb origin
				v0.subVectors( triangle.a, center );
				v1.subVectors( triangle.b, center );
				v2.subVectors( triangle.c, center );
	
				// compute edge vectors for triangle
				f0.subVectors( v1, v0 );
				f1.subVectors( v2, v1 );
				f2.subVectors( v0, v2 );
	
				// test against axes that are given by cross product combinations of the edges of the triangle and the edges of the aabb
				// make an axis testing of each of the 3 sides of the aabb against each of the 3 sides of the triangle = 9 axis of separation
				// axis_ij = u_i x f_j (u0, u1, u2 = face normals of aabb = x,y,z axes vectors since aabb is axis aligned)
				var axes = [
					0, - f0.z, f0.y, 0, - f1.z, f1.y, 0, - f2.z, f2.y,
					f0.z, 0, - f0.x, f1.z, 0, - f1.x, f2.z, 0, - f2.x,
					- f0.y, f0.x, 0, - f1.y, f1.x, 0, - f2.y, f2.x, 0
				];
				if ( ! satForAxes( axes ) ) {
	
					return false;
	
				}
	
				// test 3 face normals from the aabb
				axes = [ 1, 0, 0, 0, 1, 0, 0, 0, 1 ];
				if ( ! satForAxes( axes ) ) {
	
					return false;
	
				}
	
				// finally testing the face normal of the triangle
				// use already existing triangle edge vectors here
				triangleNormal.crossVectors( f0, f1 );
				axes = [ triangleNormal.x, triangleNormal.y, triangleNormal.z ];
				return satForAxes( axes );
	
			};
	
		} )(),
	
		clampPoint: function ( point, target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box3: .clampPoint() target is now required' );
				target = new Vector3();
	
			}
	
			return target.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new Vector3();
	
			return function distanceToPoint( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		getBoundingSphere: function () {
	
			var v1 = new Vector3();
	
			return function getBoundingSphere( target ) {
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Box3: .getBoundingSphere() target is now required' );
					target = new Sphere();
	
				}
	
				this.getCenter( target.center );
	
				target.radius = this.getSize( v1 ).length() * 0.5;
	
				return target;
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			// ensure that if there is no overlap, the result is fully empty, not slightly empty with non-inf/+inf values that will cause subsequence intersects to erroneously return valid values.
			if ( this.isEmpty() ) this.makeEmpty();
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		applyMatrix4: function () {
	
			var points = [
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3(),
				new Vector3()
			];
	
			return function applyMatrix4( matrix ) {
	
				// transform of empty box is an empty box.
				if ( this.isEmpty() ) return this;
	
				// NOTE: I am using a binary pattern to specify all 2^3 combinations below
				points[ 0 ].set( this.min.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 000
				points[ 1 ].set( this.min.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 001
				points[ 2 ].set( this.min.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 010
				points[ 3 ].set( this.min.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 011
				points[ 4 ].set( this.max.x, this.min.y, this.min.z ).applyMatrix4( matrix ); // 100
				points[ 5 ].set( this.max.x, this.min.y, this.max.z ).applyMatrix4( matrix ); // 101
				points[ 6 ].set( this.max.x, this.max.y, this.min.z ).applyMatrix4( matrix ); // 110
				points[ 7 ].set( this.max.x, this.max.y, this.max.z ).applyMatrix4( matrix ); // 111
	
				this.setFromPoints( points );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Sphere( center, radius ) {
	
		this.center = ( center !== undefined ) ? center : new Vector3();
		this.radius = ( radius !== undefined ) ? radius : 0;
	
	}
	
	Object.assign( Sphere.prototype, {
	
		set: function ( center, radius ) {
	
			this.center.copy( center );
			this.radius = radius;
	
			return this;
	
		},
	
		setFromPoints: function () {
	
			var box = new Box3();
	
			return function setFromPoints( points, optionalCenter ) {
	
				var center = this.center;
	
				if ( optionalCenter !== undefined ) {
	
					center.copy( optionalCenter );
	
				} else {
	
					box.setFromPoints( points ).getCenter( center );
	
				}
	
				var maxRadiusSq = 0;
	
				for ( var i = 0, il = points.length; i < il; i ++ ) {
	
					maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( points[ i ] ) );
	
				}
	
				this.radius = Math.sqrt( maxRadiusSq );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( sphere ) {
	
			this.center.copy( sphere.center );
			this.radius = sphere.radius;
	
			return this;
	
		},
	
		empty: function () {
	
			return ( this.radius <= 0 );
	
		},
	
		containsPoint: function ( point ) {
	
			return ( point.distanceToSquared( this.center ) <= ( this.radius * this.radius ) );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return ( point.distanceTo( this.center ) - this.radius );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			var radiusSum = this.radius + sphere.radius;
	
			return sphere.center.distanceToSquared( this.center ) <= ( radiusSum * radiusSum );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsSphere( this );
	
		},
	
		intersectsPlane: function ( plane ) {
	
			return Math.abs( plane.distanceToPoint( this.center ) ) <= this.radius;
	
		},
	
		clampPoint: function ( point, target ) {
	
			var deltaLengthSq = this.center.distanceToSquared( point );
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Sphere: .clampPoint() target is now required' );
				target = new Vector3();
	
			}
	
			target.copy( point );
	
			if ( deltaLengthSq > ( this.radius * this.radius ) ) {
	
				target.sub( this.center ).normalize();
				target.multiplyScalar( this.radius ).add( this.center );
	
			}
	
			return target;
	
		},
	
		getBoundingBox: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Sphere: .getBoundingBox() target is now required' );
				target = new Box3();
	
			}
	
			target.set( this.center, this.center );
			target.expandByScalar( this.radius );
	
			return target;
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.center.applyMatrix4( matrix );
			this.radius = this.radius * matrix.getMaxScaleOnAxis();
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.center.add( offset );
	
			return this;
	
		},
	
		equals: function ( sphere ) {
	
			return sphere.center.equals( this.center ) && ( sphere.radius === this.radius );
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	function Plane( normal, constant ) {
	
		// normal is assumed to be normalized
	
		this.normal = ( normal !== undefined ) ? normal : new Vector3( 1, 0, 0 );
		this.constant = ( constant !== undefined ) ? constant : 0;
	
	}
	
	Object.assign( Plane.prototype, {
	
		set: function ( normal, constant ) {
	
			this.normal.copy( normal );
			this.constant = constant;
	
			return this;
	
		},
	
		setComponents: function ( x, y, z, w ) {
	
			this.normal.set( x, y, z );
			this.constant = w;
	
			return this;
	
		},
	
		setFromNormalAndCoplanarPoint: function ( normal, point ) {
	
			this.normal.copy( normal );
			this.constant = - point.dot( this.normal );
	
			return this;
	
		},
	
		setFromCoplanarPoints: function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			return function setFromCoplanarPoints( a, b, c ) {
	
				var normal = v1.subVectors( c, b ).cross( v2.subVectors( a, b ) ).normalize();
	
				// Q: should an error be thrown if normal is zero (e.g. degenerate plane)?
	
				this.setFromNormalAndCoplanarPoint( normal, a );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( plane ) {
	
			this.normal.copy( plane.normal );
			this.constant = plane.constant;
	
			return this;
	
		},
	
		normalize: function () {
	
			// Note: will lead to a divide by zero if the plane is invalid.
	
			var inverseNormalLength = 1.0 / this.normal.length();
			this.normal.multiplyScalar( inverseNormalLength );
			this.constant *= inverseNormalLength;
	
			return this;
	
		},
	
		negate: function () {
	
			this.constant *= - 1;
			this.normal.negate();
	
			return this;
	
		},
	
		distanceToPoint: function ( point ) {
	
			return this.normal.dot( point ) + this.constant;
	
		},
	
		distanceToSphere: function ( sphere ) {
	
			return this.distanceToPoint( sphere.center ) - sphere.radius;
	
		},
	
		projectPoint: function ( point, target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Plane: .projectPoint() target is now required' );
				target = new Vector3();
	
			}
	
			return target.copy( this.normal ).multiplyScalar( - this.distanceToPoint( point ) ).add( point );
	
		},
	
		intersectLine: function () {
	
			var v1 = new Vector3();
	
			return function intersectLine( line, target ) {
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Plane: .intersectLine() target is now required' );
					target = new Vector3();
	
				}
	
				var direction = line.delta( v1 );
	
				var denominator = this.normal.dot( direction );
	
				if ( denominator === 0 ) {
	
					// line is coplanar, return origin
					if ( this.distanceToPoint( line.start ) === 0 ) {
	
						return target.copy( line.start );
	
					}
	
					// Unsure if this is the correct method to handle this case.
					return undefined;
	
				}
	
				var t = - ( line.start.dot( this.normal ) + this.constant ) / denominator;
	
				if ( t < 0 || t > 1 ) {
	
					return undefined;
	
				}
	
				return target.copy( direction ).multiplyScalar( t ).add( line.start );
	
			};
	
		}(),
	
		intersectsLine: function ( line ) {
	
			// Note: this tests if a line intersects the plane, not whether it (or its end-points) are coplanar with it.
	
			var startSign = this.distanceToPoint( line.start );
			var endSign = this.distanceToPoint( line.end );
	
			return ( startSign < 0 && endSign > 0 ) || ( endSign < 0 && startSign > 0 );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsPlane( this );
	
		},
	
		intersectsSphere: function ( sphere ) {
	
			return sphere.intersectsPlane( this );
	
		},
	
		coplanarPoint: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Plane: .coplanarPoint() target is now required' );
				target = new Vector3();
	
			}
	
			return target.copy( this.normal ).multiplyScalar( - this.constant );
	
		},
	
		applyMatrix4: function () {
	
			var v1 = new Vector3();
			var m1 = new Matrix3();
	
			return function applyMatrix4( matrix, optionalNormalMatrix ) {
	
				var normalMatrix = optionalNormalMatrix || m1.getNormalMatrix( matrix );
	
				var referencePoint = this.coplanarPoint( v1 ).applyMatrix4( matrix );
	
				var normal = this.normal.applyMatrix3( normalMatrix ).normalize();
	
				this.constant = - referencePoint.dot( normal );
	
				return this;
	
			};
	
		}(),
	
		translate: function ( offset ) {
	
			this.constant -= offset.dot( this.normal );
	
			return this;
	
		},
	
		equals: function ( plane ) {
	
			return plane.normal.equals( this.normal ) && ( plane.constant === this.constant );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / http://clara.io
	 */
	
	function Frustum( p0, p1, p2, p3, p4, p5 ) {
	
		this.planes = [
	
			( p0 !== undefined ) ? p0 : new Plane(),
			( p1 !== undefined ) ? p1 : new Plane(),
			( p2 !== undefined ) ? p2 : new Plane(),
			( p3 !== undefined ) ? p3 : new Plane(),
			( p4 !== undefined ) ? p4 : new Plane(),
			( p5 !== undefined ) ? p5 : new Plane()
	
		];
	
	}
	
	Object.assign( Frustum.prototype, {
	
		set: function ( p0, p1, p2, p3, p4, p5 ) {
	
			var planes = this.planes;
	
			planes[ 0 ].copy( p0 );
			planes[ 1 ].copy( p1 );
			planes[ 2 ].copy( p2 );
			planes[ 3 ].copy( p3 );
			planes[ 4 ].copy( p4 );
			planes[ 5 ].copy( p5 );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( frustum ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				planes[ i ].copy( frustum.planes[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromMatrix: function ( m ) {
	
			var planes = this.planes;
			var me = m.elements;
			var me0 = me[ 0 ], me1 = me[ 1 ], me2 = me[ 2 ], me3 = me[ 3 ];
			var me4 = me[ 4 ], me5 = me[ 5 ], me6 = me[ 6 ], me7 = me[ 7 ];
			var me8 = me[ 8 ], me9 = me[ 9 ], me10 = me[ 10 ], me11 = me[ 11 ];
			var me12 = me[ 12 ], me13 = me[ 13 ], me14 = me[ 14 ], me15 = me[ 15 ];
	
			planes[ 0 ].setComponents( me3 - me0, me7 - me4, me11 - me8, me15 - me12 ).normalize();
			planes[ 1 ].setComponents( me3 + me0, me7 + me4, me11 + me8, me15 + me12 ).normalize();
			planes[ 2 ].setComponents( me3 + me1, me7 + me5, me11 + me9, me15 + me13 ).normalize();
			planes[ 3 ].setComponents( me3 - me1, me7 - me5, me11 - me9, me15 - me13 ).normalize();
			planes[ 4 ].setComponents( me3 - me2, me7 - me6, me11 - me10, me15 - me14 ).normalize();
			planes[ 5 ].setComponents( me3 + me2, me7 + me6, me11 + me10, me15 + me14 ).normalize();
	
			return this;
	
		},
	
		intersectsObject: function () {
	
			var sphere = new Sphere();
	
			return function intersectsObject( object ) {
	
				var geometry = object.geometry;
	
				if ( geometry.boundingSphere === null )
					geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere )
					.applyMatrix4( object.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSprite: function () {
	
			var sphere = new Sphere();
	
			return function intersectsSprite( sprite ) {
	
				sphere.center.set( 0, 0, 0 );
				sphere.radius = 0.7071067811865476;
				sphere.applyMatrix4( sprite.matrixWorld );
	
				return this.intersectsSphere( sphere );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			var planes = this.planes;
			var center = sphere.center;
			var negRadius = - sphere.radius;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				var distance = planes[ i ].distanceToPoint( center );
	
				if ( distance < negRadius ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		},
	
		intersectsBox: function () {
	
			var p = new Vector3();
	
			return function intersectsBox( box ) {
	
				var planes = this.planes;
	
				for ( var i = 0; i < 6; i ++ ) {
	
					var plane = planes[ i ];
	
					// corner at max distance
	
					p.x = plane.normal.x > 0 ? box.max.x : box.min.x;
					p.y = plane.normal.y > 0 ? box.max.y : box.min.y;
					p.z = plane.normal.z > 0 ? box.max.z : box.min.z;
	
					if ( plane.distanceToPoint( p ) < 0 ) {
	
						return false;
	
					}
	
				}
	
				return true;
	
			};
	
		}(),
	
		containsPoint: function ( point ) {
	
			var planes = this.planes;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				if ( planes[ i ].distanceToPoint( point ) < 0 ) {
	
					return false;
	
				}
	
			}
	
			return true;
	
		}
	
	} );
	
	var alphamap_fragment = "#ifdef USE_ALPHAMAP\n\tdiffuseColor.a *= texture2D( alphaMap, vUv ).g;\n#endif";
	
	var alphamap_pars_fragment = "#ifdef USE_ALPHAMAP\n\tuniform sampler2D alphaMap;\n#endif";
	
	var alphatest_fragment = "#ifdef ALPHATEST\n\tif ( diffuseColor.a < ALPHATEST ) discard;\n#endif";
	
	var aomap_fragment = "#ifdef USE_AOMAP\n\tfloat ambientOcclusion = ( texture2D( aoMap, vUv2 ).r - 1.0 ) * aoMapIntensity + 1.0;\n\treflectedLight.indirectDiffuse *= ambientOcclusion;\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\treflectedLight.indirectSpecular *= computeSpecularOcclusion( dotNV, ambientOcclusion, material.specularRoughness );\n\t#endif\n#endif";
	
	var aomap_pars_fragment = "#ifdef USE_AOMAP\n\tuniform sampler2D aoMap;\n\tuniform float aoMapIntensity;\n#endif";
	
	var begin_vertex = "vec3 transformed = vec3( position );";
	
	var beginnormal_vertex = "vec3 objectNormal = vec3( normal );";
	
	var bsdfs = "vec2 integrateSpecularBRDF( const in float dotNV, const in float roughness ) {\n\tconst vec4 c0 = vec4( - 1, - 0.0275, - 0.572, 0.022 );\n\tconst vec4 c1 = vec4( 1, 0.0425, 1.04, - 0.04 );\n\tvec4 r = roughness * c0 + c1;\n\tfloat a004 = min( r.x * r.x, exp2( - 9.28 * dotNV ) ) * r.x + r.y;\n\treturn vec2( -1.04, 1.04 ) * a004 + r.zw;\n}\nfloat punctualLightIntensityToIrradianceFactor( const in float lightDistance, const in float cutoffDistance, const in float decayExponent ) {\n#if defined ( PHYSICALLY_CORRECT_LIGHTS )\n\tfloat distanceFalloff = 1.0 / max( pow( lightDistance, decayExponent ), 0.01 );\n\tif( cutoffDistance > 0.0 ) {\n\t\tdistanceFalloff *= pow2( saturate( 1.0 - pow4( lightDistance / cutoffDistance ) ) );\n\t}\n\treturn distanceFalloff;\n#else\n\tif( cutoffDistance > 0.0 && decayExponent > 0.0 ) {\n\t\treturn pow( saturate( -lightDistance / cutoffDistance + 1.0 ), decayExponent );\n\t}\n\treturn 1.0;\n#endif\n}\nvec3 BRDF_Diffuse_Lambert( const in vec3 diffuseColor ) {\n\treturn RECIPROCAL_PI * diffuseColor;\n}\nvec3 F_Schlick( const in vec3 specularColor, const in float dotLH ) {\n\tfloat fresnel = exp2( ( -5.55473 * dotLH - 6.98316 ) * dotLH );\n\treturn ( 1.0 - specularColor ) * fresnel + specularColor;\n}\nfloat G_GGX_Smith( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gl = dotNL + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\tfloat gv = dotNV + sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\treturn 1.0 / ( gl * gv );\n}\nfloat G_GGX_SmithCorrelated( const in float alpha, const in float dotNL, const in float dotNV ) {\n\tfloat a2 = pow2( alpha );\n\tfloat gv = dotNL * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNV ) );\n\tfloat gl = dotNV * sqrt( a2 + ( 1.0 - a2 ) * pow2( dotNL ) );\n\treturn 0.5 / max( gv + gl, EPSILON );\n}\nfloat D_GGX( const in float alpha, const in float dotNH ) {\n\tfloat a2 = pow2( alpha );\n\tfloat denom = pow2( dotNH ) * ( a2 - 1.0 ) + 1.0;\n\treturn RECIPROCAL_PI * a2 / pow2( denom );\n}\nvec3 BRDF_Specular_GGX( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat alpha = pow2( roughness );\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNL = saturate( dot( geometry.normal, incidentLight.direction ) );\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_GGX_SmithCorrelated( alpha, dotNL, dotNV );\n\tfloat D = D_GGX( alpha, dotNH );\n\treturn F * ( G * D );\n}\nvec2 LTC_Uv( const in vec3 N, const in vec3 V, const in float roughness ) {\n\tconst float LUT_SIZE  = 64.0;\n\tconst float LUT_SCALE = ( LUT_SIZE - 1.0 ) / LUT_SIZE;\n\tconst float LUT_BIAS  = 0.5 / LUT_SIZE;\n\tfloat dotNV = saturate( dot( N, V ) );\n\tvec2 uv = vec2( roughness, sqrt( 1.0 - dotNV ) );\n\tuv = uv * LUT_SCALE + LUT_BIAS;\n\treturn uv;\n}\nfloat LTC_ClippedSphereFormFactor( const in vec3 f ) {\n\tfloat l = length( f );\n\treturn max( ( l * l + f.z ) / ( l + 1.0 ), 0.0 );\n}\nvec3 LTC_EdgeVectorFormFactor( const in vec3 v1, const in vec3 v2 ) {\n\tfloat x = dot( v1, v2 );\n\tfloat y = abs( x );\n\tfloat a = 0.8543985 + ( 0.4965155 + 0.0145206 * y ) * y;\n\tfloat b = 3.4175940 + ( 4.1616724 + y ) * y;\n\tfloat v = a / b;\n\tfloat theta_sintheta = ( x > 0.0 ) ? v : 0.5 * inversesqrt( max( 1.0 - x * x, 1e-7 ) ) - v;\n\treturn cross( v1, v2 ) * theta_sintheta;\n}\nvec3 LTC_Evaluate( const in vec3 N, const in vec3 V, const in vec3 P, const in mat3 mInv, const in vec3 rectCoords[ 4 ] ) {\n\tvec3 v1 = rectCoords[ 1 ] - rectCoords[ 0 ];\n\tvec3 v2 = rectCoords[ 3 ] - rectCoords[ 0 ];\n\tvec3 lightNormal = cross( v1, v2 );\n\tif( dot( lightNormal, P - rectCoords[ 0 ] ) < 0.0 ) return vec3( 0.0 );\n\tvec3 T1, T2;\n\tT1 = normalize( V - N * dot( V, N ) );\n\tT2 = - cross( N, T1 );\n\tmat3 mat = mInv * transposeMat3( mat3( T1, T2, N ) );\n\tvec3 coords[ 4 ];\n\tcoords[ 0 ] = mat * ( rectCoords[ 0 ] - P );\n\tcoords[ 1 ] = mat * ( rectCoords[ 1 ] - P );\n\tcoords[ 2 ] = mat * ( rectCoords[ 2 ] - P );\n\tcoords[ 3 ] = mat * ( rectCoords[ 3 ] - P );\n\tcoords[ 0 ] = normalize( coords[ 0 ] );\n\tcoords[ 1 ] = normalize( coords[ 1 ] );\n\tcoords[ 2 ] = normalize( coords[ 2 ] );\n\tcoords[ 3 ] = normalize( coords[ 3 ] );\n\tvec3 vectorFormFactor = vec3( 0.0 );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 0 ], coords[ 1 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 1 ], coords[ 2 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 2 ], coords[ 3 ] );\n\tvectorFormFactor += LTC_EdgeVectorFormFactor( coords[ 3 ], coords[ 0 ] );\n\tfloat result = LTC_ClippedSphereFormFactor( vectorFormFactor );\n\treturn vec3( result );\n}\nvec3 BRDF_Specular_GGX_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\treturn specularColor * brdf.x + brdf.y;\n}\nvoid BRDF_Specular_Multiscattering_Environment( const in GeometricContext geometry, const in vec3 specularColor, const in float roughness, inout vec3 singleScatter, inout vec3 multiScatter ) {\n\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\tvec3 F = F_Schlick( specularColor, dotNV );\n\tvec2 brdf = integrateSpecularBRDF( dotNV, roughness );\n\tvec3 FssEss = F * brdf.x + brdf.y;\n\tfloat Ess = brdf.x + brdf.y;\n\tfloat Ems = 1.0 - Ess;\n\tvec3 Favg = specularColor + ( 1.0 - specularColor ) * 0.047619;\tvec3 Fms = FssEss * Favg / ( 1.0 - Ems * Favg );\n\tsingleScatter += FssEss;\n\tmultiScatter += Fms * Ems;\n}\nfloat G_BlinnPhong_Implicit( ) {\n\treturn 0.25;\n}\nfloat D_BlinnPhong( const in float shininess, const in float dotNH ) {\n\treturn RECIPROCAL_PI * ( shininess * 0.5 + 1.0 ) * pow( dotNH, shininess );\n}\nvec3 BRDF_Specular_BlinnPhong( const in IncidentLight incidentLight, const in GeometricContext geometry, const in vec3 specularColor, const in float shininess ) {\n\tvec3 halfDir = normalize( incidentLight.direction + geometry.viewDir );\n\tfloat dotNH = saturate( dot( geometry.normal, halfDir ) );\n\tfloat dotLH = saturate( dot( incidentLight.direction, halfDir ) );\n\tvec3 F = F_Schlick( specularColor, dotLH );\n\tfloat G = G_BlinnPhong_Implicit( );\n\tfloat D = D_BlinnPhong( shininess, dotNH );\n\treturn F * ( G * D );\n}\nfloat GGXRoughnessToBlinnExponent( const in float ggxRoughness ) {\n\treturn ( 2.0 / pow2( ggxRoughness + 0.0001 ) - 2.0 );\n}\nfloat BlinnExponentToGGXRoughness( const in float blinnExponent ) {\n\treturn sqrt( 2.0 / ( blinnExponent + 2.0 ) );\n}";
	
	var bumpmap_pars_fragment = "#ifdef USE_BUMPMAP\n\tuniform sampler2D bumpMap;\n\tuniform float bumpScale;\n\tvec2 dHdxy_fwd() {\n\t\tvec2 dSTdx = dFdx( vUv );\n\t\tvec2 dSTdy = dFdy( vUv );\n\t\tfloat Hll = bumpScale * texture2D( bumpMap, vUv ).x;\n\t\tfloat dBx = bumpScale * texture2D( bumpMap, vUv + dSTdx ).x - Hll;\n\t\tfloat dBy = bumpScale * texture2D( bumpMap, vUv + dSTdy ).x - Hll;\n\t\treturn vec2( dBx, dBy );\n\t}\n\tvec3 perturbNormalArb( vec3 surf_pos, vec3 surf_norm, vec2 dHdxy ) {\n\t\tvec3 vSigmaX = vec3( dFdx( surf_pos.x ), dFdx( surf_pos.y ), dFdx( surf_pos.z ) );\n\t\tvec3 vSigmaY = vec3( dFdy( surf_pos.x ), dFdy( surf_pos.y ), dFdy( surf_pos.z ) );\n\t\tvec3 vN = surf_norm;\n\t\tvec3 R1 = cross( vSigmaY, vN );\n\t\tvec3 R2 = cross( vN, vSigmaX );\n\t\tfloat fDet = dot( vSigmaX, R1 );\n\t\tfDet *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\tvec3 vGrad = sign( fDet ) * ( dHdxy.x * R1 + dHdxy.y * R2 );\n\t\treturn normalize( abs( fDet ) * surf_norm - vGrad );\n\t}\n#endif";
	
	var clipping_planes_fragment = "#if NUM_CLIPPING_PLANES > 0\n\tvec4 plane;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < UNION_CLIPPING_PLANES; i ++ ) {\n\t\tplane = clippingPlanes[ i ];\n\t\tif ( dot( vViewPosition, plane.xyz ) > plane.w ) discard;\n\t}\n\t#if UNION_CLIPPING_PLANES < NUM_CLIPPING_PLANES\n\t\tbool clipped = true;\n\t\t#pragma unroll_loop\n\t\tfor ( int i = UNION_CLIPPING_PLANES; i < NUM_CLIPPING_PLANES; i ++ ) {\n\t\t\tplane = clippingPlanes[ i ];\n\t\t\tclipped = ( dot( vViewPosition, plane.xyz ) > plane.w ) && clipped;\n\t\t}\n\t\tif ( clipped ) discard;\n\t#endif\n#endif";
	
	var clipping_planes_pars_fragment = "#if NUM_CLIPPING_PLANES > 0\n\t#if ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\t\tvarying vec3 vViewPosition;\n\t#endif\n\tuniform vec4 clippingPlanes[ NUM_CLIPPING_PLANES ];\n#endif";
	
	var clipping_planes_pars_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvarying vec3 vViewPosition;\n#endif";
	
	var clipping_planes_vertex = "#if NUM_CLIPPING_PLANES > 0 && ! defined( PHYSICAL ) && ! defined( PHONG ) && ! defined( MATCAP )\n\tvViewPosition = - mvPosition.xyz;\n#endif";
	
	var color_fragment = "#ifdef USE_COLOR\n\tdiffuseColor.rgb *= vColor;\n#endif";
	
	var color_pars_fragment = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	
	var color_pars_vertex = "#ifdef USE_COLOR\n\tvarying vec3 vColor;\n#endif";
	
	var color_vertex = "#ifdef USE_COLOR\n\tvColor.xyz = color.xyz;\n#endif";
	
	var common = "#define PI 3.14159265359\n#define PI2 6.28318530718\n#define PI_HALF 1.5707963267949\n#define RECIPROCAL_PI 0.31830988618\n#define RECIPROCAL_PI2 0.15915494\n#define LOG2 1.442695\n#define EPSILON 1e-6\n#define saturate(a) clamp( a, 0.0, 1.0 )\n#define whiteCompliment(a) ( 1.0 - saturate( a ) )\nfloat pow2( const in float x ) { return x*x; }\nfloat pow3( const in float x ) { return x*x*x; }\nfloat pow4( const in float x ) { float x2 = x*x; return x2*x2; }\nfloat average( const in vec3 color ) { return dot( color, vec3( 0.3333 ) ); }\nhighp float rand( const in vec2 uv ) {\n\tconst highp float a = 12.9898, b = 78.233, c = 43758.5453;\n\thighp float dt = dot( uv.xy, vec2( a,b ) ), sn = mod( dt, PI );\n\treturn fract(sin(sn) * c);\n}\nstruct IncidentLight {\n\tvec3 color;\n\tvec3 direction;\n\tbool visible;\n};\nstruct ReflectedLight {\n\tvec3 directDiffuse;\n\tvec3 directSpecular;\n\tvec3 indirectDiffuse;\n\tvec3 indirectSpecular;\n};\nstruct GeometricContext {\n\tvec3 position;\n\tvec3 normal;\n\tvec3 viewDir;\n};\nvec3 transformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( matrix * vec4( dir, 0.0 ) ).xyz );\n}\nvec3 inverseTransformDirection( in vec3 dir, in mat4 matrix ) {\n\treturn normalize( ( vec4( dir, 0.0 ) * matrix ).xyz );\n}\nvec3 projectOnPlane(in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\tfloat distance = dot( planeNormal, point - pointOnPlane );\n\treturn - distance * planeNormal + point;\n}\nfloat sideOfPlane( in vec3 point, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn sign( dot( point - pointOnPlane, planeNormal ) );\n}\nvec3 linePlaneIntersect( in vec3 pointOnLine, in vec3 lineDirection, in vec3 pointOnPlane, in vec3 planeNormal ) {\n\treturn lineDirection * ( dot( planeNormal, pointOnPlane - pointOnLine ) / dot( planeNormal, lineDirection ) ) + pointOnLine;\n}\nmat3 transposeMat3( const in mat3 m ) {\n\tmat3 tmp;\n\ttmp[ 0 ] = vec3( m[ 0 ].x, m[ 1 ].x, m[ 2 ].x );\n\ttmp[ 1 ] = vec3( m[ 0 ].y, m[ 1 ].y, m[ 2 ].y );\n\ttmp[ 2 ] = vec3( m[ 0 ].z, m[ 1 ].z, m[ 2 ].z );\n\treturn tmp;\n}\nfloat linearToRelativeLuminance( const in vec3 color ) {\n\tvec3 weights = vec3( 0.2126, 0.7152, 0.0722 );\n\treturn dot( weights, color.rgb );\n}";
	
	var cube_uv_reflection_fragment = "#ifdef ENVMAP_TYPE_CUBE_UV\n#define cubeUV_textureSize (1024.0)\nint getFaceFromDirection(vec3 direction) {\n\tvec3 absDirection = abs(direction);\n\tint face = -1;\n\tif( absDirection.x > absDirection.z ) {\n\t\tif(absDirection.x > absDirection.y )\n\t\t\tface = direction.x > 0.0 ? 0 : 3;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\telse {\n\t\tif(absDirection.z > absDirection.y )\n\t\t\tface = direction.z > 0.0 ? 2 : 5;\n\t\telse\n\t\t\tface = direction.y > 0.0 ? 1 : 4;\n\t}\n\treturn face;\n}\n#define cubeUV_maxLods1  (log2(cubeUV_textureSize*0.25) - 1.0)\n#define cubeUV_rangeClamp (exp2((6.0 - 1.0) * 2.0))\nvec2 MipLevelInfo( vec3 vec, float roughnessLevel, float roughness ) {\n\tfloat scale = exp2(cubeUV_maxLods1 - roughnessLevel);\n\tfloat dxRoughness = dFdx(roughness);\n\tfloat dyRoughness = dFdy(roughness);\n\tvec3 dx = dFdx( vec * scale * dxRoughness );\n\tvec3 dy = dFdy( vec * scale * dyRoughness );\n\tfloat d = max( dot( dx, dx ), dot( dy, dy ) );\n\td = clamp(d, 1.0, cubeUV_rangeClamp);\n\tfloat mipLevel = 0.5 * log2(d);\n\treturn vec2(floor(mipLevel), fract(mipLevel));\n}\n#define cubeUV_maxLods2 (log2(cubeUV_textureSize*0.25) - 2.0)\n#define cubeUV_rcpTextureSize (1.0 / cubeUV_textureSize)\nvec2 getCubeUV(vec3 direction, float roughnessLevel, float mipLevel) {\n\tmipLevel = roughnessLevel > cubeUV_maxLods2 - 3.0 ? 0.0 : mipLevel;\n\tfloat a = 16.0 * cubeUV_rcpTextureSize;\n\tvec2 exp2_packed = exp2( vec2( roughnessLevel, mipLevel ) );\n\tvec2 rcp_exp2_packed = vec2( 1.0 ) / exp2_packed;\n\tfloat powScale = exp2_packed.x * exp2_packed.y;\n\tfloat scale = rcp_exp2_packed.x * rcp_exp2_packed.y * 0.25;\n\tfloat mipOffset = 0.75*(1.0 - rcp_exp2_packed.y) * rcp_exp2_packed.x;\n\tbool bRes = mipLevel == 0.0;\n\tscale =  bRes && (scale < a) ? a : scale;\n\tvec3 r;\n\tvec2 offset;\n\tint face = getFaceFromDirection(direction);\n\tfloat rcpPowScale = 1.0 / powScale;\n\tif( face == 0) {\n\t\tr = vec3(direction.x, -direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 1) {\n\t\tr = vec3(direction.y, direction.x, direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 2) {\n\t\tr = vec3(direction.z, direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.75 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? a : offset.y;\n\t}\n\telse if( face == 3) {\n\t\tr = vec3(direction.x, direction.z, direction.y);\n\t\toffset = vec2(0.0+mipOffset,0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse if( face == 4) {\n\t\tr = vec3(direction.y, direction.x, -direction.z);\n\t\toffset = vec2(scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\telse {\n\t\tr = vec3(direction.z, -direction.x, direction.y);\n\t\toffset = vec2(2.0*scale+mipOffset, 0.5 * rcpPowScale);\n\t\toffset.y = bRes && (offset.y < 2.0*a) ? 0.0 : offset.y;\n\t}\n\tr = normalize(r);\n\tfloat texelOffset = 0.5 * cubeUV_rcpTextureSize;\n\tvec2 s = ( r.yz / abs( r.x ) + vec2( 1.0 ) ) * 0.5;\n\tvec2 base = offset + vec2( texelOffset );\n\treturn base + s * ( scale - 2.0 * texelOffset );\n}\n#define cubeUV_maxLods3 (log2(cubeUV_textureSize*0.25) - 3.0)\nvec4 textureCubeUV( sampler2D envMap, vec3 reflectedDirection, float roughness ) {\n\tfloat roughnessVal = roughness* cubeUV_maxLods3;\n\tfloat r1 = floor(roughnessVal);\n\tfloat r2 = r1 + 1.0;\n\tfloat t = fract(roughnessVal);\n\tvec2 mipInfo = MipLevelInfo(reflectedDirection, r1, roughness);\n\tfloat s = mipInfo.y;\n\tfloat level0 = mipInfo.x;\n\tfloat level1 = level0 + 1.0;\n\tlevel1 = level1 > 5.0 ? 5.0 : level1;\n\tlevel0 += min( floor( s + 0.5 ), 5.0 );\n\tvec2 uv_10 = getCubeUV(reflectedDirection, r1, level0);\n\tvec4 color10 = envMapTexelToLinear(texture2D(envMap, uv_10));\n\tvec2 uv_20 = getCubeUV(reflectedDirection, r2, level0);\n\tvec4 color20 = envMapTexelToLinear(texture2D(envMap, uv_20));\n\tvec4 result = mix(color10, color20, t);\n\treturn vec4(result.rgb, 1.0);\n}\n#endif";
	
	var defaultnormal_vertex = "vec3 transformedNormal = normalMatrix * objectNormal;\n#ifdef FLIP_SIDED\n\ttransformedNormal = - transformedNormal;\n#endif";
	
	var displacementmap_pars_vertex = "#ifdef USE_DISPLACEMENTMAP\n\tuniform sampler2D displacementMap;\n\tuniform float displacementScale;\n\tuniform float displacementBias;\n#endif";
	
	var displacementmap_vertex = "#ifdef USE_DISPLACEMENTMAP\n\ttransformed += normalize( objectNormal ) * ( texture2D( displacementMap, uv ).x * displacementScale + displacementBias );\n#endif";
	
	var emissivemap_fragment = "#ifdef USE_EMISSIVEMAP\n\tvec4 emissiveColor = texture2D( emissiveMap, vUv );\n\temissiveColor.rgb = emissiveMapTexelToLinear( emissiveColor ).rgb;\n\ttotalEmissiveRadiance *= emissiveColor.rgb;\n#endif";
	
	var emissivemap_pars_fragment = "#ifdef USE_EMISSIVEMAP\n\tuniform sampler2D emissiveMap;\n#endif";
	
	var encodings_fragment = "gl_FragColor = linearToOutputTexel( gl_FragColor );";
	
	var encodings_pars_fragment = "\nvec4 LinearToLinear( in vec4 value ) {\n\treturn value;\n}\nvec4 GammaToLinear( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( gammaFactor ) ), value.a );\n}\nvec4 LinearToGamma( in vec4 value, in float gammaFactor ) {\n\treturn vec4( pow( value.rgb, vec3( 1.0 / gammaFactor ) ), value.a );\n}\nvec4 sRGBToLinear( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb * 0.9478672986 + vec3( 0.0521327014 ), vec3( 2.4 ) ), value.rgb * 0.0773993808, vec3( lessThanEqual( value.rgb, vec3( 0.04045 ) ) ) ), value.a );\n}\nvec4 LinearTosRGB( in vec4 value ) {\n\treturn vec4( mix( pow( value.rgb, vec3( 0.41666 ) ) * 1.055 - vec3( 0.055 ), value.rgb * 12.92, vec3( lessThanEqual( value.rgb, vec3( 0.0031308 ) ) ) ), value.a );\n}\nvec4 RGBEToLinear( in vec4 value ) {\n\treturn vec4( value.rgb * exp2( value.a * 255.0 - 128.0 ), 1.0 );\n}\nvec4 LinearToRGBE( in vec4 value ) {\n\tfloat maxComponent = max( max( value.r, value.g ), value.b );\n\tfloat fExp = clamp( ceil( log2( maxComponent ) ), -128.0, 127.0 );\n\treturn vec4( value.rgb / exp2( fExp ), ( fExp + 128.0 ) / 255.0 );\n}\nvec4 RGBMToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * value.a * maxRange, 1.0 );\n}\nvec4 LinearToRGBM( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat M = clamp( maxRGB / maxRange, 0.0, 1.0 );\n\tM = ceil( M * 255.0 ) / 255.0;\n\treturn vec4( value.rgb / ( M * maxRange ), M );\n}\nvec4 RGBDToLinear( in vec4 value, in float maxRange ) {\n\treturn vec4( value.rgb * ( ( maxRange / 255.0 ) / value.a ), 1.0 );\n}\nvec4 LinearToRGBD( in vec4 value, in float maxRange ) {\n\tfloat maxRGB = max( value.r, max( value.g, value.b ) );\n\tfloat D = max( maxRange / maxRGB, 1.0 );\n\tD = min( floor( D ) / 255.0, 1.0 );\n\treturn vec4( value.rgb * ( D * ( 255.0 / maxRange ) ), D );\n}\nconst mat3 cLogLuvM = mat3( 0.2209, 0.3390, 0.4184, 0.1138, 0.6780, 0.7319, 0.0102, 0.1130, 0.2969 );\nvec4 LinearToLogLuv( in vec4 value )  {\n\tvec3 Xp_Y_XYZp = cLogLuvM * value.rgb;\n\tXp_Y_XYZp = max( Xp_Y_XYZp, vec3( 1e-6, 1e-6, 1e-6 ) );\n\tvec4 vResult;\n\tvResult.xy = Xp_Y_XYZp.xy / Xp_Y_XYZp.z;\n\tfloat Le = 2.0 * log2(Xp_Y_XYZp.y) + 127.0;\n\tvResult.w = fract( Le );\n\tvResult.z = ( Le - ( floor( vResult.w * 255.0 ) ) / 255.0 ) / 255.0;\n\treturn vResult;\n}\nconst mat3 cLogLuvInverseM = mat3( 6.0014, -2.7008, -1.7996, -1.3320, 3.1029, -5.7721, 0.3008, -1.0882, 5.6268 );\nvec4 LogLuvToLinear( in vec4 value ) {\n\tfloat Le = value.z * 255.0 + value.w;\n\tvec3 Xp_Y_XYZp;\n\tXp_Y_XYZp.y = exp2( ( Le - 127.0 ) / 2.0 );\n\tXp_Y_XYZp.z = Xp_Y_XYZp.y / value.y;\n\tXp_Y_XYZp.x = value.x * Xp_Y_XYZp.z;\n\tvec3 vRGB = cLogLuvInverseM * Xp_Y_XYZp.rgb;\n\treturn vec4( max( vRGB, 0.0 ), 1.0 );\n}";
	
	var envmap_fragment = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvec3 cameraToVertex = normalize( vWorldPosition - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( normal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#else\n\t\tvec3 reflectVec = vReflect;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tvec4 envColor = textureCube( envMap, vec3( flipEnvMap * reflectVec.x, reflectVec.yz ) );\n\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\tvec2 sampleUV;\n\t\treflectVec = normalize( reflectVec );\n\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\tvec4 envColor = texture2D( envMap, sampleUV );\n\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\treflectVec = normalize( reflectVec );\n\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0, 0.0, 1.0 ) );\n\t\tvec4 envColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5 );\n\t#else\n\t\tvec4 envColor = vec4( 0.0 );\n\t#endif\n\tenvColor = envMapTexelToLinear( envColor );\n\t#ifdef ENVMAP_BLENDING_MULTIPLY\n\t\toutgoingLight = mix( outgoingLight, outgoingLight * envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_MIX )\n\t\toutgoingLight = mix( outgoingLight, envColor.xyz, specularStrength * reflectivity );\n\t#elif defined( ENVMAP_BLENDING_ADD )\n\t\toutgoingLight += envColor.xyz * specularStrength * reflectivity;\n\t#endif\n#endif";
	
	var envmap_pars_fragment = "#if defined( USE_ENVMAP ) || defined( PHYSICAL )\n\tuniform float reflectivity;\n\tuniform float envMapIntensity;\n#endif\n#ifdef USE_ENVMAP\n\t#if ! defined( PHYSICAL ) && ( defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) )\n\t\tvarying vec3 vWorldPosition;\n\t#endif\n\t#ifdef ENVMAP_TYPE_CUBE\n\t\tuniform samplerCube envMap;\n\t#else\n\t\tuniform sampler2D envMap;\n\t#endif\n\tuniform float flipEnvMap;\n\tuniform int maxMipLevel;\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG ) || defined( PHYSICAL )\n\t\tuniform float refractionRatio;\n\t#else\n\t\tvarying vec3 vReflect;\n\t#endif\n#endif";
	
	var envmap_pars_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvarying vec3 vWorldPosition;\n\t#else\n\t\tvarying vec3 vReflect;\n\t\tuniform float refractionRatio;\n\t#endif\n#endif";
	
	var envmap_vertex = "#ifdef USE_ENVMAP\n\t#if defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( PHONG )\n\t\tvWorldPosition = worldPosition.xyz;\n\t#else\n\t\tvec3 cameraToVertex = normalize( worldPosition.xyz - cameraPosition );\n\t\tvec3 worldNormal = inverseTransformDirection( transformedNormal, viewMatrix );\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvReflect = reflect( cameraToVertex, worldNormal );\n\t\t#else\n\t\t\tvReflect = refract( cameraToVertex, worldNormal, refractionRatio );\n\t\t#endif\n\t#endif\n#endif";
	
	var fog_vertex = "#ifdef USE_FOG\n\tfogDepth = -mvPosition.z;\n#endif";
	
	var fog_pars_vertex = "#ifdef USE_FOG\n\tvarying float fogDepth;\n#endif";
	
	var fog_fragment = "#ifdef USE_FOG\n\t#ifdef FOG_EXP2\n\t\tfloat fogFactor = whiteCompliment( exp2( - fogDensity * fogDensity * fogDepth * fogDepth * LOG2 ) );\n\t#else\n\t\tfloat fogFactor = smoothstep( fogNear, fogFar, fogDepth );\n\t#endif\n\tgl_FragColor.rgb = mix( gl_FragColor.rgb, fogColor, fogFactor );\n#endif";
	
	var fog_pars_fragment = "#ifdef USE_FOG\n\tuniform vec3 fogColor;\n\tvarying float fogDepth;\n\t#ifdef FOG_EXP2\n\t\tuniform float fogDensity;\n\t#else\n\t\tuniform float fogNear;\n\t\tuniform float fogFar;\n\t#endif\n#endif";
	
	var gradientmap_pars_fragment = "#ifdef TOON\n\tuniform sampler2D gradientMap;\n\tvec3 getGradientIrradiance( vec3 normal, vec3 lightDirection ) {\n\t\tfloat dotNL = dot( normal, lightDirection );\n\t\tvec2 coord = vec2( dotNL * 0.5 + 0.5, 0.0 );\n\t\t#ifdef USE_GRADIENTMAP\n\t\t\treturn texture2D( gradientMap, coord ).rgb;\n\t\t#else\n\t\t\treturn ( coord.x < 0.7 ) ? vec3( 0.7 ) : vec3( 1.0 );\n\t\t#endif\n\t}\n#endif";
	
	var lightmap_fragment = "#ifdef USE_LIGHTMAP\n\treflectedLight.indirectDiffuse += PI * texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n#endif";
	
	var lightmap_pars_fragment = "#ifdef USE_LIGHTMAP\n\tuniform sampler2D lightMap;\n\tuniform float lightMapIntensity;\n#endif";
	
	var lights_lambert_vertex = "vec3 diffuse = vec3( 1.0 );\nGeometricContext geometry;\ngeometry.position = mvPosition.xyz;\ngeometry.normal = normalize( transformedNormal );\ngeometry.viewDir = normalize( -mvPosition.xyz );\nGeometricContext backGeometry;\nbackGeometry.position = geometry.position;\nbackGeometry.normal = -geometry.normal;\nbackGeometry.viewDir = geometry.viewDir;\nvLightFront = vec3( 0.0 );\nvIndirectFront = vec3( 0.0 );\n#ifdef DOUBLE_SIDED\n\tvLightBack = vec3( 0.0 );\n\tvIndirectBack = vec3( 0.0 );\n#endif\nIncidentLight directLight;\nfloat dotNL;\nvec3 directLightColor_Diffuse;\n#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tgetPointDirectLightIrradiance( pointLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tgetSpotDirectLightIrradiance( spotLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tgetDirectionalDirectLightIrradiance( directionalLights[ i ], geometry, directLight );\n\t\tdotNL = dot( geometry.normal, directLight.direction );\n\t\tdirectLightColor_Diffuse = PI * directLight.color;\n\t\tvLightFront += saturate( dotNL ) * directLightColor_Diffuse;\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvLightBack += saturate( -dotNL ) * directLightColor_Diffuse;\n\t\t#endif\n\t}\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\tvIndirectFront += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tvIndirectBack += getHemisphereLightIrradiance( hemisphereLights[ i ], backGeometry );\n\t\t#endif\n\t}\n#endif";
	
	var lights_pars_begin = "uniform vec3 ambientLightColor;\nvec3 getAmbientLightIrradiance( const in vec3 ambientLightColor ) {\n\tvec3 irradiance = ambientLightColor;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treturn irradiance;\n}\n#if NUM_DIR_LIGHTS > 0\n\tstruct DirectionalLight {\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform DirectionalLight directionalLights[ NUM_DIR_LIGHTS ];\n\tvoid getDirectionalDirectLightIrradiance( const in DirectionalLight directionalLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tdirectLight.color = directionalLight.color;\n\t\tdirectLight.direction = directionalLight.direction;\n\t\tdirectLight.visible = true;\n\t}\n#endif\n#if NUM_POINT_LIGHTS > 0\n\tstruct PointLight {\n\t\tvec3 position;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t\tfloat shadowCameraNear;\n\t\tfloat shadowCameraFar;\n\t};\n\tuniform PointLight pointLights[ NUM_POINT_LIGHTS ];\n\tvoid getPointDirectLightIrradiance( const in PointLight pointLight, const in GeometricContext geometry, out IncidentLight directLight ) {\n\t\tvec3 lVector = pointLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tdirectLight.color = pointLight.color;\n\t\tdirectLight.color *= punctualLightIntensityToIrradianceFactor( lightDistance, pointLight.distance, pointLight.decay );\n\t\tdirectLight.visible = ( directLight.color != vec3( 0.0 ) );\n\t}\n#endif\n#if NUM_SPOT_LIGHTS > 0\n\tstruct SpotLight {\n\t\tvec3 position;\n\t\tvec3 direction;\n\t\tvec3 color;\n\t\tfloat distance;\n\t\tfloat decay;\n\t\tfloat coneCos;\n\t\tfloat penumbraCos;\n\t\tint shadow;\n\t\tfloat shadowBias;\n\t\tfloat shadowRadius;\n\t\tvec2 shadowMapSize;\n\t};\n\tuniform SpotLight spotLights[ NUM_SPOT_LIGHTS ];\n\tvoid getSpotDirectLightIrradiance( const in SpotLight spotLight, const in GeometricContext geometry, out IncidentLight directLight  ) {\n\t\tvec3 lVector = spotLight.position - geometry.position;\n\t\tdirectLight.direction = normalize( lVector );\n\t\tfloat lightDistance = length( lVector );\n\t\tfloat angleCos = dot( directLight.direction, spotLight.direction );\n\t\tif ( angleCos > spotLight.coneCos ) {\n\t\t\tfloat spotEffect = smoothstep( spotLight.coneCos, spotLight.penumbraCos, angleCos );\n\t\t\tdirectLight.color = spotLight.color;\n\t\t\tdirectLight.color *= spotEffect * punctualLightIntensityToIrradianceFactor( lightDistance, spotLight.distance, spotLight.decay );\n\t\t\tdirectLight.visible = true;\n\t\t} else {\n\t\t\tdirectLight.color = vec3( 0.0 );\n\t\t\tdirectLight.visible = false;\n\t\t}\n\t}\n#endif\n#if NUM_RECT_AREA_LIGHTS > 0\n\tstruct RectAreaLight {\n\t\tvec3 color;\n\t\tvec3 position;\n\t\tvec3 halfWidth;\n\t\tvec3 halfHeight;\n\t};\n\tuniform sampler2D ltc_1;\tuniform sampler2D ltc_2;\n\tuniform RectAreaLight rectAreaLights[ NUM_RECT_AREA_LIGHTS ];\n#endif\n#if NUM_HEMI_LIGHTS > 0\n\tstruct HemisphereLight {\n\t\tvec3 direction;\n\t\tvec3 skyColor;\n\t\tvec3 groundColor;\n\t};\n\tuniform HemisphereLight hemisphereLights[ NUM_HEMI_LIGHTS ];\n\tvec3 getHemisphereLightIrradiance( const in HemisphereLight hemiLight, const in GeometricContext geometry ) {\n\t\tfloat dotNL = dot( geometry.normal, hemiLight.direction );\n\t\tfloat hemiDiffuseWeight = 0.5 * dotNL + 0.5;\n\t\tvec3 irradiance = mix( hemiLight.groundColor, hemiLight.skyColor, hemiDiffuseWeight );\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tirradiance *= PI;\n\t\t#endif\n\t\treturn irradiance;\n\t}\n#endif";
	
	var envmap_physical_pars_fragment = "#if defined( USE_ENVMAP ) && defined( PHYSICAL )\n\tvec3 getLightProbeIndirectIrradiance( const in GeometricContext geometry, const in int maxMIPLevel ) {\n\t\tvec3 worldNormal = inverseTransformDirection( geometry.normal, viewMatrix );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryVec, float( maxMIPLevel ) );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryVec = vec3( flipEnvMap * worldNormal.x, worldNormal.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryVec, 1.0 );\n\t\t#else\n\t\t\tvec4 envMapColor = vec4( 0.0 );\n\t\t#endif\n\t\treturn PI * envMapColor.rgb * envMapIntensity;\n\t}\n\tfloat getSpecularMIPLevel( const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\tfloat maxMIPLevelScalar = float( maxMIPLevel );\n\t\tfloat desiredMIPLevel = maxMIPLevelScalar + 0.79248 - 0.5 * log2( pow2( blinnShininessExponent ) + 1.0 );\n\t\treturn clamp( desiredMIPLevel, 0.0, maxMIPLevelScalar );\n\t}\n\tvec3 getLightProbeIndirectRadiance( const in GeometricContext geometry, const in float blinnShininessExponent, const in int maxMIPLevel ) {\n\t\t#ifdef ENVMAP_MODE_REFLECTION\n\t\t\tvec3 reflectVec = reflect( -geometry.viewDir, geometry.normal );\n\t\t#else\n\t\t\tvec3 reflectVec = refract( -geometry.viewDir, geometry.normal, refractionRatio );\n\t\t#endif\n\t\treflectVec = inverseTransformDirection( reflectVec, viewMatrix );\n\t\tfloat specularMIPLevel = getSpecularMIPLevel( blinnShininessExponent, maxMIPLevel );\n\t\t#ifdef ENVMAP_TYPE_CUBE\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = textureCubeLodEXT( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = textureCube( envMap, queryReflectVec, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_CUBE_UV )\n\t\t\tvec3 queryReflectVec = vec3( flipEnvMap * reflectVec.x, reflectVec.yz );\n\t\t\tvec4 envMapColor = textureCubeUV( envMap, queryReflectVec, BlinnExponentToGGXRoughness(blinnShininessExponent ));\n\t\t#elif defined( ENVMAP_TYPE_EQUIREC )\n\t\t\tvec2 sampleUV;\n\t\t\tsampleUV.y = asin( clamp( reflectVec.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\t\t\tsampleUV.x = atan( reflectVec.z, reflectVec.x ) * RECIPROCAL_PI2 + 0.5;\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, sampleUV, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, sampleUV, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#elif defined( ENVMAP_TYPE_SPHERE )\n\t\t\tvec3 reflectView = normalize( ( viewMatrix * vec4( reflectVec, 0.0 ) ).xyz + vec3( 0.0,0.0,1.0 ) );\n\t\t\t#ifdef TEXTURE_LOD_EXT\n\t\t\t\tvec4 envMapColor = texture2DLodEXT( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#else\n\t\t\t\tvec4 envMapColor = texture2D( envMap, reflectView.xy * 0.5 + 0.5, specularMIPLevel );\n\t\t\t#endif\n\t\t\tenvMapColor.rgb = envMapTexelToLinear( envMapColor ).rgb;\n\t\t#endif\n\t\treturn envMapColor.rgb * envMapIntensity;\n\t}\n#endif";
	
	var lights_phong_fragment = "BlinnPhongMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb;\nmaterial.specularColor = specular;\nmaterial.specularShininess = shininess;\nmaterial.specularStrength = specularStrength;";
	
	var lights_phong_pars_fragment = "varying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\nstruct BlinnPhongMaterial {\n\tvec3\tdiffuseColor;\n\tvec3\tspecularColor;\n\tfloat\tspecularShininess;\n\tfloat\tspecularStrength;\n};\nvoid RE_Direct_BlinnPhong( const in IncidentLight directLight, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifdef TOON\n\t\tvec3 irradiance = getGradientIrradiance( geometry.normal, directLight.direction ) * directLight.color;\n\t#else\n\t\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\t\tvec3 irradiance = dotNL * directLight.color;\n\t#endif\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\treflectedLight.directDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\treflectedLight.directSpecular += irradiance * BRDF_Specular_BlinnPhong( directLight, geometry, material.specularColor, material.specularShininess ) * material.specularStrength;\n}\nvoid RE_IndirectDiffuse_BlinnPhong( const in vec3 irradiance, const in GeometricContext geometry, const in BlinnPhongMaterial material, inout ReflectedLight reflectedLight ) {\n\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n}\n#define RE_Direct\t\t\t\tRE_Direct_BlinnPhong\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_BlinnPhong\n#define Material_LightProbeLOD( material )\t(0)";
	
	var lights_physical_fragment = "PhysicalMaterial material;\nmaterial.diffuseColor = diffuseColor.rgb * ( 1.0 - metalnessFactor );\nmaterial.specularRoughness = clamp( roughnessFactor, 0.04, 1.0 );\n#ifdef STANDARD\n\tmaterial.specularColor = mix( vec3( DEFAULT_SPECULAR_COEFFICIENT ), diffuseColor.rgb, metalnessFactor );\n#else\n\tmaterial.specularColor = mix( vec3( MAXIMUM_SPECULAR_COEFFICIENT * pow2( reflectivity ) ), diffuseColor.rgb, metalnessFactor );\n\tmaterial.clearCoat = saturate( clearCoat );\tmaterial.clearCoatRoughness = clamp( clearCoatRoughness, 0.04, 1.0 );\n#endif";
	
	var lights_physical_pars_fragment = "struct PhysicalMaterial {\n\tvec3\tdiffuseColor;\n\tfloat\tspecularRoughness;\n\tvec3\tspecularColor;\n\t#ifndef STANDARD\n\t\tfloat clearCoat;\n\t\tfloat clearCoatRoughness;\n\t#endif\n};\n#define MAXIMUM_SPECULAR_COEFFICIENT 0.16\n#define DEFAULT_SPECULAR_COEFFICIENT 0.04\nfloat clearCoatDHRApprox( const in float roughness, const in float dotNL ) {\n\treturn DEFAULT_SPECULAR_COEFFICIENT + ( 1.0 - DEFAULT_SPECULAR_COEFFICIENT ) * ( pow( 1.0 - dotNL, 5.0 ) * pow( 1.0 - roughness, 2.0 ) );\n}\n#if NUM_RECT_AREA_LIGHTS > 0\n\tvoid RE_Direct_RectArea_Physical( const in RectAreaLight rectAreaLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t\tvec3 normal = geometry.normal;\n\t\tvec3 viewDir = geometry.viewDir;\n\t\tvec3 position = geometry.position;\n\t\tvec3 lightPos = rectAreaLight.position;\n\t\tvec3 halfWidth = rectAreaLight.halfWidth;\n\t\tvec3 halfHeight = rectAreaLight.halfHeight;\n\t\tvec3 lightColor = rectAreaLight.color;\n\t\tfloat roughness = material.specularRoughness;\n\t\tvec3 rectCoords[ 4 ];\n\t\trectCoords[ 0 ] = lightPos + halfWidth - halfHeight;\t\trectCoords[ 1 ] = lightPos - halfWidth - halfHeight;\n\t\trectCoords[ 2 ] = lightPos - halfWidth + halfHeight;\n\t\trectCoords[ 3 ] = lightPos + halfWidth + halfHeight;\n\t\tvec2 uv = LTC_Uv( normal, viewDir, roughness );\n\t\tvec4 t1 = texture2D( ltc_1, uv );\n\t\tvec4 t2 = texture2D( ltc_2, uv );\n\t\tmat3 mInv = mat3(\n\t\t\tvec3( t1.x, 0, t1.y ),\n\t\t\tvec3(    0, 1,    0 ),\n\t\t\tvec3( t1.z, 0, t1.w )\n\t\t);\n\t\tvec3 fresnel = ( material.specularColor * t2.x + ( vec3( 1.0 ) - material.specularColor ) * t2.y );\n\t\treflectedLight.directSpecular += lightColor * fresnel * LTC_Evaluate( normal, viewDir, position, mInv, rectCoords );\n\t\treflectedLight.directDiffuse += lightColor * material.diffuseColor * LTC_Evaluate( normal, viewDir, position, mat3( 1.0 ), rectCoords );\n\t}\n#endif\nvoid RE_Direct_Physical( const in IncidentLight directLight, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\tfloat dotNL = saturate( dot( geometry.normal, directLight.direction ) );\n\tvec3 irradiance = dotNL * directLight.color;\n\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\tirradiance *= PI;\n\t#endif\n\t#ifndef STANDARD\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\treflectedLight.directSpecular += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Specular_GGX( directLight, geometry, material.specularColor, material.specularRoughness );\n\treflectedLight.directDiffuse += ( 1.0 - clearCoatDHR ) * irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#ifndef STANDARD\n\t\treflectedLight.directSpecular += irradiance * material.clearCoat * BRDF_Specular_GGX( directLight, geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\nvoid RE_IndirectDiffuse_Physical( const in vec3 irradiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight ) {\n\t#ifndef ENVMAP_TYPE_CUBE_UV\n\t\treflectedLight.indirectDiffuse += irradiance * BRDF_Diffuse_Lambert( material.diffuseColor );\n\t#endif\n}\nvoid RE_IndirectSpecular_Physical( const in vec3 radiance, const in vec3 irradiance, const in vec3 clearCoatRadiance, const in GeometricContext geometry, const in PhysicalMaterial material, inout ReflectedLight reflectedLight) {\n\t#ifndef STANDARD\n\t\tfloat dotNV = saturate( dot( geometry.normal, geometry.viewDir ) );\n\t\tfloat dotNL = dotNV;\n\t\tfloat clearCoatDHR = material.clearCoat * clearCoatDHRApprox( material.clearCoatRoughness, dotNL );\n\t#else\n\t\tfloat clearCoatDHR = 0.0;\n\t#endif\n\tfloat clearCoatInv = 1.0 - clearCoatDHR;\n\t#if defined( ENVMAP_TYPE_CUBE_UV )\n\t\tvec3 singleScattering = vec3( 0.0 );\n\t\tvec3 multiScattering = vec3( 0.0 );\n\t\tvec3 cosineWeightedIrradiance = irradiance * RECIPROCAL_PI;\n\t\tBRDF_Specular_Multiscattering_Environment( geometry, material.specularColor, material.specularRoughness, singleScattering, multiScattering );\n\t\tvec3 diffuse = material.diffuseColor;\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * singleScattering;\n\t\treflectedLight.indirectDiffuse += multiScattering * cosineWeightedIrradiance;\n\t\treflectedLight.indirectDiffuse += diffuse * cosineWeightedIrradiance;\n\t#else\n\t\treflectedLight.indirectSpecular += clearCoatInv * radiance * BRDF_Specular_GGX_Environment( geometry, material.specularColor, material.specularRoughness );\n\t#endif\n\t#ifndef STANDARD\n\t\treflectedLight.indirectSpecular += clearCoatRadiance * material.clearCoat * BRDF_Specular_GGX_Environment( geometry, vec3( DEFAULT_SPECULAR_COEFFICIENT ), material.clearCoatRoughness );\n\t#endif\n}\n#define RE_Direct\t\t\t\tRE_Direct_Physical\n#define RE_Direct_RectArea\t\tRE_Direct_RectArea_Physical\n#define RE_IndirectDiffuse\t\tRE_IndirectDiffuse_Physical\n#define RE_IndirectSpecular\t\tRE_IndirectSpecular_Physical\n#define Material_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.specularRoughness )\n#define Material_ClearCoat_BlinnShininessExponent( material )   GGXRoughnessToBlinnExponent( material.clearCoatRoughness )\nfloat computeSpecularOcclusion( const in float dotNV, const in float ambientOcclusion, const in float roughness ) {\n\treturn saturate( pow( dotNV + ambientOcclusion, exp2( - 16.0 * roughness - 1.0 ) ) - 1.0 + ambientOcclusion );\n}";
	
	var lights_fragment_begin = "\nGeometricContext geometry;\ngeometry.position = - vViewPosition;\ngeometry.normal = normal;\ngeometry.viewDir = normalize( vViewPosition );\nIncidentLight directLight;\n#if ( NUM_POINT_LIGHTS > 0 ) && defined( RE_Direct )\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tgetPointDirectLightIrradiance( pointLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( pointLight.shadow, directLight.visible ) ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_SPOT_LIGHTS > 0 ) && defined( RE_Direct )\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tgetSpotDirectLightIrradiance( spotLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( spotLight.shadow, directLight.visible ) ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_DIR_LIGHTS > 0 ) && defined( RE_Direct )\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tgetDirectionalDirectLightIrradiance( directionalLight, geometry, directLight );\n\t\t#ifdef USE_SHADOWMAP\n\t\tdirectLight.color *= all( bvec2( directionalLight.shadow, directLight.visible ) ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t\t#endif\n\t\tRE_Direct( directLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if ( NUM_RECT_AREA_LIGHTS > 0 ) && defined( RE_Direct_RectArea )\n\tRectAreaLight rectAreaLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_RECT_AREA_LIGHTS; i ++ ) {\n\t\trectAreaLight = rectAreaLights[ i ];\n\t\tRE_Direct_RectArea( rectAreaLight, geometry, material, reflectedLight );\n\t}\n#endif\n#if defined( RE_IndirectDiffuse )\n\tvec3 irradiance = getAmbientLightIrradiance( ambientLightColor );\n\t#if ( NUM_HEMI_LIGHTS > 0 )\n\t\t#pragma unroll_loop\n\t\tfor ( int i = 0; i < NUM_HEMI_LIGHTS; i ++ ) {\n\t\t\tirradiance += getHemisphereLightIrradiance( hemisphereLights[ i ], geometry );\n\t\t}\n\t#endif\n#endif\n#if defined( RE_IndirectSpecular )\n\tvec3 radiance = vec3( 0.0 );\n\tvec3 clearCoatRadiance = vec3( 0.0 );\n#endif";
	
	var lights_fragment_maps = "#if defined( RE_IndirectDiffuse )\n\t#ifdef USE_LIGHTMAP\n\t\tvec3 lightMapIrradiance = texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t\t#ifndef PHYSICALLY_CORRECT_LIGHTS\n\t\t\tlightMapIrradiance *= PI;\n\t\t#endif\n\t\tirradiance += lightMapIrradiance;\n\t#endif\n\t#if defined( USE_ENVMAP ) && defined( PHYSICAL ) && defined( ENVMAP_TYPE_CUBE_UV )\n\t\tirradiance += getLightProbeIndirectIrradiance( geometry, maxMipLevel );\n\t#endif\n#endif\n#if defined( USE_ENVMAP ) && defined( RE_IndirectSpecular )\n\tradiance += getLightProbeIndirectRadiance( geometry, Material_BlinnShininessExponent( material ), maxMipLevel );\n\t#ifndef STANDARD\n\t\tclearCoatRadiance += getLightProbeIndirectRadiance( geometry, Material_ClearCoat_BlinnShininessExponent( material ), maxMipLevel );\n\t#endif\n#endif";
	
	var lights_fragment_end = "#if defined( RE_IndirectDiffuse )\n\tRE_IndirectDiffuse( irradiance, geometry, material, reflectedLight );\n#endif\n#if defined( RE_IndirectSpecular )\n\tRE_IndirectSpecular( radiance, irradiance, clearCoatRadiance, geometry, material, reflectedLight );\n#endif";
	
	var logdepthbuf_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tgl_FragDepthEXT = log2( vFragDepth ) * logDepthBufFC * 0.5;\n#endif";
	
	var logdepthbuf_pars_fragment = "#if defined( USE_LOGDEPTHBUF ) && defined( USE_LOGDEPTHBUF_EXT )\n\tuniform float logDepthBufFC;\n\tvarying float vFragDepth;\n#endif";
	
	var logdepthbuf_pars_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvarying float vFragDepth;\n\t#else\n\t\tuniform float logDepthBufFC;\n\t#endif\n#endif";
	
	var logdepthbuf_vertex = "#ifdef USE_LOGDEPTHBUF\n\t#ifdef USE_LOGDEPTHBUF_EXT\n\t\tvFragDepth = 1.0 + gl_Position.w;\n\t#else\n\t\tgl_Position.z = log2( max( EPSILON, gl_Position.w + 1.0 ) ) * logDepthBufFC - 1.0;\n\t\tgl_Position.z *= gl_Position.w;\n\t#endif\n#endif";
	
	var map_fragment = "#ifdef USE_MAP\n\tvec4 texelColor = texture2D( map, vUv );\n\ttexelColor = mapTexelToLinear( texelColor );\n\tdiffuseColor *= texelColor;\n#endif";
	
	var map_pars_fragment = "#ifdef USE_MAP\n\tuniform sampler2D map;\n#endif";
	
	var map_particle_fragment = "#ifdef USE_MAP\n\tvec2 uv = ( uvTransform * vec3( gl_PointCoord.x, 1.0 - gl_PointCoord.y, 1 ) ).xy;\n\tvec4 mapTexel = texture2D( map, uv );\n\tdiffuseColor *= mapTexelToLinear( mapTexel );\n#endif";
	
	var map_particle_pars_fragment = "#ifdef USE_MAP\n\tuniform mat3 uvTransform;\n\tuniform sampler2D map;\n#endif";
	
	var metalnessmap_fragment = "float metalnessFactor = metalness;\n#ifdef USE_METALNESSMAP\n\tvec4 texelMetalness = texture2D( metalnessMap, vUv );\n\tmetalnessFactor *= texelMetalness.b;\n#endif";
	
	var metalnessmap_pars_fragment = "#ifdef USE_METALNESSMAP\n\tuniform sampler2D metalnessMap;\n#endif";
	
	var morphnormal_vertex = "#ifdef USE_MORPHNORMALS\n\tobjectNormal += ( morphNormal0 - normal ) * morphTargetInfluences[ 0 ];\n\tobjectNormal += ( morphNormal1 - normal ) * morphTargetInfluences[ 1 ];\n\tobjectNormal += ( morphNormal2 - normal ) * morphTargetInfluences[ 2 ];\n\tobjectNormal += ( morphNormal3 - normal ) * morphTargetInfluences[ 3 ];\n#endif";
	
	var morphtarget_pars_vertex = "#ifdef USE_MORPHTARGETS\n\t#ifndef USE_MORPHNORMALS\n\tuniform float morphTargetInfluences[ 8 ];\n\t#else\n\tuniform float morphTargetInfluences[ 4 ];\n\t#endif\n#endif";
	
	var morphtarget_vertex = "#ifdef USE_MORPHTARGETS\n\ttransformed += ( morphTarget0 - position ) * morphTargetInfluences[ 0 ];\n\ttransformed += ( morphTarget1 - position ) * morphTargetInfluences[ 1 ];\n\ttransformed += ( morphTarget2 - position ) * morphTargetInfluences[ 2 ];\n\ttransformed += ( morphTarget3 - position ) * morphTargetInfluences[ 3 ];\n\t#ifndef USE_MORPHNORMALS\n\ttransformed += ( morphTarget4 - position ) * morphTargetInfluences[ 4 ];\n\ttransformed += ( morphTarget5 - position ) * morphTargetInfluences[ 5 ];\n\ttransformed += ( morphTarget6 - position ) * morphTargetInfluences[ 6 ];\n\ttransformed += ( morphTarget7 - position ) * morphTargetInfluences[ 7 ];\n\t#endif\n#endif";
	
	var normal_fragment_begin = "#ifdef FLAT_SHADED\n\tvec3 fdx = vec3( dFdx( vViewPosition.x ), dFdx( vViewPosition.y ), dFdx( vViewPosition.z ) );\n\tvec3 fdy = vec3( dFdy( vViewPosition.x ), dFdy( vViewPosition.y ), dFdy( vViewPosition.z ) );\n\tvec3 normal = normalize( cross( fdx, fdy ) );\n#else\n\tvec3 normal = normalize( vNormal );\n\t#ifdef DOUBLE_SIDED\n\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t#endif\n#endif";
	
	var normal_fragment_maps = "#ifdef USE_NORMALMAP\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tnormal = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t#ifdef FLIP_SIDED\n\t\t\tnormal = - normal;\n\t\t#endif\n\t\t#ifdef DOUBLE_SIDED\n\t\t\tnormal = normal * ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t#endif\n\t\tnormal = normalize( normalMatrix * normal );\n\t#else\n\t\tnormal = perturbNormal2Arb( -vViewPosition, normal );\n\t#endif\n#elif defined( USE_BUMPMAP )\n\tnormal = perturbNormalArb( -vViewPosition, normal, dHdxy_fwd() );\n#endif";
	
	var normalmap_pars_fragment = "#ifdef USE_NORMALMAP\n\tuniform sampler2D normalMap;\n\tuniform vec2 normalScale;\n\t#ifdef OBJECTSPACE_NORMALMAP\n\t\tuniform mat3 normalMatrix;\n\t#else\n\t\tvec3 perturbNormal2Arb( vec3 eye_pos, vec3 surf_norm ) {\n\t\t\tvec3 q0 = vec3( dFdx( eye_pos.x ), dFdx( eye_pos.y ), dFdx( eye_pos.z ) );\n\t\t\tvec3 q1 = vec3( dFdy( eye_pos.x ), dFdy( eye_pos.y ), dFdy( eye_pos.z ) );\n\t\t\tvec2 st0 = dFdx( vUv.st );\n\t\t\tvec2 st1 = dFdy( vUv.st );\n\t\t\tfloat scale = sign( st1.t * st0.s - st0.t * st1.s );\n\t\t\tvec3 S = normalize( ( q0 * st1.t - q1 * st0.t ) * scale );\n\t\t\tvec3 T = normalize( ( - q0 * st1.s + q1 * st0.s ) * scale );\n\t\t\tvec3 N = normalize( surf_norm );\n\t\t\tmat3 tsn = mat3( S, T, N );\n\t\t\tvec3 mapN = texture2D( normalMap, vUv ).xyz * 2.0 - 1.0;\n\t\t\tmapN.xy *= normalScale;\n\t\t\tmapN.xy *= ( float( gl_FrontFacing ) * 2.0 - 1.0 );\n\t\t\treturn normalize( tsn * mapN );\n\t\t}\n\t#endif\n#endif";
	
	var packing = "vec3 packNormalToRGB( const in vec3 normal ) {\n\treturn normalize( normal ) * 0.5 + 0.5;\n}\nvec3 unpackRGBToNormal( const in vec3 rgb ) {\n\treturn 2.0 * rgb.xyz - 1.0;\n}\nconst float PackUpscale = 256. / 255.;const float UnpackDownscale = 255. / 256.;\nconst vec3 PackFactors = vec3( 256. * 256. * 256., 256. * 256.,  256. );\nconst vec4 UnpackFactors = UnpackDownscale / vec4( PackFactors, 1. );\nconst float ShiftRight8 = 1. / 256.;\nvec4 packDepthToRGBA( const in float v ) {\n\tvec4 r = vec4( fract( v * PackFactors ), v );\n\tr.yzw -= r.xyz * ShiftRight8;\treturn r * PackUpscale;\n}\nfloat unpackRGBAToDepth( const in vec4 v ) {\n\treturn dot( v, UnpackFactors );\n}\nfloat viewZToOrthographicDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn ( viewZ + near ) / ( near - far );\n}\nfloat orthographicDepthToViewZ( const in float linearClipZ, const in float near, const in float far ) {\n\treturn linearClipZ * ( near - far ) - near;\n}\nfloat viewZToPerspectiveDepth( const in float viewZ, const in float near, const in float far ) {\n\treturn (( near + viewZ ) * far ) / (( far - near ) * viewZ );\n}\nfloat perspectiveDepthToViewZ( const in float invClipZ, const in float near, const in float far ) {\n\treturn ( near * far ) / ( ( far - near ) * invClipZ - far );\n}";
	
	var premultiplied_alpha_fragment = "#ifdef PREMULTIPLIED_ALPHA\n\tgl_FragColor.rgb *= gl_FragColor.a;\n#endif";
	
	var project_vertex = "vec4 mvPosition = modelViewMatrix * vec4( transformed, 1.0 );\ngl_Position = projectionMatrix * mvPosition;";
	
	var dithering_fragment = "#if defined( DITHERING )\n  gl_FragColor.rgb = dithering( gl_FragColor.rgb );\n#endif";
	
	var dithering_pars_fragment = "#if defined( DITHERING )\n\tvec3 dithering( vec3 color ) {\n\t\tfloat grid_position = rand( gl_FragCoord.xy );\n\t\tvec3 dither_shift_RGB = vec3( 0.25 / 255.0, -0.25 / 255.0, 0.25 / 255.0 );\n\t\tdither_shift_RGB = mix( 2.0 * dither_shift_RGB, -2.0 * dither_shift_RGB, grid_position );\n\t\treturn color + dither_shift_RGB;\n\t}\n#endif";
	
	var roughnessmap_fragment = "float roughnessFactor = roughness;\n#ifdef USE_ROUGHNESSMAP\n\tvec4 texelRoughness = texture2D( roughnessMap, vUv );\n\troughnessFactor *= texelRoughness.g;\n#endif";
	
	var roughnessmap_pars_fragment = "#ifdef USE_ROUGHNESSMAP\n\tuniform sampler2D roughnessMap;\n#endif";
	
	var shadowmap_pars_fragment = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform sampler2D directionalShadowMap[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform sampler2D spotShadowMap[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform sampler2D pointShadowMap[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n\tfloat texture2DCompare( sampler2D depths, vec2 uv, float compare ) {\n\t\treturn step( compare, unpackRGBAToDepth( texture2D( depths, uv ) ) );\n\t}\n\tfloat texture2DShadowLerp( sampler2D depths, vec2 size, vec2 uv, float compare ) {\n\t\tconst vec2 offset = vec2( 0.0, 1.0 );\n\t\tvec2 texelSize = vec2( 1.0 ) / size;\n\t\tvec2 centroidUV = floor( uv * size + 0.5 ) / size;\n\t\tfloat lb = texture2DCompare( depths, centroidUV + texelSize * offset.xx, compare );\n\t\tfloat lt = texture2DCompare( depths, centroidUV + texelSize * offset.xy, compare );\n\t\tfloat rb = texture2DCompare( depths, centroidUV + texelSize * offset.yx, compare );\n\t\tfloat rt = texture2DCompare( depths, centroidUV + texelSize * offset.yy, compare );\n\t\tvec2 f = fract( uv * size + 0.5 );\n\t\tfloat a = mix( lb, lt, f.y );\n\t\tfloat b = mix( rb, rt, f.y );\n\t\tfloat c = mix( a, b, f.x );\n\t\treturn c;\n\t}\n\tfloat getShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord ) {\n\t\tfloat shadow = 1.0;\n\t\tshadowCoord.xyz /= shadowCoord.w;\n\t\tshadowCoord.z += shadowBias;\n\t\tbvec4 inFrustumVec = bvec4 ( shadowCoord.x >= 0.0, shadowCoord.x <= 1.0, shadowCoord.y >= 0.0, shadowCoord.y <= 1.0 );\n\t\tbool inFrustum = all( inFrustumVec );\n\t\tbvec2 frustumTestVec = bvec2( inFrustum, shadowCoord.z <= 1.0 );\n\t\tbool frustumTest = all( frustumTestVec );\n\t\tif ( frustumTest ) {\n\t\t#if defined( SHADOWMAP_TYPE_PCF )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DCompare( shadowMap, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#elif defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 texelSize = vec2( 1.0 ) / shadowMapSize;\n\t\t\tfloat dx0 = - texelSize.x * shadowRadius;\n\t\t\tfloat dy0 = - texelSize.y * shadowRadius;\n\t\t\tfloat dx1 = + texelSize.x * shadowRadius;\n\t\t\tfloat dy1 = + texelSize.y * shadowRadius;\n\t\t\tshadow = (\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy, shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, 0.0 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( 0.0, dy1 ), shadowCoord.z ) +\n\t\t\t\ttexture2DShadowLerp( shadowMap, shadowMapSize, shadowCoord.xy + vec2( dx1, dy1 ), shadowCoord.z )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\tshadow = texture2DCompare( shadowMap, shadowCoord.xy, shadowCoord.z );\n\t\t#endif\n\t\t}\n\t\treturn shadow;\n\t}\n\tvec2 cubeToUV( vec3 v, float texelSizeY ) {\n\t\tvec3 absV = abs( v );\n\t\tfloat scaleToCube = 1.0 / max( absV.x, max( absV.y, absV.z ) );\n\t\tabsV *= scaleToCube;\n\t\tv *= scaleToCube * ( 1.0 - 2.0 * texelSizeY );\n\t\tvec2 planar = v.xy;\n\t\tfloat almostATexel = 1.5 * texelSizeY;\n\t\tfloat almostOne = 1.0 - almostATexel;\n\t\tif ( absV.z >= almostOne ) {\n\t\t\tif ( v.z > 0.0 )\n\t\t\t\tplanar.x = 4.0 - v.x;\n\t\t} else if ( absV.x >= almostOne ) {\n\t\t\tfloat signX = sign( v.x );\n\t\t\tplanar.x = v.z * signX + 2.0 * signX;\n\t\t} else if ( absV.y >= almostOne ) {\n\t\t\tfloat signY = sign( v.y );\n\t\t\tplanar.x = v.x + 2.0 * signY + 2.0;\n\t\t\tplanar.y = v.z * signY - 2.0;\n\t\t}\n\t\treturn vec2( 0.125, 0.25 ) * planar + vec2( 0.375, 0.75 );\n\t}\n\tfloat getPointShadow( sampler2D shadowMap, vec2 shadowMapSize, float shadowBias, float shadowRadius, vec4 shadowCoord, float shadowCameraNear, float shadowCameraFar ) {\n\t\tvec2 texelSize = vec2( 1.0 ) / ( shadowMapSize * vec2( 4.0, 2.0 ) );\n\t\tvec3 lightToPosition = shadowCoord.xyz;\n\t\tfloat dp = ( length( lightToPosition ) - shadowCameraNear ) / ( shadowCameraFar - shadowCameraNear );\t\tdp += shadowBias;\n\t\tvec3 bd3D = normalize( lightToPosition );\n\t\t#if defined( SHADOWMAP_TYPE_PCF ) || defined( SHADOWMAP_TYPE_PCF_SOFT )\n\t\t\tvec2 offset = vec2( - 1, 1 ) * shadowRadius * texelSize.y;\n\t\t\treturn (\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yyx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxy, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.xxx, texelSize.y ), dp ) +\n\t\t\t\ttexture2DCompare( shadowMap, cubeToUV( bd3D + offset.yxx, texelSize.y ), dp )\n\t\t\t) * ( 1.0 / 9.0 );\n\t\t#else\n\t\t\treturn texture2DCompare( shadowMap, cubeToUV( bd3D, texelSize.y ), dp );\n\t\t#endif\n\t}\n#endif";
	
	var shadowmap_pars_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t\tuniform mat4 directionalShadowMatrix[ NUM_DIR_LIGHTS ];\n\t\tvarying vec4 vDirectionalShadowCoord[ NUM_DIR_LIGHTS ];\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t\tuniform mat4 spotShadowMatrix[ NUM_SPOT_LIGHTS ];\n\t\tvarying vec4 vSpotShadowCoord[ NUM_SPOT_LIGHTS ];\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t\tuniform mat4 pointShadowMatrix[ NUM_POINT_LIGHTS ];\n\t\tvarying vec4 vPointShadowCoord[ NUM_POINT_LIGHTS ];\n\t#endif\n#endif";
	
	var shadowmap_vertex = "#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tvDirectionalShadowCoord[ i ] = directionalShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tvSpotShadowCoord[ i ] = spotShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tvPointShadowCoord[ i ] = pointShadowMatrix[ i ] * worldPosition;\n\t}\n\t#endif\n#endif";
	
	var shadowmask_pars_fragment = "float getShadowMask() {\n\tfloat shadow = 1.0;\n\t#ifdef USE_SHADOWMAP\n\t#if NUM_DIR_LIGHTS > 0\n\tDirectionalLight directionalLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_DIR_LIGHTS; i ++ ) {\n\t\tdirectionalLight = directionalLights[ i ];\n\t\tshadow *= bool( directionalLight.shadow ) ? getShadow( directionalShadowMap[ i ], directionalLight.shadowMapSize, directionalLight.shadowBias, directionalLight.shadowRadius, vDirectionalShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_SPOT_LIGHTS > 0\n\tSpotLight spotLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_SPOT_LIGHTS; i ++ ) {\n\t\tspotLight = spotLights[ i ];\n\t\tshadow *= bool( spotLight.shadow ) ? getShadow( spotShadowMap[ i ], spotLight.shadowMapSize, spotLight.shadowBias, spotLight.shadowRadius, vSpotShadowCoord[ i ] ) : 1.0;\n\t}\n\t#endif\n\t#if NUM_POINT_LIGHTS > 0\n\tPointLight pointLight;\n\t#pragma unroll_loop\n\tfor ( int i = 0; i < NUM_POINT_LIGHTS; i ++ ) {\n\t\tpointLight = pointLights[ i ];\n\t\tshadow *= bool( pointLight.shadow ) ? getPointShadow( pointShadowMap[ i ], pointLight.shadowMapSize, pointLight.shadowBias, pointLight.shadowRadius, vPointShadowCoord[ i ], pointLight.shadowCameraNear, pointLight.shadowCameraFar ) : 1.0;\n\t}\n\t#endif\n\t#endif\n\treturn shadow;\n}";
	
	var skinbase_vertex = "#ifdef USE_SKINNING\n\tmat4 boneMatX = getBoneMatrix( skinIndex.x );\n\tmat4 boneMatY = getBoneMatrix( skinIndex.y );\n\tmat4 boneMatZ = getBoneMatrix( skinIndex.z );\n\tmat4 boneMatW = getBoneMatrix( skinIndex.w );\n#endif";
	
	var skinning_pars_vertex = "#ifdef USE_SKINNING\n\tuniform mat4 bindMatrix;\n\tuniform mat4 bindMatrixInverse;\n\t#ifdef BONE_TEXTURE\n\t\tuniform sampler2D boneTexture;\n\t\tuniform int boneTextureSize;\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tfloat j = i * 4.0;\n\t\t\tfloat x = mod( j, float( boneTextureSize ) );\n\t\t\tfloat y = floor( j / float( boneTextureSize ) );\n\t\t\tfloat dx = 1.0 / float( boneTextureSize );\n\t\t\tfloat dy = 1.0 / float( boneTextureSize );\n\t\t\ty = dy * ( y + 0.5 );\n\t\t\tvec4 v1 = texture2D( boneTexture, vec2( dx * ( x + 0.5 ), y ) );\n\t\t\tvec4 v2 = texture2D( boneTexture, vec2( dx * ( x + 1.5 ), y ) );\n\t\t\tvec4 v3 = texture2D( boneTexture, vec2( dx * ( x + 2.5 ), y ) );\n\t\t\tvec4 v4 = texture2D( boneTexture, vec2( dx * ( x + 3.5 ), y ) );\n\t\t\tmat4 bone = mat4( v1, v2, v3, v4 );\n\t\t\treturn bone;\n\t\t}\n\t#else\n\t\tuniform mat4 boneMatrices[ MAX_BONES ];\n\t\tmat4 getBoneMatrix( const in float i ) {\n\t\t\tmat4 bone = boneMatrices[ int(i) ];\n\t\t\treturn bone;\n\t\t}\n\t#endif\n#endif";
	
	var skinning_vertex = "#ifdef USE_SKINNING\n\tvec4 skinVertex = bindMatrix * vec4( transformed, 1.0 );\n\tvec4 skinned = vec4( 0.0 );\n\tskinned += boneMatX * skinVertex * skinWeight.x;\n\tskinned += boneMatY * skinVertex * skinWeight.y;\n\tskinned += boneMatZ * skinVertex * skinWeight.z;\n\tskinned += boneMatW * skinVertex * skinWeight.w;\n\ttransformed = ( bindMatrixInverse * skinned ).xyz;\n#endif";
	
	var skinnormal_vertex = "#ifdef USE_SKINNING\n\tmat4 skinMatrix = mat4( 0.0 );\n\tskinMatrix += skinWeight.x * boneMatX;\n\tskinMatrix += skinWeight.y * boneMatY;\n\tskinMatrix += skinWeight.z * boneMatZ;\n\tskinMatrix += skinWeight.w * boneMatW;\n\tskinMatrix  = bindMatrixInverse * skinMatrix * bindMatrix;\n\tobjectNormal = vec4( skinMatrix * vec4( objectNormal, 0.0 ) ).xyz;\n#endif";
	
	var specularmap_fragment = "float specularStrength;\n#ifdef USE_SPECULARMAP\n\tvec4 texelSpecular = texture2D( specularMap, vUv );\n\tspecularStrength = texelSpecular.r;\n#else\n\tspecularStrength = 1.0;\n#endif";
	
	var specularmap_pars_fragment = "#ifdef USE_SPECULARMAP\n\tuniform sampler2D specularMap;\n#endif";
	
	var tonemapping_fragment = "#if defined( TONE_MAPPING )\n  gl_FragColor.rgb = toneMapping( gl_FragColor.rgb );\n#endif";
	
	var tonemapping_pars_fragment = "#ifndef saturate\n\t#define saturate(a) clamp( a, 0.0, 1.0 )\n#endif\nuniform float toneMappingExposure;\nuniform float toneMappingWhitePoint;\nvec3 LinearToneMapping( vec3 color ) {\n\treturn toneMappingExposure * color;\n}\nvec3 ReinhardToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( color / ( vec3( 1.0 ) + color ) );\n}\n#define Uncharted2Helper( x ) max( ( ( x * ( 0.15 * x + 0.10 * 0.50 ) + 0.20 * 0.02 ) / ( x * ( 0.15 * x + 0.50 ) + 0.20 * 0.30 ) ) - 0.02 / 0.30, vec3( 0.0 ) )\nvec3 Uncharted2ToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( Uncharted2Helper( color ) / Uncharted2Helper( vec3( toneMappingWhitePoint ) ) );\n}\nvec3 OptimizedCineonToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\tcolor = max( vec3( 0.0 ), color - 0.004 );\n\treturn pow( ( color * ( 6.2 * color + 0.5 ) ) / ( color * ( 6.2 * color + 1.7 ) + 0.06 ), vec3( 2.2 ) );\n}\nvec3 ACESFilmicToneMapping( vec3 color ) {\n\tcolor *= toneMappingExposure;\n\treturn saturate( ( color * ( 2.51 * color + 0.03 ) ) / ( color * ( 2.43 * color + 0.59 ) + 0.14 ) );\n}";
	
	var uv_pars_fragment = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n#endif";
	
	var uv_pars_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvarying vec2 vUv;\n\tuniform mat3 uvTransform;\n#endif";
	
	var uv_vertex = "#if defined( USE_MAP ) || defined( USE_BUMPMAP ) || defined( USE_NORMALMAP ) || defined( USE_SPECULARMAP ) || defined( USE_ALPHAMAP ) || defined( USE_EMISSIVEMAP ) || defined( USE_ROUGHNESSMAP ) || defined( USE_METALNESSMAP )\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n#endif";
	
	var uv2_pars_fragment = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvarying vec2 vUv2;\n#endif";
	
	var uv2_pars_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tattribute vec2 uv2;\n\tvarying vec2 vUv2;\n#endif";
	
	var uv2_vertex = "#if defined( USE_LIGHTMAP ) || defined( USE_AOMAP )\n\tvUv2 = uv2;\n#endif";
	
	var worldpos_vertex = "#if defined( USE_ENVMAP ) || defined( DISTANCE ) || defined ( USE_SHADOWMAP )\n\tvec4 worldPosition = modelMatrix * vec4( transformed, 1.0 );\n#endif";
	
	var background_frag = "uniform sampler2D t2D;\nvarying vec2 vUv;\nvoid main() {\n\tvec4 texColor = texture2D( t2D, vUv );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	
	var background_vert = "varying vec2 vUv;\nuniform mat3 uvTransform;\nvoid main() {\n\tvUv = ( uvTransform * vec3( uv, 1 ) ).xy;\n\tgl_Position = vec4( position.xy, 1.0, 1.0 );\n}";
	
	var cube_frag = "uniform samplerCube tCube;\nuniform float tFlip;\nuniform float opacity;\nvarying vec3 vWorldDirection;\nvoid main() {\n\tvec4 texColor = textureCube( tCube, vec3( tFlip * vWorldDirection.x, vWorldDirection.yz ) );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\tgl_FragColor.a *= opacity;\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	
	var cube_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\tgl_Position.z = gl_Position.w;\n}";
	
	var depth_frag = "#if DEPTH_PACKING == 3200\n\tuniform float opacity;\n#endif\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#if DEPTH_PACKING == 3200\n\t\tdiffuseColor.a = opacity;\n\t#endif\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <logdepthbuf_fragment>\n\t#if DEPTH_PACKING == 3200\n\t\tgl_FragColor = vec4( vec3( 1.0 - gl_FragCoord.z ), opacity );\n\t#elif DEPTH_PACKING == 3201\n\t\tgl_FragColor = packDepthToRGBA( gl_FragCoord.z );\n\t#endif\n}";
	
	var depth_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n}";
	
	var distanceRGBA_frag = "#define DISTANCE\nuniform vec3 referencePosition;\nuniform float nearDistance;\nuniform float farDistance;\nvarying vec3 vWorldPosition;\n#include <common>\n#include <packing>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main () {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( 1.0 );\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\tfloat dist = length( vWorldPosition - referencePosition );\n\tdist = ( dist - nearDistance ) / ( farDistance - nearDistance );\n\tdist = saturate( dist );\n\tgl_FragColor = packDepthToRGBA( dist );\n}";
	
	var distanceRGBA_vert = "#define DISTANCE\nvarying vec3 vWorldPosition;\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_DISPLACEMENTMAP\n\t\t#include <beginnormal_vertex>\n\t\t#include <morphnormal_vertex>\n\t\t#include <skinnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\tvWorldPosition = worldPosition.xyz;\n}";
	
	var equirect_frag = "uniform sampler2D tEquirect;\nvarying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvec3 direction = normalize( vWorldDirection );\n\tvec2 sampleUV;\n\tsampleUV.y = asin( clamp( direction.y, - 1.0, 1.0 ) ) * RECIPROCAL_PI + 0.5;\n\tsampleUV.x = atan( direction.z, direction.x ) * RECIPROCAL_PI2 + 0.5;\n\tvec4 texColor = texture2D( tEquirect, sampleUV );\n\tgl_FragColor = mapTexelToLinear( texColor );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n}";
	
	var equirect_vert = "varying vec3 vWorldDirection;\n#include <common>\nvoid main() {\n\tvWorldDirection = transformDirection( position, modelMatrix );\n\t#include <begin_vertex>\n\t#include <project_vertex>\n}";
	
	var linedashed_frag = "uniform vec3 diffuse;\nuniform float opacity;\nuniform float dashSize;\nuniform float totalSize;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tif ( mod( vLineDistance, totalSize ) > dashSize ) {\n\t\tdiscard;\n\t}\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <color_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	
	var linedashed_vert = "uniform float scale;\nattribute float lineDistance;\nvarying float vLineDistance;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\tvLineDistance = scale * lineDistance;\n\tvec4 mvPosition = modelViewMatrix * vec4( position, 1.0 );\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	
	var meshbasic_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\t#ifdef USE_LIGHTMAP\n\t\treflectedLight.indirectDiffuse += texture2D( lightMap, vUv2 ).xyz * lightMapIntensity;\n\t#else\n\t\treflectedLight.indirectDiffuse += vec3( 1.0 );\n\t#endif\n\t#include <aomap_fragment>\n\treflectedLight.indirectDiffuse *= diffuseColor.rgb;\n\tvec3 outgoingLight = reflectedLight.indirectDiffuse;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	
	var meshbasic_vert = "#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <skinbase_vertex>\n\t#ifdef USE_ENVMAP\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <worldpos_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <envmap_vertex>\n\t#include <fog_vertex>\n}";
	
	var meshlambert_frag = "uniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float opacity;\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <fog_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <emissivemap_fragment>\n\treflectedLight.indirectDiffuse = getAmbientLightIrradiance( ambientLightColor );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.indirectDiffuse += ( gl_FrontFacing ) ? vIndirectFront : vIndirectBack;\n\t#else\n\t\treflectedLight.indirectDiffuse += vIndirectFront;\n\t#endif\n\t#include <lightmap_fragment>\n\treflectedLight.indirectDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb );\n\t#ifdef DOUBLE_SIDED\n\t\treflectedLight.directDiffuse = ( gl_FrontFacing ) ? vLightFront : vLightBack;\n\t#else\n\t\treflectedLight.directDiffuse = vLightFront;\n\t#endif\n\treflectedLight.directDiffuse *= BRDF_Diffuse_Lambert( diffuseColor.rgb ) * getShadowMask();\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	
	var meshlambert_vert = "#define LAMBERT\nvarying vec3 vLightFront;\nvarying vec3 vIndirectFront;\n#ifdef DOUBLE_SIDED\n\tvarying vec3 vLightBack;\n\tvarying vec3 vIndirectBack;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <envmap_pars_vertex>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <lights_lambert_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	
	var meshmatcap_frag = "#define MATCAP\nuniform vec3 diffuse;\nuniform float opacity;\nuniform sampler2D matcap;\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tvec3 viewDir = normalize( vViewPosition );\n\tvec3 x = normalize( vec3( viewDir.z, 0.0, - viewDir.x ) );\n\tvec3 y = cross( viewDir, x );\n\tvec2 uv = vec2( dot( x, normal ), dot( y, normal ) ) * 0.495 + 0.5;\n\t#ifdef USE_MATCAP\n\t\tvec4 matcapColor = texture2D( matcap, uv );\n\t\tmatcapColor = matcapTexelToLinear( matcapColor );\n\t#else\n\t\tvec4 matcapColor = vec4( 1.0 );\n\t#endif\n\tvec3 outgoingLight = diffuseColor.rgb * matcapColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	
	var meshmatcap_vert = "#define MATCAP\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n\t#ifndef FLAT_SHADED\n\t\tvNormal = normalize( transformedNormal );\n\t#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n\tvViewPosition = - mvPosition.xyz;\n}";
	
	var meshphong_frag = "#define PHONG\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform vec3 specular;\nuniform float shininess;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <envmap_pars_fragment>\n#include <gradientmap_pars_fragment>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <lights_phong_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <specularmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <specularmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_phong_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\t#include <envmap_fragment>\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	
	var meshphong_vert = "#define PHONG\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <envmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <envmap_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	
	var meshphysical_frag = "#define PHYSICAL\nuniform vec3 diffuse;\nuniform vec3 emissive;\nuniform float roughness;\nuniform float metalness;\nuniform float opacity;\n#ifndef STANDARD\n\tuniform float clearCoat;\n\tuniform float clearCoatRoughness;\n#endif\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <packing>\n#include <dithering_pars_fragment>\n#include <color_pars_fragment>\n#include <uv_pars_fragment>\n#include <uv2_pars_fragment>\n#include <map_pars_fragment>\n#include <alphamap_pars_fragment>\n#include <aomap_pars_fragment>\n#include <lightmap_pars_fragment>\n#include <emissivemap_pars_fragment>\n#include <bsdfs>\n#include <cube_uv_reflection_fragment>\n#include <envmap_pars_fragment>\n#include <envmap_physical_pars_fragment>\n#include <fog_pars_fragment>\n#include <lights_pars_begin>\n#include <lights_physical_pars_fragment>\n#include <shadowmap_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <roughnessmap_pars_fragment>\n#include <metalnessmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\tReflectedLight reflectedLight = ReflectedLight( vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ), vec3( 0.0 ) );\n\tvec3 totalEmissiveRadiance = emissive;\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <color_fragment>\n\t#include <alphamap_fragment>\n\t#include <alphatest_fragment>\n\t#include <roughnessmap_fragment>\n\t#include <metalnessmap_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\t#include <emissivemap_fragment>\n\t#include <lights_physical_fragment>\n\t#include <lights_fragment_begin>\n\t#include <lights_fragment_maps>\n\t#include <lights_fragment_end>\n\t#include <aomap_fragment>\n\tvec3 outgoingLight = reflectedLight.directDiffuse + reflectedLight.indirectDiffuse + reflectedLight.directSpecular + reflectedLight.indirectSpecular + totalEmissiveRadiance;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n\t#include <premultiplied_alpha_fragment>\n\t#include <dithering_fragment>\n}";
	
	var meshphysical_vert = "#define PHYSICAL\nvarying vec3 vViewPosition;\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <common>\n#include <uv_pars_vertex>\n#include <uv2_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <shadowmap_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <uv2_vertex>\n\t#include <color_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\tvViewPosition = - mvPosition.xyz;\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	
	var normal_frag = "#define NORMAL\nuniform float opacity;\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <packing>\n#include <uv_pars_fragment>\n#include <bumpmap_pars_fragment>\n#include <normalmap_pars_fragment>\n#include <logdepthbuf_pars_fragment>\nvoid main() {\n\t#include <logdepthbuf_fragment>\n\t#include <normal_fragment_begin>\n\t#include <normal_fragment_maps>\n\tgl_FragColor = vec4( packNormalToRGB( normal ), opacity );\n}";
	
	var normal_vert = "#define NORMAL\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvarying vec3 vViewPosition;\n#endif\n#ifndef FLAT_SHADED\n\tvarying vec3 vNormal;\n#endif\n#include <uv_pars_vertex>\n#include <displacementmap_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <skinning_pars_vertex>\n#include <logdepthbuf_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\t#include <beginnormal_vertex>\n\t#include <morphnormal_vertex>\n\t#include <skinbase_vertex>\n\t#include <skinnormal_vertex>\n\t#include <defaultnormal_vertex>\n#ifndef FLAT_SHADED\n\tvNormal = normalize( transformedNormal );\n#endif\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <skinning_vertex>\n\t#include <displacementmap_vertex>\n\t#include <project_vertex>\n\t#include <logdepthbuf_vertex>\n#if defined( FLAT_SHADED ) || defined( USE_BUMPMAP ) || ( defined( USE_NORMALMAP ) && ! defined( OBJECTSPACE_NORMALMAP ) )\n\tvViewPosition = - mvPosition.xyz;\n#endif\n}";
	
	var points_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <color_pars_fragment>\n#include <map_particle_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_particle_fragment>\n\t#include <color_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <premultiplied_alpha_fragment>\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	
	var points_vert = "uniform float size;\nuniform float scale;\n#include <common>\n#include <color_pars_vertex>\n#include <fog_pars_vertex>\n#include <morphtarget_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <color_vertex>\n\t#include <begin_vertex>\n\t#include <morphtarget_vertex>\n\t#include <project_vertex>\n\tgl_PointSize = size;\n\t#ifdef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) gl_PointSize *= ( scale / - mvPosition.z );\n\t#endif\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <worldpos_vertex>\n\t#include <fog_vertex>\n}";
	
	var shadow_frag = "uniform vec3 color;\nuniform float opacity;\n#include <common>\n#include <packing>\n#include <fog_pars_fragment>\n#include <bsdfs>\n#include <lights_pars_begin>\n#include <shadowmap_pars_fragment>\n#include <shadowmask_pars_fragment>\nvoid main() {\n\tgl_FragColor = vec4( color, opacity * ( 1.0 - getShadowMask() ) );\n\t#include <fog_fragment>\n}";
	
	var shadow_vert = "#include <fog_pars_vertex>\n#include <shadowmap_pars_vertex>\nvoid main() {\n\t#include <begin_vertex>\n\t#include <project_vertex>\n\t#include <worldpos_vertex>\n\t#include <shadowmap_vertex>\n\t#include <fog_vertex>\n}";
	
	var sprite_frag = "uniform vec3 diffuse;\nuniform float opacity;\n#include <common>\n#include <uv_pars_fragment>\n#include <map_pars_fragment>\n#include <fog_pars_fragment>\n#include <logdepthbuf_pars_fragment>\n#include <clipping_planes_pars_fragment>\nvoid main() {\n\t#include <clipping_planes_fragment>\n\tvec3 outgoingLight = vec3( 0.0 );\n\tvec4 diffuseColor = vec4( diffuse, opacity );\n\t#include <logdepthbuf_fragment>\n\t#include <map_fragment>\n\t#include <alphatest_fragment>\n\toutgoingLight = diffuseColor.rgb;\n\tgl_FragColor = vec4( outgoingLight, diffuseColor.a );\n\t#include <tonemapping_fragment>\n\t#include <encodings_fragment>\n\t#include <fog_fragment>\n}";
	
	var sprite_vert = "uniform float rotation;\nuniform vec2 center;\n#include <common>\n#include <uv_pars_vertex>\n#include <fog_pars_vertex>\n#include <logdepthbuf_pars_vertex>\n#include <clipping_planes_pars_vertex>\nvoid main() {\n\t#include <uv_vertex>\n\tvec4 mvPosition = modelViewMatrix * vec4( 0.0, 0.0, 0.0, 1.0 );\n\tvec2 scale;\n\tscale.x = length( vec3( modelMatrix[ 0 ].x, modelMatrix[ 0 ].y, modelMatrix[ 0 ].z ) );\n\tscale.y = length( vec3( modelMatrix[ 1 ].x, modelMatrix[ 1 ].y, modelMatrix[ 1 ].z ) );\n\t#ifndef USE_SIZEATTENUATION\n\t\tbool isPerspective = ( projectionMatrix[ 2 ][ 3 ] == - 1.0 );\n\t\tif ( isPerspective ) scale *= - mvPosition.z;\n\t#endif\n\tvec2 alignedPosition = ( position.xy - ( center - vec2( 0.5 ) ) ) * scale;\n\tvec2 rotatedPosition;\n\trotatedPosition.x = cos( rotation ) * alignedPosition.x - sin( rotation ) * alignedPosition.y;\n\trotatedPosition.y = sin( rotation ) * alignedPosition.x + cos( rotation ) * alignedPosition.y;\n\tmvPosition.xy += rotatedPosition;\n\tgl_Position = projectionMatrix * mvPosition;\n\t#include <logdepthbuf_vertex>\n\t#include <clipping_planes_vertex>\n\t#include <fog_vertex>\n}";
	
	var ShaderChunk = {
		alphamap_fragment: alphamap_fragment,
		alphamap_pars_fragment: alphamap_pars_fragment,
		alphatest_fragment: alphatest_fragment,
		aomap_fragment: aomap_fragment,
		aomap_pars_fragment: aomap_pars_fragment,
		begin_vertex: begin_vertex,
		beginnormal_vertex: beginnormal_vertex,
		bsdfs: bsdfs,
		bumpmap_pars_fragment: bumpmap_pars_fragment,
		clipping_planes_fragment: clipping_planes_fragment,
		clipping_planes_pars_fragment: clipping_planes_pars_fragment,
		clipping_planes_pars_vertex: clipping_planes_pars_vertex,
		clipping_planes_vertex: clipping_planes_vertex,
		color_fragment: color_fragment,
		color_pars_fragment: color_pars_fragment,
		color_pars_vertex: color_pars_vertex,
		color_vertex: color_vertex,
		common: common,
		cube_uv_reflection_fragment: cube_uv_reflection_fragment,
		defaultnormal_vertex: defaultnormal_vertex,
		displacementmap_pars_vertex: displacementmap_pars_vertex,
		displacementmap_vertex: displacementmap_vertex,
		emissivemap_fragment: emissivemap_fragment,
		emissivemap_pars_fragment: emissivemap_pars_fragment,
		encodings_fragment: encodings_fragment,
		encodings_pars_fragment: encodings_pars_fragment,
		envmap_fragment: envmap_fragment,
		envmap_pars_fragment: envmap_pars_fragment,
		envmap_pars_vertex: envmap_pars_vertex,
		envmap_physical_pars_fragment: envmap_physical_pars_fragment,
		envmap_vertex: envmap_vertex,
		fog_vertex: fog_vertex,
		fog_pars_vertex: fog_pars_vertex,
		fog_fragment: fog_fragment,
		fog_pars_fragment: fog_pars_fragment,
		gradientmap_pars_fragment: gradientmap_pars_fragment,
		lightmap_fragment: lightmap_fragment,
		lightmap_pars_fragment: lightmap_pars_fragment,
		lights_lambert_vertex: lights_lambert_vertex,
		lights_pars_begin: lights_pars_begin,
		lights_phong_fragment: lights_phong_fragment,
		lights_phong_pars_fragment: lights_phong_pars_fragment,
		lights_physical_fragment: lights_physical_fragment,
		lights_physical_pars_fragment: lights_physical_pars_fragment,
		lights_fragment_begin: lights_fragment_begin,
		lights_fragment_maps: lights_fragment_maps,
		lights_fragment_end: lights_fragment_end,
		logdepthbuf_fragment: logdepthbuf_fragment,
		logdepthbuf_pars_fragment: logdepthbuf_pars_fragment,
		logdepthbuf_pars_vertex: logdepthbuf_pars_vertex,
		logdepthbuf_vertex: logdepthbuf_vertex,
		map_fragment: map_fragment,
		map_pars_fragment: map_pars_fragment,
		map_particle_fragment: map_particle_fragment,
		map_particle_pars_fragment: map_particle_pars_fragment,
		metalnessmap_fragment: metalnessmap_fragment,
		metalnessmap_pars_fragment: metalnessmap_pars_fragment,
		morphnormal_vertex: morphnormal_vertex,
		morphtarget_pars_vertex: morphtarget_pars_vertex,
		morphtarget_vertex: morphtarget_vertex,
		normal_fragment_begin: normal_fragment_begin,
		normal_fragment_maps: normal_fragment_maps,
		normalmap_pars_fragment: normalmap_pars_fragment,
		packing: packing,
		premultiplied_alpha_fragment: premultiplied_alpha_fragment,
		project_vertex: project_vertex,
		dithering_fragment: dithering_fragment,
		dithering_pars_fragment: dithering_pars_fragment,
		roughnessmap_fragment: roughnessmap_fragment,
		roughnessmap_pars_fragment: roughnessmap_pars_fragment,
		shadowmap_pars_fragment: shadowmap_pars_fragment,
		shadowmap_pars_vertex: shadowmap_pars_vertex,
		shadowmap_vertex: shadowmap_vertex,
		shadowmask_pars_fragment: shadowmask_pars_fragment,
		skinbase_vertex: skinbase_vertex,
		skinning_pars_vertex: skinning_pars_vertex,
		skinning_vertex: skinning_vertex,
		skinnormal_vertex: skinnormal_vertex,
		specularmap_fragment: specularmap_fragment,
		specularmap_pars_fragment: specularmap_pars_fragment,
		tonemapping_fragment: tonemapping_fragment,
		tonemapping_pars_fragment: tonemapping_pars_fragment,
		uv_pars_fragment: uv_pars_fragment,
		uv_pars_vertex: uv_pars_vertex,
		uv_vertex: uv_vertex,
		uv2_pars_fragment: uv2_pars_fragment,
		uv2_pars_vertex: uv2_pars_vertex,
		uv2_vertex: uv2_vertex,
		worldpos_vertex: worldpos_vertex,
	
		background_frag: background_frag,
		background_vert: background_vert,
		cube_frag: cube_frag,
		cube_vert: cube_vert,
		depth_frag: depth_frag,
		depth_vert: depth_vert,
		distanceRGBA_frag: distanceRGBA_frag,
		distanceRGBA_vert: distanceRGBA_vert,
		equirect_frag: equirect_frag,
		equirect_vert: equirect_vert,
		linedashed_frag: linedashed_frag,
		linedashed_vert: linedashed_vert,
		meshbasic_frag: meshbasic_frag,
		meshbasic_vert: meshbasic_vert,
		meshlambert_frag: meshlambert_frag,
		meshlambert_vert: meshlambert_vert,
		meshmatcap_frag: meshmatcap_frag,
		meshmatcap_vert: meshmatcap_vert,
		meshphong_frag: meshphong_frag,
		meshphong_vert: meshphong_vert,
		meshphysical_frag: meshphysical_frag,
		meshphysical_vert: meshphysical_vert,
		normal_frag: normal_frag,
		normal_vert: normal_vert,
		points_frag: points_frag,
		points_vert: points_vert,
		shadow_frag: shadow_frag,
		shadow_vert: shadow_vert,
		sprite_frag: sprite_frag,
		sprite_vert: sprite_vert
	};
	
	/**
	 * Uniform Utilities
	 */
	
	function cloneUniforms( src ) {
	
		var dst = {};
	
		for ( var u in src ) {
	
			dst[ u ] = {};
	
			for ( var p in src[ u ] ) {
	
				var property = src[ u ][ p ];
	
				if ( property && ( property.isColor ||
					property.isMatrix3 || property.isMatrix4 ||
					property.isVector2 || property.isVector3 || property.isVector4 ||
					property.isTexture ) ) {
	
					dst[ u ][ p ] = property.clone();
	
				} else if ( Array.isArray( property ) ) {
	
					dst[ u ][ p ] = property.slice();
	
				} else {
	
					dst[ u ][ p ] = property;
	
				}
	
			}
	
		}
	
		return dst;
	
	}
	
	function mergeUniforms( uniforms ) {
	
		var merged = {};
	
		for ( var u = 0; u < uniforms.length; u ++ ) {
	
			var tmp = cloneUniforms( uniforms[ u ] );
	
			for ( var p in tmp ) {
	
				merged[ p ] = tmp[ p ];
	
			}
	
		}
	
		return merged;
	
	}
	
	// Legacy
	
	var UniformsUtils = { clone: cloneUniforms, merge: mergeUniforms };
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var ColorKeywords = { 'aliceblue': 0xF0F8FF, 'antiquewhite': 0xFAEBD7, 'aqua': 0x00FFFF, 'aquamarine': 0x7FFFD4, 'azure': 0xF0FFFF,
		'beige': 0xF5F5DC, 'bisque': 0xFFE4C4, 'black': 0x000000, 'blanchedalmond': 0xFFEBCD, 'blue': 0x0000FF, 'blueviolet': 0x8A2BE2,
		'brown': 0xA52A2A, 'burlywood': 0xDEB887, 'cadetblue': 0x5F9EA0, 'chartreuse': 0x7FFF00, 'chocolate': 0xD2691E, 'coral': 0xFF7F50,
		'cornflowerblue': 0x6495ED, 'cornsilk': 0xFFF8DC, 'crimson': 0xDC143C, 'cyan': 0x00FFFF, 'darkblue': 0x00008B, 'darkcyan': 0x008B8B,
		'darkgoldenrod': 0xB8860B, 'darkgray': 0xA9A9A9, 'darkgreen': 0x006400, 'darkgrey': 0xA9A9A9, 'darkkhaki': 0xBDB76B, 'darkmagenta': 0x8B008B,
		'darkolivegreen': 0x556B2F, 'darkorange': 0xFF8C00, 'darkorchid': 0x9932CC, 'darkred': 0x8B0000, 'darksalmon': 0xE9967A, 'darkseagreen': 0x8FBC8F,
		'darkslateblue': 0x483D8B, 'darkslategray': 0x2F4F4F, 'darkslategrey': 0x2F4F4F, 'darkturquoise': 0x00CED1, 'darkviolet': 0x9400D3,
		'deeppink': 0xFF1493, 'deepskyblue': 0x00BFFF, 'dimgray': 0x696969, 'dimgrey': 0x696969, 'dodgerblue': 0x1E90FF, 'firebrick': 0xB22222,
		'floralwhite': 0xFFFAF0, 'forestgreen': 0x228B22, 'fuchsia': 0xFF00FF, 'gainsboro': 0xDCDCDC, 'ghostwhite': 0xF8F8FF, 'gold': 0xFFD700,
		'goldenrod': 0xDAA520, 'gray': 0x808080, 'green': 0x008000, 'greenyellow': 0xADFF2F, 'grey': 0x808080, 'honeydew': 0xF0FFF0, 'hotpink': 0xFF69B4,
		'indianred': 0xCD5C5C, 'indigo': 0x4B0082, 'ivory': 0xFFFFF0, 'khaki': 0xF0E68C, 'lavender': 0xE6E6FA, 'lavenderblush': 0xFFF0F5, 'lawngreen': 0x7CFC00,
		'lemonchiffon': 0xFFFACD, 'lightblue': 0xADD8E6, 'lightcoral': 0xF08080, 'lightcyan': 0xE0FFFF, 'lightgoldenrodyellow': 0xFAFAD2, 'lightgray': 0xD3D3D3,
		'lightgreen': 0x90EE90, 'lightgrey': 0xD3D3D3, 'lightpink': 0xFFB6C1, 'lightsalmon': 0xFFA07A, 'lightseagreen': 0x20B2AA, 'lightskyblue': 0x87CEFA,
		'lightslategray': 0x778899, 'lightslategrey': 0x778899, 'lightsteelblue': 0xB0C4DE, 'lightyellow': 0xFFFFE0, 'lime': 0x00FF00, 'limegreen': 0x32CD32,
		'linen': 0xFAF0E6, 'magenta': 0xFF00FF, 'maroon': 0x800000, 'mediumaquamarine': 0x66CDAA, 'mediumblue': 0x0000CD, 'mediumorchid': 0xBA55D3,
		'mediumpurple': 0x9370DB, 'mediumseagreen': 0x3CB371, 'mediumslateblue': 0x7B68EE, 'mediumspringgreen': 0x00FA9A, 'mediumturquoise': 0x48D1CC,
		'mediumvioletred': 0xC71585, 'midnightblue': 0x191970, 'mintcream': 0xF5FFFA, 'mistyrose': 0xFFE4E1, 'moccasin': 0xFFE4B5, 'navajowhite': 0xFFDEAD,
		'navy': 0x000080, 'oldlace': 0xFDF5E6, 'olive': 0x808000, 'olivedrab': 0x6B8E23, 'orange': 0xFFA500, 'orangered': 0xFF4500, 'orchid': 0xDA70D6,
		'palegoldenrod': 0xEEE8AA, 'palegreen': 0x98FB98, 'paleturquoise': 0xAFEEEE, 'palevioletred': 0xDB7093, 'papayawhip': 0xFFEFD5, 'peachpuff': 0xFFDAB9,
		'peru': 0xCD853F, 'pink': 0xFFC0CB, 'plum': 0xDDA0DD, 'powderblue': 0xB0E0E6, 'purple': 0x800080, 'rebeccapurple': 0x663399, 'red': 0xFF0000, 'rosybrown': 0xBC8F8F,
		'royalblue': 0x4169E1, 'saddlebrown': 0x8B4513, 'salmon': 0xFA8072, 'sandybrown': 0xF4A460, 'seagreen': 0x2E8B57, 'seashell': 0xFFF5EE,
		'sienna': 0xA0522D, 'silver': 0xC0C0C0, 'skyblue': 0x87CEEB, 'slateblue': 0x6A5ACD, 'slategray': 0x708090, 'slategrey': 0x708090, 'snow': 0xFFFAFA,
		'springgreen': 0x00FF7F, 'steelblue': 0x4682B4, 'tan': 0xD2B48C, 'teal': 0x008080, 'thistle': 0xD8BFD8, 'tomato': 0xFF6347, 'turquoise': 0x40E0D0,
		'violet': 0xEE82EE, 'wheat': 0xF5DEB3, 'white': 0xFFFFFF, 'whitesmoke': 0xF5F5F5, 'yellow': 0xFFFF00, 'yellowgreen': 0x9ACD32 };
	
	function Color( r, g, b ) {
	
		if ( g === undefined && b === undefined ) {
	
			// r is THREE.Color, hex or string
			return this.set( r );
	
		}
	
		return this.setRGB( r, g, b );
	
	}
	
	Object.assign( Color.prototype, {
	
		isColor: true,
	
		r: 1, g: 1, b: 1,
	
		set: function ( value ) {
	
			if ( value && value.isColor ) {
	
				this.copy( value );
	
			} else if ( typeof value === 'number' ) {
	
				this.setHex( value );
	
			} else if ( typeof value === 'string' ) {
	
				this.setStyle( value );
	
			}
	
			return this;
	
		},
	
		setScalar: function ( scalar ) {
	
			this.r = scalar;
			this.g = scalar;
			this.b = scalar;
	
			return this;
	
		},
	
		setHex: function ( hex ) {
	
			hex = Math.floor( hex );
	
			this.r = ( hex >> 16 & 255 ) / 255;
			this.g = ( hex >> 8 & 255 ) / 255;
			this.b = ( hex & 255 ) / 255;
	
			return this;
	
		},
	
		setRGB: function ( r, g, b ) {
	
			this.r = r;
			this.g = g;
			this.b = b;
	
			return this;
	
		},
	
		setHSL: function () {
	
			function hue2rgb( p, q, t ) {
	
				if ( t < 0 ) t += 1;
				if ( t > 1 ) t -= 1;
				if ( t < 1 / 6 ) return p + ( q - p ) * 6 * t;
				if ( t < 1 / 2 ) return q;
				if ( t < 2 / 3 ) return p + ( q - p ) * 6 * ( 2 / 3 - t );
				return p;
	
			}
	
			return function setHSL( h, s, l ) {
	
				// h,s,l ranges are in 0.0 - 1.0
				h = _Math.euclideanModulo( h, 1 );
				s = _Math.clamp( s, 0, 1 );
				l = _Math.clamp( l, 0, 1 );
	
				if ( s === 0 ) {
	
					this.r = this.g = this.b = l;
	
				} else {
	
					var p = l <= 0.5 ? l * ( 1 + s ) : l + s - ( l * s );
					var q = ( 2 * l ) - p;
	
					this.r = hue2rgb( q, p, h + 1 / 3 );
					this.g = hue2rgb( q, p, h );
					this.b = hue2rgb( q, p, h - 1 / 3 );
	
				}
	
				return this;
	
			};
	
		}(),
	
		setStyle: function ( style ) {
	
			function handleAlpha( string ) {
	
				if ( string === undefined ) return;
	
				if ( parseFloat( string ) < 1 ) {
	
					console.warn( 'THREE.Color: Alpha component of ' + style + ' will be ignored.' );
	
				}
	
			}
	
	
			var m;
	
			if ( m = /^((?:rgb|hsl)a?)\(\s*([^\)]*)\)/.exec( style ) ) {
	
				// rgb / hsl
	
				var color;
				var name = m[ 1 ];
				var components = m[ 2 ];
	
				switch ( name ) {
	
					case 'rgb':
					case 'rgba':
	
						if ( color = /^(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(255,0,0) rgba(255,0,0,0.5)
							this.r = Math.min( 255, parseInt( color[ 1 ], 10 ) ) / 255;
							this.g = Math.min( 255, parseInt( color[ 2 ], 10 ) ) / 255;
							this.b = Math.min( 255, parseInt( color[ 3 ], 10 ) ) / 255;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						if ( color = /^(\d+)\%\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// rgb(100%,0%,0%) rgba(100%,0%,0%,0.5)
							this.r = Math.min( 100, parseInt( color[ 1 ], 10 ) ) / 100;
							this.g = Math.min( 100, parseInt( color[ 2 ], 10 ) ) / 100;
							this.b = Math.min( 100, parseInt( color[ 3 ], 10 ) ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this;
	
						}
	
						break;
	
					case 'hsl':
					case 'hsla':
	
						if ( color = /^([0-9]*\.?[0-9]+)\s*,\s*(\d+)\%\s*,\s*(\d+)\%\s*(,\s*([0-9]*\.?[0-9]+)\s*)?$/.exec( components ) ) {
	
							// hsl(120,50%,50%) hsla(120,50%,50%,0.5)
							var h = parseFloat( color[ 1 ] ) / 360;
							var s = parseInt( color[ 2 ], 10 ) / 100;
							var l = parseInt( color[ 3 ], 10 ) / 100;
	
							handleAlpha( color[ 5 ] );
	
							return this.setHSL( h, s, l );
	
						}
	
						break;
	
				}
	
			} else if ( m = /^\#([A-Fa-f0-9]+)$/.exec( style ) ) {
	
				// hex color
	
				var hex = m[ 1 ];
				var size = hex.length;
	
				if ( size === 3 ) {
	
					// #ff0
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 0 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 1 ) + hex.charAt( 1 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 2 ) + hex.charAt( 2 ), 16 ) / 255;
	
					return this;
	
				} else if ( size === 6 ) {
	
					// #ff0000
					this.r = parseInt( hex.charAt( 0 ) + hex.charAt( 1 ), 16 ) / 255;
					this.g = parseInt( hex.charAt( 2 ) + hex.charAt( 3 ), 16 ) / 255;
					this.b = parseInt( hex.charAt( 4 ) + hex.charAt( 5 ), 16 ) / 255;
	
					return this;
	
				}
	
			}
	
			if ( style && style.length > 0 ) {
	
				// color keywords
				var hex = ColorKeywords[ style ];
	
				if ( hex !== undefined ) {
	
					// red
					this.setHex( hex );
	
				} else {
	
					// unknown color
					console.warn( 'THREE.Color: Unknown color ' + style );
	
				}
	
			}
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this.r, this.g, this.b );
	
		},
	
		copy: function ( color ) {
	
			this.r = color.r;
			this.g = color.g;
			this.b = color.b;
	
			return this;
	
		},
	
		copyGammaToLinear: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			this.r = Math.pow( color.r, gammaFactor );
			this.g = Math.pow( color.g, gammaFactor );
			this.b = Math.pow( color.b, gammaFactor );
	
			return this;
	
		},
	
		copyLinearToGamma: function ( color, gammaFactor ) {
	
			if ( gammaFactor === undefined ) gammaFactor = 2.0;
	
			var safeInverse = ( gammaFactor > 0 ) ? ( 1.0 / gammaFactor ) : 1.0;
	
			this.r = Math.pow( color.r, safeInverse );
			this.g = Math.pow( color.g, safeInverse );
			this.b = Math.pow( color.b, safeInverse );
	
			return this;
	
		},
	
		convertGammaToLinear: function ( gammaFactor ) {
	
			this.copyGammaToLinear( this, gammaFactor );
	
			return this;
	
		},
	
		convertLinearToGamma: function ( gammaFactor ) {
	
			this.copyLinearToGamma( this, gammaFactor );
	
			return this;
	
		},
	
		copySRGBToLinear: function () {
	
			function SRGBToLinear( c ) {
	
				return ( c < 0.04045 ) ? c * 0.0773993808 : Math.pow( c * 0.9478672986 + 0.0521327014, 2.4 );
	
			}
	
			return function copySRGBToLinear( color ) {
	
				this.r = SRGBToLinear( color.r );
				this.g = SRGBToLinear( color.g );
				this.b = SRGBToLinear( color.b );
	
				return this;
	
			};
	
		}(),
	
		copyLinearToSRGB: function () {
	
			function LinearToSRGB( c ) {
	
				return ( c < 0.0031308 ) ? c * 12.92 : 1.055 * ( Math.pow( c, 0.41666 ) ) - 0.055;
	
			}
	
			return function copyLinearToSRGB( color ) {
	
				this.r = LinearToSRGB( color.r );
				this.g = LinearToSRGB( color.g );
				this.b = LinearToSRGB( color.b );
	
				return this;
	
			};
	
		}(),
	
		convertSRGBToLinear: function () {
	
			this.copySRGBToLinear( this );
	
			return this;
	
		},
	
		convertLinearToSRGB: function () {
	
			this.copyLinearToSRGB( this );
	
			return this;
	
		},
	
		getHex: function () {
	
			return ( this.r * 255 ) << 16 ^ ( this.g * 255 ) << 8 ^ ( this.b * 255 ) << 0;
	
		},
	
		getHexString: function () {
	
			return ( '000000' + this.getHex().toString( 16 ) ).slice( - 6 );
	
		},
	
		getHSL: function ( target ) {
	
			// h,s,l ranges are in 0.0 - 1.0
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Color: .getHSL() target is now required' );
				target = { h: 0, s: 0, l: 0 };
	
			}
	
			var r = this.r, g = this.g, b = this.b;
	
			var max = Math.max( r, g, b );
			var min = Math.min( r, g, b );
	
			var hue, saturation;
			var lightness = ( min + max ) / 2.0;
	
			if ( min === max ) {
	
				hue = 0;
				saturation = 0;
	
			} else {
	
				var delta = max - min;
	
				saturation = lightness <= 0.5 ? delta / ( max + min ) : delta / ( 2 - max - min );
	
				switch ( max ) {
	
					case r: hue = ( g - b ) / delta + ( g < b ? 6 : 0 ); break;
					case g: hue = ( b - r ) / delta + 2; break;
					case b: hue = ( r - g ) / delta + 4; break;
	
				}
	
				hue /= 6;
	
			}
	
			target.h = hue;
			target.s = saturation;
			target.l = lightness;
	
			return target;
	
		},
	
		getStyle: function () {
	
			return 'rgb(' + ( ( this.r * 255 ) | 0 ) + ',' + ( ( this.g * 255 ) | 0 ) + ',' + ( ( this.b * 255 ) | 0 ) + ')';
	
		},
	
		offsetHSL: function () {
	
			var hsl = {};
	
			return function ( h, s, l ) {
	
				this.getHSL( hsl );
	
				hsl.h += h; hsl.s += s; hsl.l += l;
	
				this.setHSL( hsl.h, hsl.s, hsl.l );
	
				return this;
	
			};
	
		}(),
	
		add: function ( color ) {
	
			this.r += color.r;
			this.g += color.g;
			this.b += color.b;
	
			return this;
	
		},
	
		addColors: function ( color1, color2 ) {
	
			this.r = color1.r + color2.r;
			this.g = color1.g + color2.g;
			this.b = color1.b + color2.b;
	
			return this;
	
		},
	
		addScalar: function ( s ) {
	
			this.r += s;
			this.g += s;
			this.b += s;
	
			return this;
	
		},
	
		sub: function ( color ) {
	
			this.r = Math.max( 0, this.r - color.r );
			this.g = Math.max( 0, this.g - color.g );
			this.b = Math.max( 0, this.b - color.b );
	
			return this;
	
		},
	
		multiply: function ( color ) {
	
			this.r *= color.r;
			this.g *= color.g;
			this.b *= color.b;
	
			return this;
	
		},
	
		multiplyScalar: function ( s ) {
	
			this.r *= s;
			this.g *= s;
			this.b *= s;
	
			return this;
	
		},
	
		lerp: function ( color, alpha ) {
	
			this.r += ( color.r - this.r ) * alpha;
			this.g += ( color.g - this.g ) * alpha;
			this.b += ( color.b - this.b ) * alpha;
	
			return this;
	
		},
	
		lerpHSL: function () {
	
			var hslA = { h: 0, s: 0, l: 0 };
			var hslB = { h: 0, s: 0, l: 0 };
	
			return function lerpHSL( color, alpha ) {
	
				this.getHSL( hslA );
				color.getHSL( hslB );
	
				var h = _Math.lerp( hslA.h, hslB.h, alpha );
				var s = _Math.lerp( hslA.s, hslB.s, alpha );
				var l = _Math.lerp( hslA.l, hslB.l, alpha );
	
				this.setHSL( h, s, l );
	
				return this;
	
			};
	
		}(),
	
		equals: function ( c ) {
	
			return ( c.r === this.r ) && ( c.g === this.g ) && ( c.b === this.b );
	
		},
	
		fromArray: function ( array, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.r = array[ offset ];
			this.g = array[ offset + 1 ];
			this.b = array[ offset + 2 ];
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this.r;
			array[ offset + 1 ] = this.g;
			array[ offset + 2 ] = this.b;
	
			return array;
	
		},
	
		toJSON: function () {
	
			return this.getHex();
	
		}
	
	} );
	
	/**
	 * Uniforms library for shared webgl shaders
	 */
	
	var UniformsLib = {
	
		common: {
	
			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
	
			map: { value: null },
			uvTransform: { value: new Matrix3() },
	
			alphaMap: { value: null },
	
		},
	
		specularmap: {
	
			specularMap: { value: null },
	
		},
	
		envmap: {
	
			envMap: { value: null },
			flipEnvMap: { value: - 1 },
			reflectivity: { value: 1.0 },
			refractionRatio: { value: 0.98 },
			maxMipLevel: { value: 0 }
	
		},
	
		aomap: {
	
			aoMap: { value: null },
			aoMapIntensity: { value: 1 }
	
		},
	
		lightmap: {
	
			lightMap: { value: null },
			lightMapIntensity: { value: 1 }
	
		},
	
		emissivemap: {
	
			emissiveMap: { value: null }
	
		},
	
		bumpmap: {
	
			bumpMap: { value: null },
			bumpScale: { value: 1 }
	
		},
	
		normalmap: {
	
			normalMap: { value: null },
			normalScale: { value: new Vector2( 1, 1 ) }
	
		},
	
		displacementmap: {
	
			displacementMap: { value: null },
			displacementScale: { value: 1 },
			displacementBias: { value: 0 }
	
		},
	
		roughnessmap: {
	
			roughnessMap: { value: null }
	
		},
	
		metalnessmap: {
	
			metalnessMap: { value: null }
	
		},
	
		gradientmap: {
	
			gradientMap: { value: null }
	
		},
	
		fog: {
	
			fogDensity: { value: 0.00025 },
			fogNear: { value: 1 },
			fogFar: { value: 2000 },
			fogColor: { value: new Color( 0xffffff ) }
	
		},
	
		lights: {
	
			ambientLightColor: { value: [] },
	
			directionalLights: { value: [], properties: {
				direction: {},
				color: {},
	
				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },
	
			directionalShadowMap: { value: [] },
			directionalShadowMatrix: { value: [] },
	
			spotLights: { value: [], properties: {
				color: {},
				position: {},
				direction: {},
				distance: {},
				coneCos: {},
				penumbraCos: {},
				decay: {},
	
				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {}
			} },
	
			spotShadowMap: { value: [] },
			spotShadowMatrix: { value: [] },
	
			pointLights: { value: [], properties: {
				color: {},
				position: {},
				decay: {},
				distance: {},
	
				shadow: {},
				shadowBias: {},
				shadowRadius: {},
				shadowMapSize: {},
				shadowCameraNear: {},
				shadowCameraFar: {}
			} },
	
			pointShadowMap: { value: [] },
			pointShadowMatrix: { value: [] },
	
			hemisphereLights: { value: [], properties: {
				direction: {},
				skyColor: {},
				groundColor: {}
			} },
	
			// TODO (abelnation): RectAreaLight BRDF data needs to be moved from example to main src
			rectAreaLights: { value: [], properties: {
				color: {},
				position: {},
				width: {},
				height: {}
			} }
	
		},
	
		points: {
	
			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			size: { value: 1.0 },
			scale: { value: 1.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }
	
		},
	
		sprite: {
	
			diffuse: { value: new Color( 0xeeeeee ) },
			opacity: { value: 1.0 },
			center: { value: new Vector2( 0.5, 0.5 ) },
			rotation: { value: 0.0 },
			map: { value: null },
			uvTransform: { value: new Matrix3() }
	
		}
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 */
	
	var ShaderLib = {
	
		basic: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.fog
			] ),
	
			vertexShader: ShaderChunk.meshbasic_vert,
			fragmentShader: ShaderChunk.meshbasic_frag
	
		},
	
		lambert: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) }
				}
			] ),
	
			vertexShader: ShaderChunk.meshlambert_vert,
			fragmentShader: ShaderChunk.meshlambert_frag
	
		},
	
		phong: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.specularmap,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.gradientmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					specular: { value: new Color( 0x111111 ) },
					shininess: { value: 30 }
				}
			] ),
	
			vertexShader: ShaderChunk.meshphong_vert,
			fragmentShader: ShaderChunk.meshphong_frag
	
		},
	
		standard: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.envmap,
				UniformsLib.aomap,
				UniformsLib.lightmap,
				UniformsLib.emissivemap,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.roughnessmap,
				UniformsLib.metalnessmap,
				UniformsLib.fog,
				UniformsLib.lights,
				{
					emissive: { value: new Color( 0x000000 ) },
					roughness: { value: 0.5 },
					metalness: { value: 0.5 },
					envMapIntensity: { value: 1 } // temporary
				}
			] ),
	
			vertexShader: ShaderChunk.meshphysical_vert,
			fragmentShader: ShaderChunk.meshphysical_frag
	
		},
	
		matcap: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				UniformsLib.fog,
				{
					matcap: { value: null }
				}
			] ),
	
			vertexShader: ShaderChunk.meshmatcap_vert,
			fragmentShader: ShaderChunk.meshmatcap_frag
	
		},
	
		points: {
	
			uniforms: mergeUniforms( [
				UniformsLib.points,
				UniformsLib.fog
			] ),
	
			vertexShader: ShaderChunk.points_vert,
			fragmentShader: ShaderChunk.points_frag
	
		},
	
		dashed: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.fog,
				{
					scale: { value: 1 },
					dashSize: { value: 1 },
					totalSize: { value: 2 }
				}
			] ),
	
			vertexShader: ShaderChunk.linedashed_vert,
			fragmentShader: ShaderChunk.linedashed_frag
	
		},
	
		depth: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap
			] ),
	
			vertexShader: ShaderChunk.depth_vert,
			fragmentShader: ShaderChunk.depth_frag
	
		},
	
		normal: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.bumpmap,
				UniformsLib.normalmap,
				UniformsLib.displacementmap,
				{
					opacity: { value: 1.0 }
				}
			] ),
	
			vertexShader: ShaderChunk.normal_vert,
			fragmentShader: ShaderChunk.normal_frag
	
		},
	
		sprite: {
	
			uniforms: mergeUniforms( [
				UniformsLib.sprite,
				UniformsLib.fog
			] ),
	
			vertexShader: ShaderChunk.sprite_vert,
			fragmentShader: ShaderChunk.sprite_frag
	
		},
	
		background: {
	
			uniforms: {
				uvTransform: { value: new Matrix3() },
				t2D: { value: null },
			},
	
			vertexShader: ShaderChunk.background_vert,
			fragmentShader: ShaderChunk.background_frag
	
		},
		/* -------------------------------------------------------------------------
		//	Cube map shader
		 ------------------------------------------------------------------------- */
	
		cube: {
	
			uniforms: {
				tCube: { value: null },
				tFlip: { value: - 1 },
				opacity: { value: 1.0 }
			},
	
			vertexShader: ShaderChunk.cube_vert,
			fragmentShader: ShaderChunk.cube_frag
	
		},
	
		equirect: {
	
			uniforms: {
				tEquirect: { value: null },
			},
	
			vertexShader: ShaderChunk.equirect_vert,
			fragmentShader: ShaderChunk.equirect_frag
	
		},
	
		distanceRGBA: {
	
			uniforms: mergeUniforms( [
				UniformsLib.common,
				UniformsLib.displacementmap,
				{
					referencePosition: { value: new Vector3() },
					nearDistance: { value: 1 },
					farDistance: { value: 1000 }
				}
			] ),
	
			vertexShader: ShaderChunk.distanceRGBA_vert,
			fragmentShader: ShaderChunk.distanceRGBA_frag
	
		},
	
		shadow: {
	
			uniforms: mergeUniforms( [
				UniformsLib.lights,
				UniformsLib.fog,
				{
					color: { value: new Color( 0x00000 ) },
					opacity: { value: 1.0 }
				},
			] ),
	
			vertexShader: ShaderChunk.shadow_vert,
			fragmentShader: ShaderChunk.shadow_frag
	
		}
	
	};
	
	ShaderLib.physical = {
	
		uniforms: mergeUniforms( [
			ShaderLib.standard.uniforms,
			{
				clearCoat: { value: 0 },
				clearCoatRoughness: { value: 0 }
			}
		] ),
	
		vertexShader: ShaderChunk.meshphysical_vert,
		fragmentShader: ShaderChunk.meshphysical_frag
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLAnimation() {
	
		var context = null;
		var isAnimating = false;
		var animationLoop = null;
	
		function onAnimationFrame( time, frame ) {
	
			if ( isAnimating === false ) return;
	
			animationLoop( time, frame );
	
			context.requestAnimationFrame( onAnimationFrame );
	
		}
	
		return {
	
			start: function () {
	
				if ( isAnimating === true ) return;
				if ( animationLoop === null ) return;
	
				context.requestAnimationFrame( onAnimationFrame );
	
				isAnimating = true;
	
			},
	
			stop: function () {
	
				isAnimating = false;
	
			},
	
			setAnimationLoop: function ( callback ) {
	
				animationLoop = callback;
	
			},
	
			setContext: function ( value ) {
	
				context = value;
	
			}
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLAttributes( gl ) {
	
		var buffers = new WeakMap();
	
		function createBuffer( attribute, bufferType ) {
	
			var array = attribute.array;
			var usage = attribute.dynamic ? 35048 : 35044;
	
			var buffer = gl.createBuffer();
	
			gl.bindBuffer( bufferType, buffer );
			gl.bufferData( bufferType, array, usage );
	
			attribute.onUploadCallback();
	
			var type = 5126;
	
			if ( array instanceof Float32Array ) {
	
				type = 5126;
	
			} else if ( array instanceof Float64Array ) {
	
				console.warn( 'THREE.WebGLAttributes: Unsupported data buffer format: Float64Array.' );
	
			} else if ( array instanceof Uint16Array ) {
	
				type = 5123;
	
			} else if ( array instanceof Int16Array ) {
	
				type = 5122;
	
			} else if ( array instanceof Uint32Array ) {
	
				type = 5125;
	
			} else if ( array instanceof Int32Array ) {
	
				type = 5124;
	
			} else if ( array instanceof Int8Array ) {
	
				type = 5120;
	
			} else if ( array instanceof Uint8Array ) {
	
				type = 5121;
	
			}
	
			return {
				buffer: buffer,
				type: type,
				bytesPerElement: array.BYTES_PER_ELEMENT,
				version: attribute.version
			};
	
		}
	
		function updateBuffer( buffer, attribute, bufferType ) {
	
			var array = attribute.array;
			var updateRange = attribute.updateRange;
	
			gl.bindBuffer( bufferType, buffer );
	
			if ( attribute.dynamic === false ) {
	
				gl.bufferData( bufferType, array, 35044 );
	
			} else if ( updateRange.count === - 1 ) {
	
				// Not using update ranges
	
				gl.bufferSubData( bufferType, 0, array );
	
			} else if ( updateRange.count === 0 ) {
	
				console.error( 'THREE.WebGLObjects.updateBuffer: dynamic THREE.BufferAttribute marked as needsUpdate but updateRange.count is 0, ensure you are using set methods or updating manually.' );
	
			} else {
	
				gl.bufferSubData( bufferType, updateRange.offset * array.BYTES_PER_ELEMENT,
					array.subarray( updateRange.offset, updateRange.offset + updateRange.count ) );
	
				updateRange.count = - 1; // reset range
	
			}
	
		}
	
		//
	
		function get( attribute ) {
	
			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
	
			return buffers.get( attribute );
	
		}
	
		function remove( attribute ) {
	
			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
	
			var data = buffers.get( attribute );
	
			if ( data ) {
	
				gl.deleteBuffer( data.buffer );
	
				buffers.delete( attribute );
	
			}
	
		}
	
		function update( attribute, bufferType ) {
	
			if ( attribute.isInterleavedBufferAttribute ) attribute = attribute.data;
	
			var data = buffers.get( attribute );
	
			if ( data === undefined ) {
	
				buffers.set( attribute, createBuffer( attribute, bufferType ) );
	
			} else if ( data.version < attribute.version ) {
	
				updateBuffer( data.buffer, attribute, bufferType );
	
				data.version = attribute.version;
	
			}
	
		}
	
		return {
	
			get: get,
			remove: remove,
			update: update
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function Face3( a, b, c, normal, color, materialIndex ) {
	
		this.a = a;
		this.b = b;
		this.c = c;
	
		this.normal = ( normal && normal.isVector3 ) ? normal : new Vector3();
		this.vertexNormals = Array.isArray( normal ) ? normal : [];
	
		this.color = ( color && color.isColor ) ? color : new Color();
		this.vertexColors = Array.isArray( color ) ? color : [];
	
		this.materialIndex = materialIndex !== undefined ? materialIndex : 0;
	
	}
	
	Object.assign( Face3.prototype, {
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.a = source.a;
			this.b = source.b;
			this.c = source.c;
	
			this.normal.copy( source.normal );
			this.color.copy( source.color );
	
			this.materialIndex = source.materialIndex;
	
			for ( var i = 0, il = source.vertexNormals.length; i < il; i ++ ) {
	
				this.vertexNormals[ i ] = source.vertexNormals[ i ].clone();
	
			}
	
			for ( var i = 0, il = source.vertexColors.length; i < il; i ++ ) {
	
				this.vertexColors[ i ] = source.vertexColors[ i ].clone();
	
			}
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author bhouston / http://clara.io
	 */
	
	function Euler( x, y, z, order ) {
	
		this._x = x || 0;
		this._y = y || 0;
		this._z = z || 0;
		this._order = order || Euler.DefaultOrder;
	
	}
	
	Euler.RotationOrders = [ 'XYZ', 'YZX', 'ZXY', 'XZY', 'YXZ', 'ZYX' ];
	
	Euler.DefaultOrder = 'XYZ';
	
	Object.defineProperties( Euler.prototype, {
	
		x: {
	
			get: function () {
	
				return this._x;
	
			},
	
			set: function ( value ) {
	
				this._x = value;
				this.onChangeCallback();
	
			}
	
		},
	
		y: {
	
			get: function () {
	
				return this._y;
	
			},
	
			set: function ( value ) {
	
				this._y = value;
				this.onChangeCallback();
	
			}
	
		},
	
		z: {
	
			get: function () {
	
				return this._z;
	
			},
	
			set: function ( value ) {
	
				this._z = value;
				this.onChangeCallback();
	
			}
	
		},
	
		order: {
	
			get: function () {
	
				return this._order;
	
			},
	
			set: function ( value ) {
	
				this._order = value;
				this.onChangeCallback();
	
			}
	
		}
	
	} );
	
	Object.assign( Euler.prototype, {
	
		isEuler: true,
	
		set: function ( x, y, z, order ) {
	
			this._x = x;
			this._y = y;
			this._z = z;
			this._order = order || this._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this._x, this._y, this._z, this._order );
	
		},
	
		copy: function ( euler ) {
	
			this._x = euler._x;
			this._y = euler._y;
			this._z = euler._z;
			this._order = euler._order;
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		setFromRotationMatrix: function ( m, order, update ) {
	
			var clamp = _Math.clamp;
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			var te = m.elements;
			var m11 = te[ 0 ], m12 = te[ 4 ], m13 = te[ 8 ];
			var m21 = te[ 1 ], m22 = te[ 5 ], m23 = te[ 9 ];
			var m31 = te[ 2 ], m32 = te[ 6 ], m33 = te[ 10 ];
	
			order = order || this._order;
	
			if ( order === 'XYZ' ) {
	
				this._y = Math.asin( clamp( m13, - 1, 1 ) );
	
				if ( Math.abs( m13 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m33 );
					this._z = Math.atan2( - m12, m11 );
	
				} else {
	
					this._x = Math.atan2( m32, m22 );
					this._z = 0;
	
				}
	
			} else if ( order === 'YXZ' ) {
	
				this._x = Math.asin( - clamp( m23, - 1, 1 ) );
	
				if ( Math.abs( m23 ) < 0.99999 ) {
	
					this._y = Math.atan2( m13, m33 );
					this._z = Math.atan2( m21, m22 );
	
				} else {
	
					this._y = Math.atan2( - m31, m11 );
					this._z = 0;
	
				}
	
			} else if ( order === 'ZXY' ) {
	
				this._x = Math.asin( clamp( m32, - 1, 1 ) );
	
				if ( Math.abs( m32 ) < 0.99999 ) {
	
					this._y = Math.atan2( - m31, m33 );
					this._z = Math.atan2( - m12, m22 );
	
				} else {
	
					this._y = 0;
					this._z = Math.atan2( m21, m11 );
	
				}
	
			} else if ( order === 'ZYX' ) {
	
				this._y = Math.asin( - clamp( m31, - 1, 1 ) );
	
				if ( Math.abs( m31 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m33 );
					this._z = Math.atan2( m21, m11 );
	
				} else {
	
					this._x = 0;
					this._z = Math.atan2( - m12, m22 );
	
				}
	
			} else if ( order === 'YZX' ) {
	
				this._z = Math.asin( clamp( m21, - 1, 1 ) );
	
				if ( Math.abs( m21 ) < 0.99999 ) {
	
					this._x = Math.atan2( - m23, m22 );
					this._y = Math.atan2( - m31, m11 );
	
				} else {
	
					this._x = 0;
					this._y = Math.atan2( m13, m33 );
	
				}
	
			} else if ( order === 'XZY' ) {
	
				this._z = Math.asin( - clamp( m12, - 1, 1 ) );
	
				if ( Math.abs( m12 ) < 0.99999 ) {
	
					this._x = Math.atan2( m32, m22 );
					this._y = Math.atan2( m13, m11 );
	
				} else {
	
					this._x = Math.atan2( - m23, m33 );
					this._y = 0;
	
				}
	
			} else {
	
				console.warn( 'THREE.Euler: .setFromRotationMatrix() given unsupported order: ' + order );
	
			}
	
			this._order = order;
	
			if ( update !== false ) this.onChangeCallback();
	
			return this;
	
		},
	
		setFromQuaternion: function () {
	
			var matrix = new Matrix4();
	
			return function setFromQuaternion( q, order, update ) {
	
				matrix.makeRotationFromQuaternion( q );
	
				return this.setFromRotationMatrix( matrix, order, update );
	
			};
	
		}(),
	
		setFromVector3: function ( v, order ) {
	
			return this.set( v.x, v.y, v.z, order || this._order );
	
		},
	
		reorder: function () {
	
			// WARNING: this discards revolution information -bhouston
	
			var q = new Quaternion();
	
			return function reorder( newOrder ) {
	
				q.setFromEuler( this );
	
				return this.setFromQuaternion( q, newOrder );
	
			};
	
		}(),
	
		equals: function ( euler ) {
	
			return ( euler._x === this._x ) && ( euler._y === this._y ) && ( euler._z === this._z ) && ( euler._order === this._order );
	
		},
	
		fromArray: function ( array ) {
	
			this._x = array[ 0 ];
			this._y = array[ 1 ];
			this._z = array[ 2 ];
			if ( array[ 3 ] !== undefined ) this._order = array[ 3 ];
	
			this.onChangeCallback();
	
			return this;
	
		},
	
		toArray: function ( array, offset ) {
	
			if ( array === undefined ) array = [];
			if ( offset === undefined ) offset = 0;
	
			array[ offset ] = this._x;
			array[ offset + 1 ] = this._y;
			array[ offset + 2 ] = this._z;
			array[ offset + 3 ] = this._order;
	
			return array;
	
		},
	
		toVector3: function ( optionalResult ) {
	
			if ( optionalResult ) {
	
				return optionalResult.set( this._x, this._y, this._z );
	
			} else {
	
				return new Vector3( this._x, this._y, this._z );
	
			}
	
		},
	
		onChange: function ( callback ) {
	
			this.onChangeCallback = callback;
	
			return this;
	
		},
	
		onChangeCallback: function () {}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Layers() {
	
		this.mask = 1 | 0;
	
	}
	
	Object.assign( Layers.prototype, {
	
		set: function ( channel ) {
	
			this.mask = 1 << channel | 0;
	
		},
	
		enable: function ( channel ) {
	
			this.mask |= 1 << channel | 0;
	
		},
	
		toggle: function ( channel ) {
	
			this.mask ^= 1 << channel | 0;
	
		},
	
		disable: function ( channel ) {
	
			this.mask &= ~ ( 1 << channel | 0 );
	
		},
	
		test: function ( layers ) {
	
			return ( this.mask & layers.mask ) !== 0;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author WestLangley / http://github.com/WestLangley
	 * @author elephantatwork / www.elephantatwork.ch
	 */
	
	var object3DId = 0;
	
	function Object3D() {
	
		Object.defineProperty( this, 'id', { value: object3DId ++ } );
	
		this.uuid = _Math.generateUUID();
	
		this.name = '';
		this.type = 'Object3D';
	
		this.parent = null;
		this.children = [];
	
		this.up = Object3D.DefaultUp.clone();
	
		var position = new Vector3();
		var rotation = new Euler();
		var quaternion = new Quaternion();
		var scale = new Vector3( 1, 1, 1 );
	
		function onRotationChange() {
	
			quaternion.setFromEuler( rotation, false );
	
		}
	
		function onQuaternionChange() {
	
			rotation.setFromQuaternion( quaternion, undefined, false );
	
		}
	
		rotation.onChange( onRotationChange );
		quaternion.onChange( onQuaternionChange );
	
		Object.defineProperties( this, {
			position: {
				configurable: true,
				enumerable: true,
				value: position
			},
			rotation: {
				configurable: true,
				enumerable: true,
				value: rotation
			},
			quaternion: {
				configurable: true,
				enumerable: true,
				value: quaternion
			},
			scale: {
				configurable: true,
				enumerable: true,
				value: scale
			},
			modelViewMatrix: {
				value: new Matrix4()
			},
			normalMatrix: {
				value: new Matrix3()
			}
		} );
	
		this.matrix = new Matrix4();
		this.matrixWorld = new Matrix4();
	
		this.matrixAutoUpdate = Object3D.DefaultMatrixAutoUpdate;
		this.matrixWorldNeedsUpdate = false;
	
		this.layers = new Layers();
		this.visible = true;
	
		this.castShadow = false;
		this.receiveShadow = false;
	
		this.frustumCulled = true;
		this.renderOrder = 0;
	
		this.userData = {};
	
	}
	
	Object3D.DefaultUp = new Vector3( 0, 1, 0 );
	Object3D.DefaultMatrixAutoUpdate = true;
	
	Object3D.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: Object3D,
	
		isObject3D: true,
	
		onBeforeRender: function () {},
		onAfterRender: function () {},
	
		applyMatrix: function ( matrix ) {
	
			this.matrix.multiplyMatrices( matrix, this.matrix );
	
			this.matrix.decompose( this.position, this.quaternion, this.scale );
	
		},
	
		applyQuaternion: function ( q ) {
	
			this.quaternion.premultiply( q );
	
			return this;
	
		},
	
		setRotationFromAxisAngle: function ( axis, angle ) {
	
			// assumes axis is normalized
	
			this.quaternion.setFromAxisAngle( axis, angle );
	
		},
	
		setRotationFromEuler: function ( euler ) {
	
			this.quaternion.setFromEuler( euler, true );
	
		},
	
		setRotationFromMatrix: function ( m ) {
	
			// assumes the upper 3x3 of m is a pure rotation matrix (i.e, unscaled)
	
			this.quaternion.setFromRotationMatrix( m );
	
		},
	
		setRotationFromQuaternion: function ( q ) {
	
			// assumes q is normalized
	
			this.quaternion.copy( q );
	
		},
	
		rotateOnAxis: function () {
	
			// rotate object on axis in object space
			// axis is assumed to be normalized
	
			var q1 = new Quaternion();
	
			return function rotateOnAxis( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.multiply( q1 );
	
				return this;
	
			};
	
		}(),
	
		rotateOnWorldAxis: function () {
	
			// rotate object on axis in world space
			// axis is assumed to be normalized
			// method assumes no rotated parent
	
			var q1 = new Quaternion();
	
			return function rotateOnWorldAxis( axis, angle ) {
	
				q1.setFromAxisAngle( axis, angle );
	
				this.quaternion.premultiply( q1 );
	
				return this;
	
			};
	
		}(),
	
		rotateX: function () {
	
			var v1 = new Vector3( 1, 0, 0 );
	
			return function rotateX( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateY: function () {
	
			var v1 = new Vector3( 0, 1, 0 );
	
			return function rotateY( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		rotateZ: function () {
	
			var v1 = new Vector3( 0, 0, 1 );
	
			return function rotateZ( angle ) {
	
				return this.rotateOnAxis( v1, angle );
	
			};
	
		}(),
	
		translateOnAxis: function () {
	
			// translate object by distance along axis in object space
			// axis is assumed to be normalized
	
			var v1 = new Vector3();
	
			return function translateOnAxis( axis, distance ) {
	
				v1.copy( axis ).applyQuaternion( this.quaternion );
	
				this.position.add( v1.multiplyScalar( distance ) );
	
				return this;
	
			};
	
		}(),
	
		translateX: function () {
	
			var v1 = new Vector3( 1, 0, 0 );
	
			return function translateX( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateY: function () {
	
			var v1 = new Vector3( 0, 1, 0 );
	
			return function translateY( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		translateZ: function () {
	
			var v1 = new Vector3( 0, 0, 1 );
	
			return function translateZ( distance ) {
	
				return this.translateOnAxis( v1, distance );
	
			};
	
		}(),
	
		localToWorld: function ( vector ) {
	
			return vector.applyMatrix4( this.matrixWorld );
	
		},
	
		worldToLocal: function () {
	
			var m1 = new Matrix4();
	
			return function worldToLocal( vector ) {
	
				return vector.applyMatrix4( m1.getInverse( this.matrixWorld ) );
	
			};
	
		}(),
	
		lookAt: function () {
	
			// This method does not support objects having non-uniformly-scaled parent(s)
	
			var q1 = new Quaternion();
			var m1 = new Matrix4();
			var target = new Vector3();
			var position = new Vector3();
	
			return function lookAt( x, y, z ) {
	
				if ( x.isVector3 ) {
	
					target.copy( x );
	
				} else {
	
					target.set( x, y, z );
	
				}
	
				var parent = this.parent;
	
				this.updateWorldMatrix( true, false );
	
				position.setFromMatrixPosition( this.matrixWorld );
	
				if ( this.isCamera || this.isLight ) {
	
					m1.lookAt( position, target, this.up );
	
				} else {
	
					m1.lookAt( target, position, this.up );
	
				}
	
				this.quaternion.setFromRotationMatrix( m1 );
	
				if ( parent ) {
	
					m1.extractRotation( parent.matrixWorld );
					q1.setFromRotationMatrix( m1 );
					this.quaternion.premultiply( q1.inverse() );
	
				}
	
			};
	
		}(),
	
		add: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.add( arguments[ i ] );
	
				}
	
				return this;
	
			}
	
			if ( object === this ) {
	
				console.error( "THREE.Object3D.add: object can't be added as a child of itself.", object );
				return this;
	
			}
	
			if ( ( object && object.isObject3D ) ) {
	
				if ( object.parent !== null ) {
	
					object.parent.remove( object );
	
				}
	
				object.parent = this;
				object.dispatchEvent( { type: 'added' } );
	
				this.children.push( object );
	
			} else {
	
				console.error( "THREE.Object3D.add: object not an instance of THREE.Object3D.", object );
	
			}
	
			return this;
	
		},
	
		remove: function ( object ) {
	
			if ( arguments.length > 1 ) {
	
				for ( var i = 0; i < arguments.length; i ++ ) {
	
					this.remove( arguments[ i ] );
	
				}
	
				return this;
	
			}
	
			var index = this.children.indexOf( object );
	
			if ( index !== - 1 ) {
	
				object.parent = null;
	
				object.dispatchEvent( { type: 'removed' } );
	
				this.children.splice( index, 1 );
	
			}
	
			return this;
	
		},
	
		getObjectById: function ( id ) {
	
			return this.getObjectByProperty( 'id', id );
	
		},
	
		getObjectByName: function ( name ) {
	
			return this.getObjectByProperty( 'name', name );
	
		},
	
		getObjectByProperty: function ( name, value ) {
	
			if ( this[ name ] === value ) return this;
	
			for ( var i = 0, l = this.children.length; i < l; i ++ ) {
	
				var child = this.children[ i ];
				var object = child.getObjectByProperty( name, value );
	
				if ( object !== undefined ) {
	
					return object;
	
				}
	
			}
	
			return undefined;
	
		},
	
		getWorldPosition: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Object3D: .getWorldPosition() target is now required' );
				target = new Vector3();
	
			}
	
			this.updateMatrixWorld( true );
	
			return target.setFromMatrixPosition( this.matrixWorld );
	
		},
	
		getWorldQuaternion: function () {
	
			var position = new Vector3();
			var scale = new Vector3();
	
			return function getWorldQuaternion( target ) {
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Object3D: .getWorldQuaternion() target is now required' );
					target = new Quaternion();
	
				}
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, target, scale );
	
				return target;
	
			};
	
		}(),
	
		getWorldScale: function () {
	
			var position = new Vector3();
			var quaternion = new Quaternion();
	
			return function getWorldScale( target ) {
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Object3D: .getWorldScale() target is now required' );
					target = new Vector3();
	
				}
	
				this.updateMatrixWorld( true );
	
				this.matrixWorld.decompose( position, quaternion, target );
	
				return target;
	
			};
	
		}(),
	
		getWorldDirection: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Object3D: .getWorldDirection() target is now required' );
				target = new Vector3();
	
			}
	
			this.updateMatrixWorld( true );
	
			var e = this.matrixWorld.elements;
	
			return target.set( e[ 8 ], e[ 9 ], e[ 10 ] ).normalize();
	
		},
	
		raycast: function () {},
	
		traverse: function ( callback ) {
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverse( callback );
	
			}
	
		},
	
		traverseVisible: function ( callback ) {
	
			if ( this.visible === false ) return;
	
			callback( this );
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].traverseVisible( callback );
	
			}
	
		},
	
		traverseAncestors: function ( callback ) {
	
			var parent = this.parent;
	
			if ( parent !== null ) {
	
				callback( parent );
	
				parent.traverseAncestors( callback );
	
			}
	
		},
	
		updateMatrix: function () {
	
			this.matrix.compose( this.position, this.quaternion, this.scale );
	
			this.matrixWorldNeedsUpdate = true;
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			if ( this.matrixAutoUpdate ) this.updateMatrix();
	
			if ( this.matrixWorldNeedsUpdate || force ) {
	
				if ( this.parent === null ) {
	
					this.matrixWorld.copy( this.matrix );
	
				} else {
	
					this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
				}
	
				this.matrixWorldNeedsUpdate = false;
	
				force = true;
	
			}
	
			// update children
	
			var children = this.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				children[ i ].updateMatrixWorld( force );
	
			}
	
		},
	
		updateWorldMatrix: function ( updateParents, updateChildren ) {
	
			var parent = this.parent;
	
			if ( updateParents === true && parent !== null ) {
	
				parent.updateWorldMatrix( true, false );
	
			}
	
			if ( this.matrixAutoUpdate ) this.updateMatrix();
	
			if ( this.parent === null ) {
	
				this.matrixWorld.copy( this.matrix );
	
			} else {
	
				this.matrixWorld.multiplyMatrices( this.parent.matrixWorld, this.matrix );
	
			}
	
			// update children
	
			if ( updateChildren === true ) {
	
				var children = this.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].updateWorldMatrix( false, true );
	
				}
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			// meta is a string when called from JSON.stringify
			var isRootObject = ( meta === undefined || typeof meta === 'string' );
	
			var output = {};
	
			// meta is a hash used to collect geometries, materials.
			// not providing it implies that this is the root object
			// being serialized.
			if ( isRootObject ) {
	
				// initialize meta obj
				meta = {
					geometries: {},
					materials: {},
					textures: {},
					images: {},
					shapes: {}
				};
	
				output.metadata = {
					version: 4.5,
					type: 'Object',
					generator: 'Object3D.toJSON'
				};
	
			}
	
			// standard Object3D serialization
	
			var object = {};
	
			object.uuid = this.uuid;
			object.type = this.type;
	
			if ( this.name !== '' ) object.name = this.name;
			if ( this.castShadow === true ) object.castShadow = true;
			if ( this.receiveShadow === true ) object.receiveShadow = true;
			if ( this.visible === false ) object.visible = false;
			if ( this.frustumCulled === false ) object.frustumCulled = false;
			if ( this.renderOrder !== 0 ) object.renderOrder = this.renderOrder;
			if ( JSON.stringify( this.userData ) !== '{}' ) object.userData = this.userData;
	
			object.layers = this.layers.mask;
			object.matrix = this.matrix.toArray();
	
			if ( this.matrixAutoUpdate === false ) object.matrixAutoUpdate = false;
	
			// object specific properties
	
			if ( this.isMesh && this.drawMode !== TrianglesDrawMode ) object.drawMode = this.drawMode;
	
			//
	
			function serialize( library, element ) {
	
				if ( library[ element.uuid ] === undefined ) {
	
					library[ element.uuid ] = element.toJSON( meta );
	
				}
	
				return element.uuid;
	
			}
	
			if ( this.isMesh || this.isLine || this.isPoints ) {
	
				object.geometry = serialize( meta.geometries, this.geometry );
	
				var parameters = this.geometry.parameters;
	
				if ( parameters !== undefined && parameters.shapes !== undefined ) {
	
					var shapes = parameters.shapes;
	
					if ( Array.isArray( shapes ) ) {
	
						for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
							var shape = shapes[ i ];
	
							serialize( meta.shapes, shape );
	
						}
	
					} else {
	
						serialize( meta.shapes, shapes );
	
					}
	
				}
	
			}
	
			if ( this.material !== undefined ) {
	
				if ( Array.isArray( this.material ) ) {
	
					var uuids = [];
	
					for ( var i = 0, l = this.material.length; i < l; i ++ ) {
	
						uuids.push( serialize( meta.materials, this.material[ i ] ) );
	
					}
	
					object.material = uuids;
	
				} else {
	
					object.material = serialize( meta.materials, this.material );
	
				}
	
			}
	
			//
	
			if ( this.children.length > 0 ) {
	
				object.children = [];
	
				for ( var i = 0; i < this.children.length; i ++ ) {
	
					object.children.push( this.children[ i ].toJSON( meta ).object );
	
				}
	
			}
	
			if ( isRootObject ) {
	
				var geometries = extractFromCache( meta.geometries );
				var materials = extractFromCache( meta.materials );
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
				var shapes = extractFromCache( meta.shapes );
	
				if ( geometries.length > 0 ) output.geometries = geometries;
				if ( materials.length > 0 ) output.materials = materials;
				if ( textures.length > 0 ) output.textures = textures;
				if ( images.length > 0 ) output.images = images;
				if ( shapes.length > 0 ) output.shapes = shapes;
	
			}
	
			output.object = object;
	
			return output;
	
			// extract data from the cache hash
			// remove metadata on each item
			// and return as array
			function extractFromCache( cache ) {
	
				var values = [];
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
				return values;
	
			}
	
		},
	
		clone: function ( recursive ) {
	
			return new this.constructor().copy( this, recursive );
	
		},
	
		copy: function ( source, recursive ) {
	
			if ( recursive === undefined ) recursive = true;
	
			this.name = source.name;
	
			this.up.copy( source.up );
	
			this.position.copy( source.position );
			this.quaternion.copy( source.quaternion );
			this.scale.copy( source.scale );
	
			this.matrix.copy( source.matrix );
			this.matrixWorld.copy( source.matrixWorld );
	
			this.matrixAutoUpdate = source.matrixAutoUpdate;
			this.matrixWorldNeedsUpdate = source.matrixWorldNeedsUpdate;
	
			this.layers.mask = source.layers.mask;
			this.visible = source.visible;
	
			this.castShadow = source.castShadow;
			this.receiveShadow = source.receiveShadow;
	
			this.frustumCulled = source.frustumCulled;
			this.renderOrder = source.renderOrder;
	
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
			if ( recursive === true ) {
	
				for ( var i = 0; i < source.children.length; i ++ ) {
	
					var child = source.children[ i ];
					this.add( child.clone() );
	
				}
	
			}
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author kile / http://kile.stravaganza.org/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author bhouston / http://clara.io
	 */
	
	var geometryId = 0; // Geometry uses even numbers as Id
	
	function Geometry() {
	
		Object.defineProperty( this, 'id', { value: geometryId += 2 } );
	
		this.uuid = _Math.generateUUID();
	
		this.name = '';
		this.type = 'Geometry';
	
		this.vertices = [];
		this.colors = [];
		this.faces = [];
		this.faceVertexUvs = [[]];
	
		this.morphTargets = [];
		this.morphNormals = [];
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.elementsNeedUpdate = false;
		this.verticesNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.lineDistancesNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	}
	
	Geometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: Geometry,
	
		isGeometry: true,
	
		applyMatrix: function ( matrix ) {
	
			var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
			for ( var i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertex.applyMatrix4( matrix );
	
			}
	
			for ( var i = 0, il = this.faces.length; i < il; i ++ ) {
	
				var face = this.faces[ i ];
				face.normal.applyMatrix3( normalMatrix ).normalize();
	
				for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
					face.vertexNormals[ j ].applyMatrix3( normalMatrix ).normalize();
	
				}
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			this.verticesNeedUpdate = true;
			this.normalsNeedUpdate = true;
	
			return this;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1 = new Matrix4();
	
			return function rotateX( angle ) {
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1 = new Matrix4();
	
			return function rotateY( angle ) {
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1 = new Matrix4();
	
			return function rotateZ( angle ) {
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1 = new Matrix4();
	
			return function translate( x, y, z ) {
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1 = new Matrix4();
	
			return function scale( x, y, z ) {
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj = new Object3D();
	
			return function lookAt( vector ) {
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		fromBufferGeometry: function ( geometry ) {
	
			var scope = this;
	
			var indices = geometry.index !== null ? geometry.index.array : undefined;
			var attributes = geometry.attributes;
	
			var positions = attributes.position.array;
			var normals = attributes.normal !== undefined ? attributes.normal.array : undefined;
			var colors = attributes.color !== undefined ? attributes.color.array : undefined;
			var uvs = attributes.uv !== undefined ? attributes.uv.array : undefined;
			var uvs2 = attributes.uv2 !== undefined ? attributes.uv2.array : undefined;
	
			if ( uvs2 !== undefined ) this.faceVertexUvs[ 1 ] = [];
	
			for ( var i = 0, j = 0; i < positions.length; i += 3, j += 2 ) {
	
				scope.vertices.push( new Vector3().fromArray( positions, i ) );
	
				if ( colors !== undefined ) {
	
					scope.colors.push( new Color().fromArray( colors, i ) );
	
				}
	
			}
	
			function addFace( a, b, c, materialIndex ) {
	
				var vertexColors = ( colors === undefined ) ? [] : [
					scope.colors[ a ].clone(),
					scope.colors[ b ].clone(),
					scope.colors[ c ].clone() ];
	
				var vertexNormals = ( normals === undefined ) ? [] : [
					new Vector3().fromArray( normals, a * 3 ),
					new Vector3().fromArray( normals, b * 3 ),
					new Vector3().fromArray( normals, c * 3 )
				];
	
				var face = new Face3( a, b, c, vertexNormals, vertexColors, materialIndex );
	
				scope.faces.push( face );
	
				if ( uvs !== undefined ) {
	
					scope.faceVertexUvs[ 0 ].push( [
						new Vector2().fromArray( uvs, a * 2 ),
						new Vector2().fromArray( uvs, b * 2 ),
						new Vector2().fromArray( uvs, c * 2 )
					] );
	
				}
	
				if ( uvs2 !== undefined ) {
	
					scope.faceVertexUvs[ 1 ].push( [
						new Vector2().fromArray( uvs2, a * 2 ),
						new Vector2().fromArray( uvs2, b * 2 ),
						new Vector2().fromArray( uvs2, c * 2 )
					] );
	
				}
	
			}
	
			var groups = geometry.groups;
	
			if ( groups.length > 0 ) {
	
				for ( var i = 0; i < groups.length; i ++ ) {
	
					var group = groups[ i ];
	
					var start = group.start;
					var count = group.count;
	
					for ( var j = start, jl = start + count; j < jl; j += 3 ) {
	
						if ( indices !== undefined ) {
	
							addFace( indices[ j ], indices[ j + 1 ], indices[ j + 2 ], group.materialIndex );
	
						} else {
	
							addFace( j, j + 1, j + 2, group.materialIndex );
	
						}
	
					}
	
				}
	
			} else {
	
				if ( indices !== undefined ) {
	
					for ( var i = 0; i < indices.length; i += 3 ) {
	
						addFace( indices[ i ], indices[ i + 1 ], indices[ i + 2 ] );
	
					}
	
				} else {
	
					for ( var i = 0; i < positions.length / 3; i += 3 ) {
	
						addFace( i, i + 1, i + 2 );
	
					}
	
				}
	
			}
	
			this.computeFaceNormals();
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			return this;
	
		},
	
		center: function () {
	
			var offset = new Vector3();
	
			return function center() {
	
				this.computeBoundingBox();
	
				this.boundingBox.getCenter( offset ).negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return this;
	
			};
	
		}(),
	
		normalize: function () {
	
			this.computeBoundingSphere();
	
			var center = this.boundingSphere.center;
			var radius = this.boundingSphere.radius;
	
			var s = radius === 0 ? 1 : 1.0 / radius;
	
			var matrix = new Matrix4();
			matrix.set(
				s, 0, 0, - s * center.x,
				0, s, 0, - s * center.y,
				0, 0, s, - s * center.z,
				0, 0, 0, 1
			);
	
			this.applyMatrix( matrix );
	
			return this;
	
		},
	
		computeFaceNormals: function () {
	
			var cb = new Vector3(), ab = new Vector3();
	
			for ( var f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				var face = this.faces[ f ];
	
				var vA = this.vertices[ face.a ];
				var vB = this.vertices[ face.b ];
				var vC = this.vertices[ face.c ];
	
				cb.subVectors( vC, vB );
				ab.subVectors( vA, vB );
				cb.cross( ab );
	
				cb.normalize();
	
				face.normal.copy( cb );
	
			}
	
		},
	
		computeVertexNormals: function ( areaWeighted ) {
	
			if ( areaWeighted === undefined ) areaWeighted = true;
	
			var v, vl, f, fl, face, vertices;
	
			vertices = new Array( this.vertices.length );
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ] = new Vector3();
	
			}
	
			if ( areaWeighted ) {
	
				// vertex normals weighted by triangle areas
				// http://www.iquilezles.org/www/articles/normals/normals.htm
	
				var vA, vB, vC;
				var cb = new Vector3(), ab = new Vector3();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vA = this.vertices[ face.a ];
					vB = this.vertices[ face.b ];
					vC = this.vertices[ face.c ];
	
					cb.subVectors( vC, vB );
					ab.subVectors( vA, vB );
					cb.cross( ab );
	
					vertices[ face.a ].add( cb );
					vertices[ face.b ].add( cb );
					vertices[ face.c ].add( cb );
	
				}
	
			} else {
	
				this.computeFaceNormals();
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					vertices[ face.a ].add( face.normal );
					vertices[ face.b ].add( face.normal );
					vertices[ face.c ].add( face.normal );
	
				}
	
			}
	
			for ( v = 0, vl = this.vertices.length; v < vl; v ++ ) {
	
				vertices[ v ].normalize();
	
			}
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					vertexNormals[ 0 ].copy( vertices[ face.a ] );
					vertexNormals[ 1 ].copy( vertices[ face.b ] );
					vertexNormals[ 2 ].copy( vertices[ face.c ] );
	
				} else {
	
					vertexNormals[ 0 ] = vertices[ face.a ].clone();
					vertexNormals[ 1 ] = vertices[ face.b ].clone();
					vertexNormals[ 2 ] = vertices[ face.c ].clone();
	
				}
	
			}
	
			if ( this.faces.length > 0 ) {
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeFlatVertexNormals: function () {
	
			var f, fl, face;
	
			this.computeFaceNormals();
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					vertexNormals[ 0 ].copy( face.normal );
					vertexNormals[ 1 ].copy( face.normal );
					vertexNormals[ 2 ].copy( face.normal );
	
				} else {
	
					vertexNormals[ 0 ] = face.normal.clone();
					vertexNormals[ 1 ] = face.normal.clone();
					vertexNormals[ 2 ] = face.normal.clone();
	
				}
	
			}
	
			if ( this.faces.length > 0 ) {
	
				this.normalsNeedUpdate = true;
	
			}
	
		},
	
		computeMorphNormals: function () {
	
			var i, il, f, fl, face;
	
			// save original normals
			// - create temp variables on first access
			//   otherwise just copy (for faster repeated calls)
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				if ( ! face.__originalFaceNormal ) {
	
					face.__originalFaceNormal = face.normal.clone();
	
				} else {
	
					face.__originalFaceNormal.copy( face.normal );
	
				}
	
				if ( ! face.__originalVertexNormals ) face.__originalVertexNormals = [];
	
				for ( i = 0, il = face.vertexNormals.length; i < il; i ++ ) {
	
					if ( ! face.__originalVertexNormals[ i ] ) {
	
						face.__originalVertexNormals[ i ] = face.vertexNormals[ i ].clone();
	
					} else {
	
						face.__originalVertexNormals[ i ].copy( face.vertexNormals[ i ] );
	
					}
	
				}
	
			}
	
			// use temp geometry to compute face and vertex normals for each morph
	
			var tmpGeo = new Geometry();
			tmpGeo.faces = this.faces;
	
			for ( i = 0, il = this.morphTargets.length; i < il; i ++ ) {
	
				// create on first access
	
				if ( ! this.morphNormals[ i ] ) {
	
					this.morphNormals[ i ] = {};
					this.morphNormals[ i ].faceNormals = [];
					this.morphNormals[ i ].vertexNormals = [];
	
					var dstNormalsFace = this.morphNormals[ i ].faceNormals;
					var dstNormalsVertex = this.morphNormals[ i ].vertexNormals;
	
					var faceNormal, vertexNormals;
	
					for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
						faceNormal = new Vector3();
						vertexNormals = { a: new Vector3(), b: new Vector3(), c: new Vector3() };
	
						dstNormalsFace.push( faceNormal );
						dstNormalsVertex.push( vertexNormals );
	
					}
	
				}
	
				var morphNormals = this.morphNormals[ i ];
	
				// set vertices to morph target
	
				tmpGeo.vertices = this.morphTargets[ i ].vertices;
	
				// compute morph normals
	
				tmpGeo.computeFaceNormals();
				tmpGeo.computeVertexNormals();
	
				// store morph normals
	
				var faceNormal, vertexNormals;
	
				for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
					face = this.faces[ f ];
	
					faceNormal = morphNormals.faceNormals[ f ];
					vertexNormals = morphNormals.vertexNormals[ f ];
	
					faceNormal.copy( face.normal );
	
					vertexNormals.a.copy( face.vertexNormals[ 0 ] );
					vertexNormals.b.copy( face.vertexNormals[ 1 ] );
					vertexNormals.c.copy( face.vertexNormals[ 2 ] );
	
				}
	
			}
	
			// restore original normals
	
			for ( f = 0, fl = this.faces.length; f < fl; f ++ ) {
	
				face = this.faces[ f ];
	
				face.normal = face.__originalFaceNormal;
				face.vertexNormals = face.__originalVertexNormals;
	
			}
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new Box3();
	
			}
	
			this.boundingBox.setFromPoints( this.vertices );
	
		},
	
		computeBoundingSphere: function () {
	
			if ( this.boundingSphere === null ) {
	
				this.boundingSphere = new Sphere();
	
			}
	
			this.boundingSphere.setFromPoints( this.vertices );
	
		},
	
		merge: function ( geometry, matrix, materialIndexOffset ) {
	
			if ( ! ( geometry && geometry.isGeometry ) ) {
	
				console.error( 'THREE.Geometry.merge(): geometry not an instance of THREE.Geometry.', geometry );
				return;
	
			}
	
			var normalMatrix,
				vertexOffset = this.vertices.length,
				vertices1 = this.vertices,
				vertices2 = geometry.vertices,
				faces1 = this.faces,
				faces2 = geometry.faces,
				uvs1 = this.faceVertexUvs[ 0 ],
				uvs2 = geometry.faceVertexUvs[ 0 ],
				colors1 = this.colors,
				colors2 = geometry.colors;
	
			if ( materialIndexOffset === undefined ) materialIndexOffset = 0;
	
			if ( matrix !== undefined ) {
	
				normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
			}
	
			// vertices
	
			for ( var i = 0, il = vertices2.length; i < il; i ++ ) {
	
				var vertex = vertices2[ i ];
	
				var vertexCopy = vertex.clone();
	
				if ( matrix !== undefined ) vertexCopy.applyMatrix4( matrix );
	
				vertices1.push( vertexCopy );
	
			}
	
			// colors
	
			for ( var i = 0, il = colors2.length; i < il; i ++ ) {
	
				colors1.push( colors2[ i ].clone() );
	
			}
	
			// faces
	
			for ( i = 0, il = faces2.length; i < il; i ++ ) {
	
				var face = faces2[ i ], faceCopy, normal, color,
					faceVertexNormals = face.vertexNormals,
					faceVertexColors = face.vertexColors;
	
				faceCopy = new Face3( face.a + vertexOffset, face.b + vertexOffset, face.c + vertexOffset );
				faceCopy.normal.copy( face.normal );
	
				if ( normalMatrix !== undefined ) {
	
					faceCopy.normal.applyMatrix3( normalMatrix ).normalize();
	
				}
	
				for ( var j = 0, jl = faceVertexNormals.length; j < jl; j ++ ) {
	
					normal = faceVertexNormals[ j ].clone();
	
					if ( normalMatrix !== undefined ) {
	
						normal.applyMatrix3( normalMatrix ).normalize();
	
					}
	
					faceCopy.vertexNormals.push( normal );
	
				}
	
				faceCopy.color.copy( face.color );
	
				for ( var j = 0, jl = faceVertexColors.length; j < jl; j ++ ) {
	
					color = faceVertexColors[ j ];
					faceCopy.vertexColors.push( color.clone() );
	
				}
	
				faceCopy.materialIndex = face.materialIndex + materialIndexOffset;
	
				faces1.push( faceCopy );
	
			}
	
			// uvs
	
			for ( i = 0, il = uvs2.length; i < il; i ++ ) {
	
				var uv = uvs2[ i ], uvCopy = [];
	
				if ( uv === undefined ) {
	
					continue;
	
				}
	
				for ( var j = 0, jl = uv.length; j < jl; j ++ ) {
	
					uvCopy.push( uv[ j ].clone() );
	
				}
	
				uvs1.push( uvCopy );
	
			}
	
		},
	
		mergeMesh: function ( mesh ) {
	
			if ( ! ( mesh && mesh.isMesh ) ) {
	
				console.error( 'THREE.Geometry.mergeMesh(): mesh not an instance of THREE.Mesh.', mesh );
				return;
	
			}
	
			if ( mesh.matrixAutoUpdate ) mesh.updateMatrix();
	
			this.merge( mesh.geometry, mesh.matrix );
	
		},
	
		/*
		 * Checks for duplicate vertices with hashmap.
		 * Duplicated vertices are removed
		 * and faces' vertices are updated.
		 */
	
		mergeVertices: function () {
	
			var verticesMap = {}; // Hashmap for looking up vertices by position coordinates (and making sure they are unique)
			var unique = [], changes = [];
	
			var v, key;
			var precisionPoints = 4; // number of decimal points, e.g. 4 for epsilon of 0.0001
			var precision = Math.pow( 10, precisionPoints );
			var i, il, face;
			var indices, j, jl;
	
			for ( i = 0, il = this.vertices.length; i < il; i ++ ) {
	
				v = this.vertices[ i ];
				key = Math.round( v.x * precision ) + '_' + Math.round( v.y * precision ) + '_' + Math.round( v.z * precision );
	
				if ( verticesMap[ key ] === undefined ) {
	
					verticesMap[ key ] = i;
					unique.push( this.vertices[ i ] );
					changes[ i ] = unique.length - 1;
	
				} else {
	
					//console.log('Duplicate vertex found. ', i, ' could be using ', verticesMap[key]);
					changes[ i ] = changes[ verticesMap[ key ] ];
	
				}
	
			}
	
	
			// if faces are completely degenerate after merging vertices, we
			// have to remove them from the geometry.
			var faceIndicesToRemove = [];
	
			for ( i = 0, il = this.faces.length; i < il; i ++ ) {
	
				face = this.faces[ i ];
	
				face.a = changes[ face.a ];
				face.b = changes[ face.b ];
				face.c = changes[ face.c ];
	
				indices = [ face.a, face.b, face.c ];
	
				// if any duplicate vertices are found in a Face3
				// we have to remove the face as nothing can be saved
				for ( var n = 0; n < 3; n ++ ) {
	
					if ( indices[ n ] === indices[ ( n + 1 ) % 3 ] ) {
	
						faceIndicesToRemove.push( i );
						break;
	
					}
	
				}
	
			}
	
			for ( i = faceIndicesToRemove.length - 1; i >= 0; i -- ) {
	
				var idx = faceIndicesToRemove[ i ];
	
				this.faces.splice( idx, 1 );
	
				for ( j = 0, jl = this.faceVertexUvs.length; j < jl; j ++ ) {
	
					this.faceVertexUvs[ j ].splice( idx, 1 );
	
				}
	
			}
	
			// Use unique set of vertices
	
			var diff = this.vertices.length - unique.length;
			this.vertices = unique;
			return diff;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.vertices = [];
	
			for ( var i = 0, l = points.length; i < l; i ++ ) {
	
				var point = points[ i ];
				this.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
	
			}
	
			return this;
	
		},
	
		sortFacesByMaterialIndex: function () {
	
			var faces = this.faces;
			var length = faces.length;
	
			// tag faces
	
			for ( var i = 0; i < length; i ++ ) {
	
				faces[ i ]._id = i;
	
			}
	
			// sort faces
	
			function materialIndexSort( a, b ) {
	
				return a.materialIndex - b.materialIndex;
	
			}
	
			faces.sort( materialIndexSort );
	
			// sort uvs
	
			var uvs1 = this.faceVertexUvs[ 0 ];
			var uvs2 = this.faceVertexUvs[ 1 ];
	
			var newUvs1, newUvs2;
	
			if ( uvs1 && uvs1.length === length ) newUvs1 = [];
			if ( uvs2 && uvs2.length === length ) newUvs2 = [];
	
			for ( var i = 0; i < length; i ++ ) {
	
				var id = faces[ i ]._id;
	
				if ( newUvs1 ) newUvs1.push( uvs1[ id ] );
				if ( newUvs2 ) newUvs2.push( uvs2[ id ] );
	
			}
	
			if ( newUvs1 ) this.faceVertexUvs[ 0 ] = newUvs1;
			if ( newUvs2 ) this.faceVertexUvs[ 1 ] = newUvs2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.5,
					type: 'Geometry',
					generator: 'Geometry.toJSON'
				}
			};
	
			// standard Geometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			var vertices = [];
	
			for ( var i = 0; i < this.vertices.length; i ++ ) {
	
				var vertex = this.vertices[ i ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
			var faces = [];
			var normals = [];
			var normalsHash = {};
			var colors = [];
			var colorsHash = {};
			var uvs = [];
			var uvsHash = {};
	
			for ( var i = 0; i < this.faces.length; i ++ ) {
	
				var face = this.faces[ i ];
	
				var hasMaterial = true;
				var hasFaceUv = false; // deprecated
				var hasFaceVertexUv = this.faceVertexUvs[ 0 ][ i ] !== undefined;
				var hasFaceNormal = face.normal.length() > 0;
				var hasFaceVertexNormal = face.vertexNormals.length > 0;
				var hasFaceColor = face.color.r !== 1 || face.color.g !== 1 || face.color.b !== 1;
				var hasFaceVertexColor = face.vertexColors.length > 0;
	
				var faceType = 0;
	
				faceType = setBit( faceType, 0, 0 ); // isQuad
				faceType = setBit( faceType, 1, hasMaterial );
				faceType = setBit( faceType, 2, hasFaceUv );
				faceType = setBit( faceType, 3, hasFaceVertexUv );
				faceType = setBit( faceType, 4, hasFaceNormal );
				faceType = setBit( faceType, 5, hasFaceVertexNormal );
				faceType = setBit( faceType, 6, hasFaceColor );
				faceType = setBit( faceType, 7, hasFaceVertexColor );
	
				faces.push( faceType );
				faces.push( face.a, face.b, face.c );
				faces.push( face.materialIndex );
	
				if ( hasFaceVertexUv ) {
	
					var faceVertexUvs = this.faceVertexUvs[ 0 ][ i ];
	
					faces.push(
						getUvIndex( faceVertexUvs[ 0 ] ),
						getUvIndex( faceVertexUvs[ 1 ] ),
						getUvIndex( faceVertexUvs[ 2 ] )
					);
	
				}
	
				if ( hasFaceNormal ) {
	
					faces.push( getNormalIndex( face.normal ) );
	
				}
	
				if ( hasFaceVertexNormal ) {
	
					var vertexNormals = face.vertexNormals;
	
					faces.push(
						getNormalIndex( vertexNormals[ 0 ] ),
						getNormalIndex( vertexNormals[ 1 ] ),
						getNormalIndex( vertexNormals[ 2 ] )
					);
	
				}
	
				if ( hasFaceColor ) {
	
					faces.push( getColorIndex( face.color ) );
	
				}
	
				if ( hasFaceVertexColor ) {
	
					var vertexColors = face.vertexColors;
	
					faces.push(
						getColorIndex( vertexColors[ 0 ] ),
						getColorIndex( vertexColors[ 1 ] ),
						getColorIndex( vertexColors[ 2 ] )
					);
	
				}
	
			}
	
			function setBit( value, position, enabled ) {
	
				return enabled ? value | ( 1 << position ) : value & ( ~ ( 1 << position ) );
	
			}
	
			function getNormalIndex( normal ) {
	
				var hash = normal.x.toString() + normal.y.toString() + normal.z.toString();
	
				if ( normalsHash[ hash ] !== undefined ) {
	
					return normalsHash[ hash ];
	
				}
	
				normalsHash[ hash ] = normals.length / 3;
				normals.push( normal.x, normal.y, normal.z );
	
				return normalsHash[ hash ];
	
			}
	
			function getColorIndex( color ) {
	
				var hash = color.r.toString() + color.g.toString() + color.b.toString();
	
				if ( colorsHash[ hash ] !== undefined ) {
	
					return colorsHash[ hash ];
	
				}
	
				colorsHash[ hash ] = colors.length;
				colors.push( color.getHex() );
	
				return colorsHash[ hash ];
	
			}
	
			function getUvIndex( uv ) {
	
				var hash = uv.x.toString() + uv.y.toString();
	
				if ( uvsHash[ hash ] !== undefined ) {
	
					return uvsHash[ hash ];
	
				}
	
				uvsHash[ hash ] = uvs.length / 2;
				uvs.push( uv.x, uv.y );
	
				return uvsHash[ hash ];
	
			}
	
			data.data = {};
	
			data.data.vertices = vertices;
			data.data.normals = normals;
			if ( colors.length > 0 ) data.data.colors = colors;
			if ( uvs.length > 0 ) data.data.uvs = [ uvs ]; // temporal backward compatibility
			data.data.faces = faces;
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			 // Handle primitives
	
			 var parameters = this.parameters;
	
			 if ( parameters !== undefined ) {
	
			 var values = [];
	
			 for ( var key in parameters ) {
	
			 values.push( parameters[ key ] );
	
			 }
	
			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
	
			 }
	
			 return new this.constructor().copy( this );
			 */
	
			return new Geometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			var i, il, j, jl, k, kl;
	
			// reset
	
			this.vertices = [];
			this.colors = [];
			this.faces = [];
			this.faceVertexUvs = [[]];
			this.morphTargets = [];
			this.morphNormals = [];
			this.skinWeights = [];
			this.skinIndices = [];
			this.lineDistances = [];
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// name
	
			this.name = source.name;
	
			// vertices
	
			var vertices = source.vertices;
	
			for ( i = 0, il = vertices.length; i < il; i ++ ) {
	
				this.vertices.push( vertices[ i ].clone() );
	
			}
	
			// colors
	
			var colors = source.colors;
	
			for ( i = 0, il = colors.length; i < il; i ++ ) {
	
				this.colors.push( colors[ i ].clone() );
	
			}
	
			// faces
	
			var faces = source.faces;
	
			for ( i = 0, il = faces.length; i < il; i ++ ) {
	
				this.faces.push( faces[ i ].clone() );
	
			}
	
			// face vertex uvs
	
			for ( i = 0, il = source.faceVertexUvs.length; i < il; i ++ ) {
	
				var faceVertexUvs = source.faceVertexUvs[ i ];
	
				if ( this.faceVertexUvs[ i ] === undefined ) {
	
					this.faceVertexUvs[ i ] = [];
	
				}
	
				for ( j = 0, jl = faceVertexUvs.length; j < jl; j ++ ) {
	
					var uvs = faceVertexUvs[ j ], uvsCopy = [];
	
					for ( k = 0, kl = uvs.length; k < kl; k ++ ) {
	
						var uv = uvs[ k ];
	
						uvsCopy.push( uv.clone() );
	
					}
	
					this.faceVertexUvs[ i ].push( uvsCopy );
	
				}
	
			}
	
			// morph targets
	
			var morphTargets = source.morphTargets;
	
			for ( i = 0, il = morphTargets.length; i < il; i ++ ) {
	
				var morphTarget = {};
				morphTarget.name = morphTargets[ i ].name;
	
				// vertices
	
				if ( morphTargets[ i ].vertices !== undefined ) {
	
					morphTarget.vertices = [];
	
					for ( j = 0, jl = morphTargets[ i ].vertices.length; j < jl; j ++ ) {
	
						morphTarget.vertices.push( morphTargets[ i ].vertices[ j ].clone() );
	
					}
	
				}
	
				// normals
	
				if ( morphTargets[ i ].normals !== undefined ) {
	
					morphTarget.normals = [];
	
					for ( j = 0, jl = morphTargets[ i ].normals.length; j < jl; j ++ ) {
	
						morphTarget.normals.push( morphTargets[ i ].normals[ j ].clone() );
	
					}
	
				}
	
				this.morphTargets.push( morphTarget );
	
			}
	
			// morph normals
	
			var morphNormals = source.morphNormals;
	
			for ( i = 0, il = morphNormals.length; i < il; i ++ ) {
	
				var morphNormal = {};
	
				// vertex normals
	
				if ( morphNormals[ i ].vertexNormals !== undefined ) {
	
					morphNormal.vertexNormals = [];
	
					for ( j = 0, jl = morphNormals[ i ].vertexNormals.length; j < jl; j ++ ) {
	
						var srcVertexNormal = morphNormals[ i ].vertexNormals[ j ];
						var destVertexNormal = {};
	
						destVertexNormal.a = srcVertexNormal.a.clone();
						destVertexNormal.b = srcVertexNormal.b.clone();
						destVertexNormal.c = srcVertexNormal.c.clone();
	
						morphNormal.vertexNormals.push( destVertexNormal );
	
					}
	
				}
	
				// face normals
	
				if ( morphNormals[ i ].faceNormals !== undefined ) {
	
					morphNormal.faceNormals = [];
	
					for ( j = 0, jl = morphNormals[ i ].faceNormals.length; j < jl; j ++ ) {
	
						morphNormal.faceNormals.push( morphNormals[ i ].faceNormals[ j ].clone() );
	
					}
	
				}
	
				this.morphNormals.push( morphNormal );
	
			}
	
			// skin weights
	
			var skinWeights = source.skinWeights;
	
			for ( i = 0, il = skinWeights.length; i < il; i ++ ) {
	
				this.skinWeights.push( skinWeights[ i ].clone() );
	
			}
	
			// skin indices
	
			var skinIndices = source.skinIndices;
	
			for ( i = 0, il = skinIndices.length; i < il; i ++ ) {
	
				this.skinIndices.push( skinIndices[ i ].clone() );
	
			}
	
			// line distances
	
			var lineDistances = source.lineDistances;
	
			for ( i = 0, il = lineDistances.length; i < il; i ++ ) {
	
				this.lineDistances.push( lineDistances[ i ] );
	
			}
	
			// bounding box
	
			var boundingBox = source.boundingBox;
	
			if ( boundingBox !== null ) {
	
				this.boundingBox = boundingBox.clone();
	
			}
	
			// bounding sphere
	
			var boundingSphere = source.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				this.boundingSphere = boundingSphere.clone();
	
			}
	
			// update flags
	
			this.elementsNeedUpdate = source.elementsNeedUpdate;
			this.verticesNeedUpdate = source.verticesNeedUpdate;
			this.uvsNeedUpdate = source.uvsNeedUpdate;
			this.normalsNeedUpdate = source.normalsNeedUpdate;
			this.colorsNeedUpdate = source.colorsNeedUpdate;
			this.lineDistancesNeedUpdate = source.lineDistancesNeedUpdate;
			this.groupsNeedUpdate = source.groupsNeedUpdate;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function BufferAttribute( array, itemSize, normalized ) {
	
		if ( Array.isArray( array ) ) {
	
			throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
		}
	
		this.name = '';
	
		this.array = array;
		this.itemSize = itemSize;
		this.count = array !== undefined ? array.length / itemSize : 0;
		this.normalized = normalized === true;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	}
	
	Object.defineProperty( BufferAttribute.prototype, 'needsUpdate', {
	
		set: function ( value ) {
	
			if ( value === true ) this.version ++;
	
		}
	
	} );
	
	Object.assign( BufferAttribute.prototype, {
	
		isBufferAttribute: true,
	
		onUploadCallback: function () {},
	
		setArray: function ( array ) {
	
			if ( Array.isArray( array ) ) {
	
				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
			}
	
			this.count = array !== undefined ? array.length / this.itemSize : 0;
			this.array = array;
	
			return this;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
			this.array = new source.array.constructor( source.array );
			this.itemSize = source.itemSize;
			this.count = source.count;
			this.normalized = source.normalized;
	
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.itemSize;
			index2 *= attribute.itemSize;
	
			for ( var i = 0, l = this.itemSize; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		copyArray: function ( array ) {
	
			this.array.set( array );
	
			return this;
	
		},
	
		copyColorsArray: function ( colors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = colors.length; i < l; i ++ ) {
	
				var color = colors[ i ];
	
				if ( color === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyColorsArray(): color is undefined', i );
					color = new Color();
	
				}
	
				array[ offset ++ ] = color.r;
				array[ offset ++ ] = color.g;
				array[ offset ++ ] = color.b;
	
			}
	
			return this;
	
		},
	
		copyVector2sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector2sArray(): vector is undefined', i );
					vector = new Vector2();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
	
			}
	
			return this;
	
		},
	
		copyVector3sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector3sArray(): vector is undefined', i );
					vector = new Vector3();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
	
			}
	
			return this;
	
		},
	
		copyVector4sArray: function ( vectors ) {
	
			var array = this.array, offset = 0;
	
			for ( var i = 0, l = vectors.length; i < l; i ++ ) {
	
				var vector = vectors[ i ];
	
				if ( vector === undefined ) {
	
					console.warn( 'THREE.BufferAttribute.copyVector4sArray(): vector is undefined', i );
					vector = new Vector4();
	
				}
	
				array[ offset ++ ] = vector.x;
				array[ offset ++ ] = vector.y;
				array[ offset ++ ] = vector.z;
				array[ offset ++ ] = vector.w;
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.array[ index * this.itemSize ];
	
		},
	
		setX: function ( index, x ) {
	
			this.array[ index * this.itemSize ] = x;
	
			return this;
	
		},
	
		getY: function ( index ) {
	
			return this.array[ index * this.itemSize + 1 ];
	
		},
	
		setY: function ( index, y ) {
	
			this.array[ index * this.itemSize + 1 ] = y;
	
			return this;
	
		},
	
		getZ: function ( index ) {
	
			return this.array[ index * this.itemSize + 2 ];
	
		},
	
		setZ: function ( index, z ) {
	
			this.array[ index * this.itemSize + 2 ] = z;
	
			return this;
	
		},
	
		getW: function ( index ) {
	
			return this.array[ index * this.itemSize + 3 ];
	
		},
	
		setW: function ( index, w ) {
	
			this.array[ index * this.itemSize + 3 ] = w;
	
			return this;
	
		},
	
		setXY: function ( index, x, y ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index *= this.itemSize;
	
			this.array[ index + 0 ] = x;
			this.array[ index + 1 ] = y;
			this.array[ index + 2 ] = z;
			this.array[ index + 3 ] = w;
	
			return this;
	
		},
	
		onUpload: function ( callback ) {
	
			this.onUploadCallback = callback;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor( this.array, this.itemSize ).copy( this );
	
		}
	
	} );
	
	//
	
	function Int8BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Int8Array( array ), itemSize, normalized );
	
	}
	
	Int8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int8BufferAttribute.prototype.constructor = Int8BufferAttribute;
	
	
	function Uint8BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Uint8Array( array ), itemSize, normalized );
	
	}
	
	Uint8BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8BufferAttribute.prototype.constructor = Uint8BufferAttribute;
	
	
	function Uint8ClampedBufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Uint8ClampedArray( array ), itemSize, normalized );
	
	}
	
	Uint8ClampedBufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint8ClampedBufferAttribute.prototype.constructor = Uint8ClampedBufferAttribute;
	
	
	function Int16BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Int16Array( array ), itemSize, normalized );
	
	}
	
	Int16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int16BufferAttribute.prototype.constructor = Int16BufferAttribute;
	
	
	function Uint16BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Uint16Array( array ), itemSize, normalized );
	
	}
	
	Uint16BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint16BufferAttribute.prototype.constructor = Uint16BufferAttribute;
	
	
	function Int32BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Int32Array( array ), itemSize, normalized );
	
	}
	
	Int32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Int32BufferAttribute.prototype.constructor = Int32BufferAttribute;
	
	
	function Uint32BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Uint32Array( array ), itemSize, normalized );
	
	}
	
	Uint32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Uint32BufferAttribute.prototype.constructor = Uint32BufferAttribute;
	
	
	function Float32BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Float32Array( array ), itemSize, normalized );
	
	}
	
	Float32BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float32BufferAttribute.prototype.constructor = Float32BufferAttribute;
	
	
	function Float64BufferAttribute( array, itemSize, normalized ) {
	
		BufferAttribute.call( this, new Float64Array( array ), itemSize, normalized );
	
	}
	
	Float64BufferAttribute.prototype = Object.create( BufferAttribute.prototype );
	Float64BufferAttribute.prototype.constructor = Float64BufferAttribute;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function DirectGeometry() {
	
		this.vertices = [];
		this.normals = [];
		this.colors = [];
		this.uvs = [];
		this.uvs2 = [];
	
		this.groups = [];
	
		this.morphTargets = {};
	
		this.skinWeights = [];
		this.skinIndices = [];
	
		// this.lineDistances = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		// update flags
	
		this.verticesNeedUpdate = false;
		this.normalsNeedUpdate = false;
		this.colorsNeedUpdate = false;
		this.uvsNeedUpdate = false;
		this.groupsNeedUpdate = false;
	
	}
	
	Object.assign( DirectGeometry.prototype, {
	
		computeGroups: function ( geometry ) {
	
			var group;
			var groups = [];
			var materialIndex = undefined;
	
			var faces = geometry.faces;
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				// materials
	
				if ( face.materialIndex !== materialIndex ) {
	
					materialIndex = face.materialIndex;
	
					if ( group !== undefined ) {
	
						group.count = ( i * 3 ) - group.start;
						groups.push( group );
	
					}
	
					group = {
						start: i * 3,
						materialIndex: materialIndex
					};
	
				}
	
			}
	
			if ( group !== undefined ) {
	
				group.count = ( i * 3 ) - group.start;
				groups.push( group );
	
			}
	
			this.groups = groups;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			var faces = geometry.faces;
			var vertices = geometry.vertices;
			var faceVertexUvs = geometry.faceVertexUvs;
	
			var hasFaceVertexUv = faceVertexUvs[ 0 ] && faceVertexUvs[ 0 ].length > 0;
			var hasFaceVertexUv2 = faceVertexUvs[ 1 ] && faceVertexUvs[ 1 ].length > 0;
	
			// morphs
	
			var morphTargets = geometry.morphTargets;
			var morphTargetsLength = morphTargets.length;
	
			var morphTargetsPosition;
	
			if ( morphTargetsLength > 0 ) {
	
				morphTargetsPosition = [];
	
				for ( var i = 0; i < morphTargetsLength; i ++ ) {
	
					morphTargetsPosition[ i ] = {
						name: morphTargets[ i ].name,
						 data: []
					};
	
				}
	
				this.morphTargets.position = morphTargetsPosition;
	
			}
	
			var morphNormals = geometry.morphNormals;
			var morphNormalsLength = morphNormals.length;
	
			var morphTargetsNormal;
	
			if ( morphNormalsLength > 0 ) {
	
				morphTargetsNormal = [];
	
				for ( var i = 0; i < morphNormalsLength; i ++ ) {
	
					morphTargetsNormal[ i ] = {
						name: morphNormals[ i ].name,
						 data: []
					};
	
				}
	
				this.morphTargets.normal = morphTargetsNormal;
	
			}
	
			// skins
	
			var skinIndices = geometry.skinIndices;
			var skinWeights = geometry.skinWeights;
	
			var hasSkinIndices = skinIndices.length === vertices.length;
			var hasSkinWeights = skinWeights.length === vertices.length;
	
			//
	
			if ( vertices.length > 0 && faces.length === 0 ) {
	
				console.error( 'THREE.DirectGeometry: Faceless geometries are not supported.' );
	
			}
	
			for ( var i = 0; i < faces.length; i ++ ) {
	
				var face = faces[ i ];
	
				this.vertices.push( vertices[ face.a ], vertices[ face.b ], vertices[ face.c ] );
	
				var vertexNormals = face.vertexNormals;
	
				if ( vertexNormals.length === 3 ) {
	
					this.normals.push( vertexNormals[ 0 ], vertexNormals[ 1 ], vertexNormals[ 2 ] );
	
				} else {
	
					var normal = face.normal;
	
					this.normals.push( normal, normal, normal );
	
				}
	
				var vertexColors = face.vertexColors;
	
				if ( vertexColors.length === 3 ) {
	
					this.colors.push( vertexColors[ 0 ], vertexColors[ 1 ], vertexColors[ 2 ] );
	
				} else {
	
					var color = face.color;
	
					this.colors.push( color, color, color );
	
				}
	
				if ( hasFaceVertexUv === true ) {
	
					var vertexUvs = faceVertexUvs[ 0 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv ', i );
	
						this.uvs.push( new Vector2(), new Vector2(), new Vector2() );
	
					}
	
				}
	
				if ( hasFaceVertexUv2 === true ) {
	
					var vertexUvs = faceVertexUvs[ 1 ][ i ];
	
					if ( vertexUvs !== undefined ) {
	
						this.uvs2.push( vertexUvs[ 0 ], vertexUvs[ 1 ], vertexUvs[ 2 ] );
	
					} else {
	
						console.warn( 'THREE.DirectGeometry.fromGeometry(): Undefined vertexUv2 ', i );
	
						this.uvs2.push( new Vector2(), new Vector2(), new Vector2() );
	
					}
	
				}
	
				// morphs
	
				for ( var j = 0; j < morphTargetsLength; j ++ ) {
	
					var morphTarget = morphTargets[ j ].vertices;
	
					morphTargetsPosition[ j ].data.push( morphTarget[ face.a ], morphTarget[ face.b ], morphTarget[ face.c ] );
	
				}
	
				for ( var j = 0; j < morphNormalsLength; j ++ ) {
	
					var morphNormal = morphNormals[ j ].vertexNormals[ i ];
	
					morphTargetsNormal[ j ].data.push( morphNormal.a, morphNormal.b, morphNormal.c );
	
				}
	
				// skins
	
				if ( hasSkinIndices ) {
	
					this.skinIndices.push( skinIndices[ face.a ], skinIndices[ face.b ], skinIndices[ face.c ] );
	
				}
	
				if ( hasSkinWeights ) {
	
					this.skinWeights.push( skinWeights[ face.a ], skinWeights[ face.b ], skinWeights[ face.c ] );
	
				}
	
			}
	
			this.computeGroups( geometry );
	
			this.verticesNeedUpdate = geometry.verticesNeedUpdate;
			this.normalsNeedUpdate = geometry.normalsNeedUpdate;
			this.colorsNeedUpdate = geometry.colorsNeedUpdate;
			this.uvsNeedUpdate = geometry.uvsNeedUpdate;
			this.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function arrayMax( array ) {
	
		if ( array.length === 0 ) return - Infinity;
	
		var max = array[ 0 ];
	
		for ( var i = 1, l = array.length; i < l; ++ i ) {
	
			if ( array[ i ] > max ) max = array[ i ];
	
		}
	
		return max;
	
	}
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var bufferGeometryId = 1; // BufferGeometry uses odd numbers as Id
	
	function BufferGeometry() {
	
		Object.defineProperty( this, 'id', { value: bufferGeometryId += 2 } );
	
		this.uuid = _Math.generateUUID();
	
		this.name = '';
		this.type = 'BufferGeometry';
	
		this.index = null;
		this.attributes = {};
	
		this.morphAttributes = {};
	
		this.groups = [];
	
		this.boundingBox = null;
		this.boundingSphere = null;
	
		this.drawRange = { start: 0, count: Infinity };
	
		this.userData = {};
	
	}
	
	BufferGeometry.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: BufferGeometry,
	
		isBufferGeometry: true,
	
		getIndex: function () {
	
			return this.index;
	
		},
	
		setIndex: function ( index ) {
	
			if ( Array.isArray( index ) ) {
	
				this.index = new ( arrayMax( index ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( index, 1 );
	
			} else {
	
				this.index = index;
	
			}
	
		},
	
		addAttribute: function ( name, attribute ) {
	
			if ( ! ( attribute && attribute.isBufferAttribute ) && ! ( attribute && attribute.isInterleavedBufferAttribute ) ) {
	
				console.warn( 'THREE.BufferGeometry: .addAttribute() now expects ( name, attribute ).' );
	
				return this.addAttribute( name, new BufferAttribute( arguments[ 1 ], arguments[ 2 ] ) );
	
			}
	
			if ( name === 'index' ) {
	
				console.warn( 'THREE.BufferGeometry.addAttribute: Use .setIndex() for index attribute.' );
				this.setIndex( attribute );
	
				return this;
	
			}
	
			this.attributes[ name ] = attribute;
	
			return this;
	
		},
	
		getAttribute: function ( name ) {
	
			return this.attributes[ name ];
	
		},
	
		removeAttribute: function ( name ) {
	
			delete this.attributes[ name ];
	
			return this;
	
		},
	
		addGroup: function ( start, count, materialIndex ) {
	
			this.groups.push( {
	
				start: start,
				count: count,
				materialIndex: materialIndex !== undefined ? materialIndex : 0
	
			} );
	
		},
	
		clearGroups: function () {
	
			this.groups = [];
	
		},
	
		setDrawRange: function ( start, count ) {
	
			this.drawRange.start = start;
			this.drawRange.count = count;
	
		},
	
		applyMatrix: function ( matrix ) {
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				matrix.applyToBufferAttribute( position );
				position.needsUpdate = true;
	
			}
	
			var normal = this.attributes.normal;
	
			if ( normal !== undefined ) {
	
				var normalMatrix = new Matrix3().getNormalMatrix( matrix );
	
				normalMatrix.applyToBufferAttribute( normal );
				normal.needsUpdate = true;
	
			}
	
			if ( this.boundingBox !== null ) {
	
				this.computeBoundingBox();
	
			}
	
			if ( this.boundingSphere !== null ) {
	
				this.computeBoundingSphere();
	
			}
	
			return this;
	
		},
	
		rotateX: function () {
	
			// rotate geometry around world x-axis
	
			var m1 = new Matrix4();
	
			return function rotateX( angle ) {
	
				m1.makeRotationX( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateY: function () {
	
			// rotate geometry around world y-axis
	
			var m1 = new Matrix4();
	
			return function rotateY( angle ) {
	
				m1.makeRotationY( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		rotateZ: function () {
	
			// rotate geometry around world z-axis
	
			var m1 = new Matrix4();
	
			return function rotateZ( angle ) {
	
				m1.makeRotationZ( angle );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		translate: function () {
	
			// translate geometry
	
			var m1 = new Matrix4();
	
			return function translate( x, y, z ) {
	
				m1.makeTranslation( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		scale: function () {
	
			// scale geometry
	
			var m1 = new Matrix4();
	
			return function scale( x, y, z ) {
	
				m1.makeScale( x, y, z );
	
				this.applyMatrix( m1 );
	
				return this;
	
			};
	
		}(),
	
		lookAt: function () {
	
			var obj = new Object3D();
	
			return function lookAt( vector ) {
	
				obj.lookAt( vector );
	
				obj.updateMatrix();
	
				this.applyMatrix( obj.matrix );
	
			};
	
		}(),
	
		center: function () {
	
			var offset = new Vector3();
	
			return function center() {
	
				this.computeBoundingBox();
	
				this.boundingBox.getCenter( offset ).negate();
	
				this.translate( offset.x, offset.y, offset.z );
	
				return this;
	
			};
	
		}(),
	
		setFromObject: function ( object ) {
	
			// console.log( 'THREE.BufferGeometry.setFromObject(). Converting', object, this );
	
			var geometry = object.geometry;
	
			if ( object.isPoints || object.isLine ) {
	
				var positions = new Float32BufferAttribute( geometry.vertices.length * 3, 3 );
				var colors = new Float32BufferAttribute( geometry.colors.length * 3, 3 );
	
				this.addAttribute( 'position', positions.copyVector3sArray( geometry.vertices ) );
				this.addAttribute( 'color', colors.copyColorsArray( geometry.colors ) );
	
				if ( geometry.lineDistances && geometry.lineDistances.length === geometry.vertices.length ) {
	
					var lineDistances = new Float32BufferAttribute( geometry.lineDistances.length, 1 );
	
					this.addAttribute( 'lineDistance', lineDistances.copyArray( geometry.lineDistances ) );
	
				}
	
				if ( geometry.boundingSphere !== null ) {
	
					this.boundingSphere = geometry.boundingSphere.clone();
	
				}
	
				if ( geometry.boundingBox !== null ) {
	
					this.boundingBox = geometry.boundingBox.clone();
	
				}
	
			} else if ( object.isMesh ) {
	
				if ( geometry && geometry.isGeometry ) {
	
					this.fromGeometry( geometry );
	
				}
	
			}
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			var position = [];
	
			for ( var i = 0, l = points.length; i < l; i ++ ) {
	
				var point = points[ i ];
				position.push( point.x, point.y, point.z || 0 );
	
			}
	
			this.addAttribute( 'position', new Float32BufferAttribute( position, 3 ) );
	
			return this;
	
		},
	
		updateFromObject: function ( object ) {
	
			var geometry = object.geometry;
	
			if ( object.isMesh ) {
	
				var direct = geometry.__directGeometry;
	
				if ( geometry.elementsNeedUpdate === true ) {
	
					direct = undefined;
					geometry.elementsNeedUpdate = false;
	
				}
	
				if ( direct === undefined ) {
	
					return this.fromGeometry( geometry );
	
				}
	
				direct.verticesNeedUpdate = geometry.verticesNeedUpdate;
				direct.normalsNeedUpdate = geometry.normalsNeedUpdate;
				direct.colorsNeedUpdate = geometry.colorsNeedUpdate;
				direct.uvsNeedUpdate = geometry.uvsNeedUpdate;
				direct.groupsNeedUpdate = geometry.groupsNeedUpdate;
	
				geometry.verticesNeedUpdate = false;
				geometry.normalsNeedUpdate = false;
				geometry.colorsNeedUpdate = false;
				geometry.uvsNeedUpdate = false;
				geometry.groupsNeedUpdate = false;
	
				geometry = direct;
	
			}
	
			var attribute;
	
			if ( geometry.verticesNeedUpdate === true ) {
	
				attribute = this.attributes.position;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.vertices );
					attribute.needsUpdate = true;
	
				}
	
				geometry.verticesNeedUpdate = false;
	
			}
	
			if ( geometry.normalsNeedUpdate === true ) {
	
				attribute = this.attributes.normal;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector3sArray( geometry.normals );
					attribute.needsUpdate = true;
	
				}
	
				geometry.normalsNeedUpdate = false;
	
			}
	
			if ( geometry.colorsNeedUpdate === true ) {
	
				attribute = this.attributes.color;
	
				if ( attribute !== undefined ) {
	
					attribute.copyColorsArray( geometry.colors );
					attribute.needsUpdate = true;
	
				}
	
				geometry.colorsNeedUpdate = false;
	
			}
	
			if ( geometry.uvsNeedUpdate ) {
	
				attribute = this.attributes.uv;
	
				if ( attribute !== undefined ) {
	
					attribute.copyVector2sArray( geometry.uvs );
					attribute.needsUpdate = true;
	
				}
	
				geometry.uvsNeedUpdate = false;
	
			}
	
			if ( geometry.lineDistancesNeedUpdate ) {
	
				attribute = this.attributes.lineDistance;
	
				if ( attribute !== undefined ) {
	
					attribute.copyArray( geometry.lineDistances );
					attribute.needsUpdate = true;
	
				}
	
				geometry.lineDistancesNeedUpdate = false;
	
			}
	
			if ( geometry.groupsNeedUpdate ) {
	
				geometry.computeGroups( object.geometry );
				this.groups = geometry.groups;
	
				geometry.groupsNeedUpdate = false;
	
			}
	
			return this;
	
		},
	
		fromGeometry: function ( geometry ) {
	
			geometry.__directGeometry = new DirectGeometry().fromGeometry( geometry );
	
			return this.fromDirectGeometry( geometry.__directGeometry );
	
		},
	
		fromDirectGeometry: function ( geometry ) {
	
			var positions = new Float32Array( geometry.vertices.length * 3 );
			this.addAttribute( 'position', new BufferAttribute( positions, 3 ).copyVector3sArray( geometry.vertices ) );
	
			if ( geometry.normals.length > 0 ) {
	
				var normals = new Float32Array( geometry.normals.length * 3 );
				this.addAttribute( 'normal', new BufferAttribute( normals, 3 ).copyVector3sArray( geometry.normals ) );
	
			}
	
			if ( geometry.colors.length > 0 ) {
	
				var colors = new Float32Array( geometry.colors.length * 3 );
				this.addAttribute( 'color', new BufferAttribute( colors, 3 ).copyColorsArray( geometry.colors ) );
	
			}
	
			if ( geometry.uvs.length > 0 ) {
	
				var uvs = new Float32Array( geometry.uvs.length * 2 );
				this.addAttribute( 'uv', new BufferAttribute( uvs, 2 ).copyVector2sArray( geometry.uvs ) );
	
			}
	
			if ( geometry.uvs2.length > 0 ) {
	
				var uvs2 = new Float32Array( geometry.uvs2.length * 2 );
				this.addAttribute( 'uv2', new BufferAttribute( uvs2, 2 ).copyVector2sArray( geometry.uvs2 ) );
	
			}
	
			// groups
	
			this.groups = geometry.groups;
	
			// morphs
	
			for ( var name in geometry.morphTargets ) {
	
				var array = [];
				var morphTargets = geometry.morphTargets[ name ];
	
				for ( var i = 0, l = morphTargets.length; i < l; i ++ ) {
	
					var morphTarget = morphTargets[ i ];
	
					var attribute = new Float32BufferAttribute( morphTarget.data.length * 3, 3 );
					attribute.name = morphTarget.name;
	
					array.push( attribute.copyVector3sArray( morphTarget.data ) );
	
				}
	
				this.morphAttributes[ name ] = array;
	
			}
	
			// skinning
	
			if ( geometry.skinIndices.length > 0 ) {
	
				var skinIndices = new Float32BufferAttribute( geometry.skinIndices.length * 4, 4 );
				this.addAttribute( 'skinIndex', skinIndices.copyVector4sArray( geometry.skinIndices ) );
	
			}
	
			if ( geometry.skinWeights.length > 0 ) {
	
				var skinWeights = new Float32BufferAttribute( geometry.skinWeights.length * 4, 4 );
				this.addAttribute( 'skinWeight', skinWeights.copyVector4sArray( geometry.skinWeights ) );
	
			}
	
			//
	
			if ( geometry.boundingSphere !== null ) {
	
				this.boundingSphere = geometry.boundingSphere.clone();
	
			}
	
			if ( geometry.boundingBox !== null ) {
	
				this.boundingBox = geometry.boundingBox.clone();
	
			}
	
			return this;
	
		},
	
		computeBoundingBox: function () {
	
			if ( this.boundingBox === null ) {
	
				this.boundingBox = new Box3();
	
			}
	
			var position = this.attributes.position;
	
			if ( position !== undefined ) {
	
				this.boundingBox.setFromBufferAttribute( position );
	
			} else {
	
				this.boundingBox.makeEmpty();
	
			}
	
			if ( isNaN( this.boundingBox.min.x ) || isNaN( this.boundingBox.min.y ) || isNaN( this.boundingBox.min.z ) ) {
	
				console.error( 'THREE.BufferGeometry.computeBoundingBox: Computed min/max have NaN values. The "position" attribute is likely to have NaN values.', this );
	
			}
	
		},
	
		computeBoundingSphere: function () {
	
			var box = new Box3();
			var vector = new Vector3();
	
			return function computeBoundingSphere() {
	
				if ( this.boundingSphere === null ) {
	
					this.boundingSphere = new Sphere();
	
				}
	
				var position = this.attributes.position;
	
				if ( position ) {
	
					var center = this.boundingSphere.center;
	
					box.setFromBufferAttribute( position );
					box.getCenter( center );
	
					// hoping to find a boundingSphere with a radius smaller than the
					// boundingSphere of the boundingBox: sqrt(3) smaller in the best case
	
					var maxRadiusSq = 0;
	
					for ( var i = 0, il = position.count; i < il; i ++ ) {
	
						vector.x = position.getX( i );
						vector.y = position.getY( i );
						vector.z = position.getZ( i );
						maxRadiusSq = Math.max( maxRadiusSq, center.distanceToSquared( vector ) );
	
					}
	
					this.boundingSphere.radius = Math.sqrt( maxRadiusSq );
	
					if ( isNaN( this.boundingSphere.radius ) ) {
	
						console.error( 'THREE.BufferGeometry.computeBoundingSphere(): Computed radius is NaN. The "position" attribute is likely to have NaN values.', this );
	
					}
	
				}
	
			};
	
		}(),
	
		computeFaceNormals: function () {
	
			// backwards compatibility
	
		},
	
		computeVertexNormals: function () {
	
			var index = this.index;
			var attributes = this.attributes;
	
			if ( attributes.position ) {
	
				var positions = attributes.position.array;
	
				if ( attributes.normal === undefined ) {
	
					this.addAttribute( 'normal', new BufferAttribute( new Float32Array( positions.length ), 3 ) );
	
				} else {
	
					// reset existing normals to zero
	
					var array = attributes.normal.array;
	
					for ( var i = 0, il = array.length; i < il; i ++ ) {
	
						array[ i ] = 0;
	
					}
	
				}
	
				var normals = attributes.normal.array;
	
				var vA, vB, vC;
				var pA = new Vector3(), pB = new Vector3(), pC = new Vector3();
				var cb = new Vector3(), ab = new Vector3();
	
				// indexed elements
	
				if ( index ) {
	
					var indices = index.array;
	
					for ( var i = 0, il = index.count; i < il; i += 3 ) {
	
						vA = indices[ i + 0 ] * 3;
						vB = indices[ i + 1 ] * 3;
						vC = indices[ i + 2 ] * 3;
	
						pA.fromArray( positions, vA );
						pB.fromArray( positions, vB );
						pC.fromArray( positions, vC );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ vA ] += cb.x;
						normals[ vA + 1 ] += cb.y;
						normals[ vA + 2 ] += cb.z;
	
						normals[ vB ] += cb.x;
						normals[ vB + 1 ] += cb.y;
						normals[ vB + 2 ] += cb.z;
	
						normals[ vC ] += cb.x;
						normals[ vC + 1 ] += cb.y;
						normals[ vC + 2 ] += cb.z;
	
					}
	
				} else {
	
					// non-indexed elements (unconnected triangle soup)
	
					for ( var i = 0, il = positions.length; i < il; i += 9 ) {
	
						pA.fromArray( positions, i );
						pB.fromArray( positions, i + 3 );
						pC.fromArray( positions, i + 6 );
	
						cb.subVectors( pC, pB );
						ab.subVectors( pA, pB );
						cb.cross( ab );
	
						normals[ i ] = cb.x;
						normals[ i + 1 ] = cb.y;
						normals[ i + 2 ] = cb.z;
	
						normals[ i + 3 ] = cb.x;
						normals[ i + 4 ] = cb.y;
						normals[ i + 5 ] = cb.z;
	
						normals[ i + 6 ] = cb.x;
						normals[ i + 7 ] = cb.y;
						normals[ i + 8 ] = cb.z;
	
					}
	
				}
	
				this.normalizeNormals();
	
				attributes.normal.needsUpdate = true;
	
			}
	
		},
	
		merge: function ( geometry, offset ) {
	
			if ( ! ( geometry && geometry.isBufferGeometry ) ) {
	
				console.error( 'THREE.BufferGeometry.merge(): geometry not an instance of THREE.BufferGeometry.', geometry );
				return;
	
			}
	
			if ( offset === undefined ) {
	
				offset = 0;
	
				console.warn(
					'THREE.BufferGeometry.merge(): Overwriting original geometry, starting at offset=0. '
					+ 'Use BufferGeometryUtils.mergeBufferGeometries() for lossless merge.'
				);
	
			}
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				if ( geometry.attributes[ key ] === undefined ) continue;
	
				var attribute1 = attributes[ key ];
				var attributeArray1 = attribute1.array;
	
				var attribute2 = geometry.attributes[ key ];
				var attributeArray2 = attribute2.array;
	
				var attributeSize = attribute2.itemSize;
	
				for ( var i = 0, j = attributeSize * offset; i < attributeArray2.length; i ++, j ++ ) {
	
					attributeArray1[ j ] = attributeArray2[ i ];
	
				}
	
			}
	
			return this;
	
		},
	
		normalizeNormals: function () {
	
			var vector = new Vector3();
	
			return function normalizeNormals() {
	
				var normals = this.attributes.normal;
	
				for ( var i = 0, il = normals.count; i < il; i ++ ) {
	
					vector.x = normals.getX( i );
					vector.y = normals.getY( i );
					vector.z = normals.getZ( i );
	
					vector.normalize();
	
					normals.setXYZ( i, vector.x, vector.y, vector.z );
	
				}
	
			};
	
		}(),
	
		toNonIndexed: function () {
	
			function convertBufferAttribute( attribute, indices ) {
	
				var array = attribute.array;
				var itemSize = attribute.itemSize;
	
				var array2 = new array.constructor( indices.length * itemSize );
	
				var index = 0, index2 = 0;
	
				for ( var i = 0, l = indices.length; i < l; i ++ ) {
	
					index = indices[ i ] * itemSize;
	
					for ( var j = 0; j < itemSize; j ++ ) {
	
						array2[ index2 ++ ] = array[ index ++ ];
	
					}
	
				}
	
				return new BufferAttribute( array2, itemSize );
	
			}
	
			//
	
			if ( this.index === null ) {
	
				console.warn( 'THREE.BufferGeometry.toNonIndexed(): Geometry is already non-indexed.' );
				return this;
	
			}
	
			var geometry2 = new BufferGeometry();
	
			var indices = this.index.array;
			var attributes = this.attributes;
	
			// attributes
	
			for ( var name in attributes ) {
	
				var attribute = attributes[ name ];
	
				var newAttribute = convertBufferAttribute( attribute, indices );
	
				geometry2.addAttribute( name, newAttribute );
	
			}
	
			// morph attributes
	
			var morphAttributes = this.morphAttributes;
	
			for ( name in morphAttributes ) {
	
				var morphArray = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
	
				for ( var i = 0, il = morphAttribute.length; i < il; i ++ ) {
	
					var attribute = morphAttribute[ i ];
	
					var newAttribute = convertBufferAttribute( attribute, indices );
	
					morphArray.push( newAttribute );
	
				}
	
				geometry2.morphAttributes[ name ] = morphArray;
	
			}
	
			// groups
	
			var groups = this.groups;
	
			for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				geometry2.addGroup( group.start, group.count, group.materialIndex );
	
			}
	
			return geometry2;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.5,
					type: 'BufferGeometry',
					generator: 'BufferGeometry.toJSON'
				}
			};
	
			// standard BufferGeometry serialization
	
			data.uuid = this.uuid;
			data.type = this.type;
			if ( this.name !== '' ) data.name = this.name;
			if ( Object.keys( this.userData ).length > 0 ) data.userData = this.userData;
	
			if ( this.parameters !== undefined ) {
	
				var parameters = this.parameters;
	
				for ( var key in parameters ) {
	
					if ( parameters[ key ] !== undefined ) data[ key ] = parameters[ key ];
	
				}
	
				return data;
	
			}
	
			data.data = { attributes: {} };
	
			var index = this.index;
	
			if ( index !== null ) {
	
				var array = Array.prototype.slice.call( index.array );
	
				data.data.index = {
					type: index.array.constructor.name,
					array: array
				};
	
			}
	
			var attributes = this.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
	
				var array = Array.prototype.slice.call( attribute.array );
	
				data.data.attributes[ key ] = {
					itemSize: attribute.itemSize,
					type: attribute.array.constructor.name,
					array: array,
					normalized: attribute.normalized
				};
	
			}
	
			var groups = this.groups;
	
			if ( groups.length > 0 ) {
	
				data.data.groups = JSON.parse( JSON.stringify( groups ) );
	
			}
	
			var boundingSphere = this.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				data.data.boundingSphere = {
					center: boundingSphere.center.toArray(),
					radius: boundingSphere.radius
				};
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			/*
			 // Handle primitives
	
			 var parameters = this.parameters;
	
			 if ( parameters !== undefined ) {
	
			 var values = [];
	
			 for ( var key in parameters ) {
	
			 values.push( parameters[ key ] );
	
			 }
	
			 var geometry = Object.create( this.constructor.prototype );
			 this.constructor.apply( geometry, values );
			 return geometry;
	
			 }
	
			 return new this.constructor().copy( this );
			 */
	
			return new BufferGeometry().copy( this );
	
		},
	
		copy: function ( source ) {
	
			var name, i, l;
	
			// reset
	
			this.index = null;
			this.attributes = {};
			this.morphAttributes = {};
			this.groups = [];
			this.boundingBox = null;
			this.boundingSphere = null;
	
			// name
	
			this.name = source.name;
	
			// index
	
			var index = source.index;
	
			if ( index !== null ) {
	
				this.setIndex( index.clone() );
	
			}
	
			// attributes
	
			var attributes = source.attributes;
	
			for ( name in attributes ) {
	
				var attribute = attributes[ name ];
				this.addAttribute( name, attribute.clone() );
	
			}
	
			// morph attributes
	
			var morphAttributes = source.morphAttributes;
	
			for ( name in morphAttributes ) {
	
				var array = [];
				var morphAttribute = morphAttributes[ name ]; // morphAttribute: array of Float32BufferAttributes
	
				for ( i = 0, l = morphAttribute.length; i < l; i ++ ) {
	
					array.push( morphAttribute[ i ].clone() );
	
				}
	
				this.morphAttributes[ name ] = array;
	
			}
	
			// groups
	
			var groups = source.groups;
	
			for ( i = 0, l = groups.length; i < l; i ++ ) {
	
				var group = groups[ i ];
				this.addGroup( group.start, group.count, group.materialIndex );
	
			}
	
			// bounding box
	
			var boundingBox = source.boundingBox;
	
			if ( boundingBox !== null ) {
	
				this.boundingBox = boundingBox.clone();
	
			}
	
			// bounding sphere
	
			var boundingSphere = source.boundingSphere;
	
			if ( boundingSphere !== null ) {
	
				this.boundingSphere = boundingSphere.clone();
	
			}
	
			// draw range
	
			this.drawRange.start = source.drawRange.start;
			this.drawRange.count = source.drawRange.count;
	
			// user data
	
			this.userData = source.userData;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// BoxGeometry
	
	function BoxGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		Geometry.call( this );
	
		this.type = 'BoxGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		this.fromBufferGeometry( new BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) );
		this.mergeVertices();
	
	}
	
	BoxGeometry.prototype = Object.create( Geometry.prototype );
	BoxGeometry.prototype.constructor = BoxGeometry;
	
	// BoxBufferGeometry
	
	function BoxBufferGeometry( width, height, depth, widthSegments, heightSegments, depthSegments ) {
	
		BufferGeometry.call( this );
	
		this.type = 'BoxBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			depth: depth,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			depthSegments: depthSegments
		};
	
		var scope = this;
	
		width = width || 1;
		height = height || 1;
		depth = depth || 1;
	
		// segments
	
		widthSegments = Math.floor( widthSegments ) || 1;
		heightSegments = Math.floor( heightSegments ) || 1;
		depthSegments = Math.floor( depthSegments ) || 1;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// helper variables
	
		var numberOfVertices = 0;
		var groupStart = 0;
	
		// build each side of the box geometry
	
		buildPlane( 'z', 'y', 'x', - 1, - 1, depth, height, width, depthSegments, heightSegments, 0 ); // px
		buildPlane( 'z', 'y', 'x', 1, - 1, depth, height, - width, depthSegments, heightSegments, 1 ); // nx
		buildPlane( 'x', 'z', 'y', 1, 1, width, depth, height, widthSegments, depthSegments, 2 ); // py
		buildPlane( 'x', 'z', 'y', 1, - 1, width, depth, - height, widthSegments, depthSegments, 3 ); // ny
		buildPlane( 'x', 'y', 'z', 1, - 1, width, height, depth, widthSegments, heightSegments, 4 ); // pz
		buildPlane( 'x', 'y', 'z', - 1, - 1, width, height, - depth, widthSegments, heightSegments, 5 ); // nz
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		function buildPlane( u, v, w, udir, vdir, width, height, depth, gridX, gridY, materialIndex ) {
	
			var segmentWidth = width / gridX;
			var segmentHeight = height / gridY;
	
			var widthHalf = width / 2;
			var heightHalf = height / 2;
			var depthHalf = depth / 2;
	
			var gridX1 = gridX + 1;
			var gridY1 = gridY + 1;
	
			var vertexCounter = 0;
			var groupCount = 0;
	
			var ix, iy;
	
			var vector = new Vector3();
	
			// generate vertices, normals and uvs
	
			for ( iy = 0; iy < gridY1; iy ++ ) {
	
				var y = iy * segmentHeight - heightHalf;
	
				for ( ix = 0; ix < gridX1; ix ++ ) {
	
					var x = ix * segmentWidth - widthHalf;
	
					// set values to correct vector component
	
					vector[ u ] = x * udir;
					vector[ v ] = y * vdir;
					vector[ w ] = depthHalf;
	
					// now apply vector to vertex buffer
	
					vertices.push( vector.x, vector.y, vector.z );
	
					// set values to correct vector component
	
					vector[ u ] = 0;
					vector[ v ] = 0;
					vector[ w ] = depth > 0 ? 1 : - 1;
	
					// now apply vector to normal buffer
	
					normals.push( vector.x, vector.y, vector.z );
	
					// uvs
	
					uvs.push( ix / gridX );
					uvs.push( 1 - ( iy / gridY ) );
	
					// counters
	
					vertexCounter += 1;
	
				}
	
			}
	
			// indices
	
			// 1. you need three indices to draw a single face
			// 2. a single segment consists of two faces
			// 3. so we need to generate six (2*3) indices per segment
	
			for ( iy = 0; iy < gridY; iy ++ ) {
	
				for ( ix = 0; ix < gridX; ix ++ ) {
	
					var a = numberOfVertices + ix + gridX1 * iy;
					var b = numberOfVertices + ix + gridX1 * ( iy + 1 );
					var c = numberOfVertices + ( ix + 1 ) + gridX1 * ( iy + 1 );
					var d = numberOfVertices + ( ix + 1 ) + gridX1 * iy;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
					// increase counter
	
					groupCount += 6;
	
				}
	
			}
	
			// add a group to the geometry. this will ensure multi material support
	
			scope.addGroup( groupStart, groupCount, materialIndex );
	
			// calculate new start value for groups
	
			groupStart += groupCount;
	
			// update total number of vertices
	
			numberOfVertices += vertexCounter;
	
		}
	
	}
	
	BoxBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	BoxBufferGeometry.prototype.constructor = BoxBufferGeometry;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// PlaneGeometry
	
	function PlaneGeometry( width, height, widthSegments, heightSegments ) {
	
		Geometry.call( this );
	
		this.type = 'PlaneGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		this.fromBufferGeometry( new PlaneBufferGeometry( width, height, widthSegments, heightSegments ) );
		this.mergeVertices();
	
	}
	
	PlaneGeometry.prototype = Object.create( Geometry.prototype );
	PlaneGeometry.prototype.constructor = PlaneGeometry;
	
	// PlaneBufferGeometry
	
	function PlaneBufferGeometry( width, height, widthSegments, heightSegments ) {
	
		BufferGeometry.call( this );
	
		this.type = 'PlaneBufferGeometry';
	
		this.parameters = {
			width: width,
			height: height,
			widthSegments: widthSegments,
			heightSegments: heightSegments
		};
	
		width = width || 1;
		height = height || 1;
	
		var width_half = width / 2;
		var height_half = height / 2;
	
		var gridX = Math.floor( widthSegments ) || 1;
		var gridY = Math.floor( heightSegments ) || 1;
	
		var gridX1 = gridX + 1;
		var gridY1 = gridY + 1;
	
		var segment_width = width / gridX;
		var segment_height = height / gridY;
	
		var ix, iy;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// generate vertices, normals and uvs
	
		for ( iy = 0; iy < gridY1; iy ++ ) {
	
			var y = iy * segment_height - height_half;
	
			for ( ix = 0; ix < gridX1; ix ++ ) {
	
				var x = ix * segment_width - width_half;
	
				vertices.push( x, - y, 0 );
	
				normals.push( 0, 0, 1 );
	
				uvs.push( ix / gridX );
				uvs.push( 1 - ( iy / gridY ) );
	
			}
	
		}
	
		// indices
	
		for ( iy = 0; iy < gridY; iy ++ ) {
	
			for ( ix = 0; ix < gridX; ix ++ ) {
	
				var a = ix + gridX1 * iy;
				var b = ix + gridX1 * ( iy + 1 );
				var c = ( ix + 1 ) + gridX1 * ( iy + 1 );
				var d = ( ix + 1 ) + gridX1 * iy;
	
				// faces
	
				indices.push( a, b, d );
				indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	}
	
	PlaneBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PlaneBufferGeometry.prototype.constructor = PlaneBufferGeometry;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	var materialId = 0;
	
	function Material() {
	
		Object.defineProperty( this, 'id', { value: materialId ++ } );
	
		this.uuid = _Math.generateUUID();
	
		this.name = '';
		this.type = 'Material';
	
		this.fog = true;
		this.lights = true;
	
		this.blending = NormalBlending;
		this.side = FrontSide;
		this.flatShading = false;
		this.vertexColors = NoColors; // THREE.NoColors, THREE.VertexColors, THREE.FaceColors
	
		this.opacity = 1;
		this.transparent = false;
	
		this.blendSrc = SrcAlphaFactor;
		this.blendDst = OneMinusSrcAlphaFactor;
		this.blendEquation = AddEquation;
		this.blendSrcAlpha = null;
		this.blendDstAlpha = null;
		this.blendEquationAlpha = null;
	
		this.depthFunc = LessEqualDepth;
		this.depthTest = true;
		this.depthWrite = true;
	
		this.clippingPlanes = null;
		this.clipIntersection = false;
		this.clipShadows = false;
	
		this.shadowSide = null;
	
		this.colorWrite = true;
	
		this.precision = null; // override the renderer's default precision for this material
	
		this.polygonOffset = false;
		this.polygonOffsetFactor = 0;
		this.polygonOffsetUnits = 0;
	
		this.dithering = false;
	
		this.alphaTest = 0;
		this.premultipliedAlpha = false;
	
		this.visible = true;
	
		this.userData = {};
	
		this.needsUpdate = true;
	
	}
	
	Material.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: Material,
	
		isMaterial: true,
	
		onBeforeCompile: function () {},
	
		setValues: function ( values ) {
	
			if ( values === undefined ) return;
	
			for ( var key in values ) {
	
				var newValue = values[ key ];
	
				if ( newValue === undefined ) {
	
					console.warn( "THREE.Material: '" + key + "' parameter is undefined." );
					continue;
	
				}
	
				// for backward compatability if shading is set in the constructor
				if ( key === 'shading' ) {
	
					console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
					this.flatShading = ( newValue === FlatShading ) ? true : false;
					continue;
	
				}
	
				var currentValue = this[ key ];
	
				if ( currentValue === undefined ) {
	
					console.warn( "THREE." + this.type + ": '" + key + "' is not a property of this material." );
					continue;
	
				}
	
				if ( currentValue && currentValue.isColor ) {
	
					currentValue.set( newValue );
	
				} else if ( ( currentValue && currentValue.isVector3 ) && ( newValue && newValue.isVector3 ) ) {
	
					currentValue.copy( newValue );
	
				} else {
	
					this[ key ] = newValue;
	
				}
	
			}
	
		},
	
		toJSON: function ( meta ) {
	
			var isRoot = ( meta === undefined || typeof meta === 'string' );
	
			if ( isRoot ) {
	
				meta = {
					textures: {},
					images: {}
				};
	
			}
	
			var data = {
				metadata: {
					version: 4.5,
					type: 'Material',
					generator: 'Material.toJSON'
				}
			};
	
			// standard Material serialization
			data.uuid = this.uuid;
			data.type = this.type;
	
			if ( this.name !== '' ) data.name = this.name;
	
			if ( this.color && this.color.isColor ) data.color = this.color.getHex();
	
			if ( this.roughness !== undefined ) data.roughness = this.roughness;
			if ( this.metalness !== undefined ) data.metalness = this.metalness;
	
			if ( this.emissive && this.emissive.isColor ) data.emissive = this.emissive.getHex();
			if ( this.emissiveIntensity !== 1 ) data.emissiveIntensity = this.emissiveIntensity;
	
			if ( this.specular && this.specular.isColor ) data.specular = this.specular.getHex();
			if ( this.shininess !== undefined ) data.shininess = this.shininess;
			if ( this.clearCoat !== undefined ) data.clearCoat = this.clearCoat;
			if ( this.clearCoatRoughness !== undefined ) data.clearCoatRoughness = this.clearCoatRoughness;
	
			if ( this.map && this.map.isTexture ) data.map = this.map.toJSON( meta ).uuid;
			if ( this.alphaMap && this.alphaMap.isTexture ) data.alphaMap = this.alphaMap.toJSON( meta ).uuid;
			if ( this.lightMap && this.lightMap.isTexture ) data.lightMap = this.lightMap.toJSON( meta ).uuid;
	
			if ( this.aoMap && this.aoMap.isTexture ) {
	
				data.aoMap = this.aoMap.toJSON( meta ).uuid;
				data.aoMapIntensity = this.aoMapIntensity;
	
			}
	
			if ( this.bumpMap && this.bumpMap.isTexture ) {
	
				data.bumpMap = this.bumpMap.toJSON( meta ).uuid;
				data.bumpScale = this.bumpScale;
	
			}
	
			if ( this.normalMap && this.normalMap.isTexture ) {
	
				data.normalMap = this.normalMap.toJSON( meta ).uuid;
				data.normalMapType = this.normalMapType;
				data.normalScale = this.normalScale.toArray();
	
			}
	
			if ( this.displacementMap && this.displacementMap.isTexture ) {
	
				data.displacementMap = this.displacementMap.toJSON( meta ).uuid;
				data.displacementScale = this.displacementScale;
				data.displacementBias = this.displacementBias;
	
			}
	
			if ( this.roughnessMap && this.roughnessMap.isTexture ) data.roughnessMap = this.roughnessMap.toJSON( meta ).uuid;
			if ( this.metalnessMap && this.metalnessMap.isTexture ) data.metalnessMap = this.metalnessMap.toJSON( meta ).uuid;
	
			if ( this.emissiveMap && this.emissiveMap.isTexture ) data.emissiveMap = this.emissiveMap.toJSON( meta ).uuid;
			if ( this.specularMap && this.specularMap.isTexture ) data.specularMap = this.specularMap.toJSON( meta ).uuid;
	
			if ( this.envMap && this.envMap.isTexture ) {
	
				data.envMap = this.envMap.toJSON( meta ).uuid;
				data.reflectivity = this.reflectivity; // Scale behind envMap
	
				if ( this.combine !== undefined ) data.combine = this.combine;
				if ( this.envMapIntensity !== undefined ) data.envMapIntensity = this.envMapIntensity;
	
			}
	
			if ( this.gradientMap && this.gradientMap.isTexture ) {
	
				data.gradientMap = this.gradientMap.toJSON( meta ).uuid;
	
			}
	
			if ( this.size !== undefined ) data.size = this.size;
			if ( this.sizeAttenuation !== undefined ) data.sizeAttenuation = this.sizeAttenuation;
	
			if ( this.blending !== NormalBlending ) data.blending = this.blending;
			if ( this.flatShading === true ) data.flatShading = this.flatShading;
			if ( this.side !== FrontSide ) data.side = this.side;
			if ( this.vertexColors !== NoColors ) data.vertexColors = this.vertexColors;
	
			if ( this.opacity < 1 ) data.opacity = this.opacity;
			if ( this.transparent === true ) data.transparent = this.transparent;
	
			data.depthFunc = this.depthFunc;
			data.depthTest = this.depthTest;
			data.depthWrite = this.depthWrite;
	
			// rotation (SpriteMaterial)
			if ( this.rotation !== 0 ) data.rotation = this.rotation;
	
			if ( this.polygonOffset === true ) data.polygonOffset = true;
			if ( this.polygonOffsetFactor !== 0 ) data.polygonOffsetFactor = this.polygonOffsetFactor;
			if ( this.polygonOffsetUnits !== 0 ) data.polygonOffsetUnits = this.polygonOffsetUnits;
	
			if ( this.linewidth !== 1 ) data.linewidth = this.linewidth;
			if ( this.dashSize !== undefined ) data.dashSize = this.dashSize;
			if ( this.gapSize !== undefined ) data.gapSize = this.gapSize;
			if ( this.scale !== undefined ) data.scale = this.scale;
	
			if ( this.dithering === true ) data.dithering = true;
	
			if ( this.alphaTest > 0 ) data.alphaTest = this.alphaTest;
			if ( this.premultipliedAlpha === true ) data.premultipliedAlpha = this.premultipliedAlpha;
	
			if ( this.wireframe === true ) data.wireframe = this.wireframe;
			if ( this.wireframeLinewidth > 1 ) data.wireframeLinewidth = this.wireframeLinewidth;
			if ( this.wireframeLinecap !== 'round' ) data.wireframeLinecap = this.wireframeLinecap;
			if ( this.wireframeLinejoin !== 'round' ) data.wireframeLinejoin = this.wireframeLinejoin;
	
			if ( this.morphTargets === true ) data.morphTargets = true;
			if ( this.skinning === true ) data.skinning = true;
	
			if ( this.visible === false ) data.visible = false;
			if ( JSON.stringify( this.userData ) !== '{}' ) data.userData = this.userData;
	
			// TODO: Copied from Object3D.toJSON
	
			function extractFromCache( cache ) {
	
				var values = [];
	
				for ( var key in cache ) {
	
					var data = cache[ key ];
					delete data.metadata;
					values.push( data );
	
				}
	
				return values;
	
			}
	
			if ( isRoot ) {
	
				var textures = extractFromCache( meta.textures );
				var images = extractFromCache( meta.images );
	
				if ( textures.length > 0 ) data.textures = textures;
				if ( images.length > 0 ) data.images = images;
	
			}
	
			return data;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.name = source.name;
	
			this.fog = source.fog;
			this.lights = source.lights;
	
			this.blending = source.blending;
			this.side = source.side;
			this.flatShading = source.flatShading;
			this.vertexColors = source.vertexColors;
	
			this.opacity = source.opacity;
			this.transparent = source.transparent;
	
			this.blendSrc = source.blendSrc;
			this.blendDst = source.blendDst;
			this.blendEquation = source.blendEquation;
			this.blendSrcAlpha = source.blendSrcAlpha;
			this.blendDstAlpha = source.blendDstAlpha;
			this.blendEquationAlpha = source.blendEquationAlpha;
	
			this.depthFunc = source.depthFunc;
			this.depthTest = source.depthTest;
			this.depthWrite = source.depthWrite;
	
			this.colorWrite = source.colorWrite;
	
			this.precision = source.precision;
	
			this.polygonOffset = source.polygonOffset;
			this.polygonOffsetFactor = source.polygonOffsetFactor;
			this.polygonOffsetUnits = source.polygonOffsetUnits;
	
			this.dithering = source.dithering;
	
			this.alphaTest = source.alphaTest;
			this.premultipliedAlpha = source.premultipliedAlpha;
	
			this.visible = source.visible;
			this.userData = JSON.parse( JSON.stringify( source.userData ) );
	
			this.clipShadows = source.clipShadows;
			this.clipIntersection = source.clipIntersection;
	
			var srcPlanes = source.clippingPlanes,
				dstPlanes = null;
	
			if ( srcPlanes !== null ) {
	
				var n = srcPlanes.length;
				dstPlanes = new Array( n );
	
				for ( var i = 0; i !== n; ++ i )
					dstPlanes[ i ] = srcPlanes[ i ].clone();
	
			}
	
			this.clippingPlanes = dstPlanes;
	
			this.shadowSide = source.shadowSide;
	
			return this;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  defines: { "label" : "value" },
	 *  uniforms: { "parameter1": { value: 1.0 }, "parameter2": { value2: 2 } },
	 *
	 *  fragmentShader: <string>,
	 *  vertexShader: <string>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  lights: <bool>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	function ShaderMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'ShaderMaterial';
	
		this.defines = {};
		this.uniforms = {};
	
		this.vertexShader = 'void main() {\n\tgl_Position = projectionMatrix * modelViewMatrix * vec4( position, 1.0 );\n}';
		this.fragmentShader = 'void main() {\n\tgl_FragColor = vec4( 1.0, 0.0, 0.0, 1.0 );\n}';
	
		this.linewidth = 1;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false; // set to use scene fog
		this.lights = false; // set to use scene lights
		this.clipping = false; // set to use user-defined clipping planes
	
		this.skinning = false; // set to use skinning attribute streams
		this.morphTargets = false; // set to use morph targets
		this.morphNormals = false; // set to use morph normals
	
		this.extensions = {
			derivatives: false, // set to use derivatives
			fragDepth: false, // set to use fragment depth values
			drawBuffers: false, // set to use draw buffers
			shaderTextureLOD: false // set to use shader texture LOD
		};
	
		// When rendered geometry doesn't include these attributes but the material does,
		// use these default values in WebGL. This avoids errors when buffer data is missing.
		this.defaultAttributeValues = {
			'color': [ 1, 1, 1 ],
			'uv': [ 0, 0 ],
			'uv2': [ 0, 0 ]
		};
	
		this.index0AttributeName = undefined;
		this.uniformsNeedUpdate = false;
	
		if ( parameters !== undefined ) {
	
			if ( parameters.attributes !== undefined ) {
	
				console.error( 'THREE.ShaderMaterial: attributes should now be defined in THREE.BufferGeometry instead.' );
	
			}
	
			this.setValues( parameters );
	
		}
	
	}
	
	ShaderMaterial.prototype = Object.create( Material.prototype );
	ShaderMaterial.prototype.constructor = ShaderMaterial;
	
	ShaderMaterial.prototype.isShaderMaterial = true;
	
	ShaderMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.fragmentShader = source.fragmentShader;
		this.vertexShader = source.vertexShader;
	
		this.uniforms = cloneUniforms( source.uniforms );
	
		this.defines = Object.assign( {}, source.defines );
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.lights = source.lights;
		this.clipping = source.clipping;
	
		this.skinning = source.skinning;
	
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		this.extensions = source.extensions;
	
		return this;
	
	};
	
	ShaderMaterial.prototype.toJSON = function ( meta ) {
	
		var data = Material.prototype.toJSON.call( this, meta );
	
		data.uniforms = {};
	
		for ( var name in this.uniforms ) {
	
			var uniform = this.uniforms[ name ];
			var value = uniform.value;
	
			if ( value && value.isTexture ) {
	
				data.uniforms[ name ] = {
					type: 't',
					value: value.toJSON( meta ).uuid
				};
	
			} else if ( value && value.isColor ) {
	
				data.uniforms[ name ] = {
					type: 'c',
					value: value.getHex()
				};
	
			} else if ( value && value.isVector2 ) {
	
				data.uniforms[ name ] = {
					type: 'v2',
					value: value.toArray()
				};
	
			} else if ( value && value.isVector3 ) {
	
				data.uniforms[ name ] = {
					type: 'v3',
					value: value.toArray()
				};
	
			} else if ( value && value.isVector4 ) {
	
				data.uniforms[ name ] = {
					type: 'v4',
					value: value.toArray()
				};
	
			} else if ( value && value.isMatrix3 ) {
	
				data.uniforms[ name ] = {
					type: 'm3',
					value: value.toArray()
				};
	
			} else if ( value && value.isMatrix4 ) {
	
				data.uniforms[ name ] = {
					type: 'm4',
					value: value.toArray()
				};
	
			} else {
	
				data.uniforms[ name ] = {
					value: value
				};
	
				// note: the array variants v2v, v3v, v4v, m4v and tv are not supported so far
	
			}
	
		}
	
		if ( Object.keys( this.defines ).length > 0 ) data.defines = this.defines;
	
		data.vertexShader = this.vertexShader;
		data.fragmentShader = this.fragmentShader;
	
		var extensions = {};
	
		for ( var key in this.extensions ) {
	
			if ( this.extensions[ key ] === true ) extensions[ key ] = true;
	
		}
	
		if ( Object.keys( extensions ).length > 0 ) data.extensions = extensions;
	
		return data;
	
	};
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	function Ray( origin, direction ) {
	
		this.origin = ( origin !== undefined ) ? origin : new Vector3();
		this.direction = ( direction !== undefined ) ? direction : new Vector3();
	
	}
	
	Object.assign( Ray.prototype, {
	
		set: function ( origin, direction ) {
	
			this.origin.copy( origin );
			this.direction.copy( direction );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( ray ) {
	
			this.origin.copy( ray.origin );
			this.direction.copy( ray.direction );
	
			return this;
	
		},
	
		at: function ( t, target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Ray: .at() target is now required' );
				target = new Vector3();
	
			}
	
			return target.copy( this.direction ).multiplyScalar( t ).add( this.origin );
	
		},
	
		lookAt: function ( v ) {
	
			this.direction.copy( v ).sub( this.origin ).normalize();
	
			return this;
	
		},
	
		recast: function () {
	
			var v1 = new Vector3();
	
			return function recast( t ) {
	
				this.origin.copy( this.at( t, v1 ) );
	
				return this;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Ray: .closestPointToPoint() target is now required' );
				target = new Vector3();
	
			}
	
			target.subVectors( point, this.origin );
	
			var directionDistance = target.dot( this.direction );
	
			if ( directionDistance < 0 ) {
	
				return target.copy( this.origin );
	
			}
	
			return target.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
		},
	
		distanceToPoint: function ( point ) {
	
			return Math.sqrt( this.distanceSqToPoint( point ) );
	
		},
	
		distanceSqToPoint: function () {
	
			var v1 = new Vector3();
	
			return function distanceSqToPoint( point ) {
	
				var directionDistance = v1.subVectors( point, this.origin ).dot( this.direction );
	
				// point behind the ray
	
				if ( directionDistance < 0 ) {
	
					return this.origin.distanceToSquared( point );
	
				}
	
				v1.copy( this.direction ).multiplyScalar( directionDistance ).add( this.origin );
	
				return v1.distanceToSquared( point );
	
			};
	
		}(),
	
		distanceSqToSegment: function () {
	
			var segCenter = new Vector3();
			var segDir = new Vector3();
			var diff = new Vector3();
	
			return function distanceSqToSegment( v0, v1, optionalPointOnRay, optionalPointOnSegment ) {
	
				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteDistRaySegment.h
				// It returns the min distance between the ray and the segment
				// defined by v0 and v1
				// It can also set two optional targets :
				// - The closest point on the ray
				// - The closest point on the segment
	
				segCenter.copy( v0 ).add( v1 ).multiplyScalar( 0.5 );
				segDir.copy( v1 ).sub( v0 ).normalize();
				diff.copy( this.origin ).sub( segCenter );
	
				var segExtent = v0.distanceTo( v1 ) * 0.5;
				var a01 = - this.direction.dot( segDir );
				var b0 = diff.dot( this.direction );
				var b1 = - diff.dot( segDir );
				var c = diff.lengthSq();
				var det = Math.abs( 1 - a01 * a01 );
				var s0, s1, sqrDist, extDet;
	
				if ( det > 0 ) {
	
					// The ray and segment are not parallel.
	
					s0 = a01 * b1 - b0;
					s1 = a01 * b0 - b1;
					extDet = segExtent * det;
	
					if ( s0 >= 0 ) {
	
						if ( s1 >= - extDet ) {
	
							if ( s1 <= extDet ) {
	
								// region 0
								// Minimum at interior points of ray and segment.
	
								var invDet = 1 / det;
								s0 *= invDet;
								s1 *= invDet;
								sqrDist = s0 * ( s0 + a01 * s1 + 2 * b0 ) + s1 * ( a01 * s0 + s1 + 2 * b1 ) + c;
	
							} else {
	
								// region 1
	
								s1 = segExtent;
								s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
								sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
							}
	
						} else {
	
							// region 5
	
							s1 = - segExtent;
							s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					} else {
	
						if ( s1 <= - extDet ) {
	
							// region 4
	
							s0 = Math.max( 0, - ( - a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? - segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						} else if ( s1 <= extDet ) {
	
							// region 3
	
							s0 = 0;
							s1 = Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = s1 * ( s1 + 2 * b1 ) + c;
	
						} else {
	
							// region 2
	
							s0 = Math.max( 0, - ( a01 * segExtent + b0 ) );
							s1 = ( s0 > 0 ) ? segExtent : Math.min( Math.max( - segExtent, - b1 ), segExtent );
							sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
						}
	
					}
	
				} else {
	
					// Ray and segment are parallel.
	
					s1 = ( a01 > 0 ) ? - segExtent : segExtent;
					s0 = Math.max( 0, - ( a01 * s1 + b0 ) );
					sqrDist = - s0 * s0 + s1 * ( s1 + 2 * b1 ) + c;
	
				}
	
				if ( optionalPointOnRay ) {
	
					optionalPointOnRay.copy( this.direction ).multiplyScalar( s0 ).add( this.origin );
	
				}
	
				if ( optionalPointOnSegment ) {
	
					optionalPointOnSegment.copy( segDir ).multiplyScalar( s1 ).add( segCenter );
	
				}
	
				return sqrDist;
	
			};
	
		}(),
	
		intersectSphere: function () {
	
			var v1 = new Vector3();
	
			return function intersectSphere( sphere, target ) {
	
				v1.subVectors( sphere.center, this.origin );
				var tca = v1.dot( this.direction );
				var d2 = v1.dot( v1 ) - tca * tca;
				var radius2 = sphere.radius * sphere.radius;
	
				if ( d2 > radius2 ) return null;
	
				var thc = Math.sqrt( radius2 - d2 );
	
				// t0 = first intersect point - entrance on front of sphere
				var t0 = tca - thc;
	
				// t1 = second intersect point - exit point on back of sphere
				var t1 = tca + thc;
	
				// test to see if both t0 and t1 are behind the ray - if so, return null
				if ( t0 < 0 && t1 < 0 ) return null;
	
				// test to see if t0 is behind the ray:
				// if it is, the ray is inside the sphere, so return the second exit point scaled by t1,
				// in order to always return an intersect point that is in front of the ray.
				if ( t0 < 0 ) return this.at( t1, target );
	
				// else t0 is in front of the ray, so return the first collision point scaled by t0
				return this.at( t0, target );
	
			};
	
		}(),
	
		intersectsSphere: function ( sphere ) {
	
			return this.distanceSqToPoint( sphere.center ) <= ( sphere.radius * sphere.radius );
	
		},
	
		distanceToPlane: function ( plane ) {
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator === 0 ) {
	
				// line is coplanar, return origin
				if ( plane.distanceToPoint( this.origin ) === 0 ) {
	
					return 0;
	
				}
	
				// Null is preferable to undefined since undefined means.... it is undefined
	
				return null;
	
			}
	
			var t = - ( this.origin.dot( plane.normal ) + plane.constant ) / denominator;
	
			// Return if the ray never intersects the plane
	
			return t >= 0 ? t : null;
	
		},
	
		intersectPlane: function ( plane, target ) {
	
			var t = this.distanceToPlane( plane );
	
			if ( t === null ) {
	
				return null;
	
			}
	
			return this.at( t, target );
	
		},
	
		intersectsPlane: function ( plane ) {
	
			// check if the ray lies on the plane first
	
			var distToPoint = plane.distanceToPoint( this.origin );
	
			if ( distToPoint === 0 ) {
	
				return true;
	
			}
	
			var denominator = plane.normal.dot( this.direction );
	
			if ( denominator * distToPoint < 0 ) {
	
				return true;
	
			}
	
			// ray origin is behind the plane (and is pointing behind it)
	
			return false;
	
		},
	
		intersectBox: function ( box, target ) {
	
			var tmin, tmax, tymin, tymax, tzmin, tzmax;
	
			var invdirx = 1 / this.direction.x,
				invdiry = 1 / this.direction.y,
				invdirz = 1 / this.direction.z;
	
			var origin = this.origin;
	
			if ( invdirx >= 0 ) {
	
				tmin = ( box.min.x - origin.x ) * invdirx;
				tmax = ( box.max.x - origin.x ) * invdirx;
	
			} else {
	
				tmin = ( box.max.x - origin.x ) * invdirx;
				tmax = ( box.min.x - origin.x ) * invdirx;
	
			}
	
			if ( invdiry >= 0 ) {
	
				tymin = ( box.min.y - origin.y ) * invdiry;
				tymax = ( box.max.y - origin.y ) * invdiry;
	
			} else {
	
				tymin = ( box.max.y - origin.y ) * invdiry;
				tymax = ( box.min.y - origin.y ) * invdiry;
	
			}
	
			if ( ( tmin > tymax ) || ( tymin > tmax ) ) return null;
	
			// These lines also handle the case where tmin or tmax is NaN
			// (result of 0 * Infinity). x !== x returns true if x is NaN
	
			if ( tymin > tmin || tmin !== tmin ) tmin = tymin;
	
			if ( tymax < tmax || tmax !== tmax ) tmax = tymax;
	
			if ( invdirz >= 0 ) {
	
				tzmin = ( box.min.z - origin.z ) * invdirz;
				tzmax = ( box.max.z - origin.z ) * invdirz;
	
			} else {
	
				tzmin = ( box.max.z - origin.z ) * invdirz;
				tzmax = ( box.min.z - origin.z ) * invdirz;
	
			}
	
			if ( ( tmin > tzmax ) || ( tzmin > tmax ) ) return null;
	
			if ( tzmin > tmin || tmin !== tmin ) tmin = tzmin;
	
			if ( tzmax < tmax || tmax !== tmax ) tmax = tzmax;
	
			//return point closest to the ray (positive side)
	
			if ( tmax < 0 ) return null;
	
			return this.at( tmin >= 0 ? tmin : tmax, target );
	
		},
	
		intersectsBox: ( function () {
	
			var v = new Vector3();
	
			return function intersectsBox( box ) {
	
				return this.intersectBox( box, v ) !== null;
	
			};
	
		} )(),
	
		intersectTriangle: function () {
	
			// Compute the offset origin, edges, and normal.
			var diff = new Vector3();
			var edge1 = new Vector3();
			var edge2 = new Vector3();
			var normal = new Vector3();
	
			return function intersectTriangle( a, b, c, backfaceCulling, target ) {
	
				// from http://www.geometrictools.com/GTEngine/Include/Mathematics/GteIntrRay3Triangle3.h
	
				edge1.subVectors( b, a );
				edge2.subVectors( c, a );
				normal.crossVectors( edge1, edge2 );
	
				// Solve Q + t*D = b1*E1 + b2*E2 (Q = kDiff, D = ray direction,
				// E1 = kEdge1, E2 = kEdge2, N = Cross(E1,E2)) by
				//   |Dot(D,N)|*b1 = sign(Dot(D,N))*Dot(D,Cross(Q,E2))
				//   |Dot(D,N)|*b2 = sign(Dot(D,N))*Dot(D,Cross(E1,Q))
				//   |Dot(D,N)|*t = -sign(Dot(D,N))*Dot(Q,N)
				var DdN = this.direction.dot( normal );
				var sign;
	
				if ( DdN > 0 ) {
	
					if ( backfaceCulling ) return null;
					sign = 1;
	
				} else if ( DdN < 0 ) {
	
					sign = - 1;
					DdN = - DdN;
	
				} else {
	
					return null;
	
				}
	
				diff.subVectors( this.origin, a );
				var DdQxE2 = sign * this.direction.dot( edge2.crossVectors( diff, edge2 ) );
	
				// b1 < 0, no intersection
				if ( DdQxE2 < 0 ) {
	
					return null;
	
				}
	
				var DdE1xQ = sign * this.direction.dot( edge1.cross( diff ) );
	
				// b2 < 0, no intersection
				if ( DdE1xQ < 0 ) {
	
					return null;
	
				}
	
				// b1+b2 > 1, no intersection
				if ( DdQxE2 + DdE1xQ > DdN ) {
	
					return null;
	
				}
	
				// Line intersects triangle, check if ray does.
				var QdN = - sign * diff.dot( normal );
	
				// t < 0, no intersection
				if ( QdN < 0 ) {
	
					return null;
	
				}
	
				// Ray intersects triangle.
				return this.at( QdN / DdN, target );
	
			};
	
		}(),
	
		applyMatrix4: function ( matrix4 ) {
	
			this.origin.applyMatrix4( matrix4 );
			this.direction.transformDirection( matrix4 );
	
			return this;
	
		},
	
		equals: function ( ray ) {
	
			return ray.origin.equals( this.origin ) && ray.direction.equals( this.direction );
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Triangle( a, b, c ) {
	
		this.a = ( a !== undefined ) ? a : new Vector3();
		this.b = ( b !== undefined ) ? b : new Vector3();
		this.c = ( c !== undefined ) ? c : new Vector3();
	
	}
	
	Object.assign( Triangle, {
	
		getNormal: function () {
	
			var v0 = new Vector3();
	
			return function getNormal( a, b, c, target ) {
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Triangle: .getNormal() target is now required' );
					target = new Vector3();
	
				}
	
				target.subVectors( c, b );
				v0.subVectors( a, b );
				target.cross( v0 );
	
				var targetLengthSq = target.lengthSq();
				if ( targetLengthSq > 0 ) {
	
					return target.multiplyScalar( 1 / Math.sqrt( targetLengthSq ) );
	
				}
	
				return target.set( 0, 0, 0 );
	
			};
	
		}(),
	
		// static/instance method to calculate barycentric coordinates
		// based on: http://www.blackpawn.com/texts/pointinpoly/default.html
		getBarycoord: function () {
	
			var v0 = new Vector3();
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			return function getBarycoord( point, a, b, c, target ) {
	
				v0.subVectors( c, a );
				v1.subVectors( b, a );
				v2.subVectors( point, a );
	
				var dot00 = v0.dot( v0 );
				var dot01 = v0.dot( v1 );
				var dot02 = v0.dot( v2 );
				var dot11 = v1.dot( v1 );
				var dot12 = v1.dot( v2 );
	
				var denom = ( dot00 * dot11 - dot01 * dot01 );
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Triangle: .getBarycoord() target is now required' );
					target = new Vector3();
	
				}
	
				// collinear or singular triangle
				if ( denom === 0 ) {
	
					// arbitrary location outside of triangle?
					// not sure if this is the best idea, maybe should be returning undefined
					return target.set( - 2, - 1, - 1 );
	
				}
	
				var invDenom = 1 / denom;
				var u = ( dot11 * dot02 - dot01 * dot12 ) * invDenom;
				var v = ( dot00 * dot12 - dot01 * dot02 ) * invDenom;
	
				// barycentric coordinates must always sum to 1
				return target.set( 1 - u - v, v, u );
	
			};
	
		}(),
	
		containsPoint: function () {
	
			var v1 = new Vector3();
	
			return function containsPoint( point, a, b, c ) {
	
				Triangle.getBarycoord( point, a, b, c, v1 );
	
				return ( v1.x >= 0 ) && ( v1.y >= 0 ) && ( ( v1.x + v1.y ) <= 1 );
	
			};
	
		}(),
	
		getUV: function () {
	
			var barycoord = new Vector3();
	
			return function getUV( point, p1, p2, p3, uv1, uv2, uv3, target ) {
	
				this.getBarycoord( point, p1, p2, p3, barycoord );
	
				target.set( 0, 0 );
				target.addScaledVector( uv1, barycoord.x );
				target.addScaledVector( uv2, barycoord.y );
				target.addScaledVector( uv3, barycoord.z );
	
				return target;
	
			};
	
		}()
	
	} );
	
	Object.assign( Triangle.prototype, {
	
		set: function ( a, b, c ) {
	
			this.a.copy( a );
			this.b.copy( b );
			this.c.copy( c );
	
			return this;
	
		},
	
		setFromPointsAndIndices: function ( points, i0, i1, i2 ) {
	
			this.a.copy( points[ i0 ] );
			this.b.copy( points[ i1 ] );
			this.c.copy( points[ i2 ] );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( triangle ) {
	
			this.a.copy( triangle.a );
			this.b.copy( triangle.b );
			this.c.copy( triangle.c );
	
			return this;
	
		},
	
		getArea: function () {
	
			var v0 = new Vector3();
			var v1 = new Vector3();
	
			return function getArea() {
	
				v0.subVectors( this.c, this.b );
				v1.subVectors( this.a, this.b );
	
				return v0.cross( v1 ).length() * 0.5;
	
			};
	
		}(),
	
		getMidpoint: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Triangle: .getMidpoint() target is now required' );
				target = new Vector3();
	
			}
	
			return target.addVectors( this.a, this.b ).add( this.c ).multiplyScalar( 1 / 3 );
	
		},
	
		getNormal: function ( target ) {
	
			return Triangle.getNormal( this.a, this.b, this.c, target );
	
		},
	
		getPlane: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Triangle: .getPlane() target is now required' );
				target = new Vector3();
	
			}
	
			return target.setFromCoplanarPoints( this.a, this.b, this.c );
	
		},
	
		getBarycoord: function ( point, target ) {
	
			return Triangle.getBarycoord( point, this.a, this.b, this.c, target );
	
		},
	
		containsPoint: function ( point ) {
	
			return Triangle.containsPoint( point, this.a, this.b, this.c );
	
		},
	
		getUV: function ( point, uv1, uv2, uv3, result ) {
	
			return Triangle.getUV( point, this.a, this.b, this.c, uv1, uv2, uv3, result );
	
		},
	
		intersectsBox: function ( box ) {
	
			return box.intersectsTriangle( this );
	
		},
	
		closestPointToPoint: function () {
	
			var vab = new Vector3();
			var vac = new Vector3();
			var vbc = new Vector3();
			var vap = new Vector3();
			var vbp = new Vector3();
			var vcp = new Vector3();
	
			return function closestPointToPoint( p, target ) {
	
				if ( target === undefined ) {
	
					console.warn( 'THREE.Triangle: .closestPointToPoint() target is now required' );
					target = new Vector3();
	
				}
	
				var a = this.a, b = this.b, c = this.c;
				var v, w;
	
				// algorithm thanks to Real-Time Collision Detection by Christer Ericson,
				// published by Morgan Kaufmann Publishers, (c) 2005 Elsevier Inc.,
				// under the accompanying license; see chapter 5.1.5 for detailed explanation.
				// basically, we're distinguishing which of the voronoi regions of the triangle
				// the point lies in with the minimum amount of redundant computation.
	
				vab.subVectors( b, a );
				vac.subVectors( c, a );
				vap.subVectors( p, a );
				var d1 = vab.dot( vap );
				var d2 = vac.dot( vap );
				if ( d1 <= 0 && d2 <= 0 ) {
	
					// vertex region of A; barycentric coords (1, 0, 0)
					return target.copy( a );
	
				}
	
				vbp.subVectors( p, b );
				var d3 = vab.dot( vbp );
				var d4 = vac.dot( vbp );
				if ( d3 >= 0 && d4 <= d3 ) {
	
					// vertex region of B; barycentric coords (0, 1, 0)
					return target.copy( b );
	
				}
	
				var vc = d1 * d4 - d3 * d2;
				if ( vc <= 0 && d1 >= 0 && d3 <= 0 ) {
	
					v = d1 / ( d1 - d3 );
					// edge region of AB; barycentric coords (1-v, v, 0)
					return target.copy( a ).addScaledVector( vab, v );
	
				}
	
				vcp.subVectors( p, c );
				var d5 = vab.dot( vcp );
				var d6 = vac.dot( vcp );
				if ( d6 >= 0 && d5 <= d6 ) {
	
					// vertex region of C; barycentric coords (0, 0, 1)
					return target.copy( c );
	
				}
	
				var vb = d5 * d2 - d1 * d6;
				if ( vb <= 0 && d2 >= 0 && d6 <= 0 ) {
	
					w = d2 / ( d2 - d6 );
					// edge region of AC; barycentric coords (1-w, 0, w)
					return target.copy( a ).addScaledVector( vac, w );
	
				}
	
				var va = d3 * d6 - d5 * d4;
				if ( va <= 0 && ( d4 - d3 ) >= 0 && ( d5 - d6 ) >= 0 ) {
	
					vbc.subVectors( c, b );
					w = ( d4 - d3 ) / ( ( d4 - d3 ) + ( d5 - d6 ) );
					// edge region of BC; barycentric coords (0, 1-w, w)
					return target.copy( b ).addScaledVector( vbc, w ); // edge region of BC
	
				}
	
				// face region
				var denom = 1 / ( va + vb + vc );
				// u = va * denom
				v = vb * denom;
				w = vc * denom;
				return target.copy( a ).addScaledVector( vab, v ).addScaledVector( vac, w );
	
			};
	
		}(),
	
		equals: function ( triangle ) {
	
			return triangle.a.equals( this.a ) && triangle.b.equals( this.b ) && triangle.c.equals( this.c );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  depthTest: <bool>,
	 *  depthWrite: <bool>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>
	 * }
	 */
	
	function MeshBasicMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'MeshBasicMaterial';
	
		this.color = new Color( 0xffffff ); // emissive
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	}
	
	MeshBasicMaterial.prototype = Object.create( Material.prototype );
	MeshBasicMaterial.prototype.constructor = MeshBasicMaterial;
	
	MeshBasicMaterial.prototype.isMeshBasicMaterial = true;
	
	MeshBasicMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		return this;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author jonobr1 / http://jonobr1.com/
	 */
	
	function Mesh( geometry, material ) {
	
		Object3D.call( this );
	
		this.type = 'Mesh';
	
		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new MeshBasicMaterial( { color: Math.random() * 0xffffff } );
	
		this.drawMode = TrianglesDrawMode;
	
		this.updateMorphTargets();
	
	}
	
	Mesh.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Mesh,
	
		isMesh: true,
	
		setDrawMode: function ( value ) {
	
			this.drawMode = value;
	
		},
	
		copy: function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			this.drawMode = source.drawMode;
	
			if ( source.morphTargetInfluences !== undefined ) {
	
				this.morphTargetInfluences = source.morphTargetInfluences.slice();
	
			}
	
			if ( source.morphTargetDictionary !== undefined ) {
	
				this.morphTargetDictionary = Object.assign( {}, source.morphTargetDictionary );
	
			}
	
			return this;
	
		},
	
		updateMorphTargets: function () {
	
			var geometry = this.geometry;
			var m, ml, name;
	
			if ( geometry.isBufferGeometry ) {
	
				var morphAttributes = geometry.morphAttributes;
				var keys = Object.keys( morphAttributes );
	
				if ( keys.length > 0 ) {
	
					var morphAttribute = morphAttributes[ keys[ 0 ] ];
	
					if ( morphAttribute !== undefined ) {
	
						this.morphTargetInfluences = [];
						this.morphTargetDictionary = {};
	
						for ( m = 0, ml = morphAttribute.length; m < ml; m ++ ) {
	
							name = morphAttribute[ m ].name || String( m );
	
							this.morphTargetInfluences.push( 0 );
							this.morphTargetDictionary[ name ] = m;
	
						}
	
					}
	
				}
	
			} else {
	
				var morphTargets = geometry.morphTargets;
	
				if ( morphTargets !== undefined && morphTargets.length > 0 ) {
	
					console.error( 'THREE.Mesh.updateMorphTargets() no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
	
				}
	
			}
	
		},
	
		raycast: ( function () {
	
			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();
	
			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();
	
			var tempA = new Vector3();
			var tempB = new Vector3();
			var tempC = new Vector3();
	
			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();
	
			var intersectionPoint = new Vector3();
			var intersectionPointWorld = new Vector3();
	
			function checkIntersection( object, material, raycaster, ray, pA, pB, pC, point ) {
	
				var intersect;
	
				if ( material.side === BackSide ) {
	
					intersect = ray.intersectTriangle( pC, pB, pA, true, point );
	
				} else {
	
					intersect = ray.intersectTriangle( pA, pB, pC, material.side !== DoubleSide, point );
	
				}
	
				if ( intersect === null ) return null;
	
				intersectionPointWorld.copy( point );
				intersectionPointWorld.applyMatrix4( object.matrixWorld );
	
				var distance = raycaster.ray.origin.distanceTo( intersectionPointWorld );
	
				if ( distance < raycaster.near || distance > raycaster.far ) return null;
	
				return {
					distance: distance,
					point: intersectionPointWorld.clone(),
					object: object
				};
	
			}
	
			function checkBufferGeometryIntersection( object, material, raycaster, ray, position, uv, a, b, c ) {
	
				vA.fromBufferAttribute( position, a );
				vB.fromBufferAttribute( position, b );
				vC.fromBufferAttribute( position, c );
	
				var intersection = checkIntersection( object, material, raycaster, ray, vA, vB, vC, intersectionPoint );
	
				if ( intersection ) {
	
					if ( uv ) {
	
						uvA.fromBufferAttribute( uv, a );
						uvB.fromBufferAttribute( uv, b );
						uvC.fromBufferAttribute( uv, c );
	
						intersection.uv = Triangle.getUV( intersectionPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() );
	
					}
	
					var face = new Face3( a, b, c );
					Triangle.getNormal( vA, vB, vC, face.normal );
	
					intersection.face = face;
	
				}
	
				return intersection;
	
			}
	
			return function raycast( raycaster, intersects ) {
	
				var geometry = this.geometry;
				var material = this.material;
				var matrixWorld = this.matrixWorld;
	
				if ( material === undefined ) return;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
	
				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
				//
	
				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				// Check boundingBox before continuing
	
				if ( geometry.boundingBox !== null ) {
	
					if ( ray.intersectsBox( geometry.boundingBox ) === false ) return;
	
				}
	
				var intersection;
	
				if ( geometry.isBufferGeometry ) {
	
					var a, b, c;
					var index = geometry.index;
					var position = geometry.attributes.position;
					var uv = geometry.attributes.uv;
					var groups = geometry.groups;
					var drawRange = geometry.drawRange;
					var i, j, il, jl;
					var group, groupMaterial;
					var start, end;
	
					if ( index !== null ) {
	
						// indexed buffer geometry
	
						if ( Array.isArray( material ) ) {
	
							for ( i = 0, il = groups.length; i < il; i ++ ) {
	
								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];
	
								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );
	
								for ( j = start, jl = end; j < jl; j += 3 ) {
	
									a = index.getX( j );
									b = index.getX( j + 1 );
									c = index.getX( j + 2 );
	
									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );
	
									if ( intersection ) {
	
										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );
	
									}
	
								}
	
							}
	
						} else {
	
							start = Math.max( 0, drawRange.start );
							end = Math.min( index.count, ( drawRange.start + drawRange.count ) );
	
							for ( i = start, il = end; i < il; i += 3 ) {
	
								a = index.getX( i );
								b = index.getX( i + 1 );
								c = index.getX( i + 2 );
	
								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in indexed buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						}
	
					} else if ( position !== undefined ) {
	
						// non-indexed buffer geometry
	
						if ( Array.isArray( material ) ) {
	
							for ( i = 0, il = groups.length; i < il; i ++ ) {
	
								group = groups[ i ];
								groupMaterial = material[ group.materialIndex ];
	
								start = Math.max( group.start, drawRange.start );
								end = Math.min( ( group.start + group.count ), ( drawRange.start + drawRange.count ) );
	
								for ( j = start, jl = end; j < jl; j += 3 ) {
	
									a = j;
									b = j + 1;
									c = j + 2;
	
									intersection = checkBufferGeometryIntersection( this, groupMaterial, raycaster, ray, position, uv, a, b, c );
	
									if ( intersection ) {
	
										intersection.faceIndex = Math.floor( j / 3 ); // triangle number in non-indexed buffer semantics
										intersection.face.materialIndex = group.materialIndex;
										intersects.push( intersection );
	
									}
	
								}
	
							}
	
						} else {
	
							start = Math.max( 0, drawRange.start );
							end = Math.min( position.count, ( drawRange.start + drawRange.count ) );
	
							for ( i = start, il = end; i < il; i += 3 ) {
	
								a = i;
								b = i + 1;
								c = i + 2;
	
								intersection = checkBufferGeometryIntersection( this, material, raycaster, ray, position, uv, a, b, c );
	
								if ( intersection ) {
	
									intersection.faceIndex = Math.floor( i / 3 ); // triangle number in non-indexed buffer semantics
									intersects.push( intersection );
	
								}
	
							}
	
						}
	
					}
	
				} else if ( geometry.isGeometry ) {
	
					var fvA, fvB, fvC;
					var isMultiMaterial = Array.isArray( material );
	
					var vertices = geometry.vertices;
					var faces = geometry.faces;
					var uvs;
	
					var faceVertexUvs = geometry.faceVertexUvs[ 0 ];
					if ( faceVertexUvs.length > 0 ) uvs = faceVertexUvs;
	
					for ( var f = 0, fl = faces.length; f < fl; f ++ ) {
	
						var face = faces[ f ];
						var faceMaterial = isMultiMaterial ? material[ face.materialIndex ] : material;
	
						if ( faceMaterial === undefined ) continue;
	
						fvA = vertices[ face.a ];
						fvB = vertices[ face.b ];
						fvC = vertices[ face.c ];
	
						if ( faceMaterial.morphTargets === true ) {
	
							var morphTargets = geometry.morphTargets;
							var morphInfluences = this.morphTargetInfluences;
	
							vA.set( 0, 0, 0 );
							vB.set( 0, 0, 0 );
							vC.set( 0, 0, 0 );
	
							for ( var t = 0, tl = morphTargets.length; t < tl; t ++ ) {
	
								var influence = morphInfluences[ t ];
	
								if ( influence === 0 ) continue;
	
								var targets = morphTargets[ t ].vertices;
	
								vA.addScaledVector( tempA.subVectors( targets[ face.a ], fvA ), influence );
								vB.addScaledVector( tempB.subVectors( targets[ face.b ], fvB ), influence );
								vC.addScaledVector( tempC.subVectors( targets[ face.c ], fvC ), influence );
	
							}
	
							vA.add( fvA );
							vB.add( fvB );
							vC.add( fvC );
	
							fvA = vA;
							fvB = vB;
							fvC = vC;
	
						}
	
						intersection = checkIntersection( this, faceMaterial, raycaster, ray, fvA, fvB, fvC, intersectionPoint );
	
						if ( intersection ) {
	
							if ( uvs && uvs[ f ] ) {
	
								var uvs_f = uvs[ f ];
								uvA.copy( uvs_f[ 0 ] );
								uvB.copy( uvs_f[ 1 ] );
								uvC.copy( uvs_f[ 2 ] );
	
								intersection.uv = Triangle.getUV( intersectionPoint, fvA, fvB, fvC, uvA, uvB, uvC, new Vector2() );
	
							}
	
							intersection.face = face;
							intersection.faceIndex = f;
							intersects.push( intersection );
	
						}
	
					}
	
				}
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.geometry, this.material ).copy( this );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLBackground( renderer, state, objects, premultipliedAlpha ) {
	
		var clearColor = new Color( 0x000000 );
		var clearAlpha = 0;
	
		var planeMesh;
		var boxMesh;
		// Store the current background texture and its `version`
		// so we can recompile the material accordingly.
		var currentBackground = null;
		var currentBackgroundVersion = 0;
	
		function render( renderList, scene, camera, forceClear ) {
	
			var background = scene.background;
	
			if ( background === null ) {
	
				setClear( clearColor, clearAlpha );
				currentBackground = null;
				currentBackgroundVersion = 0;
	
			} else if ( background && background.isColor ) {
	
				setClear( background, 1 );
				forceClear = true;
				currentBackground = null;
				currentBackgroundVersion = 0;
	
			}
	
			if ( renderer.autoClear || forceClear ) {
	
				renderer.clear( renderer.autoClearColor, renderer.autoClearDepth, renderer.autoClearStencil );
	
			}
	
			if ( background && ( background.isCubeTexture || background.isWebGLRenderTargetCube ) ) {
	
				if ( boxMesh === undefined ) {
	
					boxMesh = new Mesh(
						new BoxBufferGeometry( 1, 1, 1 ),
						new ShaderMaterial( {
							type: 'BackgroundCubeMaterial',
							uniforms: cloneUniforms( ShaderLib.cube.uniforms ),
							vertexShader: ShaderLib.cube.vertexShader,
							fragmentShader: ShaderLib.cube.fragmentShader,
							side: BackSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);
	
					boxMesh.geometry.removeAttribute( 'normal' );
					boxMesh.geometry.removeAttribute( 'uv' );
	
					boxMesh.onBeforeRender = function ( renderer, scene, camera ) {
	
						this.matrixWorld.copyPosition( camera.matrixWorld );
	
					};
	
					// enable code injection for non-built-in material
					Object.defineProperty( boxMesh.material, 'map', {
	
						get: function () {
	
							return this.uniforms.tCube.value;
	
						}
	
					} );
	
					objects.update( boxMesh );
	
				}
	
				var texture = background.isWebGLRenderTargetCube ? background.texture : background;
				boxMesh.material.uniforms.tCube.value = texture;
				boxMesh.material.uniforms.tFlip.value = ( background.isWebGLRenderTargetCube ) ? 1 : - 1;
	
				if ( currentBackground !== background ||
						 currentBackgroundVersion !== texture.version ) {
	
					boxMesh.material.needsUpdate = true;
	
					currentBackground = background;
					currentBackgroundVersion = texture.version;
	
				}
	
				// push to the pre-sorted opaque render list
				renderList.unshift( boxMesh, boxMesh.geometry, boxMesh.material, 0, 0, null );
	
			} else if ( background && background.isTexture ) {
	
				if ( planeMesh === undefined ) {
	
					planeMesh = new Mesh(
						new PlaneBufferGeometry( 2, 2 ),
						new ShaderMaterial( {
							type: 'BackgroundMaterial',
							uniforms: cloneUniforms( ShaderLib.background.uniforms ),
							vertexShader: ShaderLib.background.vertexShader,
							fragmentShader: ShaderLib.background.fragmentShader,
							side: FrontSide,
							depthTest: false,
							depthWrite: false,
							fog: false
						} )
					);
	
					planeMesh.geometry.removeAttribute( 'normal' );
	
					// enable code injection for non-built-in material
					Object.defineProperty( planeMesh.material, 'map', {
	
						get: function () {
	
							return this.uniforms.t2D.value;
	
						}
	
					} );
	
					objects.update( planeMesh );
	
				}
	
				planeMesh.material.uniforms.t2D.value = background;
	
				if ( background.matrixAutoUpdate === true ) {
	
					background.updateMatrix();
	
				}
	
				planeMesh.material.uniforms.uvTransform.value.copy( background.matrix );
	
				if ( currentBackground !== background ||
						 currentBackgroundVersion !== background.version ) {
	
					planeMesh.material.needsUpdate = true;
	
					currentBackground = background;
					currentBackgroundVersion = background.version;
	
				}
	
	
				// push to the pre-sorted opaque render list
				renderList.unshift( planeMesh, planeMesh.geometry, planeMesh.material, 0, 0, null );
	
			}
	
		}
	
		function setClear( color, alpha ) {
	
			state.buffers.color.setClear( color.r, color.g, color.b, alpha, premultipliedAlpha );
	
		}
	
		return {
	
			getClearColor: function () {
	
				return clearColor;
	
			},
			setClearColor: function ( color, alpha ) {
	
				clearColor.set( color );
				clearAlpha = alpha !== undefined ? alpha : 1;
				setClear( clearColor, clearAlpha );
	
			},
			getClearAlpha: function () {
	
				return clearAlpha;
	
			},
			setClearAlpha: function ( alpha ) {
	
				clearAlpha = alpha;
				setClear( clearColor, clearAlpha );
	
			},
			render: render
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLBufferRenderer( gl, extensions, info, capabilities ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		function render( start, count ) {
	
			gl.drawArrays( mode, start, count );
	
			info.update( count, mode );
	
		}
	
		function renderInstances( geometry, start, count ) {
	
			var extension;
	
			if ( capabilities.isWebGL2 ) {
	
				extension = gl;
	
			} else {
	
				extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			extension[ capabilities.isWebGL2 ? 'drawArraysInstanced' : 'drawArraysInstancedANGLE' ]( mode, start, count, geometry.maxInstancedCount );
	
			info.update( count, mode, geometry.maxInstancedCount );
	
		}
	
		//
	
		this.setMode = setMode;
		this.render = render;
		this.renderInstances = renderInstances;
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLCapabilities( gl, extensions, parameters ) {
	
		var maxAnisotropy;
	
		function getMaxAnisotropy() {
	
			if ( maxAnisotropy !== undefined ) return maxAnisotropy;
	
			var extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension !== null ) {
	
				maxAnisotropy = gl.getParameter( extension.MAX_TEXTURE_MAX_ANISOTROPY_EXT );
	
			} else {
	
				maxAnisotropy = 0;
	
			}
	
			return maxAnisotropy;
	
		}
	
		function getMaxPrecision( precision ) {
	
			if ( precision === 'highp' ) {
	
				if ( gl.getShaderPrecisionFormat( 35633, 36338 ).precision > 0 &&
						 gl.getShaderPrecisionFormat( 35632, 36338 ).precision > 0 ) {
	
					return 'highp';
	
				}
	
				precision = 'mediump';
	
			}
	
			if ( precision === 'mediump' ) {
	
				if ( gl.getShaderPrecisionFormat( 35633, 36337 ).precision > 0 &&
						 gl.getShaderPrecisionFormat( 35632, 36337 ).precision > 0 ) {
	
					return 'mediump';
	
				}
	
			}
	
			return 'lowp';
	
		}
	
		var isWebGL2 = typeof WebGL2RenderingContext !== 'undefined' && gl instanceof WebGL2RenderingContext;
	
		var precision = parameters.precision !== undefined ? parameters.precision : 'highp';
		var maxPrecision = getMaxPrecision( precision );
	
		if ( maxPrecision !== precision ) {
	
			console.warn( 'THREE.WebGLRenderer:', precision, 'not supported, using', maxPrecision, 'instead.' );
			precision = maxPrecision;
	
		}
	
		var logarithmicDepthBuffer = parameters.logarithmicDepthBuffer === true;
	
		var maxTextures = gl.getParameter( 34930 );
		var maxVertexTextures = gl.getParameter( 35660 );
		var maxTextureSize = gl.getParameter( 3379 );
		var maxCubemapSize = gl.getParameter( 34076 );
	
		var maxAttributes = gl.getParameter( 34921 );
		var maxVertexUniforms = gl.getParameter( 36347 );
		var maxVaryings = gl.getParameter( 36348 );
		var maxFragmentUniforms = gl.getParameter( 36349 );
	
		var vertexTextures = maxVertexTextures > 0;
		var floatFragmentTextures = isWebGL2 || !! extensions.get( 'OES_texture_float' );
		var floatVertexTextures = vertexTextures && floatFragmentTextures;
	
		var maxSamples = isWebGL2 ? gl.getParameter( 36183 ) : 0;
	
		return {
	
			isWebGL2: isWebGL2,
	
			getMaxAnisotropy: getMaxAnisotropy,
			getMaxPrecision: getMaxPrecision,
	
			precision: precision,
			logarithmicDepthBuffer: logarithmicDepthBuffer,
	
			maxTextures: maxTextures,
			maxVertexTextures: maxVertexTextures,
			maxTextureSize: maxTextureSize,
			maxCubemapSize: maxCubemapSize,
	
			maxAttributes: maxAttributes,
			maxVertexUniforms: maxVertexUniforms,
			maxVaryings: maxVaryings,
			maxFragmentUniforms: maxFragmentUniforms,
	
			vertexTextures: vertexTextures,
			floatFragmentTextures: floatFragmentTextures,
			floatVertexTextures: floatVertexTextures,
	
			maxSamples: maxSamples
	
		};
	
	}
	
	/**
	 * @author tschw
	 */
	
	function WebGLClipping() {
	
		var scope = this,
	
			globalState = null,
			numGlobalPlanes = 0,
			localClippingEnabled = false,
			renderingShadows = false,
	
			plane = new Plane(),
			viewNormalMatrix = new Matrix3(),
	
			uniform = { value: null, needsUpdate: false };
	
		this.uniform = uniform;
		this.numPlanes = 0;
		this.numIntersection = 0;
	
		this.init = function ( planes, enableLocalClipping, camera ) {
	
			var enabled =
				planes.length !== 0 ||
				enableLocalClipping ||
				// enable state of previous frame - the clipping code has to
				// run another frame in order to reset the state:
				numGlobalPlanes !== 0 ||
				localClippingEnabled;
	
			localClippingEnabled = enableLocalClipping;
	
			globalState = projectPlanes( planes, camera, 0 );
			numGlobalPlanes = planes.length;
	
			return enabled;
	
		};
	
		this.beginShadows = function () {
	
			renderingShadows = true;
			projectPlanes( null );
	
		};
	
		this.endShadows = function () {
	
			renderingShadows = false;
			resetGlobalState();
	
		};
	
		this.setState = function ( planes, clipIntersection, clipShadows, camera, cache, fromCache ) {
	
			if ( ! localClippingEnabled || planes === null || planes.length === 0 || renderingShadows && ! clipShadows ) {
	
				// there's no local clipping
	
				if ( renderingShadows ) {
	
					// there's no global clipping
	
					projectPlanes( null );
	
				} else {
	
					resetGlobalState();
	
				}
	
			} else {
	
				var nGlobal = renderingShadows ? 0 : numGlobalPlanes,
					lGlobal = nGlobal * 4,
	
					dstArray = cache.clippingState || null;
	
				uniform.value = dstArray; // ensure unique state
	
				dstArray = projectPlanes( planes, camera, lGlobal, fromCache );
	
				for ( var i = 0; i !== lGlobal; ++ i ) {
	
					dstArray[ i ] = globalState[ i ];
	
				}
	
				cache.clippingState = dstArray;
				this.numIntersection = clipIntersection ? this.numPlanes : 0;
				this.numPlanes += nGlobal;
	
			}
	
	
		};
	
		function resetGlobalState() {
	
			if ( uniform.value !== globalState ) {
	
				uniform.value = globalState;
				uniform.needsUpdate = numGlobalPlanes > 0;
	
			}
	
			scope.numPlanes = numGlobalPlanes;
			scope.numIntersection = 0;
	
		}
	
		function projectPlanes( planes, camera, dstOffset, skipTransform ) {
	
			var nPlanes = planes !== null ? planes.length : 0,
				dstArray = null;
	
			if ( nPlanes !== 0 ) {
	
				dstArray = uniform.value;
	
				if ( skipTransform !== true || dstArray === null ) {
	
					var flatSize = dstOffset + nPlanes * 4,
						viewMatrix = camera.matrixWorldInverse;
	
					viewNormalMatrix.getNormalMatrix( viewMatrix );
	
					if ( dstArray === null || dstArray.length < flatSize ) {
	
						dstArray = new Float32Array( flatSize );
	
					}
	
					for ( var i = 0, i4 = dstOffset; i !== nPlanes; ++ i, i4 += 4 ) {
	
						plane.copy( planes[ i ] ).applyMatrix4( viewMatrix, viewNormalMatrix );
	
						plane.normal.toArray( dstArray, i4 );
						dstArray[ i4 + 3 ] = plane.constant;
	
					}
	
				}
	
				uniform.value = dstArray;
				uniform.needsUpdate = true;
	
			}
	
			scope.numPlanes = nPlanes;
	
			return dstArray;
	
		}
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLExtensions( gl ) {
	
		var extensions = {};
	
		return {
	
			get: function ( name ) {
	
				if ( extensions[ name ] !== undefined ) {
	
					return extensions[ name ];
	
				}
	
				var extension;
	
				switch ( name ) {
	
					case 'WEBGL_depth_texture':
						extension = gl.getExtension( 'WEBGL_depth_texture' ) || gl.getExtension( 'MOZ_WEBGL_depth_texture' ) || gl.getExtension( 'WEBKIT_WEBGL_depth_texture' );
						break;
	
					case 'EXT_texture_filter_anisotropic':
						extension = gl.getExtension( 'EXT_texture_filter_anisotropic' ) || gl.getExtension( 'MOZ_EXT_texture_filter_anisotropic' ) || gl.getExtension( 'WEBKIT_EXT_texture_filter_anisotropic' );
						break;
	
					case 'WEBGL_compressed_texture_s3tc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'MOZ_WEBGL_compressed_texture_s3tc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_s3tc' );
						break;
	
					case 'WEBGL_compressed_texture_pvrtc':
						extension = gl.getExtension( 'WEBGL_compressed_texture_pvrtc' ) || gl.getExtension( 'WEBKIT_WEBGL_compressed_texture_pvrtc' );
						break;
	
					default:
						extension = gl.getExtension( name );
	
				}
	
				if ( extension === null ) {
	
					console.warn( 'THREE.WebGLRenderer: ' + name + ' extension not supported.' );
	
				}
	
				extensions[ name ] = extension;
	
				return extension;
	
			}
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLGeometries( gl, attributes, info ) {
	
		var geometries = {};
		var wireframeAttributes = {};
	
		function onGeometryDispose( event ) {
	
			var geometry = event.target;
			var buffergeometry = geometries[ geometry.id ];
	
			if ( buffergeometry.index !== null ) {
	
				attributes.remove( buffergeometry.index );
	
			}
	
			for ( var name in buffergeometry.attributes ) {
	
				attributes.remove( buffergeometry.attributes[ name ] );
	
			}
	
			geometry.removeEventListener( 'dispose', onGeometryDispose );
	
			delete geometries[ geometry.id ];
	
			var attribute = wireframeAttributes[ buffergeometry.id ];
	
			if ( attribute ) {
	
				attributes.remove( attribute );
				delete wireframeAttributes[ buffergeometry.id ];
	
			}
	
			//
	
			info.memory.geometries --;
	
		}
	
		function get( object, geometry ) {
	
			var buffergeometry = geometries[ geometry.id ];
	
			if ( buffergeometry ) return buffergeometry;
	
			geometry.addEventListener( 'dispose', onGeometryDispose );
	
			if ( geometry.isBufferGeometry ) {
	
				buffergeometry = geometry;
	
			} else if ( geometry.isGeometry ) {
	
				if ( geometry._bufferGeometry === undefined ) {
	
					geometry._bufferGeometry = new BufferGeometry().setFromObject( object );
	
				}
	
				buffergeometry = geometry._bufferGeometry;
	
			}
	
			geometries[ geometry.id ] = buffergeometry;
	
			info.memory.geometries ++;
	
			return buffergeometry;
	
		}
	
		function update( geometry ) {
	
			var index = geometry.index;
			var geometryAttributes = geometry.attributes;
	
			if ( index !== null ) {
	
				attributes.update( index, 34963 );
	
			}
	
			for ( var name in geometryAttributes ) {
	
				attributes.update( geometryAttributes[ name ], 34962 );
	
			}
	
			// morph targets
	
			var morphAttributes = geometry.morphAttributes;
	
			for ( var name in morphAttributes ) {
	
				var array = morphAttributes[ name ];
	
				for ( var i = 0, l = array.length; i < l; i ++ ) {
	
					attributes.update( array[ i ], 34962 );
	
				}
	
			}
	
		}
	
		function getWireframeAttribute( geometry ) {
	
			var attribute = wireframeAttributes[ geometry.id ];
	
			if ( attribute ) return attribute;
	
			var indices = [];
	
			var geometryIndex = geometry.index;
			var geometryAttributes = geometry.attributes;
	
			// console.time( 'wireframe' );
	
			if ( geometryIndex !== null ) {
	
				var array = geometryIndex.array;
	
				for ( var i = 0, l = array.length; i < l; i += 3 ) {
	
					var a = array[ i + 0 ];
					var b = array[ i + 1 ];
					var c = array[ i + 2 ];
	
					indices.push( a, b, b, c, c, a );
	
				}
	
			} else {
	
				var array = geometryAttributes.position.array;
	
				for ( var i = 0, l = ( array.length / 3 ) - 1; i < l; i += 3 ) {
	
					var a = i + 0;
					var b = i + 1;
					var c = i + 2;
	
					indices.push( a, b, b, c, c, a );
	
				}
	
			}
	
			// console.timeEnd( 'wireframe' );
	
			attribute = new ( arrayMax( indices ) > 65535 ? Uint32BufferAttribute : Uint16BufferAttribute )( indices, 1 );
	
			attributes.update( attribute, 34963 );
	
			wireframeAttributes[ geometry.id ] = attribute;
	
			return attribute;
	
		}
	
		return {
	
			get: get,
			update: update,
	
			getWireframeAttribute: getWireframeAttribute
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLIndexedBufferRenderer( gl, extensions, info, capabilities ) {
	
		var mode;
	
		function setMode( value ) {
	
			mode = value;
	
		}
	
		var type, bytesPerElement;
	
		function setIndex( value ) {
	
			type = value.type;
			bytesPerElement = value.bytesPerElement;
	
		}
	
		function render( start, count ) {
	
			gl.drawElements( mode, count, type, start * bytesPerElement );
	
			info.update( count, mode );
	
		}
	
		function renderInstances( geometry, start, count ) {
	
			var extension;
	
			if ( capabilities.isWebGL2 ) {
	
				extension = gl;
	
			} else {
	
				var extension = extensions.get( 'ANGLE_instanced_arrays' );
	
				if ( extension === null ) {
	
					console.error( 'THREE.WebGLIndexedBufferRenderer: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			extension[ capabilities.isWebGL2 ? 'drawElementsInstanced' : 'drawElementsInstancedANGLE' ]( mode, count, type, start * bytesPerElement, geometry.maxInstancedCount );
	
			info.update( count, mode, geometry.maxInstancedCount );
	
		}
	
		//
	
		this.setMode = setMode;
		this.setIndex = setIndex;
		this.render = render;
		this.renderInstances = renderInstances;
	
	}
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	function WebGLInfo( gl ) {
	
		var memory = {
			geometries: 0,
			textures: 0
		};
	
		var render = {
			frame: 0,
			calls: 0,
			triangles: 0,
			points: 0,
			lines: 0
		};
	
		function update( count, mode, instanceCount ) {
	
			instanceCount = instanceCount || 1;
	
			render.calls ++;
	
			switch ( mode ) {
	
				case 4:
					render.triangles += instanceCount * ( count / 3 );
					break;
	
				case 5:
				case 6:
					render.triangles += instanceCount * ( count - 2 );
					break;
	
				case 1:
					render.lines += instanceCount * ( count / 2 );
					break;
	
				case 3:
					render.lines += instanceCount * ( count - 1 );
					break;
	
				case 2:
					render.lines += instanceCount * count;
					break;
	
				case 0:
					render.points += instanceCount * count;
					break;
	
				default:
					console.error( 'THREE.WebGLInfo: Unknown draw mode:', mode );
					break;
	
			}
	
		}
	
		function reset() {
	
			render.frame ++;
			render.calls = 0;
			render.triangles = 0;
			render.points = 0;
			render.lines = 0;
	
		}
	
		return {
			memory: memory,
			render: render,
			programs: null,
			autoReset: true,
			reset: reset,
			update: update
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function absNumericalSort( a, b ) {
	
		return Math.abs( b[ 1 ] ) - Math.abs( a[ 1 ] );
	
	}
	
	function WebGLMorphtargets( gl ) {
	
		var influencesList = {};
		var morphInfluences = new Float32Array( 8 );
	
		function update( object, geometry, material, program ) {
	
			var objectInfluences = object.morphTargetInfluences;
	
			var length = objectInfluences.length;
	
			var influences = influencesList[ geometry.id ];
	
			if ( influences === undefined ) {
	
				// initialise list
	
				influences = [];
	
				for ( var i = 0; i < length; i ++ ) {
	
					influences[ i ] = [ i, 0 ];
	
				}
	
				influencesList[ geometry.id ] = influences;
	
			}
	
			var morphTargets = material.morphTargets && geometry.morphAttributes.position;
			var morphNormals = material.morphNormals && geometry.morphAttributes.normal;
	
			// Remove current morphAttributes
	
			for ( var i = 0; i < length; i ++ ) {
	
				var influence = influences[ i ];
	
				if ( influence[ 1 ] !== 0 ) {
	
					if ( morphTargets ) geometry.removeAttribute( 'morphTarget' + i );
					if ( morphNormals ) geometry.removeAttribute( 'morphNormal' + i );
	
				}
	
			}
	
			// Collect influences
	
			for ( var i = 0; i < length; i ++ ) {
	
				var influence = influences[ i ];
	
				influence[ 0 ] = i;
				influence[ 1 ] = objectInfluences[ i ];
	
			}
	
			influences.sort( absNumericalSort );
	
			// Add morphAttributes
	
			for ( var i = 0; i < 8; i ++ ) {
	
				var influence = influences[ i ];
	
				if ( influence ) {
	
					var index = influence[ 0 ];
					var value = influence[ 1 ];
	
					if ( value ) {
	
						if ( morphTargets ) geometry.addAttribute( 'morphTarget' + i, morphTargets[ index ] );
						if ( morphNormals ) geometry.addAttribute( 'morphNormal' + i, morphNormals[ index ] );
	
						morphInfluences[ i ] = value;
						continue;
	
					}
	
				}
	
				morphInfluences[ i ] = 0;
	
			}
	
			program.getUniforms().setValue( gl, 'morphTargetInfluences', morphInfluences );
	
		}
	
		return {
	
			update: update
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLObjects( geometries, info ) {
	
		var updateList = {};
	
		function update( object ) {
	
			var frame = info.render.frame;
	
			var geometry = object.geometry;
			var buffergeometry = geometries.get( object, geometry );
	
			// Update once per frame
	
			if ( updateList[ buffergeometry.id ] !== frame ) {
	
				if ( geometry.isGeometry ) {
	
					buffergeometry.updateFromObject( object );
	
				}
	
				geometries.update( buffergeometry );
	
				updateList[ buffergeometry.id ] = frame;
	
			}
	
			return buffergeometry;
	
		}
	
		function dispose() {
	
			updateList = {};
	
		}
	
		return {
	
			update: update,
			dispose: dispose
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function CubeTexture( images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding ) {
	
		images = images !== undefined ? images : [];
		mapping = mapping !== undefined ? mapping : CubeReflectionMapping;
	
		Texture.call( this, images, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
		this.flipY = false;
	
	}
	
	CubeTexture.prototype = Object.create( Texture.prototype );
	CubeTexture.prototype.constructor = CubeTexture;
	
	CubeTexture.prototype.isCubeTexture = true;
	
	Object.defineProperty( CubeTexture.prototype, 'images', {
	
		get: function () {
	
			return this.image;
	
		},
	
		set: function ( value ) {
	
			this.image = value;
	
		}
	
	} );
	
	/**
	 * @author Artur Trzesiok
	 */
	
	function DataTexture3D( data, width, height, depth ) {
	
		// We're going to add .setXXX() methods for setting properties later.
		// Users can still set in DataTexture3D directly.
		//
		//	var texture = new THREE.DataTexture3D( data, width, height, depth );
		// 	texture.anisotropy = 16;
		//
		// See #14839
	
		Texture.call( this, null );
	
		this.image = { data: data, width: width, height: height, depth: depth };
	
		this.magFilter = NearestFilter;
		this.minFilter = NearestFilter;
	
		this.generateMipmaps = false;
		this.flipY = false;
	
	}
	
	DataTexture3D.prototype = Object.create( Texture.prototype );
	DataTexture3D.prototype.constructor = DataTexture3D;
	DataTexture3D.prototype.isDataTexture3D = true;
	
	/**
	 * @author tschw
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Uniforms of a program.
	 * Those form a tree structure with a special top-level container for the root,
	 * which you get by calling 'new WebGLUniforms( gl, program, renderer )'.
	 *
	 *
	 * Properties of inner nodes including the top-level container:
	 *
	 * .seq - array of nested uniforms
	 * .map - nested uniforms by name
	 *
	 *
	 * Methods of all nodes except the top-level container:
	 *
	 * .setValue( gl, value, [renderer] )
	 *
	 * 		uploads a uniform value(s)
	 *  	the 'renderer' parameter is needed for sampler uniforms
	 *
	 *
	 * Static methods of the top-level container (renderer factorizations):
	 *
	 * .upload( gl, seq, values, renderer )
	 *
	 * 		sets uniforms in 'seq' to 'values[id].value'
	 *
	 * .seqWithValue( seq, values ) : filteredSeq
	 *
	 * 		filters 'seq' entries with corresponding entry in values
	 *
	 *
	 * Methods of the top-level container (renderer factorizations):
	 *
	 * .setValue( gl, name, value )
	 *
	 * 		sets uniform with  name 'name' to 'value'
	 *
	 * .set( gl, obj, prop )
	 *
	 * 		sets uniform from object and property with same name than uniform
	 *
	 * .setOptional( gl, obj, prop )
	 *
	 * 		like .set for an optional property of the object
	 *
	 */
	
	var emptyTexture = new Texture();
	var emptyTexture3d = new DataTexture3D();
	var emptyCubeTexture = new CubeTexture();
	
	// --- Base for inner nodes (including the root) ---
	
	function UniformContainer() {
	
		this.seq = [];
		this.map = {};
	
	}
	
	// --- Utilities ---
	
	// Array Caches (provide typed arrays for temporary by size)
	
	var arrayCacheF32 = [];
	var arrayCacheI32 = [];
	
	// Float32Array caches used for uploading Matrix uniforms
	
	var mat4array = new Float32Array( 16 );
	var mat3array = new Float32Array( 9 );
	var mat2array = new Float32Array( 4 );
	
	// Flattening for arrays of vectors and matrices
	
	function flatten( array, nBlocks, blockSize ) {
	
		var firstElem = array[ 0 ];
	
		if ( firstElem <= 0 || firstElem > 0 ) return array;
		// unoptimized: ! isNaN( firstElem )
		// see http://jacksondunstan.com/articles/983
	
		var n = nBlocks * blockSize,
			r = arrayCacheF32[ n ];
	
		if ( r === undefined ) {
	
			r = new Float32Array( n );
			arrayCacheF32[ n ] = r;
	
		}
	
		if ( nBlocks !== 0 ) {
	
			firstElem.toArray( r, 0 );
	
			for ( var i = 1, offset = 0; i !== nBlocks; ++ i ) {
	
				offset += blockSize;
				array[ i ].toArray( r, offset );
	
			}
	
		}
	
		return r;
	
	}
	
	function arraysEqual( a, b ) {
	
		if ( a.length !== b.length ) return false;
	
		for ( var i = 0, l = a.length; i < l; i ++ ) {
	
			if ( a[ i ] !== b[ i ] ) return false;
	
		}
	
		return true;
	
	}
	
	function copyArray( a, b ) {
	
		for ( var i = 0, l = b.length; i < l; i ++ ) {
	
			a[ i ] = b[ i ];
	
		}
	
	}
	
	// Texture unit allocation
	
	function allocTexUnits( renderer, n ) {
	
		var r = arrayCacheI32[ n ];
	
		if ( r === undefined ) {
	
			r = new Int32Array( n );
			arrayCacheI32[ n ] = r;
	
		}
	
		for ( var i = 0; i !== n; ++ i )
			r[ i ] = renderer.allocTextureUnit();
	
		return r;
	
	}
	
	// --- Setters ---
	
	// Note: Defining these methods externally, because they come in a bunch
	// and this way their names minify.
	
	// Single scalar
	
	function setValue1f( gl, v ) {
	
		var cache = this.cache;
	
		if ( cache[ 0 ] === v ) return;
	
		gl.uniform1f( this.addr, v );
	
		cache[ 0 ] = v;
	
	}
	
	function setValue1i( gl, v ) {
	
		var cache = this.cache;
	
		if ( cache[ 0 ] === v ) return;
	
		gl.uniform1i( this.addr, v );
	
		cache[ 0 ] = v;
	
	}
	
	// Single float vector (from flat array or THREE.VectorN)
	
	function setValue2fv( gl, v ) {
	
		var cache = this.cache;
	
		if ( v.x !== undefined ) {
	
			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y ) {
	
				gl.uniform2f( this.addr, v.x, v.y );
	
				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
	
			}
	
		} else {
	
			if ( arraysEqual( cache, v ) ) return;
	
			gl.uniform2fv( this.addr, v );
	
			copyArray( cache, v );
	
		}
	
	}
	
	function setValue3fv( gl, v ) {
	
		var cache = this.cache;
	
		if ( v.x !== undefined ) {
	
			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z ) {
	
				gl.uniform3f( this.addr, v.x, v.y, v.z );
	
				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
	
			}
	
		} else if ( v.r !== undefined ) {
	
			if ( cache[ 0 ] !== v.r || cache[ 1 ] !== v.g || cache[ 2 ] !== v.b ) {
	
				gl.uniform3f( this.addr, v.r, v.g, v.b );
	
				cache[ 0 ] = v.r;
				cache[ 1 ] = v.g;
				cache[ 2 ] = v.b;
	
			}
	
		} else {
	
			if ( arraysEqual( cache, v ) ) return;
	
			gl.uniform3fv( this.addr, v );
	
			copyArray( cache, v );
	
		}
	
	}
	
	function setValue4fv( gl, v ) {
	
		var cache = this.cache;
	
		if ( v.x !== undefined ) {
	
			if ( cache[ 0 ] !== v.x || cache[ 1 ] !== v.y || cache[ 2 ] !== v.z || cache[ 3 ] !== v.w ) {
	
				gl.uniform4f( this.addr, v.x, v.y, v.z, v.w );
	
				cache[ 0 ] = v.x;
				cache[ 1 ] = v.y;
				cache[ 2 ] = v.z;
				cache[ 3 ] = v.w;
	
			}
	
		} else {
	
			if ( arraysEqual( cache, v ) ) return;
	
			gl.uniform4fv( this.addr, v );
	
			copyArray( cache, v );
	
		}
	
	}
	
	// Single matrix (from flat array or MatrixN)
	
	function setValue2fm( gl, v ) {
	
		var cache = this.cache;
		var elements = v.elements;
	
		if ( elements === undefined ) {
	
			if ( arraysEqual( cache, v ) ) return;
	
			gl.uniformMatrix2fv( this.addr, false, v );
	
			copyArray( cache, v );
	
		} else {
	
			if ( arraysEqual( cache, elements ) ) return;
	
			mat2array.set( elements );
	
			gl.uniformMatrix2fv( this.addr, false, mat2array );
	
			copyArray( cache, elements );
	
		}
	
	}
	
	function setValue3fm( gl, v ) {
	
		var cache = this.cache;
		var elements = v.elements;
	
		if ( elements === undefined ) {
	
			if ( arraysEqual( cache, v ) ) return;
	
			gl.uniformMatrix3fv( this.addr, false, v );
	
			copyArray( cache, v );
	
		} else {
	
			if ( arraysEqual( cache, elements ) ) return;
	
			mat3array.set( elements );
	
			gl.uniformMatrix3fv( this.addr, false, mat3array );
	
			copyArray( cache, elements );
	
		}
	
	}
	
	function setValue4fm( gl, v ) {
	
		var cache = this.cache;
		var elements = v.elements;
	
		if ( elements === undefined ) {
	
			if ( arraysEqual( cache, v ) ) return;
	
			gl.uniformMatrix4fv( this.addr, false, v );
	
			copyArray( cache, v );
	
		} else {
	
			if ( arraysEqual( cache, elements ) ) return;
	
			mat4array.set( elements );
	
			gl.uniformMatrix4fv( this.addr, false, mat4array );
	
			copyArray( cache, elements );
	
		}
	
	}
	
	// Single texture (2D / Cube)
	
	function setValueT1( gl, v, renderer ) {
	
		var cache = this.cache;
		var unit = renderer.allocTextureUnit();
	
		if ( cache[ 0 ] !== unit ) {
	
			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;
	
		}
	
		renderer.setTexture2D( v || emptyTexture, unit );
	
	}
	
	function setValueT3D1( gl, v, renderer ) {
	
		var cache = this.cache;
		var unit = renderer.allocTextureUnit();
	
		if ( cache[ 0 ] !== unit ) {
	
			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;
	
		}
	
		renderer.setTexture3D( v || emptyTexture3d, unit );
	
	}
	
	function setValueT6( gl, v, renderer ) {
	
		var cache = this.cache;
		var unit = renderer.allocTextureUnit();
	
		if ( cache[ 0 ] !== unit ) {
	
			gl.uniform1i( this.addr, unit );
			cache[ 0 ] = unit;
	
		}
	
		renderer.setTextureCube( v || emptyCubeTexture, unit );
	
	}
	
	// Integer / Boolean vectors or arrays thereof (always flat arrays)
	
	function setValue2iv( gl, v ) {
	
		var cache = this.cache;
	
		if ( arraysEqual( cache, v ) ) return;
	
		gl.uniform2iv( this.addr, v );
	
		copyArray( cache, v );
	
	}
	
	function setValue3iv( gl, v ) {
	
		var cache = this.cache;
	
		if ( arraysEqual( cache, v ) ) return;
	
		gl.uniform3iv( this.addr, v );
	
		copyArray( cache, v );
	
	}
	
	function setValue4iv( gl, v ) {
	
		var cache = this.cache;
	
		if ( arraysEqual( cache, v ) ) return;
	
		gl.uniform4iv( this.addr, v );
	
		copyArray( cache, v );
	
	}
	
	// Helper to pick the right setter for the singular case
	
	function getSingularSetter( type ) {
	
		switch ( type ) {
	
			case 0x1406: return setValue1f; // FLOAT
			case 0x8b50: return setValue2fv; // _VEC2
			case 0x8b51: return setValue3fv; // _VEC3
			case 0x8b52: return setValue4fv; // _VEC4
	
			case 0x8b5a: return setValue2fm; // _MAT2
			case 0x8b5b: return setValue3fm; // _MAT3
			case 0x8b5c: return setValue4fm; // _MAT4
	
			case 0x8b5e: case 0x8d66: return setValueT1; // SAMPLER_2D, SAMPLER_EXTERNAL_OES
			case 0x8B5F: return setValueT3D1; // SAMPLER_3D
			case 0x8b60: return setValueT6; // SAMPLER_CUBE
	
			case 0x1404: case 0x8b56: return setValue1i; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
		}
	
	}
	
	// Array of scalars
	
	function setValue1fv( gl, v ) {
	
		var cache = this.cache;
	
		if ( arraysEqual( cache, v ) ) return;
	
		gl.uniform1fv( this.addr, v );
	
		copyArray( cache, v );
	
	}
	function setValue1iv( gl, v ) {
	
		var cache = this.cache;
	
		if ( arraysEqual( cache, v ) ) return;
	
		gl.uniform1iv( this.addr, v );
	
		copyArray( cache, v );
	
	}
	
	// Array of vectors (flat or from THREE classes)
	
	function setValueV2a( gl, v ) {
	
		var cache = this.cache;
		var data = flatten( v, this.size, 2 );
	
		if ( arraysEqual( cache, data ) ) return;
	
		gl.uniform2fv( this.addr, data );
	
		this.updateCache( data );
	
	}
	
	function setValueV3a( gl, v ) {
	
		var cache = this.cache;
		var data = flatten( v, this.size, 3 );
	
		if ( arraysEqual( cache, data ) ) return;
	
		gl.uniform3fv( this.addr, data );
	
		this.updateCache( data );
	
	}
	
	function setValueV4a( gl, v ) {
	
		var cache = this.cache;
		var data = flatten( v, this.size, 4 );
	
		if ( arraysEqual( cache, data ) ) return;
	
		gl.uniform4fv( this.addr, data );
	
		this.updateCache( data );
	
	}
	
	// Array of matrices (flat or from THREE clases)
	
	function setValueM2a( gl, v ) {
	
		var cache = this.cache;
		var data = flatten( v, this.size, 4 );
	
		if ( arraysEqual( cache, data ) ) return;
	
		gl.uniformMatrix2fv( this.addr, false, data );
	
		this.updateCache( data );
	
	}
	
	function setValueM3a( gl, v ) {
	
		var cache = this.cache;
		var data = flatten( v, this.size, 9 );
	
		if ( arraysEqual( cache, data ) ) return;
	
		gl.uniformMatrix3fv( this.addr, false, data );
	
		this.updateCache( data );
	
	}
	
	function setValueM4a( gl, v ) {
	
		var cache = this.cache;
		var data = flatten( v, this.size, 16 );
	
		if ( arraysEqual( cache, data ) ) return;
	
		gl.uniformMatrix4fv( this.addr, false, data );
	
		this.updateCache( data );
	
	}
	
	// Array of textures (2D / Cube)
	
	function setValueT1a( gl, v, renderer ) {
	
		var cache = this.cache;
		var n = v.length;
	
		var units = allocTexUnits( renderer, n );
	
		if ( arraysEqual( cache, units ) === false ) {
	
			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );
	
		}
	
		for ( var i = 0; i !== n; ++ i ) {
	
			renderer.setTexture2D( v[ i ] || emptyTexture, units[ i ] );
	
		}
	
	}
	
	function setValueT6a( gl, v, renderer ) {
	
		var cache = this.cache;
		var n = v.length;
	
		var units = allocTexUnits( renderer, n );
	
		if ( arraysEqual( cache, units ) === false ) {
	
			gl.uniform1iv( this.addr, units );
			copyArray( cache, units );
	
		}
	
		for ( var i = 0; i !== n; ++ i ) {
	
			renderer.setTextureCube( v[ i ] || emptyCubeTexture, units[ i ] );
	
		}
	
	}
	
	// Helper to pick the right setter for a pure (bottom-level) array
	
	function getPureArraySetter( type ) {
	
		switch ( type ) {
	
			case 0x1406: return setValue1fv; // FLOAT
			case 0x8b50: return setValueV2a; // _VEC2
			case 0x8b51: return setValueV3a; // _VEC3
			case 0x8b52: return setValueV4a; // _VEC4
	
			case 0x8b5a: return setValueM2a; // _MAT2
			case 0x8b5b: return setValueM3a; // _MAT3
			case 0x8b5c: return setValueM4a; // _MAT4
	
			case 0x8b5e: return setValueT1a; // SAMPLER_2D
			case 0x8b60: return setValueT6a; // SAMPLER_CUBE
	
			case 0x1404: case 0x8b56: return setValue1iv; // INT, BOOL
			case 0x8b53: case 0x8b57: return setValue2iv; // _VEC2
			case 0x8b54: case 0x8b58: return setValue3iv; // _VEC3
			case 0x8b55: case 0x8b59: return setValue4iv; // _VEC4
	
		}
	
	}
	
	// --- Uniform Classes ---
	
	function SingleUniform( id, activeInfo, addr ) {
	
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.setValue = getSingularSetter( activeInfo.type );
	
		// this.path = activeInfo.name; // DEBUG
	
	}
	
	function PureArrayUniform( id, activeInfo, addr ) {
	
		this.id = id;
		this.addr = addr;
		this.cache = [];
		this.size = activeInfo.size;
		this.setValue = getPureArraySetter( activeInfo.type );
	
		// this.path = activeInfo.name; // DEBUG
	
	}
	
	PureArrayUniform.prototype.updateCache = function ( data ) {
	
		var cache = this.cache;
	
		if ( data instanceof Float32Array && cache.length !== data.length ) {
	
			this.cache = new Float32Array( data.length );
	
		}
	
		copyArray( cache, data );
	
	};
	
	function StructuredUniform( id ) {
	
		this.id = id;
	
		UniformContainer.call( this ); // mix-in
	
	}
	
	StructuredUniform.prototype.setValue = function ( gl, value, renderer ) {
	
		var seq = this.seq;
	
		for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
			var u = seq[ i ];
			u.setValue( gl, value[ u.id ], renderer );
	
		}
	
	};
	
	// --- Top-level ---
	
	// Parser - builds up the property tree from the path strings
	
	var RePathPart = /([\w\d_]+)(\])?(\[|\.)?/g;
	
	// extracts
	// 	- the identifier (member name or array index)
	//  - followed by an optional right bracket (found when array index)
	//  - followed by an optional left bracket or dot (type of subscript)
	//
	// Note: These portions can be read in a non-overlapping fashion and
	// allow straightforward parsing of the hierarchy that WebGL encodes
	// in the uniform names.
	
	function addUniform( container, uniformObject ) {
	
		container.seq.push( uniformObject );
		container.map[ uniformObject.id ] = uniformObject;
	
	}
	
	function parseUniform( activeInfo, addr, container ) {
	
		var path = activeInfo.name,
			pathLength = path.length;
	
		// reset RegExp object, because of the early exit of a previous run
		RePathPart.lastIndex = 0;
	
		while ( true ) {
	
			var match = RePathPart.exec( path ),
				matchEnd = RePathPart.lastIndex,
	
				id = match[ 1 ],
				idIsIndex = match[ 2 ] === ']',
				subscript = match[ 3 ];
	
			if ( idIsIndex ) id = id | 0; // convert to integer
	
			if ( subscript === undefined || subscript === '[' && matchEnd + 2 === pathLength ) {
	
				// bare name or "pure" bottom-level array "[0]" suffix
	
				addUniform( container, subscript === undefined ?
					new SingleUniform( id, activeInfo, addr ) :
					new PureArrayUniform( id, activeInfo, addr ) );
	
				break;
	
			} else {
	
				// step into inner node / create it in case it doesn't exist
	
				var map = container.map, next = map[ id ];
	
				if ( next === undefined ) {
	
					next = new StructuredUniform( id );
					addUniform( container, next );
	
				}
	
				container = next;
	
			}
	
		}
	
	}
	
	// Root Container
	
	function WebGLUniforms( gl, program, renderer ) {
	
		UniformContainer.call( this );
	
		this.renderer = renderer;
	
		var n = gl.getProgramParameter( program, 35718 );
	
		for ( var i = 0; i < n; ++ i ) {
	
			var info = gl.getActiveUniform( program, i ),
				addr = gl.getUniformLocation( program, info.name );
	
			parseUniform( info, addr, this );
	
		}
	
	}
	
	WebGLUniforms.prototype.setValue = function ( gl, name, value ) {
	
		var u = this.map[ name ];
	
		if ( u !== undefined ) u.setValue( gl, value, this.renderer );
	
	};
	
	WebGLUniforms.prototype.setOptional = function ( gl, object, name ) {
	
		var v = object[ name ];
	
		if ( v !== undefined ) this.setValue( gl, name, v );
	
	};
	
	
	// Static interface
	
	WebGLUniforms.upload = function ( gl, seq, values, renderer ) {
	
		for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
			var u = seq[ i ],
				v = values[ u.id ];
	
			if ( v.needsUpdate !== false ) {
	
				// note: always updating when .needsUpdate is undefined
				u.setValue( gl, v.value, renderer );
	
			}
	
		}
	
	};
	
	WebGLUniforms.seqWithValue = function ( seq, values ) {
	
		var r = [];
	
		for ( var i = 0, n = seq.length; i !== n; ++ i ) {
	
			var u = seq[ i ];
			if ( u.id in values ) r.push( u );
	
		}
	
		return r;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function addLineNumbers( string ) {
	
		var lines = string.split( '\n' );
	
		for ( var i = 0; i < lines.length; i ++ ) {
	
			lines[ i ] = ( i + 1 ) + ': ' + lines[ i ];
	
		}
	
		return lines.join( '\n' );
	
	}
	
	function WebGLShader( gl, type, string ) {
	
		var shader = gl.createShader( type );
	
		gl.shaderSource( shader, string );
		gl.compileShader( shader );
	
		if ( gl.getShaderParameter( shader, 35713 ) === false ) {
	
			console.error( 'THREE.WebGLShader: Shader couldn\'t compile.' );
	
		}
	
		if ( gl.getShaderInfoLog( shader ) !== '' ) {
	
			console.warn( 'THREE.WebGLShader: gl.getShaderInfoLog()', type === 35633 ? 'vertex' : 'fragment', gl.getShaderInfoLog( shader ), addLineNumbers( string ) );
	
		}
	
		// --enable-privileged-webgl-extension
		// console.log( type, gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( shader ) );
	
		return shader;
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var programIdCount = 0;
	
	function getEncodingComponents( encoding ) {
	
		switch ( encoding ) {
	
			case LinearEncoding:
				return [ 'Linear', '( value )' ];
			case sRGBEncoding:
				return [ 'sRGB', '( value )' ];
			case RGBEEncoding:
				return [ 'RGBE', '( value )' ];
			case RGBM7Encoding:
				return [ 'RGBM', '( value, 7.0 )' ];
			case RGBM16Encoding:
				return [ 'RGBM', '( value, 16.0 )' ];
			case RGBDEncoding:
				return [ 'RGBD', '( value, 256.0 )' ];
			case GammaEncoding:
				return [ 'Gamma', '( value, float( GAMMA_FACTOR ) )' ];
			default:
				throw new Error( 'unsupported encoding: ' + encoding );
	
		}
	
	}
	
	function getTexelDecodingFunction( functionName, encoding ) {
	
		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return ' + components[ 0 ] + 'ToLinear' + components[ 1 ] + '; }';
	
	}
	
	function getTexelEncodingFunction( functionName, encoding ) {
	
		var components = getEncodingComponents( encoding );
		return 'vec4 ' + functionName + '( vec4 value ) { return LinearTo' + components[ 0 ] + components[ 1 ] + '; }';
	
	}
	
	function getToneMappingFunction( functionName, toneMapping ) {
	
		var toneMappingName;
	
		switch ( toneMapping ) {
	
			case LinearToneMapping:
				toneMappingName = 'Linear';
				break;
	
			case ReinhardToneMapping:
				toneMappingName = 'Reinhard';
				break;
	
			case Uncharted2ToneMapping:
				toneMappingName = 'Uncharted2';
				break;
	
			case CineonToneMapping:
				toneMappingName = 'OptimizedCineon';
				break;
	
			case ACESFilmicToneMapping:
				toneMappingName = 'ACESFilmic';
				break;
	
			default:
				throw new Error( 'unsupported toneMapping: ' + toneMapping );
	
		}
	
		return 'vec3 ' + functionName + '( vec3 color ) { return ' + toneMappingName + 'ToneMapping( color ); }';
	
	}
	
	function generateExtensions( extensions, parameters, rendererExtensions ) {
	
		extensions = extensions || {};
	
		var chunks = [
			( extensions.derivatives || parameters.envMapCubeUV || parameters.bumpMap || ( parameters.normalMap && ! parameters.objectSpaceNormalMap ) || parameters.flatShading ) ? '#extension GL_OES_standard_derivatives : enable' : '',
			( extensions.fragDepth || parameters.logarithmicDepthBuffer ) && rendererExtensions.get( 'EXT_frag_depth' ) ? '#extension GL_EXT_frag_depth : enable' : '',
			( extensions.drawBuffers ) && rendererExtensions.get( 'WEBGL_draw_buffers' ) ? '#extension GL_EXT_draw_buffers : require' : '',
			( extensions.shaderTextureLOD || parameters.envMap ) && rendererExtensions.get( 'EXT_shader_texture_lod' ) ? '#extension GL_EXT_shader_texture_lod : enable' : ''
		];
	
		return chunks.filter( filterEmptyLine ).join( '\n' );
	
	}
	
	function generateDefines( defines ) {
	
		var chunks = [];
	
		for ( var name in defines ) {
	
			var value = defines[ name ];
	
			if ( value === false ) continue;
	
			chunks.push( '#define ' + name + ' ' + value );
	
		}
	
		return chunks.join( '\n' );
	
	}
	
	function fetchAttributeLocations( gl, program ) {
	
		var attributes = {};
	
		var n = gl.getProgramParameter( program, 35721 );
	
		for ( var i = 0; i < n; i ++ ) {
	
			var info = gl.getActiveAttrib( program, i );
			var name = info.name;
	
			// console.log( 'THREE.WebGLProgram: ACTIVE VERTEX ATTRIBUTE:', name, i );
	
			attributes[ name ] = gl.getAttribLocation( program, name );
	
		}
	
		return attributes;
	
	}
	
	function filterEmptyLine( string ) {
	
		return string !== '';
	
	}
	
	function replaceLightNums( string, parameters ) {
	
		return string
			.replace( /NUM_DIR_LIGHTS/g, parameters.numDirLights )
			.replace( /NUM_SPOT_LIGHTS/g, parameters.numSpotLights )
			.replace( /NUM_RECT_AREA_LIGHTS/g, parameters.numRectAreaLights )
			.replace( /NUM_POINT_LIGHTS/g, parameters.numPointLights )
			.replace( /NUM_HEMI_LIGHTS/g, parameters.numHemiLights );
	
	}
	
	function replaceClippingPlaneNums( string, parameters ) {
	
		return string
			.replace( /NUM_CLIPPING_PLANES/g, parameters.numClippingPlanes )
			.replace( /UNION_CLIPPING_PLANES/g, ( parameters.numClippingPlanes - parameters.numClipIntersection ) );
	
	}
	
	function parseIncludes( string ) {
	
		var pattern = /^[ \t]*#include +<([\w\d./]+)>/gm;
	
		function replace( match, include ) {
	
			var replace = ShaderChunk[ include ];
	
			if ( replace === undefined ) {
	
				throw new Error( 'Can not resolve #include <' + include + '>' );
	
			}
	
			return parseIncludes( replace );
	
		}
	
		return string.replace( pattern, replace );
	
	}
	
	function unrollLoops( string ) {
	
		var pattern = /#pragma unroll_loop[\s]+?for \( int i \= (\d+)\; i < (\d+)\; i \+\+ \) \{([\s\S]+?)(?=\})\}/g;
	
		function replace( match, start, end, snippet ) {
	
			var unroll = '';
	
			for ( var i = parseInt( start ); i < parseInt( end ); i ++ ) {
	
				unroll += snippet.replace( /\[ i \]/g, '[ ' + i + ' ]' );
	
			}
	
			return unroll;
	
		}
	
		return string.replace( pattern, replace );
	
	}
	
	function WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities ) {
	
		var gl = renderer.context;
	
		var defines = material.defines;
	
		var vertexShader = shader.vertexShader;
		var fragmentShader = shader.fragmentShader;
	
		var shadowMapTypeDefine = 'SHADOWMAP_TYPE_BASIC';
	
		if ( parameters.shadowMapType === PCFShadowMap ) {
	
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF';
	
		} else if ( parameters.shadowMapType === PCFSoftShadowMap ) {
	
			shadowMapTypeDefine = 'SHADOWMAP_TYPE_PCF_SOFT';
	
		}
	
		var envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
		var envMapModeDefine = 'ENVMAP_MODE_REFLECTION';
		var envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
	
		if ( parameters.envMap ) {
	
			switch ( material.envMap.mapping ) {
	
				case CubeReflectionMapping:
				case CubeRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE';
					break;
	
				case CubeUVReflectionMapping:
				case CubeUVRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_CUBE_UV';
					break;
	
				case EquirectangularReflectionMapping:
				case EquirectangularRefractionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_EQUIREC';
					break;
	
				case SphericalReflectionMapping:
					envMapTypeDefine = 'ENVMAP_TYPE_SPHERE';
					break;
	
			}
	
			switch ( material.envMap.mapping ) {
	
				case CubeRefractionMapping:
				case EquirectangularRefractionMapping:
					envMapModeDefine = 'ENVMAP_MODE_REFRACTION';
					break;
	
			}
	
			switch ( material.combine ) {
	
				case MultiplyOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MULTIPLY';
					break;
	
				case MixOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_MIX';
					break;
	
				case AddOperation:
					envMapBlendingDefine = 'ENVMAP_BLENDING_ADD';
					break;
	
			}
	
		}
	
		var gammaFactorDefine = ( renderer.gammaFactor > 0 ) ? renderer.gammaFactor : 1.0;
	
		// console.log( 'building new program ' );
	
		//
	
		var customExtensions = capabilities.isWebGL2 ? '' : generateExtensions( material.extensions, parameters, extensions );
	
		var customDefines = generateDefines( defines );
	
		//
	
		var program = gl.createProgram();
	
		var prefixVertex, prefixFragment;
	
		if ( material.isRawShaderMaterial ) {
	
			prefixVertex = [
	
				customDefines
	
			].filter( filterEmptyLine ).join( '\n' );
	
			if ( prefixVertex.length > 0 ) {
	
				prefixVertex += '\n';
	
			}
	
			prefixFragment = [
	
				customExtensions,
				customDefines
	
			].filter( filterEmptyLine ).join( '\n' );
	
			if ( prefixFragment.length > 0 ) {
	
				prefixFragment += '\n';
	
			}
	
		} else {
	
			prefixVertex = [
	
				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',
	
				'#define SHADER_NAME ' + shader.name,
	
				customDefines,
	
				parameters.supportsVertexTextures ? '#define VERTEX_TEXTURES' : '',
	
				'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
				'#define MAX_BONES ' + parameters.maxBones,
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
				parameters.map ? '#define USE_MAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.displacementMap && parameters.supportsVertexTextures ? '#define USE_DISPLACEMENTMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
	
				parameters.flatShading ? '#define FLAT_SHADED' : '',
	
				parameters.skinning ? '#define USE_SKINNING' : '',
				parameters.useVertexTexture ? '#define BONE_TEXTURE' : '',
	
				parameters.morphTargets ? '#define USE_MORPHTARGETS' : '',
				parameters.morphNormals && parameters.flatShading === false ? '#define USE_MORPHNORMALS' : '',
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',
	
				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
				parameters.sizeAttenuation ? '#define USE_SIZEATTENUATION' : '',
	
				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
				'uniform mat4 modelMatrix;',
				'uniform mat4 modelViewMatrix;',
				'uniform mat4 projectionMatrix;',
				'uniform mat4 viewMatrix;',
				'uniform mat3 normalMatrix;',
				'uniform vec3 cameraPosition;',
	
				'attribute vec3 position;',
				'attribute vec3 normal;',
				'attribute vec2 uv;',
	
				'#ifdef USE_COLOR',
	
				'	attribute vec3 color;',
	
				'#endif',
	
				'#ifdef USE_MORPHTARGETS',
	
				'	attribute vec3 morphTarget0;',
				'	attribute vec3 morphTarget1;',
				'	attribute vec3 morphTarget2;',
				'	attribute vec3 morphTarget3;',
	
				'	#ifdef USE_MORPHNORMALS',
	
				'		attribute vec3 morphNormal0;',
				'		attribute vec3 morphNormal1;',
				'		attribute vec3 morphNormal2;',
				'		attribute vec3 morphNormal3;',
	
				'	#else',
	
				'		attribute vec3 morphTarget4;',
				'		attribute vec3 morphTarget5;',
				'		attribute vec3 morphTarget6;',
				'		attribute vec3 morphTarget7;',
	
				'	#endif',
	
				'#endif',
	
				'#ifdef USE_SKINNING',
	
				'	attribute vec4 skinIndex;',
				'	attribute vec4 skinWeight;',
	
				'#endif',
	
				'\n'
	
			].filter( filterEmptyLine ).join( '\n' );
	
			prefixFragment = [
	
				customExtensions,
	
				'precision ' + parameters.precision + ' float;',
				'precision ' + parameters.precision + ' int;',
	
				'#define SHADER_NAME ' + shader.name,
	
				customDefines,
	
				parameters.alphaTest ? '#define ALPHATEST ' + parameters.alphaTest + ( parameters.alphaTest % 1 ? '' : '.0' ) : '', // add '.0' if integer
	
				'#define GAMMA_FACTOR ' + gammaFactorDefine,
	
				( parameters.useFog && parameters.fog ) ? '#define USE_FOG' : '',
				( parameters.useFog && parameters.fogExp ) ? '#define FOG_EXP2' : '',
	
				parameters.map ? '#define USE_MAP' : '',
				parameters.matcap ? '#define USE_MATCAP' : '',
				parameters.envMap ? '#define USE_ENVMAP' : '',
				parameters.envMap ? '#define ' + envMapTypeDefine : '',
				parameters.envMap ? '#define ' + envMapModeDefine : '',
				parameters.envMap ? '#define ' + envMapBlendingDefine : '',
				parameters.lightMap ? '#define USE_LIGHTMAP' : '',
				parameters.aoMap ? '#define USE_AOMAP' : '',
				parameters.emissiveMap ? '#define USE_EMISSIVEMAP' : '',
				parameters.bumpMap ? '#define USE_BUMPMAP' : '',
				parameters.normalMap ? '#define USE_NORMALMAP' : '',
				( parameters.normalMap && parameters.objectSpaceNormalMap ) ? '#define OBJECTSPACE_NORMALMAP' : '',
				parameters.specularMap ? '#define USE_SPECULARMAP' : '',
				parameters.roughnessMap ? '#define USE_ROUGHNESSMAP' : '',
				parameters.metalnessMap ? '#define USE_METALNESSMAP' : '',
				parameters.alphaMap ? '#define USE_ALPHAMAP' : '',
				parameters.vertexColors ? '#define USE_COLOR' : '',
	
				parameters.gradientMap ? '#define USE_GRADIENTMAP' : '',
	
				parameters.flatShading ? '#define FLAT_SHADED' : '',
	
				parameters.doubleSided ? '#define DOUBLE_SIDED' : '',
				parameters.flipSided ? '#define FLIP_SIDED' : '',
	
				parameters.shadowMapEnabled ? '#define USE_SHADOWMAP' : '',
				parameters.shadowMapEnabled ? '#define ' + shadowMapTypeDefine : '',
	
				parameters.premultipliedAlpha ? '#define PREMULTIPLIED_ALPHA' : '',
	
				parameters.physicallyCorrectLights ? '#define PHYSICALLY_CORRECT_LIGHTS' : '',
	
				parameters.logarithmicDepthBuffer ? '#define USE_LOGDEPTHBUF' : '',
				parameters.logarithmicDepthBuffer && ( capabilities.isWebGL2 || extensions.get( 'EXT_frag_depth' ) ) ? '#define USE_LOGDEPTHBUF_EXT' : '',
	
				parameters.envMap && ( capabilities.isWebGL2 || extensions.get( 'EXT_shader_texture_lod' ) ) ? '#define TEXTURE_LOD_EXT' : '',
	
				'uniform mat4 viewMatrix;',
				'uniform vec3 cameraPosition;',
	
				( parameters.toneMapping !== NoToneMapping ) ? '#define TONE_MAPPING' : '',
				( parameters.toneMapping !== NoToneMapping ) ? ShaderChunk[ 'tonemapping_pars_fragment' ] : '', // this code is required here because it is used by the toneMapping() function defined below
				( parameters.toneMapping !== NoToneMapping ) ? getToneMappingFunction( 'toneMapping', parameters.toneMapping ) : '',
	
				parameters.dithering ? '#define DITHERING' : '',
	
				( parameters.outputEncoding || parameters.mapEncoding || parameters.matcapEncoding || parameters.envMapEncoding || parameters.emissiveMapEncoding ) ?
					ShaderChunk[ 'encodings_pars_fragment' ] : '', // this code is required here because it is used by the various encoding/decoding function defined below
				parameters.mapEncoding ? getTexelDecodingFunction( 'mapTexelToLinear', parameters.mapEncoding ) : '',
				parameters.matcapEncoding ? getTexelDecodingFunction( 'matcapTexelToLinear', parameters.matcapEncoding ) : '',
				parameters.envMapEncoding ? getTexelDecodingFunction( 'envMapTexelToLinear', parameters.envMapEncoding ) : '',
				parameters.emissiveMapEncoding ? getTexelDecodingFunction( 'emissiveMapTexelToLinear', parameters.emissiveMapEncoding ) : '',
				parameters.outputEncoding ? getTexelEncodingFunction( 'linearToOutputTexel', parameters.outputEncoding ) : '',
	
				parameters.depthPacking ? '#define DEPTH_PACKING ' + material.depthPacking : '',
	
				'\n'
	
			].filter( filterEmptyLine ).join( '\n' );
	
		}
	
		vertexShader = parseIncludes( vertexShader );
		vertexShader = replaceLightNums( vertexShader, parameters );
		vertexShader = replaceClippingPlaneNums( vertexShader, parameters );
	
		fragmentShader = parseIncludes( fragmentShader );
		fragmentShader = replaceLightNums( fragmentShader, parameters );
		fragmentShader = replaceClippingPlaneNums( fragmentShader, parameters );
	
		vertexShader = unrollLoops( vertexShader );
		fragmentShader = unrollLoops( fragmentShader );
	
		if ( capabilities.isWebGL2 && ! material.isRawShaderMaterial ) {
	
			var isGLSL3ShaderMaterial = false;
	
			var versionRegex = /^\s*#version\s+300\s+es\s*\n/;
	
			if ( material.isShaderMaterial &&
				vertexShader.match( versionRegex ) !== null &&
				fragmentShader.match( versionRegex ) !== null ) {
	
				isGLSL3ShaderMaterial = true;
	
				vertexShader = vertexShader.replace( versionRegex, '' );
				fragmentShader = fragmentShader.replace( versionRegex, '' );
	
			}
	
			// GLSL 3.0 conversion
			prefixVertex = [
				'#version 300 es\n',
				'#define attribute in',
				'#define varying out',
				'#define texture2D texture'
			].join( '\n' ) + '\n' + prefixVertex;
	
			prefixFragment = [
				'#version 300 es\n',
				'#define varying in',
				isGLSL3ShaderMaterial ? '' : 'out highp vec4 pc_fragColor;',
				isGLSL3ShaderMaterial ? '' : '#define gl_FragColor pc_fragColor',
				'#define gl_FragDepthEXT gl_FragDepth',
				'#define texture2D texture',
				'#define textureCube texture',
				'#define texture2DProj textureProj',
				'#define texture2DLodEXT textureLod',
				'#define texture2DProjLodEXT textureProjLod',
				'#define textureCubeLodEXT textureLod',
				'#define texture2DGradEXT textureGrad',
				'#define texture2DProjGradEXT textureProjGrad',
				'#define textureCubeGradEXT textureGrad'
			].join( '\n' ) + '\n' + prefixFragment;
	
		}
	
		var vertexGlsl = prefixVertex + vertexShader;
		var fragmentGlsl = prefixFragment + fragmentShader;
	
		// console.log( '*VERTEX*', vertexGlsl );
		// console.log( '*FRAGMENT*', fragmentGlsl );
	
		var glVertexShader = WebGLShader( gl, 35633, vertexGlsl );
		var glFragmentShader = WebGLShader( gl, 35632, fragmentGlsl );
	
		gl.attachShader( program, glVertexShader );
		gl.attachShader( program, glFragmentShader );
	
		// Force a particular attribute to index 0.
	
		if ( material.index0AttributeName !== undefined ) {
	
			gl.bindAttribLocation( program, 0, material.index0AttributeName );
	
		} else if ( parameters.morphTargets === true ) {
	
			// programs with morphTargets displace position out of attribute 0
			gl.bindAttribLocation( program, 0, 'position' );
	
		}
	
		gl.linkProgram( program );
	
		var programLog = gl.getProgramInfoLog( program ).trim();
		var vertexLog = gl.getShaderInfoLog( glVertexShader ).trim();
		var fragmentLog = gl.getShaderInfoLog( glFragmentShader ).trim();
	
		var runnable = true;
		var haveDiagnostics = true;
	
		// console.log( '**VERTEX**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glVertexShader ) );
		// console.log( '**FRAGMENT**', gl.getExtension( 'WEBGL_debug_shaders' ).getTranslatedShaderSource( glFragmentShader ) );
	
		if ( gl.getProgramParameter( program, 35714 ) === false ) {
	
			runnable = false;
	
			console.error( 'THREE.WebGLProgram: shader error: ', gl.getError(), '35715', gl.getProgramParameter( program, 35715 ), 'gl.getProgramInfoLog', programLog, vertexLog, fragmentLog );
	
		} else if ( programLog !== '' ) {
	
			console.warn( 'THREE.WebGLProgram: gl.getProgramInfoLog()', programLog );
	
		} else if ( vertexLog === '' || fragmentLog === '' ) {
	
			haveDiagnostics = false;
	
		}
	
		if ( haveDiagnostics ) {
	
			this.diagnostics = {
	
				runnable: runnable,
				material: material,
	
				programLog: programLog,
	
				vertexShader: {
	
					log: vertexLog,
					prefix: prefixVertex
	
				},
	
				fragmentShader: {
	
					log: fragmentLog,
					prefix: prefixFragment
	
				}
	
			};
	
		}
	
		// clean up
	
		gl.deleteShader( glVertexShader );
		gl.deleteShader( glFragmentShader );
	
		// set up caching for uniform locations
	
		var cachedUniforms;
	
		this.getUniforms = function () {
	
			if ( cachedUniforms === undefined ) {
	
				cachedUniforms = new WebGLUniforms( gl, program, renderer );
	
			}
	
			return cachedUniforms;
	
		};
	
		// set up caching for attribute locations
	
		var cachedAttributes;
	
		this.getAttributes = function () {
	
			if ( cachedAttributes === undefined ) {
	
				cachedAttributes = fetchAttributeLocations( gl, program );
	
			}
	
			return cachedAttributes;
	
		};
	
		// free resource
	
		this.destroy = function () {
	
			gl.deleteProgram( program );
			this.program = undefined;
	
		};
	
		// DEPRECATED
	
		Object.defineProperties( this, {
	
			uniforms: {
				get: function () {
	
					console.warn( 'THREE.WebGLProgram: .uniforms is now .getUniforms().' );
					return this.getUniforms();
	
				}
			},
	
			attributes: {
				get: function () {
	
					console.warn( 'THREE.WebGLProgram: .attributes is now .getAttributes().' );
					return this.getAttributes();
	
				}
			}
	
		} );
	
	
		//
	
		this.name = shader.name;
		this.id = programIdCount ++;
		this.code = code;
		this.usedTimes = 1;
		this.program = program;
		this.vertexShader = glVertexShader;
		this.fragmentShader = glFragmentShader;
	
		return this;
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLPrograms( renderer, extensions, capabilities ) {
	
		var programs = [];
	
		var shaderIDs = {
			MeshDepthMaterial: 'depth',
			MeshDistanceMaterial: 'distanceRGBA',
			MeshNormalMaterial: 'normal',
			MeshBasicMaterial: 'basic',
			MeshLambertMaterial: 'lambert',
			MeshPhongMaterial: 'phong',
			MeshToonMaterial: 'phong',
			MeshStandardMaterial: 'physical',
			MeshPhysicalMaterial: 'physical',
			MeshMatcapMaterial: 'matcap',
			LineBasicMaterial: 'basic',
			LineDashedMaterial: 'dashed',
			PointsMaterial: 'points',
			ShadowMaterial: 'shadow',
			SpriteMaterial: 'sprite'
		};
	
		var parameterNames = [
			"precision", "supportsVertexTextures", "map", "mapEncoding", "matcap", "matcapEncoding", "envMap", "envMapMode", "envMapEncoding",
			"lightMap", "aoMap", "emissiveMap", "emissiveMapEncoding", "bumpMap", "normalMap", "objectSpaceNormalMap", "displacementMap", "specularMap",
			"roughnessMap", "metalnessMap", "gradientMap",
			"alphaMap", "combine", "vertexColors", "fog", "useFog", "fogExp",
			"flatShading", "sizeAttenuation", "logarithmicDepthBuffer", "skinning",
			"maxBones", "useVertexTexture", "morphTargets", "morphNormals",
			"maxMorphTargets", "maxMorphNormals", "premultipliedAlpha",
			"numDirLights", "numPointLights", "numSpotLights", "numHemiLights", "numRectAreaLights",
			"shadowMapEnabled", "shadowMapType", "toneMapping", 'physicallyCorrectLights',
			"alphaTest", "doubleSided", "flipSided", "numClippingPlanes", "numClipIntersection", "depthPacking", "dithering"
		];
	
	
		function allocateBones( object ) {
	
			var skeleton = object.skeleton;
			var bones = skeleton.bones;
	
			if ( capabilities.floatVertexTextures ) {
	
				return 1024;
	
			} else {
	
				// default for when object is not specified
				// ( for example when prebuilding shader to be used with multiple objects )
				//
				//  - leave some extra space for other uniforms
				//  - limit here is ANGLE's 254 max uniform vectors
				//    (up to 54 should be safe)
	
				var nVertexUniforms = capabilities.maxVertexUniforms;
				var nVertexMatrices = Math.floor( ( nVertexUniforms - 20 ) / 4 );
	
				var maxBones = Math.min( nVertexMatrices, bones.length );
	
				if ( maxBones < bones.length ) {
	
					console.warn( 'THREE.WebGLRenderer: Skeleton has ' + bones.length + ' bones. This GPU supports ' + maxBones + '.' );
					return 0;
	
				}
	
				return maxBones;
	
			}
	
		}
	
		function getTextureEncodingFromMap( map, gammaOverrideLinear ) {
	
			var encoding;
	
			if ( ! map ) {
	
				encoding = LinearEncoding;
	
			} else if ( map.isTexture ) {
	
				encoding = map.encoding;
	
			} else if ( map.isWebGLRenderTarget ) {
	
				console.warn( "THREE.WebGLPrograms.getTextureEncodingFromMap: don't use render targets as textures. Use their .texture property instead." );
				encoding = map.texture.encoding;
	
			}
	
			// add backwards compatibility for WebGLRenderer.gammaInput/gammaOutput parameter, should probably be removed at some point.
			if ( encoding === LinearEncoding && gammaOverrideLinear ) {
	
				encoding = GammaEncoding;
	
			}
	
			return encoding;
	
		}
	
		this.getParameters = function ( material, lights, shadows, fog, nClipPlanes, nClipIntersection, object ) {
	
			var shaderID = shaderIDs[ material.type ];
	
			// heuristics to create shader parameters according to lights in the scene
			// (not to blow over maxLights budget)
	
			var maxBones = object.isSkinnedMesh ? allocateBones( object ) : 0;
			var precision = capabilities.precision;
	
			if ( material.precision !== null ) {
	
				precision = capabilities.getMaxPrecision( material.precision );
	
				if ( precision !== material.precision ) {
	
					console.warn( 'THREE.WebGLProgram.getParameters:', material.precision, 'not supported, using', precision, 'instead.' );
	
				}
	
			}
	
			var currentRenderTarget = renderer.getRenderTarget();
	
			var parameters = {
	
				shaderID: shaderID,
	
				precision: precision,
				supportsVertexTextures: capabilities.vertexTextures,
				outputEncoding: getTextureEncodingFromMap( ( ! currentRenderTarget ) ? null : currentRenderTarget.texture, renderer.gammaOutput ),
				map: !! material.map,
				mapEncoding: getTextureEncodingFromMap( material.map, renderer.gammaInput ),
				matcap: !! material.matcap,
				matcapEncoding: getTextureEncodingFromMap( material.matcap, renderer.gammaInput ),
				envMap: !! material.envMap,
				envMapMode: material.envMap && material.envMap.mapping,
				envMapEncoding: getTextureEncodingFromMap( material.envMap, renderer.gammaInput ),
				envMapCubeUV: ( !! material.envMap ) && ( ( material.envMap.mapping === CubeUVReflectionMapping ) || ( material.envMap.mapping === CubeUVRefractionMapping ) ),
				lightMap: !! material.lightMap,
				aoMap: !! material.aoMap,
				emissiveMap: !! material.emissiveMap,
				emissiveMapEncoding: getTextureEncodingFromMap( material.emissiveMap, renderer.gammaInput ),
				bumpMap: !! material.bumpMap,
				normalMap: !! material.normalMap,
				objectSpaceNormalMap: material.normalMapType === ObjectSpaceNormalMap,
				displacementMap: !! material.displacementMap,
				roughnessMap: !! material.roughnessMap,
				metalnessMap: !! material.metalnessMap,
				specularMap: !! material.specularMap,
				alphaMap: !! material.alphaMap,
	
				gradientMap: !! material.gradientMap,
	
				combine: material.combine,
	
				vertexColors: material.vertexColors,
	
				fog: !! fog,
				useFog: material.fog,
				fogExp: ( fog && fog.isFogExp2 ),
	
				flatShading: material.flatShading,
	
				sizeAttenuation: material.sizeAttenuation,
				logarithmicDepthBuffer: capabilities.logarithmicDepthBuffer,
	
				skinning: material.skinning && maxBones > 0,
				maxBones: maxBones,
				useVertexTexture: capabilities.floatVertexTextures,
	
				morphTargets: material.morphTargets,
				morphNormals: material.morphNormals,
				maxMorphTargets: renderer.maxMorphTargets,
				maxMorphNormals: renderer.maxMorphNormals,
	
				numDirLights: lights.directional.length,
				numPointLights: lights.point.length,
				numSpotLights: lights.spot.length,
				numRectAreaLights: lights.rectArea.length,
				numHemiLights: lights.hemi.length,
	
				numClippingPlanes: nClipPlanes,
				numClipIntersection: nClipIntersection,
	
				dithering: material.dithering,
	
				shadowMapEnabled: renderer.shadowMap.enabled && object.receiveShadow && shadows.length > 0,
				shadowMapType: renderer.shadowMap.type,
	
				toneMapping: renderer.toneMapping,
				physicallyCorrectLights: renderer.physicallyCorrectLights,
	
				premultipliedAlpha: material.premultipliedAlpha,
	
				alphaTest: material.alphaTest,
				doubleSided: material.side === DoubleSide,
				flipSided: material.side === BackSide,
	
				depthPacking: ( material.depthPacking !== undefined ) ? material.depthPacking : false
	
			};
	
			return parameters;
	
		};
	
		this.getProgramCode = function ( material, parameters ) {
	
			var array = [];
	
			if ( parameters.shaderID ) {
	
				array.push( parameters.shaderID );
	
			} else {
	
				array.push( material.fragmentShader );
				array.push( material.vertexShader );
	
			}
	
			if ( material.defines !== undefined ) {
	
				for ( var name in material.defines ) {
	
					array.push( name );
					array.push( material.defines[ name ] );
	
				}
	
			}
	
			for ( var i = 0; i < parameterNames.length; i ++ ) {
	
				array.push( parameters[ parameterNames[ i ] ] );
	
			}
	
			array.push( material.onBeforeCompile.toString() );
	
			array.push( renderer.gammaOutput );
	
			array.push( renderer.gammaFactor );
	
			return array.join();
	
		};
	
		this.acquireProgram = function ( material, shader, parameters, code ) {
	
			var program;
	
			// Check if code has been already compiled
			for ( var p = 0, pl = programs.length; p < pl; p ++ ) {
	
				var programInfo = programs[ p ];
	
				if ( programInfo.code === code ) {
	
					program = programInfo;
					++ program.usedTimes;
	
					break;
	
				}
	
			}
	
			if ( program === undefined ) {
	
				program = new WebGLProgram( renderer, extensions, code, material, shader, parameters, capabilities );
				programs.push( program );
	
			}
	
			return program;
	
		};
	
		this.releaseProgram = function ( program ) {
	
			if ( -- program.usedTimes === 0 ) {
	
				// Remove from unordered set
				var i = programs.indexOf( program );
				programs[ i ] = programs[ programs.length - 1 ];
				programs.pop();
	
				// Free WebGL resources
				program.destroy();
	
			}
	
		};
	
		// Exposed for resource monitoring & error feedback via renderer.info:
		this.programs = programs;
	
	}
	
	/**
	 * @author fordacious / fordacious.github.io
	 */
	
	function WebGLProperties() {
	
		var properties = new WeakMap();
	
		function get( object ) {
	
			var map = properties.get( object );
	
			if ( map === undefined ) {
	
				map = {};
				properties.set( object, map );
	
			}
	
			return map;
	
		}
	
		function remove( object ) {
	
			properties.delete( object );
	
		}
	
		function update( object, key, value ) {
	
			properties.get( object )[ key ] = value;
	
		}
	
		function dispose() {
	
			properties = new WeakMap();
	
		}
	
		return {
			get: get,
			remove: remove,
			update: update,
			dispose: dispose
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function painterSortStable( a, b ) {
	
		if ( a.groupOrder !== b.groupOrder ) {
	
			return a.groupOrder - b.groupOrder;
	
		} else if ( a.renderOrder !== b.renderOrder ) {
	
			return a.renderOrder - b.renderOrder;
	
		} else if ( a.program && b.program && a.program !== b.program ) {
	
			return a.program.id - b.program.id;
	
		} else if ( a.material.id !== b.material.id ) {
	
			return a.material.id - b.material.id;
	
		} else if ( a.z !== b.z ) {
	
			return a.z - b.z;
	
		} else {
	
			return a.id - b.id;
	
		}
	
	}
	
	function reversePainterSortStable( a, b ) {
	
		if ( a.groupOrder !== b.groupOrder ) {
	
			return a.groupOrder - b.groupOrder;
	
		} else if ( a.renderOrder !== b.renderOrder ) {
	
			return a.renderOrder - b.renderOrder;
	
		} if ( a.z !== b.z ) {
	
			return b.z - a.z;
	
		} else {
	
			return a.id - b.id;
	
		}
	
	}
	
	
	function WebGLRenderList() {
	
		var renderItems = [];
		var renderItemsIndex = 0;
	
		var opaque = [];
		var transparent = [];
	
		function init() {
	
			renderItemsIndex = 0;
	
			opaque.length = 0;
			transparent.length = 0;
	
		}
	
		function getNextRenderItem( object, geometry, material, groupOrder, z, group ) {
	
			var renderItem = renderItems[ renderItemsIndex ];
	
			if ( renderItem === undefined ) {
	
				renderItem = {
					id: object.id,
					object: object,
					geometry: geometry,
					material: material,
					program: material.program,
					groupOrder: groupOrder,
					renderOrder: object.renderOrder,
					z: z,
					group: group
				};
	
				renderItems[ renderItemsIndex ] = renderItem;
	
			} else {
	
				renderItem.id = object.id;
				renderItem.object = object;
				renderItem.geometry = geometry;
				renderItem.material = material;
				renderItem.program = material.program;
				renderItem.groupOrder = groupOrder;
				renderItem.renderOrder = object.renderOrder;
				renderItem.z = z;
				renderItem.group = group;
	
			}
	
			renderItemsIndex ++;
	
			return renderItem;
	
		}
	
		function push( object, geometry, material, groupOrder, z, group ) {
	
			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );
	
			( material.transparent === true ? transparent : opaque ).push( renderItem );
	
		}
	
		function unshift( object, geometry, material, groupOrder, z, group ) {
	
			var renderItem = getNextRenderItem( object, geometry, material, groupOrder, z, group );
	
			( material.transparent === true ? transparent : opaque ).unshift( renderItem );
	
		}
	
		function sort() {
	
			if ( opaque.length > 1 ) opaque.sort( painterSortStable );
			if ( transparent.length > 1 ) transparent.sort( reversePainterSortStable );
	
		}
	
		return {
			opaque: opaque,
			transparent: transparent,
	
			init: init,
			push: push,
			unshift: unshift,
	
			sort: sort
		};
	
	}
	
	function WebGLRenderLists() {
	
		var lists = {};
	
		function onSceneDispose( event ) {
	
			var scene = event.target;
	
			scene.removeEventListener( 'dispose', onSceneDispose );
	
			delete lists[ scene.id ];
	
		}
	
		function get( scene, camera ) {
	
			var cameras = lists[ scene.id ];
			var list;
			if ( cameras === undefined ) {
	
				list = new WebGLRenderList();
				lists[ scene.id ] = {};
				lists[ scene.id ][ camera.id ] = list;
	
				scene.addEventListener( 'dispose', onSceneDispose );
	
			} else {
	
				list = cameras[ camera.id ];
				if ( list === undefined ) {
	
					list = new WebGLRenderList();
					cameras[ camera.id ] = list;
	
				}
	
			}
	
			return list;
	
		}
	
		function dispose() {
	
			lists = {};
	
		}
	
		return {
			get: get,
			dispose: dispose
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function UniformsCache() {
	
		var lights = {};
	
		return {
	
			get: function ( light ) {
	
				if ( lights[ light.id ] !== undefined ) {
	
					return lights[ light.id ];
	
				}
	
				var uniforms;
	
				switch ( light.type ) {
	
					case 'DirectionalLight':
						uniforms = {
							direction: new Vector3(),
							color: new Color(),
	
							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;
	
					case 'SpotLight':
						uniforms = {
							position: new Vector3(),
							direction: new Vector3(),
							color: new Color(),
							distance: 0,
							coneCos: 0,
							penumbraCos: 0,
							decay: 0,
	
							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2()
						};
						break;
	
					case 'PointLight':
						uniforms = {
							position: new Vector3(),
							color: new Color(),
							distance: 0,
							decay: 0,
	
							shadow: false,
							shadowBias: 0,
							shadowRadius: 1,
							shadowMapSize: new Vector2(),
							shadowCameraNear: 1,
							shadowCameraFar: 1000
						};
						break;
	
					case 'HemisphereLight':
						uniforms = {
							direction: new Vector3(),
							skyColor: new Color(),
							groundColor: new Color()
						};
						break;
	
					case 'RectAreaLight':
						uniforms = {
							color: new Color(),
							position: new Vector3(),
							halfWidth: new Vector3(),
							halfHeight: new Vector3()
							// TODO (abelnation): set RectAreaLight shadow uniforms
						};
						break;
	
				}
	
				lights[ light.id ] = uniforms;
	
				return uniforms;
	
			}
	
		};
	
	}
	
	var count = 0;
	
	function WebGLLights() {
	
		var cache = new UniformsCache();
	
		var state = {
	
			id: count ++,
	
			hash: {
				stateID: - 1,
				directionalLength: - 1,
				pointLength: - 1,
				spotLength: - 1,
				rectAreaLength: - 1,
				hemiLength: - 1,
				shadowsLength: - 1
			},
	
			ambient: [ 0, 0, 0 ],
			directional: [],
			directionalShadowMap: [],
			directionalShadowMatrix: [],
			spot: [],
			spotShadowMap: [],
			spotShadowMatrix: [],
			rectArea: [],
			point: [],
			pointShadowMap: [],
			pointShadowMatrix: [],
			hemi: []
	
		};
	
		var vector3 = new Vector3();
		var matrix4 = new Matrix4();
		var matrix42 = new Matrix4();
	
		function setup( lights, shadows, camera ) {
	
			var r = 0, g = 0, b = 0;
	
			var directionalLength = 0;
			var pointLength = 0;
			var spotLength = 0;
			var rectAreaLength = 0;
			var hemiLength = 0;
	
			var viewMatrix = camera.matrixWorldInverse;
	
			for ( var i = 0, l = lights.length; i < l; i ++ ) {
	
				var light = lights[ i ];
	
				var color = light.color;
				var intensity = light.intensity;
				var distance = light.distance;
	
				var shadowMap = ( light.shadow && light.shadow.map ) ? light.shadow.map.texture : null;
	
				if ( light.isAmbientLight ) {
	
					r += color.r * intensity;
					g += color.g * intensity;
					b += color.b * intensity;
	
				} else if ( light.isDirectionalLight ) {
	
					var uniforms = cache.get( light );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						var shadow = light.shadow;
	
						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
	
					}
	
					state.directionalShadowMap[ directionalLength ] = shadowMap;
					state.directionalShadowMatrix[ directionalLength ] = light.shadow.matrix;
					state.directional[ directionalLength ] = uniforms;
	
					directionalLength ++;
	
				} else if ( light.isSpotLight ) {
	
					var uniforms = cache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( color ).multiplyScalar( intensity );
					uniforms.distance = distance;
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					vector3.setFromMatrixPosition( light.target.matrixWorld );
					uniforms.direction.sub( vector3 );
					uniforms.direction.transformDirection( viewMatrix );
	
					uniforms.coneCos = Math.cos( light.angle );
					uniforms.penumbraCos = Math.cos( light.angle * ( 1 - light.penumbra ) );
					uniforms.decay = light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						var shadow = light.shadow;
	
						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
	
					}
	
					state.spotShadowMap[ spotLength ] = shadowMap;
					state.spotShadowMatrix[ spotLength ] = light.shadow.matrix;
					state.spot[ spotLength ] = uniforms;
	
					spotLength ++;
	
				} else if ( light.isRectAreaLight ) {
	
					var uniforms = cache.get( light );
	
					// (a) intensity is the total visible light emitted
					//uniforms.color.copy( color ).multiplyScalar( intensity / ( light.width * light.height * Math.PI ) );
	
					// (b) intensity is the brightness of the light
					uniforms.color.copy( color ).multiplyScalar( intensity );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					// extract local rotation of light to derive width/height half vectors
					matrix42.identity();
					matrix4.copy( light.matrixWorld );
					matrix4.premultiply( viewMatrix );
					matrix42.extractRotation( matrix4 );
	
					uniforms.halfWidth.set( light.width * 0.5, 0.0, 0.0 );
					uniforms.halfHeight.set( 0.0, light.height * 0.5, 0.0 );
	
					uniforms.halfWidth.applyMatrix4( matrix42 );
					uniforms.halfHeight.applyMatrix4( matrix42 );
	
					// TODO (abelnation): RectAreaLight distance?
					// uniforms.distance = distance;
	
					state.rectArea[ rectAreaLength ] = uniforms;
	
					rectAreaLength ++;
	
				} else if ( light.isPointLight ) {
	
					var uniforms = cache.get( light );
	
					uniforms.position.setFromMatrixPosition( light.matrixWorld );
					uniforms.position.applyMatrix4( viewMatrix );
	
					uniforms.color.copy( light.color ).multiplyScalar( light.intensity );
					uniforms.distance = light.distance;
					uniforms.decay = light.decay;
	
					uniforms.shadow = light.castShadow;
	
					if ( light.castShadow ) {
	
						var shadow = light.shadow;
	
						uniforms.shadowBias = shadow.bias;
						uniforms.shadowRadius = shadow.radius;
						uniforms.shadowMapSize = shadow.mapSize;
						uniforms.shadowCameraNear = shadow.camera.near;
						uniforms.shadowCameraFar = shadow.camera.far;
	
					}
	
					state.pointShadowMap[ pointLength ] = shadowMap;
					state.pointShadowMatrix[ pointLength ] = light.shadow.matrix;
					state.point[ pointLength ] = uniforms;
	
					pointLength ++;
	
				} else if ( light.isHemisphereLight ) {
	
					var uniforms = cache.get( light );
	
					uniforms.direction.setFromMatrixPosition( light.matrixWorld );
					uniforms.direction.transformDirection( viewMatrix );
					uniforms.direction.normalize();
	
					uniforms.skyColor.copy( light.color ).multiplyScalar( intensity );
					uniforms.groundColor.copy( light.groundColor ).multiplyScalar( intensity );
	
					state.hemi[ hemiLength ] = uniforms;
	
					hemiLength ++;
	
				}
	
			}
	
			state.ambient[ 0 ] = r;
			state.ambient[ 1 ] = g;
			state.ambient[ 2 ] = b;
	
			state.directional.length = directionalLength;
			state.spot.length = spotLength;
			state.rectArea.length = rectAreaLength;
			state.point.length = pointLength;
			state.hemi.length = hemiLength;
	
			state.hash.stateID = state.id;
			state.hash.directionalLength = directionalLength;
			state.hash.pointLength = pointLength;
			state.hash.spotLength = spotLength;
			state.hash.rectAreaLength = rectAreaLength;
			state.hash.hemiLength = hemiLength;
			state.hash.shadowsLength = shadows.length;
	
		}
	
		return {
			setup: setup,
			state: state
		};
	
	}
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	function WebGLRenderState() {
	
		var lights = new WebGLLights();
	
		var lightsArray = [];
		var shadowsArray = [];
	
		function init() {
	
			lightsArray.length = 0;
			shadowsArray.length = 0;
	
		}
	
		function pushLight( light ) {
	
			lightsArray.push( light );
	
		}
	
		function pushShadow( shadowLight ) {
	
			shadowsArray.push( shadowLight );
	
		}
	
		function setupLights( camera ) {
	
			lights.setup( lightsArray, shadowsArray, camera );
	
		}
	
		var state = {
			lightsArray: lightsArray,
			shadowsArray: shadowsArray,
	
			lights: lights
		};
	
		return {
			init: init,
			state: state,
			setupLights: setupLights,
	
			pushLight: pushLight,
			pushShadow: pushShadow
		};
	
	}
	
	function WebGLRenderStates() {
	
		var renderStates = {};
	
		function onSceneDispose( event ) {
	
			var scene = event.target;
	
			scene.removeEventListener( 'dispose', onSceneDispose );
	
			delete renderStates[ scene.id ];
	
		}
	
		function get( scene, camera ) {
	
			var renderState;
	
			if ( renderStates[ scene.id ] === undefined ) {
	
				renderState = new WebGLRenderState();
				renderStates[ scene.id ] = {};
				renderStates[ scene.id ][ camera.id ] = renderState;
	
				scene.addEventListener( 'dispose', onSceneDispose );
	
			} else {
	
				if ( renderStates[ scene.id ][ camera.id ] === undefined ) {
	
					renderState = new WebGLRenderState();
					renderStates[ scene.id ][ camera.id ] = renderState;
	
				} else {
	
					renderState = renderStates[ scene.id ][ camera.id ];
	
				}
	
			}
	
			return renderState;
	
		}
	
		function dispose() {
	
			renderStates = {};
	
		}
	
		return {
			get: get,
			dispose: dispose
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author bhouston / https://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 * }
	 */
	
	function MeshDepthMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'MeshDepthMaterial';
	
		this.depthPacking = BasicDepthPacking;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.map = null;
	
		this.alphaMap = null;
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false;
		this.lights = false;
	
		this.setValues( parameters );
	
	}
	
	MeshDepthMaterial.prototype = Object.create( Material.prototype );
	MeshDepthMaterial.prototype.constructor = MeshDepthMaterial;
	
	MeshDepthMaterial.prototype.isMeshDepthMaterial = true;
	
	MeshDepthMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.depthPacking = source.depthPacking;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		this.map = source.map;
	
		this.alphaMap = source.alphaMap;
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		return this;
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *
	 *  referencePosition: <float>,
	 *  nearDistance: <float>,
	 *  farDistance: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>
	 *
	 * }
	 */
	
	function MeshDistanceMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'MeshDistanceMaterial';
	
		this.referencePosition = new Vector3();
		this.nearDistance = 1;
		this.farDistance = 1000;
	
		this.skinning = false;
		this.morphTargets = false;
	
		this.map = null;
	
		this.alphaMap = null;
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.fog = false;
		this.lights = false;
	
		this.setValues( parameters );
	
	}
	
	MeshDistanceMaterial.prototype = Object.create( Material.prototype );
	MeshDistanceMaterial.prototype.constructor = MeshDistanceMaterial;
	
	MeshDistanceMaterial.prototype.isMeshDistanceMaterial = true;
	
	MeshDistanceMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.referencePosition.copy( source.referencePosition );
		this.nearDistance = source.nearDistance;
		this.farDistance = source.farDistance;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
	
		this.map = source.map;
	
		this.alphaMap = source.alphaMap;
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		return this;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLShadowMap( _renderer, _objects, maxTextureSize ) {
	
		var _frustum = new Frustum(),
			_projScreenMatrix = new Matrix4(),
	
			_shadowMapSize = new Vector2(),
			_maxShadowMapSize = new Vector2( maxTextureSize, maxTextureSize ),
	
			_lookTarget = new Vector3(),
			_lightPositionWorld = new Vector3(),
	
			_MorphingFlag = 1,
			_SkinningFlag = 2,
	
			_NumberOfMaterialVariants = ( _MorphingFlag | _SkinningFlag ) + 1,
	
			_depthMaterials = new Array( _NumberOfMaterialVariants ),
			_distanceMaterials = new Array( _NumberOfMaterialVariants ),
	
			_materialCache = {};
	
		var shadowSide = { 0: BackSide, 1: FrontSide, 2: DoubleSide };
	
		var cubeDirections = [
			new Vector3( 1, 0, 0 ), new Vector3( - 1, 0, 0 ), new Vector3( 0, 0, 1 ),
			new Vector3( 0, 0, - 1 ), new Vector3( 0, 1, 0 ), new Vector3( 0, - 1, 0 )
		];
	
		var cubeUps = [
			new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ), new Vector3( 0, 1, 0 ),
			new Vector3( 0, 1, 0 ), new Vector3( 0, 0, 1 ),	new Vector3( 0, 0, - 1 )
		];
	
		var cube2DViewPorts = [
			new Vector4(), new Vector4(), new Vector4(),
			new Vector4(), new Vector4(), new Vector4()
		];
	
		// init
	
		for ( var i = 0; i !== _NumberOfMaterialVariants; ++ i ) {
	
			var useMorphing = ( i & _MorphingFlag ) !== 0;
			var useSkinning = ( i & _SkinningFlag ) !== 0;
	
			var depthMaterial = new MeshDepthMaterial( {
	
				depthPacking: RGBADepthPacking,
	
				morphTargets: useMorphing,
				skinning: useSkinning
	
			} );
	
			_depthMaterials[ i ] = depthMaterial;
	
			//
	
			var distanceMaterial = new MeshDistanceMaterial( {
	
				morphTargets: useMorphing,
				skinning: useSkinning
	
			} );
	
			_distanceMaterials[ i ] = distanceMaterial;
	
		}
	
		//
	
		var scope = this;
	
		this.enabled = false;
	
		this.autoUpdate = true;
		this.needsUpdate = false;
	
		this.type = PCFShadowMap;
	
		this.render = function ( lights, scene, camera ) {
	
			if ( scope.enabled === false ) return;
			if ( scope.autoUpdate === false && scope.needsUpdate === false ) return;
	
			if ( lights.length === 0 ) return;
	
			var _state = _renderer.state;
	
			// Set GL state for depth map.
			_state.setBlending( NoBlending );
			_state.buffers.color.setClear( 1, 1, 1, 1 );
			_state.buffers.depth.setTest( true );
			_state.setScissorTest( false );
	
			// render depth map
	
			var faceCount;
	
			for ( var i = 0, il = lights.length; i < il; i ++ ) {
	
				var light = lights[ i ];
				var shadow = light.shadow;
				var isPointLight = light && light.isPointLight;
	
				if ( shadow === undefined ) {
	
					console.warn( 'THREE.WebGLShadowMap:', light, 'has no shadow.' );
					continue;
	
				}
	
				var shadowCamera = shadow.camera;
	
				_shadowMapSize.copy( shadow.mapSize );
				_shadowMapSize.min( _maxShadowMapSize );
	
				if ( isPointLight ) {
	
					var vpWidth = _shadowMapSize.x;
					var vpHeight = _shadowMapSize.y;
	
					// These viewports map a cube-map onto a 2D texture with the
					// following orientation:
					//
					//  xzXZ
					//   y Y
					//
					// X - Positive x direction
					// x - Negative x direction
					// Y - Positive y direction
					// y - Negative y direction
					// Z - Positive z direction
					// z - Negative z direction
	
					// positive X
					cube2DViewPorts[ 0 ].set( vpWidth * 2, vpHeight, vpWidth, vpHeight );
					// negative X
					cube2DViewPorts[ 1 ].set( 0, vpHeight, vpWidth, vpHeight );
					// positive Z
					cube2DViewPorts[ 2 ].set( vpWidth * 3, vpHeight, vpWidth, vpHeight );
					// negative Z
					cube2DViewPorts[ 3 ].set( vpWidth, vpHeight, vpWidth, vpHeight );
					// positive Y
					cube2DViewPorts[ 4 ].set( vpWidth * 3, 0, vpWidth, vpHeight );
					// negative Y
					cube2DViewPorts[ 5 ].set( vpWidth, 0, vpWidth, vpHeight );
	
					_shadowMapSize.x *= 4.0;
					_shadowMapSize.y *= 2.0;
	
				}
	
				if ( shadow.map === null ) {
	
					var pars = { minFilter: NearestFilter, magFilter: NearestFilter, format: RGBAFormat };
	
					shadow.map = new WebGLRenderTarget( _shadowMapSize.x, _shadowMapSize.y, pars );
					shadow.map.texture.name = light.name + ".shadowMap";
	
					shadowCamera.updateProjectionMatrix();
	
				}
	
				if ( shadow.isSpotLightShadow ) {
	
					shadow.update( light );
	
				}
	
				var shadowMap = shadow.map;
				var shadowMatrix = shadow.matrix;
	
				_lightPositionWorld.setFromMatrixPosition( light.matrixWorld );
				shadowCamera.position.copy( _lightPositionWorld );
	
				if ( isPointLight ) {
	
					faceCount = 6;
	
					// for point lights we set the shadow matrix to be a translation-only matrix
					// equal to inverse of the light's position
	
					shadowMatrix.makeTranslation( - _lightPositionWorld.x, - _lightPositionWorld.y, - _lightPositionWorld.z );
	
				} else {
	
					faceCount = 1;
	
					_lookTarget.setFromMatrixPosition( light.target.matrixWorld );
					shadowCamera.lookAt( _lookTarget );
					shadowCamera.updateMatrixWorld();
	
					// compute shadow matrix
	
					shadowMatrix.set(
						0.5, 0.0, 0.0, 0.5,
						0.0, 0.5, 0.0, 0.5,
						0.0, 0.0, 0.5, 0.5,
						0.0, 0.0, 0.0, 1.0
					);
	
					shadowMatrix.multiply( shadowCamera.projectionMatrix );
					shadowMatrix.multiply( shadowCamera.matrixWorldInverse );
	
				}
	
				_renderer.setRenderTarget( shadowMap );
				_renderer.clear();
	
				// render shadow map for each cube face (if omni-directional) or
				// run a single pass if not
	
				for ( var face = 0; face < faceCount; face ++ ) {
	
					if ( isPointLight ) {
	
						_lookTarget.copy( shadowCamera.position );
						_lookTarget.add( cubeDirections[ face ] );
						shadowCamera.up.copy( cubeUps[ face ] );
						shadowCamera.lookAt( _lookTarget );
						shadowCamera.updateMatrixWorld();
	
						var vpDimensions = cube2DViewPorts[ face ];
						_state.viewport( vpDimensions );
	
					}
	
					// update camera matrices and frustum
	
					_projScreenMatrix.multiplyMatrices( shadowCamera.projectionMatrix, shadowCamera.matrixWorldInverse );
					_frustum.setFromMatrix( _projScreenMatrix );
	
					// set object matrices & frustum culling
	
					renderObject( scene, camera, shadowCamera, isPointLight );
	
				}
	
			}
	
			scope.needsUpdate = false;
	
		};
	
		function getDepthMaterial( object, material, isPointLight, lightPositionWorld, shadowCameraNear, shadowCameraFar ) {
	
			var geometry = object.geometry;
	
			var result = null;
	
			var materialVariants = _depthMaterials;
			var customMaterial = object.customDepthMaterial;
	
			if ( isPointLight ) {
	
				materialVariants = _distanceMaterials;
				customMaterial = object.customDistanceMaterial;
	
			}
	
			if ( ! customMaterial ) {
	
				var useMorphing = false;
	
				if ( material.morphTargets ) {
	
					if ( geometry && geometry.isBufferGeometry ) {
	
						useMorphing = geometry.morphAttributes && geometry.morphAttributes.position && geometry.morphAttributes.position.length > 0;
	
					} else if ( geometry && geometry.isGeometry ) {
	
						useMorphing = geometry.morphTargets && geometry.morphTargets.length > 0;
	
					}
	
				}
	
				if ( object.isSkinnedMesh && material.skinning === false ) {
	
					console.warn( 'THREE.WebGLShadowMap: THREE.SkinnedMesh with material.skinning set to false:', object );
	
				}
	
				var useSkinning = object.isSkinnedMesh && material.skinning;
	
				var variantIndex = 0;
	
				if ( useMorphing ) variantIndex |= _MorphingFlag;
				if ( useSkinning ) variantIndex |= _SkinningFlag;
	
				result = materialVariants[ variantIndex ];
	
			} else {
	
				result = customMaterial;
	
			}
	
			if ( _renderer.localClippingEnabled &&
					material.clipShadows === true &&
					material.clippingPlanes.length !== 0 ) {
	
				// in this case we need a unique material instance reflecting the
				// appropriate state
	
				var keyA = result.uuid, keyB = material.uuid;
	
				var materialsForVariant = _materialCache[ keyA ];
	
				if ( materialsForVariant === undefined ) {
	
					materialsForVariant = {};
					_materialCache[ keyA ] = materialsForVariant;
	
				}
	
				var cachedMaterial = materialsForVariant[ keyB ];
	
				if ( cachedMaterial === undefined ) {
	
					cachedMaterial = result.clone();
					materialsForVariant[ keyB ] = cachedMaterial;
	
				}
	
				result = cachedMaterial;
	
			}
	
			result.visible = material.visible;
			result.wireframe = material.wireframe;
	
			result.side = ( material.shadowSide != null ) ? material.shadowSide : shadowSide[ material.side ];
	
			result.clipShadows = material.clipShadows;
			result.clippingPlanes = material.clippingPlanes;
			result.clipIntersection = material.clipIntersection;
	
			result.wireframeLinewidth = material.wireframeLinewidth;
			result.linewidth = material.linewidth;
	
			if ( isPointLight && result.isMeshDistanceMaterial ) {
	
				result.referencePosition.copy( lightPositionWorld );
				result.nearDistance = shadowCameraNear;
				result.farDistance = shadowCameraFar;
	
			}
	
			return result;
	
		}
	
		function renderObject( object, camera, shadowCamera, isPointLight ) {
	
			if ( object.visible === false ) return;
	
			var visible = object.layers.test( camera.layers );
	
			if ( visible && ( object.isMesh || object.isLine || object.isPoints ) ) {
	
				if ( object.castShadow && ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) ) {
	
					object.modelViewMatrix.multiplyMatrices( shadowCamera.matrixWorldInverse, object.matrixWorld );
	
					var geometry = _objects.update( object );
					var material = object.material;
	
					if ( Array.isArray( material ) ) {
	
						var groups = geometry.groups;
	
						for ( var k = 0, kl = groups.length; k < kl; k ++ ) {
	
							var group = groups[ k ];
							var groupMaterial = material[ group.materialIndex ];
	
							if ( groupMaterial && groupMaterial.visible ) {
	
								var depthMaterial = getDepthMaterial( object, groupMaterial, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
								_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, group );
	
							}
	
						}
	
					} else if ( material.visible ) {
	
						var depthMaterial = getDepthMaterial( object, material, isPointLight, _lightPositionWorld, shadowCamera.near, shadowCamera.far );
						_renderer.renderBufferDirect( shadowCamera, null, geometry, depthMaterial, object, null );
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				renderObject( children[ i ], camera, shadowCamera, isPointLight );
	
			}
	
		}
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLState( gl, extensions, utils, capabilities ) {
	
		function ColorBuffer() {
	
			var locked = false;
	
			var color = new Vector4();
			var currentColorMask = null;
			var currentColorClear = new Vector4( 0, 0, 0, 0 );
	
			return {
	
				setMask: function ( colorMask ) {
	
					if ( currentColorMask !== colorMask && ! locked ) {
	
						gl.colorMask( colorMask, colorMask, colorMask, colorMask );
						currentColorMask = colorMask;
	
					}
	
				},
	
				setLocked: function ( lock ) {
	
					locked = lock;
	
				},
	
				setClear: function ( r, g, b, a, premultipliedAlpha ) {
	
					if ( premultipliedAlpha === true ) {
	
						r *= a; g *= a; b *= a;
	
					}
	
					color.set( r, g, b, a );
	
					if ( currentColorClear.equals( color ) === false ) {
	
						gl.clearColor( r, g, b, a );
						currentColorClear.copy( color );
	
					}
	
				},
	
				reset: function () {
	
					locked = false;
	
					currentColorMask = null;
					currentColorClear.set( - 1, 0, 0, 0 ); // set to invalid state
	
				}
	
			};
	
		}
	
		function DepthBuffer() {
	
			var locked = false;
	
			var currentDepthMask = null;
			var currentDepthFunc = null;
			var currentDepthClear = null;
	
			return {
	
				setTest: function ( depthTest ) {
	
					if ( depthTest ) {
	
						enable( 2929 );
	
					} else {
	
						disable( 2929 );
	
					}
	
				},
	
				setMask: function ( depthMask ) {
	
					if ( currentDepthMask !== depthMask && ! locked ) {
	
						gl.depthMask( depthMask );
						currentDepthMask = depthMask;
	
					}
	
				},
	
				setFunc: function ( depthFunc ) {
	
					if ( currentDepthFunc !== depthFunc ) {
	
						if ( depthFunc ) {
	
							switch ( depthFunc ) {
	
								case NeverDepth:
	
									gl.depthFunc( 512 );
									break;
	
								case AlwaysDepth:
	
									gl.depthFunc( 519 );
									break;
	
								case LessDepth:
	
									gl.depthFunc( 513 );
									break;
	
								case LessEqualDepth:
	
									gl.depthFunc( 515 );
									break;
	
								case EqualDepth:
	
									gl.depthFunc( 514 );
									break;
	
								case GreaterEqualDepth:
	
									gl.depthFunc( 518 );
									break;
	
								case GreaterDepth:
	
									gl.depthFunc( 516 );
									break;
	
								case NotEqualDepth:
	
									gl.depthFunc( 517 );
									break;
	
								default:
	
									gl.depthFunc( 515 );
	
							}
	
						} else {
	
							gl.depthFunc( 515 );
	
						}
	
						currentDepthFunc = depthFunc;
	
					}
	
				},
	
				setLocked: function ( lock ) {
	
					locked = lock;
	
				},
	
				setClear: function ( depth ) {
	
					if ( currentDepthClear !== depth ) {
	
						gl.clearDepth( depth );
						currentDepthClear = depth;
	
					}
	
				},
	
				reset: function () {
	
					locked = false;
	
					currentDepthMask = null;
					currentDepthFunc = null;
					currentDepthClear = null;
	
				}
	
			};
	
		}
	
		function StencilBuffer() {
	
			var locked = false;
	
			var currentStencilMask = null;
			var currentStencilFunc = null;
			var currentStencilRef = null;
			var currentStencilFuncMask = null;
			var currentStencilFail = null;
			var currentStencilZFail = null;
			var currentStencilZPass = null;
			var currentStencilClear = null;
	
			return {
	
				setTest: function ( stencilTest ) {
	
					if ( stencilTest ) {
	
						enable( 2960 );
	
					} else {
	
						disable( 2960 );
	
					}
	
				},
	
				setMask: function ( stencilMask ) {
	
					if ( currentStencilMask !== stencilMask && ! locked ) {
	
						gl.stencilMask( stencilMask );
						currentStencilMask = stencilMask;
	
					}
	
				},
	
				setFunc: function ( stencilFunc, stencilRef, stencilMask ) {
	
					if ( currentStencilFunc !== stencilFunc ||
							 currentStencilRef 	!== stencilRef 	||
							 currentStencilFuncMask !== stencilMask ) {
	
						gl.stencilFunc( stencilFunc, stencilRef, stencilMask );
	
						currentStencilFunc = stencilFunc;
						currentStencilRef = stencilRef;
						currentStencilFuncMask = stencilMask;
	
					}
	
				},
	
				setOp: function ( stencilFail, stencilZFail, stencilZPass ) {
	
					if ( currentStencilFail	 !== stencilFail 	||
							 currentStencilZFail !== stencilZFail ||
							 currentStencilZPass !== stencilZPass ) {
	
						gl.stencilOp( stencilFail, stencilZFail, stencilZPass );
	
						currentStencilFail = stencilFail;
						currentStencilZFail = stencilZFail;
						currentStencilZPass = stencilZPass;
	
					}
	
				},
	
				setLocked: function ( lock ) {
	
					locked = lock;
	
				},
	
				setClear: function ( stencil ) {
	
					if ( currentStencilClear !== stencil ) {
	
						gl.clearStencil( stencil );
						currentStencilClear = stencil;
	
					}
	
				},
	
				reset: function () {
	
					locked = false;
	
					currentStencilMask = null;
					currentStencilFunc = null;
					currentStencilRef = null;
					currentStencilFuncMask = null;
					currentStencilFail = null;
					currentStencilZFail = null;
					currentStencilZPass = null;
					currentStencilClear = null;
	
				}
	
			};
	
		}
	
		//
	
		var colorBuffer = new ColorBuffer();
		var depthBuffer = new DepthBuffer();
		var stencilBuffer = new StencilBuffer();
	
		var maxVertexAttributes = gl.getParameter( 34921 );
		var newAttributes = new Uint8Array( maxVertexAttributes );
		var enabledAttributes = new Uint8Array( maxVertexAttributes );
		var attributeDivisors = new Uint8Array( maxVertexAttributes );
	
		var enabledCapabilities = {};
	
		var compressedTextureFormats = null;
	
		var currentProgram = null;
	
		var currentBlendingEnabled = null;
		var currentBlending = null;
		var currentBlendEquation = null;
		var currentBlendSrc = null;
		var currentBlendDst = null;
		var currentBlendEquationAlpha = null;
		var currentBlendSrcAlpha = null;
		var currentBlendDstAlpha = null;
		var currentPremultipledAlpha = false;
	
		var currentFlipSided = null;
		var currentCullFace = null;
	
		var currentLineWidth = null;
	
		var currentPolygonOffsetFactor = null;
		var currentPolygonOffsetUnits = null;
	
		var maxTextures = gl.getParameter( 35661 );
	
		var lineWidthAvailable = false;
		var version = 0;
		var glVersion = gl.getParameter( 7938 );
	
		if ( glVersion.indexOf( 'WebGL' ) !== - 1 ) {
	
			version = parseFloat( /^WebGL\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 1.0 );
	
		} else if ( glVersion.indexOf( 'OpenGL ES' ) !== - 1 ) {
	
			version = parseFloat( /^OpenGL\ ES\ ([0-9])/.exec( glVersion )[ 1 ] );
			lineWidthAvailable = ( version >= 2.0 );
	
		}
	
		var currentTextureSlot = null;
		var currentBoundTextures = {};
	
		var currentScissor = new Vector4();
		var currentViewport = new Vector4();
	
		function createTexture( type, target, count ) {
	
			var data = new Uint8Array( 4 ); // 4 is required to match default unpack alignment of 4.
			var texture = gl.createTexture();
	
			gl.bindTexture( type, texture );
			gl.texParameteri( type, 10241, 9728 );
			gl.texParameteri( type, 10240, 9728 );
	
			for ( var i = 0; i < count; i ++ ) {
	
				gl.texImage2D( target + i, 0, 6408, 1, 1, 0, 6408, 5121, data );
	
			}
	
			return texture;
	
		}
	
		var emptyTextures = {};
		emptyTextures[ 3553 ] = createTexture( 3553, 3553, 1 );
		emptyTextures[ 34067 ] = createTexture( 34067, 34069, 6 );
	
		// init
	
		colorBuffer.setClear( 0, 0, 0, 1 );
		depthBuffer.setClear( 1 );
		stencilBuffer.setClear( 0 );
	
		enable( 2929 );
		depthBuffer.setFunc( LessEqualDepth );
	
		setFlipSided( false );
		setCullFace( CullFaceBack );
		enable( 2884 );
	
		setBlending( NoBlending );
	
		//
	
		function initAttributes() {
	
			for ( var i = 0, l = newAttributes.length; i < l; i ++ ) {
	
				newAttributes[ i ] = 0;
	
			}
	
		}
	
		function enableAttribute( attribute ) {
	
			enableAttributeAndDivisor( attribute, 0 );
	
		}
	
		function enableAttributeAndDivisor( attribute, meshPerAttribute ) {
	
			newAttributes[ attribute ] = 1;
	
			if ( enabledAttributes[ attribute ] === 0 ) {
	
				gl.enableVertexAttribArray( attribute );
				enabledAttributes[ attribute ] = 1;
	
			}
	
			if ( attributeDivisors[ attribute ] !== meshPerAttribute ) {
	
				var extension = capabilities.isWebGL2 ? gl : extensions.get( 'ANGLE_instanced_arrays' );
	
				extension[ capabilities.isWebGL2 ? 'vertexAttribDivisor' : 'vertexAttribDivisorANGLE' ]( attribute, meshPerAttribute );
				attributeDivisors[ attribute ] = meshPerAttribute;
	
			}
	
		}
	
		function disableUnusedAttributes() {
	
			for ( var i = 0, l = enabledAttributes.length; i !== l; ++ i ) {
	
				if ( enabledAttributes[ i ] !== newAttributes[ i ] ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
		}
	
		function enable( id ) {
	
			if ( enabledCapabilities[ id ] !== true ) {
	
				gl.enable( id );
				enabledCapabilities[ id ] = true;
	
			}
	
		}
	
		function disable( id ) {
	
			if ( enabledCapabilities[ id ] !== false ) {
	
				gl.disable( id );
				enabledCapabilities[ id ] = false;
	
			}
	
		}
	
		function getCompressedTextureFormats() {
	
			if ( compressedTextureFormats === null ) {
	
				compressedTextureFormats = [];
	
				if ( extensions.get( 'WEBGL_compressed_texture_pvrtc' ) ||
						 extensions.get( 'WEBGL_compressed_texture_s3tc' ) ||
						 extensions.get( 'WEBGL_compressed_texture_etc1' ) ||
						 extensions.get( 'WEBGL_compressed_texture_astc' ) ) {
	
					var formats = gl.getParameter( 34467 );
	
					for ( var i = 0; i < formats.length; i ++ ) {
	
						compressedTextureFormats.push( formats[ i ] );
	
					}
	
				}
	
			}
	
			return compressedTextureFormats;
	
		}
	
		function useProgram( program ) {
	
			if ( currentProgram !== program ) {
	
				gl.useProgram( program );
	
				currentProgram = program;
	
				return true;
	
			}
	
			return false;
	
		}
	
		function setBlending( blending, blendEquation, blendSrc, blendDst, blendEquationAlpha, blendSrcAlpha, blendDstAlpha, premultipliedAlpha ) {
	
			if ( blending === NoBlending ) {
	
				if ( currentBlendingEnabled ) {
	
					disable( 3042 );
					currentBlendingEnabled = false;
	
				}
	
				return;
	
			}
	
			if ( ! currentBlendingEnabled ) {
	
				enable( 3042 );
				currentBlendingEnabled = true;
	
			}
	
			if ( blending !== CustomBlending ) {
	
				if ( blending !== currentBlending || premultipliedAlpha !== currentPremultipledAlpha ) {
	
					if ( currentBlendEquation !== AddEquation || currentBlendEquationAlpha !== AddEquation ) {
	
						gl.blendEquation( 32774 );
	
						currentBlendEquation = AddEquation;
						currentBlendEquationAlpha = AddEquation;
	
					}
	
					if ( premultipliedAlpha ) {
	
						switch ( blending ) {
	
							case NormalBlending:
								gl.blendFuncSeparate( 1, 771, 1, 771 );
								break;
	
							case AdditiveBlending:
								gl.blendFunc( 1, 1 );
								break;
	
							case SubtractiveBlending:
								gl.blendFuncSeparate( 0, 0, 769, 771 );
								break;
	
							case MultiplyBlending:
								gl.blendFuncSeparate( 0, 768, 0, 770 );
								break;
	
							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;
	
						}
	
					} else {
	
						switch ( blending ) {
	
							case NormalBlending:
								gl.blendFuncSeparate( 770, 771, 1, 771 );
								break;
	
							case AdditiveBlending:
								gl.blendFunc( 770, 1 );
								break;
	
							case SubtractiveBlending:
								gl.blendFunc( 0, 769 );
								break;
	
							case MultiplyBlending:
								gl.blendFunc( 0, 768 );
								break;
	
							default:
								console.error( 'THREE.WebGLState: Invalid blending: ', blending );
								break;
	
						}
	
					}
	
					currentBlendSrc = null;
					currentBlendDst = null;
					currentBlendSrcAlpha = null;
					currentBlendDstAlpha = null;
	
					currentBlending = blending;
					currentPremultipledAlpha = premultipliedAlpha;
	
				}
	
				return;
	
			}
	
			// custom blending
	
			blendEquationAlpha = blendEquationAlpha || blendEquation;
			blendSrcAlpha = blendSrcAlpha || blendSrc;
			blendDstAlpha = blendDstAlpha || blendDst;
	
			if ( blendEquation !== currentBlendEquation || blendEquationAlpha !== currentBlendEquationAlpha ) {
	
				gl.blendEquationSeparate( utils.convert( blendEquation ), utils.convert( blendEquationAlpha ) );
	
				currentBlendEquation = blendEquation;
				currentBlendEquationAlpha = blendEquationAlpha;
	
			}
	
			if ( blendSrc !== currentBlendSrc || blendDst !== currentBlendDst || blendSrcAlpha !== currentBlendSrcAlpha || blendDstAlpha !== currentBlendDstAlpha ) {
	
				gl.blendFuncSeparate( utils.convert( blendSrc ), utils.convert( blendDst ), utils.convert( blendSrcAlpha ), utils.convert( blendDstAlpha ) );
	
				currentBlendSrc = blendSrc;
				currentBlendDst = blendDst;
				currentBlendSrcAlpha = blendSrcAlpha;
				currentBlendDstAlpha = blendDstAlpha;
	
			}
	
			currentBlending = blending;
			currentPremultipledAlpha = null;
	
		}
	
		function setMaterial( material, frontFaceCW ) {
	
			material.side === DoubleSide
				? disable( 2884 )
				: enable( 2884 );
	
			var flipSided = ( material.side === BackSide );
			if ( frontFaceCW ) flipSided = ! flipSided;
	
			setFlipSided( flipSided );
	
			( material.blending === NormalBlending && material.transparent === false )
				? setBlending( NoBlending )
				: setBlending( material.blending, material.blendEquation, material.blendSrc, material.blendDst, material.blendEquationAlpha, material.blendSrcAlpha, material.blendDstAlpha, material.premultipliedAlpha );
	
			depthBuffer.setFunc( material.depthFunc );
			depthBuffer.setTest( material.depthTest );
			depthBuffer.setMask( material.depthWrite );
			colorBuffer.setMask( material.colorWrite );
	
			setPolygonOffset( material.polygonOffset, material.polygonOffsetFactor, material.polygonOffsetUnits );
	
		}
	
		//
	
		function setFlipSided( flipSided ) {
	
			if ( currentFlipSided !== flipSided ) {
	
				if ( flipSided ) {
	
					gl.frontFace( 2304 );
	
				} else {
	
					gl.frontFace( 2305 );
	
				}
	
				currentFlipSided = flipSided;
	
			}
	
		}
	
		function setCullFace( cullFace ) {
	
			if ( cullFace !== CullFaceNone ) {
	
				enable( 2884 );
	
				if ( cullFace !== currentCullFace ) {
	
					if ( cullFace === CullFaceBack ) {
	
						gl.cullFace( 1029 );
	
					} else if ( cullFace === CullFaceFront ) {
	
						gl.cullFace( 1028 );
	
					} else {
	
						gl.cullFace( 1032 );
	
					}
	
				}
	
			} else {
	
				disable( 2884 );
	
			}
	
			currentCullFace = cullFace;
	
		}
	
		function setLineWidth( width ) {
	
			if ( width !== currentLineWidth ) {
	
				if ( lineWidthAvailable ) gl.lineWidth( width );
	
				currentLineWidth = width;
	
			}
	
		}
	
		function setPolygonOffset( polygonOffset, factor, units ) {
	
			if ( polygonOffset ) {
	
				enable( 32823 );
	
				if ( currentPolygonOffsetFactor !== factor || currentPolygonOffsetUnits !== units ) {
	
					gl.polygonOffset( factor, units );
	
					currentPolygonOffsetFactor = factor;
					currentPolygonOffsetUnits = units;
	
				}
	
			} else {
	
				disable( 32823 );
	
			}
	
		}
	
		function setScissorTest( scissorTest ) {
	
			if ( scissorTest ) {
	
				enable( 3089 );
	
			} else {
	
				disable( 3089 );
	
			}
	
		}
	
		// texture
	
		function activeTexture( webglSlot ) {
	
			if ( webglSlot === undefined ) webglSlot = 33984 + maxTextures - 1;
	
			if ( currentTextureSlot !== webglSlot ) {
	
				gl.activeTexture( webglSlot );
				currentTextureSlot = webglSlot;
	
			}
	
		}
	
		function bindTexture( webglType, webglTexture ) {
	
			if ( currentTextureSlot === null ) {
	
				activeTexture();
	
			}
	
			var boundTexture = currentBoundTextures[ currentTextureSlot ];
	
			if ( boundTexture === undefined ) {
	
				boundTexture = { type: undefined, texture: undefined };
				currentBoundTextures[ currentTextureSlot ] = boundTexture;
	
			}
	
			if ( boundTexture.type !== webglType || boundTexture.texture !== webglTexture ) {
	
				gl.bindTexture( webglType, webglTexture || emptyTextures[ webglType ] );
	
				boundTexture.type = webglType;
				boundTexture.texture = webglTexture;
	
			}
	
		}
	
		function compressedTexImage2D() {
	
			try {
	
				gl.compressedTexImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLState:', error );
	
			}
	
		}
	
		function texImage2D() {
	
			try {
	
				gl.texImage2D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLState:', error );
	
			}
	
		}
	
		function texImage3D() {
	
			try {
	
				gl.texImage3D.apply( gl, arguments );
	
			} catch ( error ) {
	
				console.error( 'THREE.WebGLState:', error );
	
			}
	
		}
	
		//
	
		function scissor( scissor ) {
	
			if ( currentScissor.equals( scissor ) === false ) {
	
				gl.scissor( scissor.x, scissor.y, scissor.z, scissor.w );
				currentScissor.copy( scissor );
	
			}
	
		}
	
		function viewport( viewport ) {
	
			if ( currentViewport.equals( viewport ) === false ) {
	
				gl.viewport( viewport.x, viewport.y, viewport.z, viewport.w );
				currentViewport.copy( viewport );
	
			}
	
		}
	
		//
	
		function reset() {
	
			for ( var i = 0; i < enabledAttributes.length; i ++ ) {
	
				if ( enabledAttributes[ i ] === 1 ) {
	
					gl.disableVertexAttribArray( i );
					enabledAttributes[ i ] = 0;
	
				}
	
			}
	
			enabledCapabilities = {};
	
			compressedTextureFormats = null;
	
			currentTextureSlot = null;
			currentBoundTextures = {};
	
			currentProgram = null;
	
			currentBlending = null;
	
			currentFlipSided = null;
			currentCullFace = null;
	
			colorBuffer.reset();
			depthBuffer.reset();
			stencilBuffer.reset();
	
		}
	
		return {
	
			buffers: {
				color: colorBuffer,
				depth: depthBuffer,
				stencil: stencilBuffer
			},
	
			initAttributes: initAttributes,
			enableAttribute: enableAttribute,
			enableAttributeAndDivisor: enableAttributeAndDivisor,
			disableUnusedAttributes: disableUnusedAttributes,
			enable: enable,
			disable: disable,
			getCompressedTextureFormats: getCompressedTextureFormats,
	
			useProgram: useProgram,
	
			setBlending: setBlending,
			setMaterial: setMaterial,
	
			setFlipSided: setFlipSided,
			setCullFace: setCullFace,
	
			setLineWidth: setLineWidth,
			setPolygonOffset: setPolygonOffset,
	
			setScissorTest: setScissorTest,
	
			activeTexture: activeTexture,
			bindTexture: bindTexture,
			compressedTexImage2D: compressedTexImage2D,
			texImage2D: texImage2D,
			texImage3D: texImage3D,
	
			scissor: scissor,
			viewport: viewport,
	
			reset: reset
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info ) {
	
		var _videoTextures = {};
		var _canvas;
	
		//
	
		function resizeImage( image, needsPowerOfTwo, needsNewCanvas, maxSize ) {
	
			var scale = 1;
	
			// handle case if texture exceeds max size
	
			if ( image.width > maxSize || image.height > maxSize ) {
	
				scale = maxSize / Math.max( image.width, image.height );
	
			}
	
			// only perform resize if necessary
	
			if ( scale < 1 || needsPowerOfTwo === true ) {
	
				// only perform resize for certain image types
	
				if ( image instanceof HTMLImageElement || image instanceof HTMLCanvasElement || image instanceof ImageBitmap ) {
	
					if ( _canvas === undefined ) _canvas = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' );
	
					// cube textures can't reuse the same canvas
	
					var canvas = needsNewCanvas ? document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ) : _canvas;
	
					var floor = needsPowerOfTwo ? _Math.floorPowerOfTwo : Math.floor;
	
					canvas.width = floor( scale * image.width );
					canvas.height = floor( scale * image.height );
	
					var context = canvas.getContext( '2d' );
					context.drawImage( image, 0, 0, canvas.width, canvas.height );
	
					console.warn( 'THREE.WebGLRenderer: Texture has been resized from (' + image.width + 'x' + image.height + ') to (' + canvas.width + 'x' + canvas.height + ').' );
	
					return canvas;
	
				} else {
	
					if ( 'data' in image ) {
	
						console.warn( 'THREE.WebGLRenderer: Image in DataTexture is too big (' + image.width + 'x' + image.height + ').' );
	
					}
	
					return image;
	
				}
	
			}
	
			return image;
	
		}
	
		function isPowerOfTwo( image ) {
	
			return _Math.isPowerOfTwo( image.width ) && _Math.isPowerOfTwo( image.height );
	
		}
	
		function textureNeedsPowerOfTwo( texture ) {
	
			if ( capabilities.isWebGL2 ) return false;
	
			return ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) ||
				( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter );
	
		}
	
		function textureNeedsGenerateMipmaps( texture, supportsMips ) {
	
			return texture.generateMipmaps && supportsMips &&
				texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter;
	
		}
	
		function generateMipmap( target, texture, width, height ) {
	
			_gl.generateMipmap( target );
	
			var textureProperties = properties.get( texture );
	
			// Note: Math.log( x ) * Math.LOG2E used instead of Math.log2( x ) which is not supported by IE11
			textureProperties.__maxMipLevel = Math.log( Math.max( width, height ) ) * Math.LOG2E;
	
		}
	
		function getInternalFormat( glFormat, glType ) {
	
			if ( ! capabilities.isWebGL2 ) return glFormat;
	
			var internalFormat = glFormat;
	
			if ( glFormat === 6403 ) {
	
				if ( glType === 5126 ) internalFormat = 33326;
				if ( glType === 5131 ) internalFormat = 33325;
				if ( glType === 5121 ) internalFormat = 33321;
	
			}
	
			if ( glFormat === 6407 ) {
	
				if ( glType === 5126 ) internalFormat = 34837;
				if ( glType === 5131 ) internalFormat = 34843;
				if ( glType === 5121 ) internalFormat = 32849;
	
			}
	
			if ( glFormat === 6408 ) {
	
				if ( glType === 5126 ) internalFormat = 34836;
				if ( glType === 5131 ) internalFormat = 34842;
				if ( glType === 5121 ) internalFormat = 32856;
	
			}
	
			if ( internalFormat === 33325 ||internalFormat === 33326 ||
				internalFormat === 34842 || internalFormat === 34836 ) {
	
				extensions.get( 'EXT_color_buffer_float' );
	
			} else if ( internalFormat === 34843 || internalFormat === 34837 ) {
	
				console.warn( 'THREE.WebGLRenderer: Floating point textures with RGB format not supported. Please use RGBA instead.' );
	
			}
	
			return internalFormat;
	
		}
	
		// Fallback filters for non-power-of-2 textures
	
		function filterFallback( f ) {
	
			if ( f === NearestFilter || f === NearestMipMapNearestFilter || f === NearestMipMapLinearFilter ) {
	
				return 9728;
	
			}
	
			return 9729;
	
		}
	
		//
	
		function onTextureDispose( event ) {
	
			var texture = event.target;
	
			texture.removeEventListener( 'dispose', onTextureDispose );
	
			deallocateTexture( texture );
	
			if ( texture.isVideoTexture ) {
	
				delete _videoTextures[ texture.id ];
	
			}
	
			info.memory.textures --;
	
		}
	
		function onRenderTargetDispose( event ) {
	
			var renderTarget = event.target;
	
			renderTarget.removeEventListener( 'dispose', onRenderTargetDispose );
	
			deallocateRenderTarget( renderTarget );
	
			info.memory.textures --;
	
		}
	
		//
	
		function deallocateTexture( texture ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image && textureProperties.__image__webglTextureCube ) {
	
				// cube texture
	
				_gl.deleteTexture( textureProperties.__image__webglTextureCube );
	
			} else {
	
				// 2D texture
	
				if ( textureProperties.__webglInit === undefined ) return;
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			// remove all webgl properties
			properties.remove( texture );
	
		}
	
		function deallocateRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			if ( ! renderTarget ) return;
	
			if ( textureProperties.__webglTexture !== undefined ) {
	
				_gl.deleteTexture( textureProperties.__webglTexture );
	
			}
	
			if ( renderTarget.depthTexture ) {
	
				renderTarget.depthTexture.dispose();
	
			}
	
			if ( renderTarget.isWebGLRenderTargetCube ) {
	
				for ( var i = 0; i < 6; i ++ ) {
	
					_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer[ i ] );
					if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer[ i ] );
	
				}
	
			} else {
	
				_gl.deleteFramebuffer( renderTargetProperties.__webglFramebuffer );
				if ( renderTargetProperties.__webglDepthbuffer ) _gl.deleteRenderbuffer( renderTargetProperties.__webglDepthbuffer );
	
			}
	
			properties.remove( renderTarget.texture );
			properties.remove( renderTarget );
	
		}
	
		//
	
	
	
		function setTexture2D( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.isVideoTexture ) updateVideoTexture( texture );
	
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
				var image = texture.image;
	
				if ( image === undefined ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is undefined' );
	
				} else if ( image.complete === false ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture marked for update but image is incomplete' );
	
				} else {
	
					uploadTexture( textureProperties, texture, slot );
					return;
	
				}
	
			}
	
			state.activeTexture( 33984 + slot );
			state.bindTexture( 3553, textureProperties.__webglTexture );
	
		}
	
		function setTexture3D( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
				uploadTexture( textureProperties, texture, slot );
				return;
	
			}
	
			state.activeTexture( 33984 + slot );
			state.bindTexture( 32879, textureProperties.__webglTexture );
	
		}
	
	
		function setTextureCube( texture, slot ) {
	
			var textureProperties = properties.get( texture );
	
			if ( texture.image.length === 6 ) {
	
				if ( texture.version > 0 && textureProperties.__version !== texture.version ) {
	
					if ( ! textureProperties.__image__webglTextureCube ) {
	
						texture.addEventListener( 'dispose', onTextureDispose );
	
						textureProperties.__image__webglTextureCube = _gl.createTexture();
	
						info.memory.textures ++;
	
					}
	
					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__image__webglTextureCube );
	
					_gl.pixelStorei( 37440, texture.flipY );
	
					var isCompressed = ( texture && texture.isCompressedTexture );
					var isDataTexture = ( texture.image[ 0 ] && texture.image[ 0 ].isDataTexture );
	
					var cubeImage = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed && ! isDataTexture ) {
	
							cubeImage[ i ] = resizeImage( texture.image[ i ], false, true, capabilities.maxCubemapSize );
	
						} else {
	
							cubeImage[ i ] = isDataTexture ? texture.image[ i ].image : texture.image[ i ];
	
						}
	
					}
	
					var image = cubeImage[ 0 ],
						supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
						glFormat = utils.convert( texture.format ),
						glType = utils.convert( texture.type ),
						glInternalFormat = getInternalFormat( glFormat, glType );
	
					setTextureParameters( 34067, texture, supportsMips );
	
					for ( var i = 0; i < 6; i ++ ) {
	
						if ( ! isCompressed ) {
	
							if ( isDataTexture ) {
	
								state.texImage2D( 34069 + i, 0, glInternalFormat, cubeImage[ i ].width, cubeImage[ i ].height, 0, glFormat, glType, cubeImage[ i ].data );
	
							} else {
	
								state.texImage2D( 34069 + i, 0, glInternalFormat, glFormat, glType, cubeImage[ i ] );
	
							}
	
						} else {
	
							var mipmap, mipmaps = cubeImage[ i ].mipmaps;
	
							for ( var j = 0, jl = mipmaps.length; j < jl; j ++ ) {
	
								mipmap = mipmaps[ j ];
	
								if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
									if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
										state.compressedTexImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
									} else {
	
										console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .setTextureCube()' );
	
									}
	
								} else {
	
									state.texImage2D( 34069 + i, j, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
								}
	
							}
	
						}
	
					}
	
					if ( ! isCompressed ) {
	
						textureProperties.__maxMipLevel = 0;
	
					} else {
	
						textureProperties.__maxMipLevel = mipmaps.length - 1;
	
					}
	
					if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
	
						// We assume images for cube map have the same size.
						generateMipmap( 34067, texture, image.width, image.height );
	
					}
	
					textureProperties.__version = texture.version;
	
					if ( texture.onUpdate ) texture.onUpdate( texture );
	
				} else {
	
					state.activeTexture( 33984 + slot );
					state.bindTexture( 34067, textureProperties.__image__webglTextureCube );
	
				}
	
			}
	
		}
	
		function setTextureCubeDynamic( texture, slot ) {
	
			state.activeTexture( 33984 + slot );
			state.bindTexture( 34067, properties.get( texture ).__webglTexture );
	
		}
	
		function setTextureParameters( textureType, texture, supportsMips ) {
	
			var extension;
	
			if ( supportsMips ) {
	
				_gl.texParameteri( textureType, 10242, utils.convert( texture.wrapS ) );
				_gl.texParameteri( textureType, 10243, utils.convert( texture.wrapT ) );
	
				_gl.texParameteri( textureType, 10240, utils.convert( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, utils.convert( texture.minFilter ) );
	
			} else {
	
				_gl.texParameteri( textureType, 10242, 33071 );
				_gl.texParameteri( textureType, 10243, 33071 );
	
				if ( texture.wrapS !== ClampToEdgeWrapping || texture.wrapT !== ClampToEdgeWrapping ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.wrapS and Texture.wrapT should be set to THREE.ClampToEdgeWrapping.' );
	
				}
	
				_gl.texParameteri( textureType, 10240, filterFallback( texture.magFilter ) );
				_gl.texParameteri( textureType, 10241, filterFallback( texture.minFilter ) );
	
				if ( texture.minFilter !== NearestFilter && texture.minFilter !== LinearFilter ) {
	
					console.warn( 'THREE.WebGLRenderer: Texture is not power of two. Texture.minFilter should be set to THREE.NearestFilter or THREE.LinearFilter.' );
	
				}
	
			}
	
			extension = extensions.get( 'EXT_texture_filter_anisotropic' );
	
			if ( extension ) {
	
				if ( texture.type === FloatType && extensions.get( 'OES_texture_float_linear' ) === null ) return;
				if ( texture.type === HalfFloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_half_float_linear' ) ) === null ) return;
	
				if ( texture.anisotropy > 1 || properties.get( texture ).__currentAnisotropy ) {
	
					_gl.texParameterf( textureType, extension.TEXTURE_MAX_ANISOTROPY_EXT, Math.min( texture.anisotropy, capabilities.getMaxAnisotropy() ) );
					properties.get( texture ).__currentAnisotropy = texture.anisotropy;
	
				}
	
			}
	
		}
	
		function uploadTexture( textureProperties, texture, slot ) {
	
			var textureType;
	
			if ( texture.isDataTexture3D ) {
	
				textureType = 32879;
	
			} else {
	
				textureType = 3553;
	
			}
	
	
			if ( textureProperties.__webglInit === undefined ) {
	
				textureProperties.__webglInit = true;
	
				texture.addEventListener( 'dispose', onTextureDispose );
	
				textureProperties.__webglTexture = _gl.createTexture();
	
				info.memory.textures ++;
	
			}
			state.activeTexture( 33984 + slot );
	
	
			state.bindTexture( textureType, textureProperties.__webglTexture );
	
	
	
			_gl.pixelStorei( 37440, texture.flipY );
			_gl.pixelStorei( 37441, texture.premultiplyAlpha );
			_gl.pixelStorei( 3317, texture.unpackAlignment );
	
			var needsPowerOfTwo = textureNeedsPowerOfTwo( texture ) && isPowerOfTwo( texture.image ) === false;
			var image = resizeImage( texture.image, needsPowerOfTwo, false, capabilities.maxTextureSize );
	
			var supportsMips = isPowerOfTwo( image ) || capabilities.isWebGL2,
				glFormat = utils.convert( texture.format ),
				glType = utils.convert( texture.type ),
				glInternalFormat = getInternalFormat( glFormat, glType );
	
			setTextureParameters( textureType, texture, supportsMips );
	
			var mipmap, mipmaps = texture.mipmaps;
	
			if ( texture.isDepthTexture ) {
	
				// populate depth texture with dummy data
	
				glInternalFormat = 6402;
	
				if ( texture.type === FloatType ) {
	
					if ( ! capabilities.isWebGL2 ) throw new Error( 'Float Depth Texture only supported in WebGL2.0' );
					glInternalFormat = 36012;
	
				} else if ( capabilities.isWebGL2 ) {
	
					// WebGL 2.0 requires signed internalformat for glTexImage2D
					glInternalFormat = 33189;
	
				}
	
				if ( texture.format === DepthFormat && glInternalFormat === 6402 ) {
	
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_COMPONENT and type is not UNSIGNED_SHORT or UNSIGNED_INT
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedShortType && texture.type !== UnsignedIntType ) {
	
						console.warn( 'THREE.WebGLRenderer: Use UnsignedShortType or UnsignedIntType for DepthFormat DepthTexture.' );
	
						texture.type = UnsignedShortType;
						glType = utils.convert( texture.type );
	
					}
	
				}
	
				// Depth stencil textures need the DEPTH_STENCIL internal format
				// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
				if ( texture.format === DepthStencilFormat ) {
	
					glInternalFormat = 34041;
	
					// The error INVALID_OPERATION is generated by texImage2D if format and internalformat are
					// DEPTH_STENCIL and type is not UNSIGNED_INT_24_8_WEBGL.
					// (https://www.khronos.org/registry/webgl/extensions/WEBGL_depth_texture/)
					if ( texture.type !== UnsignedInt248Type ) {
	
						console.warn( 'THREE.WebGLRenderer: Use UnsignedInt248Type for DepthStencilFormat DepthTexture.' );
	
						texture.type = UnsignedInt248Type;
						glType = utils.convert( texture.type );
	
					}
	
				}
	
				state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, null );
	
			} else if ( texture.isDataTexture ) {
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && supportsMips ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
	
				} else {
	
					state.texImage2D( 3553, 0, glInternalFormat, image.width, image.height, 0, glFormat, glType, image.data );
					textureProperties.__maxMipLevel = 0;
	
				}
	
			} else if ( texture.isCompressedTexture ) {
	
				for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
					mipmap = mipmaps[ i ];
	
					if ( texture.format !== RGBAFormat && texture.format !== RGBFormat ) {
	
						if ( state.getCompressedTextureFormats().indexOf( glFormat ) > - 1 ) {
	
							state.compressedTexImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, mipmap.data );
	
						} else {
	
							console.warn( 'THREE.WebGLRenderer: Attempt to load unsupported compressed texture format in .uploadTexture()' );
	
						}
	
					} else {
	
						state.texImage2D( 3553, i, glInternalFormat, mipmap.width, mipmap.height, 0, glFormat, glType, mipmap.data );
	
					}
	
				}
	
				textureProperties.__maxMipLevel = mipmaps.length - 1;
	
			} else if ( texture.isDataTexture3D ) {
	
				state.texImage3D( 32879, 0, glInternalFormat, image.width, image.height, image.depth, 0, glFormat, glType, image.data );
				textureProperties.__maxMipLevel = 0;
	
			} else {
	
				// regular Texture (image, video, canvas)
	
				// use manually created mipmaps if available
				// if there are no manual mipmaps
				// set 0 level mipmap and then use GL to generate other mipmap levels
	
				if ( mipmaps.length > 0 && supportsMips ) {
	
					for ( var i = 0, il = mipmaps.length; i < il; i ++ ) {
	
						mipmap = mipmaps[ i ];
						state.texImage2D( 3553, i, glInternalFormat, glFormat, glType, mipmap );
	
					}
	
					texture.generateMipmaps = false;
					textureProperties.__maxMipLevel = mipmaps.length - 1;
	
				} else {
	
					state.texImage2D( 3553, 0, glInternalFormat, glFormat, glType, image );
					textureProperties.__maxMipLevel = 0;
	
				}
	
			}
	
			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
	
				generateMipmap( 3553, texture, image.width, image.height );
	
			}
	
			textureProperties.__version = texture.version;
	
			if ( texture.onUpdate ) texture.onUpdate( texture );
	
		}
	
		// Render targets
	
		// Setup storage for target texture and bind it to correct framebuffer
		function setupFrameBufferTexture( framebuffer, renderTarget, attachment, textureTarget ) {
	
			var glFormat = utils.convert( renderTarget.texture.format );
			var glType = utils.convert( renderTarget.texture.type );
			var glInternalFormat = getInternalFormat( glFormat, glType );
			state.texImage2D( textureTarget, 0, glInternalFormat, renderTarget.width, renderTarget.height, 0, glFormat, glType, null );
			_gl.bindFramebuffer( 36160, framebuffer );
			_gl.framebufferTexture2D( 36160, attachment, textureTarget, properties.get( renderTarget.texture ).__webglTexture, 0 );
			_gl.bindFramebuffer( 36160, null );
	
		}
	
		// Setup storage for internal depth/stencil buffers and bind to correct framebuffer
		function setupRenderBufferStorage( renderbuffer, renderTarget, isMultisample ) {
	
			_gl.bindRenderbuffer( 36161, renderbuffer );
	
			if ( renderTarget.depthBuffer && ! renderTarget.stencilBuffer ) {
	
				if ( isMultisample ) {
	
					var samples = getRenderTargetSamples( renderTarget );
	
					_gl.renderbufferStorageMultisample( 36161, samples, 33189, renderTarget.width, renderTarget.height );
	
				} else {
	
					_gl.renderbufferStorage( 36161, 33189, renderTarget.width, renderTarget.height );
	
				}
	
				_gl.framebufferRenderbuffer( 36160, 36096, 36161, renderbuffer );
	
			} else if ( renderTarget.depthBuffer && renderTarget.stencilBuffer ) {
	
				if ( isMultisample ) {
	
					var samples = getRenderTargetSamples( renderTarget );
	
					_gl.renderbufferStorageMultisample( 36161, samples, 34041, renderTarget.width, renderTarget.height );
	
				} else {
	
					_gl.renderbufferStorage( 36161, 34041, renderTarget.width, renderTarget.height );
	
				}
	
	
				_gl.framebufferRenderbuffer( 36160, 33306, 36161, renderbuffer );
	
			} else {
	
				var glFormat = utils.convert( renderTarget.texture.format );
				var glType = utils.convert( renderTarget.texture.type );
				var glInternalFormat = getInternalFormat( glFormat, glType );
	
				if ( isMultisample ) {
	
					var samples = getRenderTargetSamples( renderTarget );
	
					_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
	
				} else {
	
					_gl.renderbufferStorage( 36161, glInternalFormat, renderTarget.width, renderTarget.height );
	
				}
	
			}
	
			_gl.bindRenderbuffer( 36161, null );
	
		}
	
		// Setup resources for a Depth Texture for a FBO (needs an extension)
		function setupDepthTexture( framebuffer, renderTarget ) {
	
			var isCube = ( renderTarget && renderTarget.isWebGLRenderTargetCube );
			if ( isCube ) throw new Error( 'Depth Texture with cube render targets is not supported' );
	
			_gl.bindFramebuffer( 36160, framebuffer );
	
			if ( ! ( renderTarget.depthTexture && renderTarget.depthTexture.isDepthTexture ) ) {
	
				throw new Error( 'renderTarget.depthTexture must be an instance of THREE.DepthTexture' );
	
			}
	
			// upload an empty depth texture with framebuffer size
			if ( ! properties.get( renderTarget.depthTexture ).__webglTexture ||
					renderTarget.depthTexture.image.width !== renderTarget.width ||
					renderTarget.depthTexture.image.height !== renderTarget.height ) {
	
				renderTarget.depthTexture.image.width = renderTarget.width;
				renderTarget.depthTexture.image.height = renderTarget.height;
				renderTarget.depthTexture.needsUpdate = true;
	
			}
	
			setTexture2D( renderTarget.depthTexture, 0 );
	
			var webglDepthTexture = properties.get( renderTarget.depthTexture ).__webglTexture;
	
			if ( renderTarget.depthTexture.format === DepthFormat ) {
	
				_gl.framebufferTexture2D( 36160, 36096, 3553, webglDepthTexture, 0 );
	
			} else if ( renderTarget.depthTexture.format === DepthStencilFormat ) {
	
				_gl.framebufferTexture2D( 36160, 33306, 3553, webglDepthTexture, 0 );
	
			} else {
	
				throw new Error( 'Unknown depthTexture format' );
	
			}
	
		}
	
		// Setup GL resources for a non-texture depth buffer
		function setupDepthRenderbuffer( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
	
			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
	
			if ( renderTarget.depthTexture ) {
	
				if ( isCube ) throw new Error( 'target.depthTexture not supported in Cube render targets' );
	
				setupDepthTexture( renderTargetProperties.__webglFramebuffer, renderTarget );
	
			} else {
	
				if ( isCube ) {
	
					renderTargetProperties.__webglDepthbuffer = [];
	
					for ( var i = 0; i < 6; i ++ ) {
	
						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer[ i ] );
						renderTargetProperties.__webglDepthbuffer[ i ] = _gl.createRenderbuffer();
						setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer[ i ], renderTarget );
	
					}
	
				} else {
	
					_gl.bindFramebuffer( 36160, renderTargetProperties.__webglFramebuffer );
					renderTargetProperties.__webglDepthbuffer = _gl.createRenderbuffer();
					setupRenderBufferStorage( renderTargetProperties.__webglDepthbuffer, renderTarget );
	
				}
	
			}
	
			_gl.bindFramebuffer( 36160, null );
	
		}
	
		// Set up GL resources for the render target
		function setupRenderTarget( renderTarget ) {
	
			var renderTargetProperties = properties.get( renderTarget );
			var textureProperties = properties.get( renderTarget.texture );
	
			renderTarget.addEventListener( 'dispose', onRenderTargetDispose );
	
			textureProperties.__webglTexture = _gl.createTexture();
	
			info.memory.textures ++;
	
			var isCube = ( renderTarget.isWebGLRenderTargetCube === true );
			var isMultisample = ( renderTarget.isWebGLMultisampleRenderTarget === true );
			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;
	
			// Setup framebuffer
	
			if ( isCube ) {
	
				renderTargetProperties.__webglFramebuffer = [];
	
				for ( var i = 0; i < 6; i ++ ) {
	
					renderTargetProperties.__webglFramebuffer[ i ] = _gl.createFramebuffer();
	
				}
	
			} else {
	
				renderTargetProperties.__webglFramebuffer = _gl.createFramebuffer();
	
				if ( isMultisample ) {
	
					if ( capabilities.isWebGL2 ) {
	
						renderTargetProperties.__webglMultisampledFramebuffer = _gl.createFramebuffer();
						renderTargetProperties.__webglColorRenderbuffer = _gl.createRenderbuffer();
	
						_gl.bindRenderbuffer( 36161, renderTargetProperties.__webglColorRenderbuffer );
						var glFormat = utils.convert( renderTarget.texture.format );
						var glType = utils.convert( renderTarget.texture.type );
						var glInternalFormat = getInternalFormat( glFormat, glType );
						var samples = getRenderTargetSamples( renderTarget );
						_gl.renderbufferStorageMultisample( 36161, samples, glInternalFormat, renderTarget.width, renderTarget.height );
	
						_gl.bindFramebuffer( 36160, renderTargetProperties.__webglMultisampledFramebuffer );
						_gl.framebufferRenderbuffer( 36160, 36064, 36161, renderTargetProperties.__webglColorRenderbuffer );
						_gl.bindRenderbuffer( 36161, null );
	
						if ( renderTarget.depthBuffer ) {
	
							renderTargetProperties.__webglDepthRenderbuffer = _gl.createRenderbuffer();
							setupRenderBufferStorage( renderTargetProperties.__webglDepthRenderbuffer, renderTarget, true );
	
						}
	
						_gl.bindFramebuffer( 36160, null );
	
	
					} else {
	
						console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );
	
					}
	
				}
	
			}
	
			// Setup color buffer
	
			if ( isCube ) {
	
				state.bindTexture( 34067, textureProperties.__webglTexture );
				setTextureParameters( 34067, renderTarget.texture, supportsMips );
	
				for ( var i = 0; i < 6; i ++ ) {
	
					setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer[ i ], renderTarget, 36064, 34069 + i );
	
				}
	
				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {
	
					generateMipmap( 34067, renderTarget.texture, renderTarget.width, renderTarget.height );
	
				}
	
				state.bindTexture( 34067, null );
	
			} else {
	
				state.bindTexture( 3553, textureProperties.__webglTexture );
				setTextureParameters( 3553, renderTarget.texture, supportsMips );
				setupFrameBufferTexture( renderTargetProperties.__webglFramebuffer, renderTarget, 36064, 3553 );
	
				if ( textureNeedsGenerateMipmaps( renderTarget.texture, supportsMips ) ) {
	
					generateMipmap( 3553, renderTarget.texture, renderTarget.width, renderTarget.height );
	
				}
	
				state.bindTexture( 3553, null );
	
			}
	
			// Setup depth and stencil buffers
	
			if ( renderTarget.depthBuffer ) {
	
				setupDepthRenderbuffer( renderTarget );
	
			}
	
		}
	
		function updateRenderTargetMipmap( renderTarget ) {
	
			var texture = renderTarget.texture;
			var supportsMips = isPowerOfTwo( renderTarget ) || capabilities.isWebGL2;
	
			if ( textureNeedsGenerateMipmaps( texture, supportsMips ) ) {
	
				var target = renderTarget.isWebGLRenderTargetCube ? 34067 : 3553;
				var webglTexture = properties.get( texture ).__webglTexture;
	
				state.bindTexture( target, webglTexture );
				generateMipmap( target, texture, renderTarget.width, renderTarget.height );
				state.bindTexture( target, null );
	
			}
	
		}
	
		function updateMultisampleRenderTarget( renderTarget ) {
	
			if ( renderTarget.isWebGLMultisampleRenderTarget ) {
	
				if ( capabilities.isWebGL2 ) {
	
					var renderTargetProperties = properties.get( renderTarget );
	
					_gl.bindFramebuffer( 36008, renderTargetProperties.__webglMultisampledFramebuffer );
					_gl.bindFramebuffer( 36009, renderTargetProperties.__webglFramebuffer );
	
					var width = renderTarget.width;
					var height = renderTarget.height;
					var mask = 16384;
	
					if ( renderTarget.depthBuffer ) mask |= 256;
					if ( renderTarget.stencilBuffer ) mask |= 1024;
	
					_gl.blitFramebuffer( 0, 0, width, height, 0, 0, width, height, mask, 9728 );
	
				} else {
	
					console.warn( 'THREE.WebGLRenderer: WebGLMultisampleRenderTarget can only be used with WebGL2.' );
	
				}
	
			}
	
		}
	
		function getRenderTargetSamples( renderTarget ) {
	
			return ( capabilities.isWebGL2 && renderTarget.isWebGLMultisampleRenderTarget ) ?
				Math.min( capabilities.maxSamples, renderTarget.samples ) : 0;
	
		}
	
		function updateVideoTexture( texture ) {
	
			var id = texture.id;
			var frame = info.render.frame;
	
			// Check the last frame we updated the VideoTexture
	
			if ( _videoTextures[ id ] !== frame ) {
	
				_videoTextures[ id ] = frame;
				texture.update();
	
			}
	
		}
	
		this.setTexture2D = setTexture2D;
		this.setTexture3D = setTexture3D;
		this.setTextureCube = setTextureCube;
		this.setTextureCubeDynamic = setTextureCubeDynamic;
		this.setupRenderTarget = setupRenderTarget;
		this.updateRenderTargetMipmap = updateRenderTargetMipmap;
		this.updateMultisampleRenderTarget = updateMultisampleRenderTarget;
	
	}
	
	/**
	 * @author thespite / http://www.twitter.com/thespite
	 */
	
	function WebGLUtils( gl, extensions, capabilities ) {
	
		function convert( p ) {
	
			var extension;
	
			if ( p === RepeatWrapping ) return 10497;
			if ( p === ClampToEdgeWrapping ) return 33071;
			if ( p === MirroredRepeatWrapping ) return 33648;
	
			if ( p === NearestFilter ) return 9728;
			if ( p === NearestMipMapNearestFilter ) return 9984;
			if ( p === NearestMipMapLinearFilter ) return 9986;
	
			if ( p === LinearFilter ) return 9729;
			if ( p === LinearMipMapNearestFilter ) return 9985;
			if ( p === LinearMipMapLinearFilter ) return 9987;
	
			if ( p === UnsignedByteType ) return 5121;
			if ( p === UnsignedShort4444Type ) return 32819;
			if ( p === UnsignedShort5551Type ) return 32820;
			if ( p === UnsignedShort565Type ) return 33635;
	
			if ( p === ByteType ) return 5120;
			if ( p === ShortType ) return 5122;
			if ( p === UnsignedShortType ) return 5123;
			if ( p === IntType ) return 5124;
			if ( p === UnsignedIntType ) return 5125;
			if ( p === FloatType ) return 5126;
	
			if ( p === HalfFloatType ) {
	
				if ( capabilities.isWebGL2 ) return 5131;
	
				extension = extensions.get( 'OES_texture_half_float' );
	
				if ( extension !== null ) return extension.HALF_FLOAT_OES;
	
			}
	
			if ( p === AlphaFormat ) return 6406;
			if ( p === RGBFormat ) return 6407;
			if ( p === RGBAFormat ) return 6408;
			if ( p === LuminanceFormat ) return 6409;
			if ( p === LuminanceAlphaFormat ) return 6410;
			if ( p === DepthFormat ) return 6402;
			if ( p === DepthStencilFormat ) return 34041;
			if ( p === RedFormat ) return 6403;
	
			if ( p === AddEquation ) return 32774;
			if ( p === SubtractEquation ) return 32778;
			if ( p === ReverseSubtractEquation ) return 32779;
	
			if ( p === ZeroFactor ) return 0;
			if ( p === OneFactor ) return 1;
			if ( p === SrcColorFactor ) return 768;
			if ( p === OneMinusSrcColorFactor ) return 769;
			if ( p === SrcAlphaFactor ) return 770;
			if ( p === OneMinusSrcAlphaFactor ) return 771;
			if ( p === DstAlphaFactor ) return 772;
			if ( p === OneMinusDstAlphaFactor ) return 773;
	
			if ( p === DstColorFactor ) return 774;
			if ( p === OneMinusDstColorFactor ) return 775;
			if ( p === SrcAlphaSaturateFactor ) return 776;
	
			if ( p === RGB_S3TC_DXT1_Format || p === RGBA_S3TC_DXT1_Format ||
				p === RGBA_S3TC_DXT3_Format || p === RGBA_S3TC_DXT5_Format ) {
	
				extension = extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
				if ( extension !== null ) {
	
					if ( p === RGB_S3TC_DXT1_Format ) return extension.COMPRESSED_RGB_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT1_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT1_EXT;
					if ( p === RGBA_S3TC_DXT3_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT3_EXT;
					if ( p === RGBA_S3TC_DXT5_Format ) return extension.COMPRESSED_RGBA_S3TC_DXT5_EXT;
	
				}
	
			}
	
			if ( p === RGB_PVRTC_4BPPV1_Format || p === RGB_PVRTC_2BPPV1_Format ||
				p === RGBA_PVRTC_4BPPV1_Format || p === RGBA_PVRTC_2BPPV1_Format ) {
	
				extension = extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
				if ( extension !== null ) {
	
					if ( p === RGB_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_4BPPV1_IMG;
					if ( p === RGB_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGB_PVRTC_2BPPV1_IMG;
					if ( p === RGBA_PVRTC_4BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG;
					if ( p === RGBA_PVRTC_2BPPV1_Format ) return extension.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG;
	
				}
	
			}
	
			if ( p === RGB_ETC1_Format ) {
	
				extension = extensions.get( 'WEBGL_compressed_texture_etc1' );
	
				if ( extension !== null ) return extension.COMPRESSED_RGB_ETC1_WEBGL;
	
			}
	
			if ( p === RGBA_ASTC_4x4_Format || p === RGBA_ASTC_5x4_Format || p === RGBA_ASTC_5x5_Format ||
				p === RGBA_ASTC_6x5_Format || p === RGBA_ASTC_6x6_Format || p === RGBA_ASTC_8x5_Format ||
				p === RGBA_ASTC_8x6_Format || p === RGBA_ASTC_8x8_Format || p === RGBA_ASTC_10x5_Format ||
				p === RGBA_ASTC_10x6_Format || p === RGBA_ASTC_10x8_Format || p === RGBA_ASTC_10x10_Format ||
				p === RGBA_ASTC_12x10_Format || p === RGBA_ASTC_12x12_Format ) {
	
				extension = extensions.get( 'WEBGL_compressed_texture_astc' );
	
				if ( extension !== null ) {
	
					return p;
	
				}
	
			}
	
			if ( p === MinEquation || p === MaxEquation ) {
	
				if ( capabilities.isWebGL2 ) {
	
					if ( p === MinEquation ) return 32775;
					if ( p === MaxEquation ) return 32776;
	
				}
	
				extension = extensions.get( 'EXT_blend_minmax' );
	
				if ( extension !== null ) {
	
					if ( p === MinEquation ) return extension.MIN_EXT;
					if ( p === MaxEquation ) return extension.MAX_EXT;
	
				}
	
			}
	
			if ( p === UnsignedInt248Type ) {
	
				if ( capabilities.isWebGL2 ) return 34042;
	
				extension = extensions.get( 'WEBGL_depth_texture' );
	
				if ( extension !== null ) return extension.UNSIGNED_INT_24_8_WEBGL;
	
			}
	
			return 0;
	
		}
	
		return { convert: convert };
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Group() {
	
		Object3D.call( this );
	
		this.type = 'Group';
	
	}
	
	Group.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Group,
	
		isGroup: true
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author mikael emtinger / http://gomo.se/
	 * @author WestLangley / http://github.com/WestLangley
	*/
	
	function Camera() {
	
		Object3D.call( this );
	
		this.type = 'Camera';
	
		this.matrixWorldInverse = new Matrix4();
	
		this.projectionMatrix = new Matrix4();
		this.projectionMatrixInverse = new Matrix4();
	
	}
	
	Camera.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Camera,
	
		isCamera: true,
	
		copy: function ( source, recursive ) {
	
			Object3D.prototype.copy.call( this, source, recursive );
	
			this.matrixWorldInverse.copy( source.matrixWorldInverse );
	
			this.projectionMatrix.copy( source.projectionMatrix );
			this.projectionMatrixInverse.copy( source.projectionMatrixInverse );
	
			return this;
	
		},
	
		getWorldDirection: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Camera: .getWorldDirection() target is now required' );
				target = new Vector3();
	
			}
	
			this.updateMatrixWorld( true );
	
			var e = this.matrixWorld.elements;
	
			return target.set( - e[ 8 ], - e[ 9 ], - e[ 10 ] ).normalize();
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			Object3D.prototype.updateMatrixWorld.call( this, force );
	
			this.matrixWorldInverse.getInverse( this.matrixWorld );
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author greggman / http://games.greggman.com/
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author tschw
	 */
	
	function PerspectiveCamera( fov, aspect, near, far ) {
	
		Camera.call( this );
	
		this.type = 'PerspectiveCamera';
	
		this.fov = fov !== undefined ? fov : 50;
		this.zoom = 1;
	
		this.near = near !== undefined ? near : 0.1;
		this.far = far !== undefined ? far : 2000;
		this.focus = 10;
	
		this.aspect = aspect !== undefined ? aspect : 1;
		this.view = null;
	
		this.filmGauge = 35;	// width of the film (default in millimeters)
		this.filmOffset = 0;	// horizontal film offset (same unit as gauge)
	
		this.updateProjectionMatrix();
	
	}
	
	PerspectiveCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
		constructor: PerspectiveCamera,
	
		isPerspectiveCamera: true,
	
		copy: function ( source, recursive ) {
	
			Camera.prototype.copy.call( this, source, recursive );
	
			this.fov = source.fov;
			this.zoom = source.zoom;
	
			this.near = source.near;
			this.far = source.far;
			this.focus = source.focus;
	
			this.aspect = source.aspect;
			this.view = source.view === null ? null : Object.assign( {}, source.view );
	
			this.filmGauge = source.filmGauge;
			this.filmOffset = source.filmOffset;
	
			return this;
	
		},
	
		/**
		 * Sets the FOV by focal length in respect to the current .filmGauge.
		 *
		 * The default film gauge is 35, so that the focal length can be specified for
		 * a 35mm (full frame) camera.
		 *
		 * Values for focal length and film gauge must have the same unit.
		 */
		setFocalLength: function ( focalLength ) {
	
			// see http://www.bobatkins.com/photography/technical/field_of_view.html
			var vExtentSlope = 0.5 * this.getFilmHeight() / focalLength;
	
			this.fov = _Math.RAD2DEG * 2 * Math.atan( vExtentSlope );
			this.updateProjectionMatrix();
	
		},
	
		/**
		 * Calculates the focal length from the current .fov and .filmGauge.
		 */
		getFocalLength: function () {
	
			var vExtentSlope = Math.tan( _Math.DEG2RAD * 0.5 * this.fov );
	
			return 0.5 * this.getFilmHeight() / vExtentSlope;
	
		},
	
		getEffectiveFOV: function () {
	
			return _Math.RAD2DEG * 2 * Math.atan(
				Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom );
	
		},
	
		getFilmWidth: function () {
	
			// film not completely covered in portrait format (aspect < 1)
			return this.filmGauge * Math.min( this.aspect, 1 );
	
		},
	
		getFilmHeight: function () {
	
			// film not completely covered in landscape format (aspect > 1)
			return this.filmGauge / Math.max( this.aspect, 1 );
	
		},
	
		/**
		 * Sets an offset in a larger frustum. This is useful for multi-window or
		 * multi-monitor/multi-machine setups.
		 *
		 * For example, if you have 3x2 monitors and each monitor is 1920x1080 and
		 * the monitors are in grid like this
		 *
		 *   +---+---+---+
		 *   | A | B | C |
		 *   +---+---+---+
		 *   | D | E | F |
		 *   +---+---+---+
		 *
		 * then for each monitor you would call it like this
		 *
		 *   var w = 1920;
		 *   var h = 1080;
		 *   var fullWidth = w * 3;
		 *   var fullHeight = h * 2;
		 *
		 *   --A--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 0, w, h );
		 *   --B--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 0, w, h );
		 *   --C--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 0, w, h );
		 *   --D--
		 *   camera.setOffset( fullWidth, fullHeight, w * 0, h * 1, w, h );
		 *   --E--
		 *   camera.setOffset( fullWidth, fullHeight, w * 1, h * 1, w, h );
		 *   --F--
		 *   camera.setOffset( fullWidth, fullHeight, w * 2, h * 1, w, h );
		 *
		 *   Note there is no reason monitors have to be the same size or in a grid.
		 */
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
			this.aspect = fullWidth / fullHeight;
	
			if ( this.view === null ) {
	
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
	
			}
	
			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
	
			this.updateProjectionMatrix();
	
		},
	
		clearViewOffset: function () {
	
			if ( this.view !== null ) {
	
				this.view.enabled = false;
	
			}
	
			this.updateProjectionMatrix();
	
		},
	
		updateProjectionMatrix: function () {
	
			var near = this.near,
				top = near * Math.tan( _Math.DEG2RAD * 0.5 * this.fov ) / this.zoom,
				height = 2 * top,
				width = this.aspect * height,
				left = - 0.5 * width,
				view = this.view;
	
			if ( this.view !== null && this.view.enabled ) {
	
				var fullWidth = view.fullWidth,
					fullHeight = view.fullHeight;
	
				left += view.offsetX * width / fullWidth;
				top -= view.offsetY * height / fullHeight;
				width *= view.width / fullWidth;
				height *= view.height / fullHeight;
	
			}
	
			var skew = this.filmOffset;
			if ( skew !== 0 ) left += near * skew / this.getFilmWidth();
	
			this.projectionMatrix.makePerspective( left, left + width, top, top - height, near, this.far );
	
			this.projectionMatrixInverse.getInverse( this.projectionMatrix );
	
		},
	
		toJSON: function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			data.object.fov = this.fov;
			data.object.zoom = this.zoom;
	
			data.object.near = this.near;
			data.object.far = this.far;
			data.object.focus = this.focus;
	
			data.object.aspect = this.aspect;
	
			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
			data.object.filmGauge = this.filmGauge;
			data.object.filmOffset = this.filmOffset;
	
			return data;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function ArrayCamera( array ) {
	
		PerspectiveCamera.call( this );
	
		this.cameras = array || [];
	
	}
	
	ArrayCamera.prototype = Object.assign( Object.create( PerspectiveCamera.prototype ), {
	
		constructor: ArrayCamera,
	
		isArrayCamera: true
	
	} );
	
	/**
	 * @author jsantell / https://www.jsantell.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var cameraLPos = new Vector3();
	var cameraRPos = new Vector3();
	
	/**
	 * Assumes 2 cameras that are parallel and share an X-axis, and that
	 * the cameras' projection and world matrices have already been set.
	 * And that near and far planes are identical for both cameras.
	 * Visualization of this technique: https://computergraphics.stackexchange.com/a/4765
	 */
	function setProjectionFromUnion( camera, cameraL, cameraR ) {
	
		cameraLPos.setFromMatrixPosition( cameraL.matrixWorld );
		cameraRPos.setFromMatrixPosition( cameraR.matrixWorld );
	
		var ipd = cameraLPos.distanceTo( cameraRPos );
	
		var projL = cameraL.projectionMatrix.elements;
		var projR = cameraR.projectionMatrix.elements;
	
		// VR systems will have identical far and near planes, and
		// most likely identical top and bottom frustum extents.
		// Use the left camera for these values.
		var near = projL[ 14 ] / ( projL[ 10 ] - 1 );
		var far = projL[ 14 ] / ( projL[ 10 ] + 1 );
		var topFov = ( projL[ 9 ] + 1 ) / projL[ 5 ];
		var bottomFov = ( projL[ 9 ] - 1 ) / projL[ 5 ];
	
		var leftFov = ( projL[ 8 ] - 1 ) / projL[ 0 ];
		var rightFov = ( projR[ 8 ] + 1 ) / projR[ 0 ];
		var left = near * leftFov;
		var right = near * rightFov;
	
		// Calculate the new camera's position offset from the
		// left camera. xOffset should be roughly half `ipd`.
		var zOffset = ipd / ( - leftFov + rightFov );
		var xOffset = zOffset * - leftFov;
	
		// TODO: Better way to apply this offset?
		cameraL.matrixWorld.decompose( camera.position, camera.quaternion, camera.scale );
		camera.translateX( xOffset );
		camera.translateZ( zOffset );
		camera.matrixWorld.compose( camera.position, camera.quaternion, camera.scale );
		camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
		// Find the union of the frustum values of the cameras and scale
		// the values so that the near plane's position does not change in world space,
		// although must now be relative to the new union camera.
		var near2 = near + zOffset;
		var far2 = far + zOffset;
		var left2 = left - xOffset;
		var right2 = right + ( ipd - xOffset );
		var top2 = topFov * far / far2 * near2;
		var bottom2 = bottomFov * far / far2 * near2;
	
		camera.projectionMatrix.makePerspective( left2, right2, top2, bottom2, near2, far2 );
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebVRManager( renderer ) {
	
		var scope = this;
	
		var device = null;
		var frameData = null;
	
		var poseTarget = null;
	
		var controllers = [];
		var standingMatrix = new Matrix4();
		var standingMatrixInverse = new Matrix4();
	
		var framebufferScaleFactor = 1.0;
	
		var frameOfReferenceType = 'stage';
	
		if ( typeof window !== 'undefined' && 'VRFrameData' in window ) {
	
			frameData = new window.VRFrameData();
			window.addEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange, false );
	
		}
	
		var matrixWorldInverse = new Matrix4();
		var tempQuaternion = new Quaternion();
		var tempPosition = new Vector3();
	
		var cameraL = new PerspectiveCamera();
		cameraL.bounds = new Vector4( 0.0, 0.0, 0.5, 1.0 );
		cameraL.layers.enable( 1 );
	
		var cameraR = new PerspectiveCamera();
		cameraR.bounds = new Vector4( 0.5, 0.0, 0.5, 1.0 );
		cameraR.layers.enable( 2 );
	
		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );
	
		//
	
		function isPresenting() {
	
			return device !== null && device.isPresenting === true;
	
		}
	
		var currentSize, currentPixelRatio;
	
		function onVRDisplayPresentChange() {
	
			if ( isPresenting() ) {
	
				var eyeParameters = device.getEyeParameters( 'left' );
				var renderWidth = eyeParameters.renderWidth * framebufferScaleFactor;
				var renderHeight = eyeParameters.renderHeight * framebufferScaleFactor;
	
				currentPixelRatio = renderer.getPixelRatio();
				currentSize = renderer.getSize();
	
				renderer.setDrawingBufferSize( renderWidth * 2, renderHeight, 1 );
	
				animation.start();
	
			} else {
	
				if ( scope.enabled ) {
	
					renderer.setDrawingBufferSize( currentSize.width, currentSize.height, currentPixelRatio );
	
				}
	
				animation.stop();
	
			}
	
		}
	
		//
	
		var triggers = [];
	
		function findGamepad( id ) {
	
			var gamepads = navigator.getGamepads && navigator.getGamepads();
	
			for ( var i = 0, j = 0, l = gamepads.length; i < l; i ++ ) {
	
				var gamepad = gamepads[ i ];
	
				if ( gamepad && ( gamepad.id === 'Daydream Controller' ||
					gamepad.id === 'Gear VR Controller' || gamepad.id === 'Oculus Go Controller' ||
					gamepad.id === 'OpenVR Gamepad' || gamepad.id.startsWith( 'Oculus Touch' ) ||
					gamepad.id.startsWith( 'Spatial Controller' ) ) ) {
	
					if ( j === id ) return gamepad;
	
					j ++;
	
				}
	
			}
	
		}
	
		function updateControllers() {
	
			for ( var i = 0; i < controllers.length; i ++ ) {
	
				var controller = controllers[ i ];
	
				var gamepad = findGamepad( i );
	
				if ( gamepad !== undefined && gamepad.pose !== undefined ) {
	
					if ( gamepad.pose === null ) return;
	
					//  Pose
	
					var pose = gamepad.pose;
	
					if ( pose.hasPosition === false ) controller.position.set( 0.2, - 0.6, - 0.05 );
	
					if ( pose.position !== null ) controller.position.fromArray( pose.position );
					if ( pose.orientation !== null ) controller.quaternion.fromArray( pose.orientation );
					controller.matrix.compose( controller.position, controller.quaternion, controller.scale );
					controller.matrix.premultiply( standingMatrix );
					controller.matrix.decompose( controller.position, controller.quaternion, controller.scale );
					controller.matrixWorldNeedsUpdate = true;
					controller.visible = true;
	
					//  Trigger
	
					var buttonId = gamepad.id === 'Daydream Controller' ? 0 : 1;
	
					if ( triggers[ i ] !== gamepad.buttons[ buttonId ].pressed ) {
	
						triggers[ i ] = gamepad.buttons[ buttonId ].pressed;
	
						if ( triggers[ i ] === true ) {
	
							controller.dispatchEvent( { type: 'selectstart' } );
	
						} else {
	
							controller.dispatchEvent( { type: 'selectend' } );
							controller.dispatchEvent( { type: 'select' } );
	
						}
	
					}
	
				} else {
	
					controller.visible = false;
	
				}
	
			}
	
		}
	
		//
	
		this.enabled = false;
	
		this.getController = function ( id ) {
	
			var controller = controllers[ id ];
	
			if ( controller === undefined ) {
	
				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;
	
				controllers[ id ] = controller;
	
			}
	
			return controller;
	
		};
	
		this.getDevice = function () {
	
			return device;
	
		};
	
		this.setDevice = function ( value ) {
	
			if ( value !== undefined ) device = value;
	
			animation.setContext( value );
	
		};
	
		this.setFramebufferScaleFactor = function ( value ) {
	
			framebufferScaleFactor = value;
	
		};
	
		this.setFrameOfReferenceType = function ( value ) {
	
			frameOfReferenceType = value;
	
		};
	
		this.setPoseTarget = function ( object ) {
	
			if ( object !== undefined ) poseTarget = object;
	
		};
	
		this.getCamera = function ( camera ) {
	
			var userHeight = frameOfReferenceType === 'stage' ? 1.6 : 0;
	
			if ( device === null ) {
	
				camera.position.set( 0, userHeight, 0 );
				return camera;
	
			}
	
			device.depthNear = camera.near;
			device.depthFar = camera.far;
	
			device.getFrameData( frameData );
	
			//
	
			if ( frameOfReferenceType === 'stage' ) {
	
				var stageParameters = device.stageParameters;
	
				if ( stageParameters ) {
	
					standingMatrix.fromArray( stageParameters.sittingToStandingTransform );
	
				} else {
	
					standingMatrix.makeTranslation( 0, userHeight, 0 );
	
				}
	
			}
	
	
			var pose = frameData.pose;
			var poseObject = poseTarget !== null ? poseTarget : camera;
	
			// We want to manipulate poseObject by its position and quaternion components since users may rely on them.
			poseObject.matrix.copy( standingMatrix );
			poseObject.matrix.decompose( poseObject.position, poseObject.quaternion, poseObject.scale );
	
			if ( pose.orientation !== null ) {
	
				tempQuaternion.fromArray( pose.orientation );
				poseObject.quaternion.multiply( tempQuaternion );
	
			}
	
			if ( pose.position !== null ) {
	
				tempQuaternion.setFromRotationMatrix( standingMatrix );
				tempPosition.fromArray( pose.position );
				tempPosition.applyQuaternion( tempQuaternion );
				poseObject.position.add( tempPosition );
	
			}
	
			poseObject.updateMatrixWorld();
	
			if ( device.isPresenting === false ) return camera;
	
			//
	
			cameraL.near = camera.near;
			cameraR.near = camera.near;
	
			cameraL.far = camera.far;
			cameraR.far = camera.far;
	
			cameraL.matrixWorldInverse.fromArray( frameData.leftViewMatrix );
			cameraR.matrixWorldInverse.fromArray( frameData.rightViewMatrix );
	
			// TODO (mrdoob) Double check this code
	
			standingMatrixInverse.getInverse( standingMatrix );
	
			if ( frameOfReferenceType === 'stage' ) {
	
				cameraL.matrixWorldInverse.multiply( standingMatrixInverse );
				cameraR.matrixWorldInverse.multiply( standingMatrixInverse );
	
			}
	
			var parent = poseObject.parent;
	
			if ( parent !== null ) {
	
				matrixWorldInverse.getInverse( parent.matrixWorld );
	
				cameraL.matrixWorldInverse.multiply( matrixWorldInverse );
				cameraR.matrixWorldInverse.multiply( matrixWorldInverse );
	
			}
	
			// envMap and Mirror needs camera.matrixWorld
	
			cameraL.matrixWorld.getInverse( cameraL.matrixWorldInverse );
			cameraR.matrixWorld.getInverse( cameraR.matrixWorldInverse );
	
			cameraL.projectionMatrix.fromArray( frameData.leftProjectionMatrix );
			cameraR.projectionMatrix.fromArray( frameData.rightProjectionMatrix );
	
			setProjectionFromUnion( cameraVR, cameraL, cameraR );
	
			//
	
			var layers = device.getLayers();
	
			if ( layers.length ) {
	
				var layer = layers[ 0 ];
	
				if ( layer.leftBounds !== null && layer.leftBounds.length === 4 ) {
	
					cameraL.bounds.fromArray( layer.leftBounds );
	
				}
	
				if ( layer.rightBounds !== null && layer.rightBounds.length === 4 ) {
	
					cameraR.bounds.fromArray( layer.rightBounds );
	
				}
	
			}
	
			updateControllers();
	
			return cameraVR;
	
		};
	
		this.getStandingMatrix = function () {
	
			return standingMatrix;
	
		};
	
		this.isPresenting = isPresenting;
	
		// Animation Loop
	
		var animation = new WebGLAnimation();
	
		this.setAnimationLoop = function ( callback ) {
	
			animation.setAnimationLoop( callback );
	
		};
	
		this.submitFrame = function () {
	
			if ( isPresenting() ) device.submitFrame();
	
		};
	
		this.dispose = function () {
	
			if ( typeof window !== 'undefined' ) {
	
				window.removeEventListener( 'vrdisplaypresentchange', onVRDisplayPresentChange );
	
			}
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function WebXRManager( renderer ) {
	
		var gl = renderer.context;
	
		var device = null;
		var session = null;
	
		var framebufferScaleFactor = 1.0;
	
		var frameOfReference = null;
		var frameOfReferenceType = 'stage';
	
		var pose = null;
	
		var controllers = [];
		var inputSources = [];
	
		function isPresenting() {
	
			return session !== null && frameOfReference !== null;
	
		}
	
		//
	
		var cameraL = new PerspectiveCamera();
		cameraL.layers.enable( 1 );
		cameraL.viewport = new Vector4();
	
		var cameraR = new PerspectiveCamera();
		cameraR.layers.enable( 2 );
		cameraR.viewport = new Vector4();
	
		var cameraVR = new ArrayCamera( [ cameraL, cameraR ] );
		cameraVR.layers.enable( 1 );
		cameraVR.layers.enable( 2 );
	
		//
	
		this.enabled = false;
	
		this.getController = function ( id ) {
	
			var controller = controllers[ id ];
	
			if ( controller === undefined ) {
	
				controller = new Group();
				controller.matrixAutoUpdate = false;
				controller.visible = false;
	
				controllers[ id ] = controller;
	
			}
	
			return controller;
	
		};
	
		this.getDevice = function () {
	
			return device;
	
		};
	
		this.setDevice = function ( value ) {
	
			if ( value !== undefined ) device = value;
			if ( value instanceof XRDevice ) gl.setCompatibleXRDevice( value );
	
		};
	
		//
	
		function onSessionEvent( event ) {
	
			var controller = controllers[ inputSources.indexOf( event.inputSource ) ];
			if ( controller ) controller.dispatchEvent( { type: event.type } );
	
		}
	
		function onSessionEnd() {
	
			renderer.setFramebuffer( null );
			animation.stop();
	
		}
	
		this.setFramebufferScaleFactor = function ( value ) {
	
			framebufferScaleFactor = value;
	
		};
	
		this.setFrameOfReferenceType = function ( value ) {
	
			frameOfReferenceType = value;
	
		};
	
		this.setSession = function ( value ) {
	
			session = value;
	
			if ( session !== null ) {
	
				session.addEventListener( 'select', onSessionEvent );
				session.addEventListener( 'selectstart', onSessionEvent );
				session.addEventListener( 'selectend', onSessionEvent );
				session.addEventListener( 'end', onSessionEnd );
	
				session.baseLayer = new XRWebGLLayer( session, gl, { framebufferScaleFactor: framebufferScaleFactor } );
				session.requestFrameOfReference( frameOfReferenceType ).then( function ( value ) {
	
					frameOfReference = value;
	
					renderer.setFramebuffer( session.baseLayer.framebuffer );
	
					animation.setContext( session );
					animation.start();
	
				} );
	
				//
	
				inputSources = session.getInputSources();
	
				session.addEventListener( 'inputsourceschange', function () {
	
					inputSources = session.getInputSources();
					console.log( inputSources );
	
					for ( var i = 0; i < controllers.length; i ++ ) {
	
						var controller = controllers[ i ];
						controller.userData.inputSource = inputSources[ i ];
	
					}
	
				} );
	
			}
	
		};
	
		function updateCamera( camera, parent ) {
	
			if ( parent === null ) {
	
				camera.matrixWorld.copy( camera.matrix );
	
			} else {
	
				camera.matrixWorld.multiplyMatrices( parent.matrixWorld, camera.matrix );
	
			}
	
			camera.matrixWorldInverse.getInverse( camera.matrixWorld );
	
		}
	
		this.getCamera = function ( camera ) {
	
			if ( isPresenting() ) {
	
				var parent = camera.parent;
				var cameras = cameraVR.cameras;
	
				updateCamera( cameraVR, parent );
	
				for ( var i = 0; i < cameras.length; i ++ ) {
	
					updateCamera( cameras[ i ], parent );
	
				}
	
				// update camera and its children
	
				camera.matrixWorld.copy( cameraVR.matrixWorld );
	
				var children = camera.children;
	
				for ( var i = 0, l = children.length; i < l; i ++ ) {
	
					children[ i ].updateMatrixWorld( true );
	
				}
	
				setProjectionFromUnion( cameraVR, cameraL, cameraR );
	
				return cameraVR;
	
			}
	
			return camera;
	
		};
	
		this.isPresenting = isPresenting;
	
		// Animation Loop
	
		var onAnimationFrameCallback = null;
	
		function onAnimationFrame( time, frame ) {
	
			pose = frame.getDevicePose( frameOfReference );
	
			if ( pose !== null ) {
	
				var layer = session.baseLayer;
				var views = frame.views;
	
				for ( var i = 0; i < views.length; i ++ ) {
	
					var view = views[ i ];
					var viewport = layer.getViewport( view );
					var viewMatrix = pose.getViewMatrix( view );
	
					var camera = cameraVR.cameras[ i ];
					camera.matrix.fromArray( viewMatrix ).getInverse( camera.matrix );
					camera.projectionMatrix.fromArray( view.projectionMatrix );
					camera.viewport.set( viewport.x, viewport.y, viewport.width, viewport.height );
	
					if ( i === 0 ) {
	
						cameraVR.matrix.copy( camera.matrix );
	
					}
	
				}
	
			}
	
			//
	
			for ( var i = 0; i < controllers.length; i ++ ) {
	
				var controller = controllers[ i ];
	
				var inputSource = inputSources[ i ];
	
				if ( inputSource ) {
	
					var inputPose = frame.getInputPose( inputSource, frameOfReference );
	
					if ( inputPose !== null ) {
	
						if ( 'targetRay' in inputPose ) {
	
							controller.matrix.elements = inputPose.targetRay.transformMatrix;
	
						} else if ( 'pointerMatrix' in inputPose ) {
	
							// DEPRECATED
	
							controller.matrix.elements = inputPose.pointerMatrix;
	
						}
	
						controller.matrix.decompose( controller.position, controller.rotation, controller.scale );
						controller.visible = true;
	
						continue;
	
					}
	
				}
	
				controller.visible = false;
	
			}
	
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );
	
		}
	
		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );
	
		this.setAnimationLoop = function ( callback ) {
	
			onAnimationFrameCallback = callback;
	
		};
	
		this.dispose = function () {};
	
		// DEPRECATED
	
		this.getStandingMatrix = function () {
	
			console.warn( 'THREE.WebXRManager: getStandingMatrix() is no longer needed.' );
			return new THREE.Matrix4();
	
		};
	
		this.submitFrame = function () {};
	
	}
	
	/**
	 * @author supereggbert / http://www.paulbrunt.co.uk/
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 * @author szimek / https://github.com/szimek/
	 * @author tschw
	 */
	
	function WebGLRenderer( parameters ) {
	
		console.log( 'THREE.WebGLRenderer', REVISION );
	
		parameters = parameters || {};
	
		var _canvas = parameters.canvas !== undefined ? parameters.canvas : document.createElementNS( 'http://www.w3.org/1999/xhtml', 'canvas' ),
			_context = parameters.context !== undefined ? parameters.context : null,
	
			_alpha = parameters.alpha !== undefined ? parameters.alpha : false,
			_depth = parameters.depth !== undefined ? parameters.depth : true,
			_stencil = parameters.stencil !== undefined ? parameters.stencil : true,
			_antialias = parameters.antialias !== undefined ? parameters.antialias : false,
			_premultipliedAlpha = parameters.premultipliedAlpha !== undefined ? parameters.premultipliedAlpha : true,
			_preserveDrawingBuffer = parameters.preserveDrawingBuffer !== undefined ? parameters.preserveDrawingBuffer : false,
			_powerPreference = parameters.powerPreference !== undefined ? parameters.powerPreference : 'default';
	
		var currentRenderList = null;
		var currentRenderState = null;
	
		// public properties
	
		this.domElement = _canvas;
		this.context = null;
	
		// clearing
	
		this.autoClear = true;
		this.autoClearColor = true;
		this.autoClearDepth = true;
		this.autoClearStencil = true;
	
		// scene graph
	
		this.sortObjects = true;
	
		// user-defined clipping
	
		this.clippingPlanes = [];
		this.localClippingEnabled = false;
	
		// physically based shading
	
		this.gammaFactor = 2.0;	// for backwards compatibility
		this.gammaInput = false;
		this.gammaOutput = false;
	
		// physical lights
	
		this.physicallyCorrectLights = false;
	
		// tone mapping
	
		this.toneMapping = LinearToneMapping;
		this.toneMappingExposure = 1.0;
		this.toneMappingWhitePoint = 1.0;
	
		// morphs
	
		this.maxMorphTargets = 8;
		this.maxMorphNormals = 4;
	
		// internal properties
	
		var _this = this,
	
			_isContextLost = false,
	
			// internal state cache
	
			_framebuffer = null,
	
			_currentRenderTarget = null,
			_currentFramebuffer = null,
			_currentMaterialId = - 1,
	
			// geometry and program caching
	
			_currentGeometryProgram = {
				geometry: null,
				program: null,
				wireframe: false
			},
	
			_currentCamera = null,
			_currentArrayCamera = null,
	
			_currentViewport = new Vector4(),
			_currentScissor = new Vector4(),
			_currentScissorTest = null,
	
			//
	
			_usedTextureUnits = 0,
	
			//
	
			_width = _canvas.width,
			_height = _canvas.height,
	
			_pixelRatio = 1,
	
			_viewport = new Vector4( 0, 0, _width, _height ),
			_scissor = new Vector4( 0, 0, _width, _height ),
			_scissorTest = false,
	
			// frustum
	
			_frustum = new Frustum(),
	
			// clipping
	
			_clipping = new WebGLClipping(),
			_clippingEnabled = false,
			_localClippingEnabled = false,
	
			// camera matrices cache
	
			_projScreenMatrix = new Matrix4(),
	
			_vector3 = new Vector3();
	
		function getTargetPixelRatio() {
	
			return _currentRenderTarget === null ? _pixelRatio : 1;
	
		}
	
		// initialize
	
		var _gl;
	
		try {
	
			var contextAttributes = {
				alpha: _alpha,
				depth: _depth,
				stencil: _stencil,
				antialias: _antialias,
				premultipliedAlpha: _premultipliedAlpha,
				preserveDrawingBuffer: _preserveDrawingBuffer,
				powerPreference: _powerPreference
			};
	
			// event listeners must be registered before WebGL context is created, see #12753
	
			_canvas.addEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.addEventListener( 'webglcontextrestored', onContextRestore, false );
	
			_gl = _context || _canvas.getContext( 'webgl', contextAttributes ) || _canvas.getContext( 'experimental-webgl', contextAttributes );
	
			if ( _gl === null ) {
	
				if ( _canvas.getContext( 'webgl' ) !== null ) {
	
					throw new Error( 'Error creating WebGL context with your selected attributes.' );
	
				} else {
	
					throw new Error( 'Error creating WebGL context.' );
	
				}
	
			}
	
			// Some experimental-webgl implementations do not have getShaderPrecisionFormat
	
			if ( _gl.getShaderPrecisionFormat === undefined ) {
	
				_gl.getShaderPrecisionFormat = function () {
	
					return { 'rangeMin': 1, 'rangeMax': 1, 'precision': 1 };
	
				};
	
			}
	
		} catch ( error ) {
	
			console.error( 'THREE.WebGLRenderer: ' + error.message );
	
		}
	
		var extensions, capabilities, state, info;
		var properties, textures, attributes, geometries, objects;
		var programCache, renderLists, renderStates;
	
		var background, morphtargets, bufferRenderer, indexedBufferRenderer;
	
		var utils;
	
		function initGLContext() {
	
			extensions = new WebGLExtensions( _gl );
	
			capabilities = new WebGLCapabilities( _gl, extensions, parameters );
	
			if ( ! capabilities.isWebGL2 ) {
	
				extensions.get( 'WEBGL_depth_texture' );
				extensions.get( 'OES_texture_float' );
				extensions.get( 'OES_texture_half_float' );
				extensions.get( 'OES_texture_half_float_linear' );
				extensions.get( 'OES_standard_derivatives' );
				extensions.get( 'OES_element_index_uint' );
				extensions.get( 'ANGLE_instanced_arrays' );
	
			}
	
			extensions.get( 'OES_texture_float_linear' );
	
			utils = new WebGLUtils( _gl, extensions, capabilities );
	
			state = new WebGLState( _gl, extensions, utils, capabilities );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
			info = new WebGLInfo( _gl );
			properties = new WebGLProperties();
			textures = new WebGLTextures( _gl, extensions, state, properties, capabilities, utils, info );
			attributes = new WebGLAttributes( _gl );
			geometries = new WebGLGeometries( _gl, attributes, info );
			objects = new WebGLObjects( geometries, info );
			morphtargets = new WebGLMorphtargets( _gl );
			programCache = new WebGLPrograms( _this, extensions, capabilities );
			renderLists = new WebGLRenderLists();
			renderStates = new WebGLRenderStates();
	
			background = new WebGLBackground( _this, state, objects, _premultipliedAlpha );
	
			bufferRenderer = new WebGLBufferRenderer( _gl, extensions, info, capabilities );
			indexedBufferRenderer = new WebGLIndexedBufferRenderer( _gl, extensions, info, capabilities );
	
			info.programs = programCache.programs;
	
			_this.context = _gl;
			_this.capabilities = capabilities;
			_this.extensions = extensions;
			_this.properties = properties;
			_this.renderLists = renderLists;
			_this.state = state;
			_this.info = info;
	
		}
	
		initGLContext();
	
		// vr
	
		var vr = null;
	
		if ( typeof navigator !== 'undefined' ) {
	
			vr = ( 'xr' in navigator ) ? new WebXRManager( _this ) : new WebVRManager( _this );
	
		}
	
		this.vr = vr;
	
		// shadow map
	
		var shadowMap = new WebGLShadowMap( _this, objects, capabilities.maxTextureSize );
	
		this.shadowMap = shadowMap;
	
		// API
	
		this.getContext = function () {
	
			return _gl;
	
		};
	
		this.getContextAttributes = function () {
	
			return _gl.getContextAttributes();
	
		};
	
		this.forceContextLoss = function () {
	
			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.loseContext();
	
		};
	
		this.forceContextRestore = function () {
	
			var extension = extensions.get( 'WEBGL_lose_context' );
			if ( extension ) extension.restoreContext();
	
		};
	
		this.getPixelRatio = function () {
	
			return _pixelRatio;
	
		};
	
		this.setPixelRatio = function ( value ) {
	
			if ( value === undefined ) return;
	
			_pixelRatio = value;
	
			this.setSize( _width, _height, false );
	
		};
	
		this.getSize = function () {
	
			return {
				width: _width,
				height: _height
			};
	
		};
	
		this.setSize = function ( width, height, updateStyle ) {
	
			if ( vr.isPresenting() ) {
	
				console.warn( 'THREE.WebGLRenderer: Can\'t change size while VR device is presenting.' );
				return;
	
			}
	
			_width = width;
			_height = height;
	
			_canvas.width = width * _pixelRatio;
			_canvas.height = height * _pixelRatio;
	
			if ( updateStyle !== false ) {
	
				_canvas.style.width = width + 'px';
				_canvas.style.height = height + 'px';
	
			}
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.getDrawingBufferSize = function () {
	
			return {
				width: _width * _pixelRatio,
				height: _height * _pixelRatio
			};
	
		};
	
		this.setDrawingBufferSize = function ( width, height, pixelRatio ) {
	
			_width = width;
			_height = height;
	
			_pixelRatio = pixelRatio;
	
			_canvas.width = width * pixelRatio;
			_canvas.height = height * pixelRatio;
	
			this.setViewport( 0, 0, width, height );
	
		};
	
		this.getCurrentViewport = function () {
	
			return _currentViewport;
	
		};
	
		this.setViewport = function ( x, y, width, height ) {
	
			_viewport.set( x, _height - y - height, width, height );
			state.viewport( _currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio ) );
	
		};
	
		this.setScissor = function ( x, y, width, height ) {
	
			_scissor.set( x, _height - y - height, width, height );
			state.scissor( _currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio ) );
	
		};
	
		this.setScissorTest = function ( boolean ) {
	
			state.setScissorTest( _scissorTest = boolean );
	
		};
	
		// Clearing
	
		this.getClearColor = function () {
	
			return background.getClearColor();
	
		};
	
		this.setClearColor = function () {
	
			background.setClearColor.apply( background, arguments );
	
		};
	
		this.getClearAlpha = function () {
	
			return background.getClearAlpha();
	
		};
	
		this.setClearAlpha = function () {
	
			background.setClearAlpha.apply( background, arguments );
	
		};
	
		this.clear = function ( color, depth, stencil ) {
	
			var bits = 0;
	
			if ( color === undefined || color ) bits |= 16384;
			if ( depth === undefined || depth ) bits |= 256;
			if ( stencil === undefined || stencil ) bits |= 1024;
	
			_gl.clear( bits );
	
		};
	
		this.clearColor = function () {
	
			this.clear( true, false, false );
	
		};
	
		this.clearDepth = function () {
	
			this.clear( false, true, false );
	
		};
	
		this.clearStencil = function () {
	
			this.clear( false, false, true );
	
		};
	
		//
	
		this.dispose = function () {
	
			_canvas.removeEventListener( 'webglcontextlost', onContextLost, false );
			_canvas.removeEventListener( 'webglcontextrestored', onContextRestore, false );
	
			renderLists.dispose();
			renderStates.dispose();
			properties.dispose();
			objects.dispose();
	
			vr.dispose();
	
			animation.stop();
	
		};
	
		// Events
	
		function onContextLost( event ) {
	
			event.preventDefault();
	
			console.log( 'THREE.WebGLRenderer: Context Lost.' );
	
			_isContextLost = true;
	
		}
	
		function onContextRestore( /* event */ ) {
	
			console.log( 'THREE.WebGLRenderer: Context Restored.' );
	
			_isContextLost = false;
	
			initGLContext();
	
		}
	
		function onMaterialDispose( event ) {
	
			var material = event.target;
	
			material.removeEventListener( 'dispose', onMaterialDispose );
	
			deallocateMaterial( material );
	
		}
	
		// Buffer deallocation
	
		function deallocateMaterial( material ) {
	
			releaseMaterialProgramReference( material );
	
			properties.remove( material );
	
		}
	
	
		function releaseMaterialProgramReference( material ) {
	
			var programInfo = properties.get( material ).program;
	
			material.program = undefined;
	
			if ( programInfo !== undefined ) {
	
				programCache.releaseProgram( programInfo );
	
			}
	
		}
	
		// Buffer rendering
	
		function renderObjectImmediate( object, program ) {
	
			object.render( function ( object ) {
	
				_this.renderBufferImmediate( object, program );
	
			} );
	
		}
	
		this.renderBufferImmediate = function ( object, program ) {
	
			state.initAttributes();
	
			var buffers = properties.get( object );
	
			if ( object.hasPositions && ! buffers.position ) buffers.position = _gl.createBuffer();
			if ( object.hasNormals && ! buffers.normal ) buffers.normal = _gl.createBuffer();
			if ( object.hasUvs && ! buffers.uv ) buffers.uv = _gl.createBuffer();
			if ( object.hasColors && ! buffers.color ) buffers.color = _gl.createBuffer();
	
			var programAttributes = program.getAttributes();
	
			if ( object.hasPositions ) {
	
				_gl.bindBuffer( 34962, buffers.position );
				_gl.bufferData( 34962, object.positionArray, 35048 );
	
				state.enableAttribute( programAttributes.position );
				_gl.vertexAttribPointer( programAttributes.position, 3, 5126, false, 0, 0 );
	
			}
	
			if ( object.hasNormals ) {
	
				_gl.bindBuffer( 34962, buffers.normal );
				_gl.bufferData( 34962, object.normalArray, 35048 );
	
				state.enableAttribute( programAttributes.normal );
				_gl.vertexAttribPointer( programAttributes.normal, 3, 5126, false, 0, 0 );
	
			}
	
			if ( object.hasUvs ) {
	
				_gl.bindBuffer( 34962, buffers.uv );
				_gl.bufferData( 34962, object.uvArray, 35048 );
	
				state.enableAttribute( programAttributes.uv );
				_gl.vertexAttribPointer( programAttributes.uv, 2, 5126, false, 0, 0 );
	
			}
	
			if ( object.hasColors ) {
	
				_gl.bindBuffer( 34962, buffers.color );
				_gl.bufferData( 34962, object.colorArray, 35048 );
	
				state.enableAttribute( programAttributes.color );
				_gl.vertexAttribPointer( programAttributes.color, 3, 5126, false, 0, 0 );
	
			}
	
			state.disableUnusedAttributes();
	
			_gl.drawArrays( 4, 0, object.count );
	
			object.count = 0;
	
		};
	
		this.renderBufferDirect = function ( camera, fog, geometry, material, object, group ) {
	
			var frontFaceCW = ( object.isMesh && object.normalMatrix.determinant() < 0 );
	
			state.setMaterial( material, frontFaceCW );
	
			var program = setProgram( camera, fog, material, object );
	
			var updateBuffers = false;
	
			if ( _currentGeometryProgram.geometry !== geometry.id ||
				_currentGeometryProgram.program !== program.id ||
				_currentGeometryProgram.wireframe !== ( material.wireframe === true ) ) {
	
				_currentGeometryProgram.geometry = geometry.id;
				_currentGeometryProgram.program = program.id;
				_currentGeometryProgram.wireframe = material.wireframe === true;
				updateBuffers = true;
	
			}
	
			if ( object.morphTargetInfluences ) {
	
				morphtargets.update( object, geometry, material, program );
	
				updateBuffers = true;
	
			}
	
			//
	
			var index = geometry.index;
			var position = geometry.attributes.position;
			var rangeFactor = 1;
	
			if ( material.wireframe === true ) {
	
				index = geometries.getWireframeAttribute( geometry );
				rangeFactor = 2;
	
			}
	
			var attribute;
			var renderer = bufferRenderer;
	
			if ( index !== null ) {
	
				attribute = attributes.get( index );
	
				renderer = indexedBufferRenderer;
				renderer.setIndex( attribute );
	
			}
	
			if ( updateBuffers ) {
	
				setupVertexAttributes( material, program, geometry );
	
				if ( index !== null ) {
	
					_gl.bindBuffer( 34963, attribute.buffer );
	
				}
	
			}
	
			//
	
			var dataCount = Infinity;
	
			if ( index !== null ) {
	
				dataCount = index.count;
	
			} else if ( position !== undefined ) {
	
				dataCount = position.count;
	
			}
	
			var rangeStart = geometry.drawRange.start * rangeFactor;
			var rangeCount = geometry.drawRange.count * rangeFactor;
	
			var groupStart = group !== null ? group.start * rangeFactor : 0;
			var groupCount = group !== null ? group.count * rangeFactor : Infinity;
	
			var drawStart = Math.max( rangeStart, groupStart );
			var drawEnd = Math.min( dataCount, rangeStart + rangeCount, groupStart + groupCount ) - 1;
	
			var drawCount = Math.max( 0, drawEnd - drawStart + 1 );
	
			if ( drawCount === 0 ) return;
	
			//
	
			if ( object.isMesh ) {
	
				if ( material.wireframe === true ) {
	
					state.setLineWidth( material.wireframeLinewidth * getTargetPixelRatio() );
					renderer.setMode( 1 );
	
				} else {
	
					switch ( object.drawMode ) {
	
						case TrianglesDrawMode:
							renderer.setMode( 4 );
							break;
	
						case TriangleStripDrawMode:
							renderer.setMode( 5 );
							break;
	
						case TriangleFanDrawMode:
							renderer.setMode( 6 );
							break;
	
					}
	
				}
	
	
			} else if ( object.isLine ) {
	
				var lineWidth = material.linewidth;
	
				if ( lineWidth === undefined ) lineWidth = 1; // Not using Line*Material
	
				state.setLineWidth( lineWidth * getTargetPixelRatio() );
	
				if ( object.isLineSegments ) {
	
					renderer.setMode( 1 );
	
				} else if ( object.isLineLoop ) {
	
					renderer.setMode( 2 );
	
				} else {
	
					renderer.setMode( 3 );
	
				}
	
			} else if ( object.isPoints ) {
	
				renderer.setMode( 0 );
	
			} else if ( object.isSprite ) {
	
				renderer.setMode( 4 );
	
			}
	
			if ( geometry && geometry.isInstancedBufferGeometry ) {
	
				if ( geometry.maxInstancedCount > 0 ) {
	
					renderer.renderInstances( geometry, drawStart, drawCount );
	
				}
	
			} else {
	
				renderer.render( drawStart, drawCount );
	
			}
	
		};
	
		function setupVertexAttributes( material, program, geometry ) {
	
			if ( geometry && geometry.isInstancedBufferGeometry & ! capabilities.isWebGL2 ) {
	
				if ( extensions.get( 'ANGLE_instanced_arrays' ) === null ) {
	
					console.error( 'THREE.WebGLRenderer.setupVertexAttributes: using THREE.InstancedBufferGeometry but hardware does not support extension ANGLE_instanced_arrays.' );
					return;
	
				}
	
			}
	
			state.initAttributes();
	
			var geometryAttributes = geometry.attributes;
	
			var programAttributes = program.getAttributes();
	
			var materialDefaultAttributeValues = material.defaultAttributeValues;
	
			for ( var name in programAttributes ) {
	
				var programAttribute = programAttributes[ name ];
	
				if ( programAttribute >= 0 ) {
	
					var geometryAttribute = geometryAttributes[ name ];
	
					if ( geometryAttribute !== undefined ) {
	
						var normalized = geometryAttribute.normalized;
						var size = geometryAttribute.itemSize;
	
						var attribute = attributes.get( geometryAttribute );
	
						// TODO Attribute may not be available on context restore
	
						if ( attribute === undefined ) continue;
	
						var buffer = attribute.buffer;
						var type = attribute.type;
						var bytesPerElement = attribute.bytesPerElement;
	
						if ( geometryAttribute.isInterleavedBufferAttribute ) {
	
							var data = geometryAttribute.data;
							var stride = data.stride;
							var offset = geometryAttribute.offset;
	
							if ( data && data.isInstancedInterleavedBuffer ) {
	
								state.enableAttributeAndDivisor( programAttribute, data.meshPerAttribute );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = data.meshPerAttribute * data.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, stride * bytesPerElement, offset * bytesPerElement );
	
						} else {
	
							if ( geometryAttribute.isInstancedBufferAttribute ) {
	
								state.enableAttributeAndDivisor( programAttribute, geometryAttribute.meshPerAttribute );
	
								if ( geometry.maxInstancedCount === undefined ) {
	
									geometry.maxInstancedCount = geometryAttribute.meshPerAttribute * geometryAttribute.count;
	
								}
	
							} else {
	
								state.enableAttribute( programAttribute );
	
							}
	
							_gl.bindBuffer( 34962, buffer );
							_gl.vertexAttribPointer( programAttribute, size, type, normalized, 0, 0 );
	
						}
	
					} else if ( materialDefaultAttributeValues !== undefined ) {
	
						var value = materialDefaultAttributeValues[ name ];
	
						if ( value !== undefined ) {
	
							switch ( value.length ) {
	
								case 2:
									_gl.vertexAttrib2fv( programAttribute, value );
									break;
	
								case 3:
									_gl.vertexAttrib3fv( programAttribute, value );
									break;
	
								case 4:
									_gl.vertexAttrib4fv( programAttribute, value );
									break;
	
								default:
									_gl.vertexAttrib1fv( programAttribute, value );
	
							}
	
						}
	
					}
	
				}
	
			}
	
			state.disableUnusedAttributes();
	
		}
	
		// Compile
	
		this.compile = function ( scene, camera ) {
	
			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();
	
			scene.traverse( function ( object ) {
	
				if ( object.isLight ) {
	
					currentRenderState.pushLight( object );
	
					if ( object.castShadow ) {
	
						currentRenderState.pushShadow( object );
	
					}
	
				}
	
			} );
	
			currentRenderState.setupLights( camera );
	
			scene.traverse( function ( object ) {
	
				if ( object.material ) {
	
					if ( Array.isArray( object.material ) ) {
	
						for ( var i = 0; i < object.material.length; i ++ ) {
	
							initMaterial( object.material[ i ], scene.fog, object );
	
						}
	
					} else {
	
						initMaterial( object.material, scene.fog, object );
	
					}
	
				}
	
			} );
	
		};
	
		// Animation Loop
	
		var onAnimationFrameCallback = null;
	
		function onAnimationFrame( time ) {
	
			if ( vr.isPresenting() ) return;
			if ( onAnimationFrameCallback ) onAnimationFrameCallback( time );
	
		}
	
		var animation = new WebGLAnimation();
		animation.setAnimationLoop( onAnimationFrame );
	
		if ( typeof window !== 'undefined' ) animation.setContext( window );
	
		this.setAnimationLoop = function ( callback ) {
	
			onAnimationFrameCallback = callback;
			vr.setAnimationLoop( callback );
	
			animation.start();
	
		};
	
		// Rendering
	
		this.render = function ( scene, camera, renderTarget, forceClear ) {
	
			if ( ! ( camera && camera.isCamera ) ) {
	
				console.error( 'THREE.WebGLRenderer.render: camera is not an instance of THREE.Camera.' );
				return;
	
			}
	
			if ( _isContextLost ) return;
	
			// reset caching for this frame
	
			_currentGeometryProgram.geometry = null;
			_currentGeometryProgram.program = null;
			_currentGeometryProgram.wireframe = false;
			_currentMaterialId = - 1;
			_currentCamera = null;
	
			// update scene graph
	
			if ( scene.autoUpdate === true ) scene.updateMatrixWorld();
	
			// update camera matrices and frustum
	
			if ( camera.parent === null ) camera.updateMatrixWorld();
	
			if ( vr.enabled ) {
	
				camera = vr.getCamera( camera );
	
			}
	
			//
	
			currentRenderState = renderStates.get( scene, camera );
			currentRenderState.init();
	
			scene.onBeforeRender( _this, scene, camera, renderTarget );
	
			_projScreenMatrix.multiplyMatrices( camera.projectionMatrix, camera.matrixWorldInverse );
			_frustum.setFromMatrix( _projScreenMatrix );
	
			_localClippingEnabled = this.localClippingEnabled;
			_clippingEnabled = _clipping.init( this.clippingPlanes, _localClippingEnabled, camera );
	
			currentRenderList = renderLists.get( scene, camera );
			currentRenderList.init();
	
			projectObject( scene, camera, 0, _this.sortObjects );
	
			if ( _this.sortObjects === true ) {
	
				currentRenderList.sort();
	
			}
	
			//
	
			if ( _clippingEnabled ) _clipping.beginShadows();
	
			var shadowsArray = currentRenderState.state.shadowsArray;
	
			shadowMap.render( shadowsArray, scene, camera );
	
			currentRenderState.setupLights( camera );
	
			if ( _clippingEnabled ) _clipping.endShadows();
	
			//
	
			if ( this.info.autoReset ) this.info.reset();
	
			if ( renderTarget === undefined ) {
	
				renderTarget = null;
	
			}
	
			this.setRenderTarget( renderTarget );
	
			//
	
			background.render( currentRenderList, scene, camera, forceClear );
	
			// render scene
	
			var opaqueObjects = currentRenderList.opaque;
			var transparentObjects = currentRenderList.transparent;
	
			if ( scene.overrideMaterial ) {
	
				var overrideMaterial = scene.overrideMaterial;
	
				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera, overrideMaterial );
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera, overrideMaterial );
	
			} else {
	
				// opaque pass (front-to-back order)
	
				if ( opaqueObjects.length ) renderObjects( opaqueObjects, scene, camera );
	
				// transparent pass (back-to-front order)
	
				if ( transparentObjects.length ) renderObjects( transparentObjects, scene, camera );
	
			}
	
			//
	
			if ( renderTarget ) {
	
				// Generate mipmap if we're using any kind of mipmap filtering
	
				textures.updateRenderTargetMipmap( renderTarget );
	
				// resolve multisample renderbuffers to a single-sample texture if necessary
	
				textures.updateMultisampleRenderTarget( renderTarget );
	
			}
	
			// Ensure depth buffer writing is enabled so it can be cleared on next render
	
			state.buffers.depth.setTest( true );
			state.buffers.depth.setMask( true );
			state.buffers.color.setMask( true );
	
			state.setPolygonOffset( false );
	
			scene.onAfterRender( _this, scene, camera );
	
			if ( vr.enabled ) {
	
				vr.submitFrame();
	
			}
	
			// _gl.finish();
	
			currentRenderList = null;
			currentRenderState = null;
	
		};
	
		function projectObject( object, camera, groupOrder, sortObjects ) {
	
			if ( object.visible === false ) return;
	
			var visible = object.layers.test( camera.layers );
	
			if ( visible ) {
	
				if ( object.isGroup ) {
	
					groupOrder = object.renderOrder;
	
				} else if ( object.isLight ) {
	
					currentRenderState.pushLight( object );
	
					if ( object.castShadow ) {
	
						currentRenderState.pushShadow( object );
	
					}
	
				} else if ( object.isSprite ) {
	
					if ( ! object.frustumCulled || _frustum.intersectsSprite( object ) ) {
	
						if ( sortObjects ) {
	
							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );
	
						}
	
						var geometry = objects.update( object );
						var material = object.material;
	
						currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );
	
					}
	
				} else if ( object.isImmediateRenderObject ) {
	
					if ( sortObjects ) {
	
						_vector3.setFromMatrixPosition( object.matrixWorld )
							.applyMatrix4( _projScreenMatrix );
	
					}
	
					currentRenderList.push( object, null, object.material, groupOrder, _vector3.z, null );
	
				} else if ( object.isMesh || object.isLine || object.isPoints ) {
	
					if ( object.isSkinnedMesh ) {
	
						object.skeleton.update();
	
					}
	
					if ( ! object.frustumCulled || _frustum.intersectsObject( object ) ) {
	
						if ( sortObjects ) {
	
							_vector3.setFromMatrixPosition( object.matrixWorld )
								.applyMatrix4( _projScreenMatrix );
	
						}
	
						var geometry = objects.update( object );
						var material = object.material;
	
						if ( Array.isArray( material ) ) {
	
							var groups = geometry.groups;
	
							for ( var i = 0, l = groups.length; i < l; i ++ ) {
	
								var group = groups[ i ];
								var groupMaterial = material[ group.materialIndex ];
	
								if ( groupMaterial && groupMaterial.visible ) {
	
									currentRenderList.push( object, geometry, groupMaterial, groupOrder, _vector3.z, group );
	
								}
	
							}
	
						} else if ( material.visible ) {
	
							currentRenderList.push( object, geometry, material, groupOrder, _vector3.z, null );
	
						}
	
					}
	
				}
	
			}
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				projectObject( children[ i ], camera, groupOrder, sortObjects );
	
			}
	
		}
	
		function renderObjects( renderList, scene, camera, overrideMaterial ) {
	
			for ( var i = 0, l = renderList.length; i < l; i ++ ) {
	
				var renderItem = renderList[ i ];
	
				var object = renderItem.object;
				var geometry = renderItem.geometry;
				var material = overrideMaterial === undefined ? renderItem.material : overrideMaterial;
				var group = renderItem.group;
	
				if ( camera.isArrayCamera ) {
	
					_currentArrayCamera = camera;
	
					var cameras = camera.cameras;
	
					for ( var j = 0, jl = cameras.length; j < jl; j ++ ) {
	
						var camera2 = cameras[ j ];
	
						if ( object.layers.test( camera2.layers ) ) {
	
							if ( 'viewport' in camera2 ) { // XR
	
								state.viewport( _currentViewport.copy( camera2.viewport ) );
	
							} else {
	
								var bounds = camera2.bounds;
	
								var x = bounds.x * _width;
								var y = bounds.y * _height;
								var width = bounds.z * _width;
								var height = bounds.w * _height;
	
								state.viewport( _currentViewport.set( x, y, width, height ).multiplyScalar( _pixelRatio ) );
	
							}
	
							currentRenderState.setupLights( camera2 );
	
							renderObject( object, scene, camera2, geometry, material, group );
	
						}
	
					}
	
				} else {
	
					_currentArrayCamera = null;
	
					renderObject( object, scene, camera, geometry, material, group );
	
				}
	
			}
	
		}
	
		function renderObject( object, scene, camera, geometry, material, group ) {
	
			object.onBeforeRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );
	
			object.modelViewMatrix.multiplyMatrices( camera.matrixWorldInverse, object.matrixWorld );
			object.normalMatrix.getNormalMatrix( object.modelViewMatrix );
	
			if ( object.isImmediateRenderObject ) {
	
				state.setMaterial( material );
	
				var program = setProgram( camera, scene.fog, material, object );
	
				_currentGeometryProgram.geometry = null;
				_currentGeometryProgram.program = null;
				_currentGeometryProgram.wireframe = false;
	
				renderObjectImmediate( object, program );
	
			} else {
	
				_this.renderBufferDirect( camera, scene.fog, geometry, material, object, group );
	
			}
	
			object.onAfterRender( _this, scene, camera, geometry, material, group );
			currentRenderState = renderStates.get( scene, _currentArrayCamera || camera );
	
		}
	
		function initMaterial( material, fog, object ) {
	
			var materialProperties = properties.get( material );
	
			var lights = currentRenderState.state.lights;
			var shadowsArray = currentRenderState.state.shadowsArray;
	
			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;
	
			var parameters = programCache.getParameters(
				material, lights.state, shadowsArray, fog, _clipping.numPlanes, _clipping.numIntersection, object );
	
			var code = programCache.getProgramCode( material, parameters );
	
			var program = materialProperties.program;
			var programChange = true;
	
			if ( program === undefined ) {
	
				// new material
				material.addEventListener( 'dispose', onMaterialDispose );
	
			} else if ( program.code !== code ) {
	
				// changed glsl or parameters
				releaseMaterialProgramReference( material );
	
			} else if ( lightsHash.stateID !== lightsStateHash.stateID ||
				lightsHash.directionalLength !== lightsStateHash.directionalLength ||
				lightsHash.pointLength !== lightsStateHash.pointLength ||
				lightsHash.spotLength !== lightsStateHash.spotLength ||
				lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
				lightsHash.hemiLength !== lightsStateHash.hemiLength ||
				lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) {
	
				lightsHash.stateID = lightsStateHash.stateID;
				lightsHash.directionalLength = lightsStateHash.directionalLength;
				lightsHash.pointLength = lightsStateHash.pointLength;
				lightsHash.spotLength = lightsStateHash.spotLength;
				lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
				lightsHash.hemiLength = lightsStateHash.hemiLength;
				lightsHash.shadowsLength = lightsStateHash.shadowsLength;
	
				programChange = false;
	
			} else if ( parameters.shaderID !== undefined ) {
	
				// same glsl and uniform list
				return;
	
			} else {
	
				// only rebuild uniform list
				programChange = false;
	
			}
	
			if ( programChange ) {
	
				if ( parameters.shaderID ) {
	
					var shader = ShaderLib[ parameters.shaderID ];
	
					materialProperties.shader = {
						name: material.type,
						uniforms: cloneUniforms( shader.uniforms ),
						vertexShader: shader.vertexShader,
						fragmentShader: shader.fragmentShader
					};
	
				} else {
	
					materialProperties.shader = {
						name: material.type,
						uniforms: material.uniforms,
						vertexShader: material.vertexShader,
						fragmentShader: material.fragmentShader
					};
	
				}
	
				material.onBeforeCompile( materialProperties.shader, _this );
	
				// Computing code again as onBeforeCompile may have changed the shaders
				code = programCache.getProgramCode( material, parameters );
	
				program = programCache.acquireProgram( material, materialProperties.shader, parameters, code );
	
				materialProperties.program = program;
				material.program = program;
	
			}
	
			var programAttributes = program.getAttributes();
	
			if ( material.morphTargets ) {
	
				material.numSupportedMorphTargets = 0;
	
				for ( var i = 0; i < _this.maxMorphTargets; i ++ ) {
	
					if ( programAttributes[ 'morphTarget' + i ] >= 0 ) {
	
						material.numSupportedMorphTargets ++;
	
					}
	
				}
	
			}
	
			if ( material.morphNormals ) {
	
				material.numSupportedMorphNormals = 0;
	
				for ( var i = 0; i < _this.maxMorphNormals; i ++ ) {
	
					if ( programAttributes[ 'morphNormal' + i ] >= 0 ) {
	
						material.numSupportedMorphNormals ++;
	
					}
	
				}
	
			}
	
			var uniforms = materialProperties.shader.uniforms;
	
			if ( ! material.isShaderMaterial &&
				! material.isRawShaderMaterial ||
				material.clipping === true ) {
	
				materialProperties.numClippingPlanes = _clipping.numPlanes;
				materialProperties.numIntersection = _clipping.numIntersection;
				uniforms.clippingPlanes = _clipping.uniform;
	
			}
	
			materialProperties.fog = fog;
	
			// store the light setup it was created for
			if ( lightsHash === undefined ) {
	
				materialProperties.lightsHash = lightsHash = {};
	
			}
	
			lightsHash.stateID = lightsStateHash.stateID;
			lightsHash.directionalLength = lightsStateHash.directionalLength;
			lightsHash.pointLength = lightsStateHash.pointLength;
			lightsHash.spotLength = lightsStateHash.spotLength;
			lightsHash.rectAreaLength = lightsStateHash.rectAreaLength;
			lightsHash.hemiLength = lightsStateHash.hemiLength;
			lightsHash.shadowsLength = lightsStateHash.shadowsLength;
	
			if ( material.lights ) {
	
				// wire up the material to this renderer's lighting state
	
				uniforms.ambientLightColor.value = lights.state.ambient;
				uniforms.directionalLights.value = lights.state.directional;
				uniforms.spotLights.value = lights.state.spot;
				uniforms.rectAreaLights.value = lights.state.rectArea;
				uniforms.pointLights.value = lights.state.point;
				uniforms.hemisphereLights.value = lights.state.hemi;
	
				uniforms.directionalShadowMap.value = lights.state.directionalShadowMap;
				uniforms.directionalShadowMatrix.value = lights.state.directionalShadowMatrix;
				uniforms.spotShadowMap.value = lights.state.spotShadowMap;
				uniforms.spotShadowMatrix.value = lights.state.spotShadowMatrix;
				uniforms.pointShadowMap.value = lights.state.pointShadowMap;
				uniforms.pointShadowMatrix.value = lights.state.pointShadowMatrix;
				// TODO (abelnation): add area lights shadow info to uniforms
	
			}
	
			var progUniforms = materialProperties.program.getUniforms(),
				uniformsList =
					WebGLUniforms.seqWithValue( progUniforms.seq, uniforms );
	
			materialProperties.uniformsList = uniformsList;
	
		}
	
		function setProgram( camera, fog, material, object ) {
	
			_usedTextureUnits = 0;
	
			var materialProperties = properties.get( material );
			var lights = currentRenderState.state.lights;
	
			var lightsHash = materialProperties.lightsHash;
			var lightsStateHash = lights.state.hash;
	
			if ( _clippingEnabled ) {
	
				if ( _localClippingEnabled || camera !== _currentCamera ) {
	
					var useCache =
						camera === _currentCamera &&
						material.id === _currentMaterialId;
	
					// we might want to call this function with some ClippingGroup
					// object instead of the material, once it becomes feasible
					// (#8465, #8379)
					_clipping.setState(
						material.clippingPlanes, material.clipIntersection, material.clipShadows,
						camera, materialProperties, useCache );
	
				}
	
			}
	
			if ( material.needsUpdate === false ) {
	
				if ( materialProperties.program === undefined ) {
	
					material.needsUpdate = true;
	
				} else if ( material.fog && materialProperties.fog !== fog ) {
	
					material.needsUpdate = true;
	
				} else if ( material.lights && ( lightsHash.stateID !== lightsStateHash.stateID ||
					lightsHash.directionalLength !== lightsStateHash.directionalLength ||
					lightsHash.pointLength !== lightsStateHash.pointLength ||
					lightsHash.spotLength !== lightsStateHash.spotLength ||
					lightsHash.rectAreaLength !== lightsStateHash.rectAreaLength ||
					lightsHash.hemiLength !== lightsStateHash.hemiLength ||
					lightsHash.shadowsLength !== lightsStateHash.shadowsLength ) ) {
	
					material.needsUpdate = true;
	
				} else if ( materialProperties.numClippingPlanes !== undefined &&
					( materialProperties.numClippingPlanes !== _clipping.numPlanes ||
					materialProperties.numIntersection !== _clipping.numIntersection ) ) {
	
					material.needsUpdate = true;
	
				}
	
			}
	
			if ( material.needsUpdate ) {
	
				initMaterial( material, fog, object );
				material.needsUpdate = false;
	
			}
	
			var refreshProgram = false;
			var refreshMaterial = false;
			var refreshLights = false;
	
			var program = materialProperties.program,
				p_uniforms = program.getUniforms(),
				m_uniforms = materialProperties.shader.uniforms;
	
			if ( state.useProgram( program.program ) ) {
	
				refreshProgram = true;
				refreshMaterial = true;
				refreshLights = true;
	
			}
	
			if ( material.id !== _currentMaterialId ) {
	
				_currentMaterialId = material.id;
	
				refreshMaterial = true;
	
			}
	
			if ( refreshProgram || _currentCamera !== camera ) {
	
				p_uniforms.setValue( _gl, 'projectionMatrix', camera.projectionMatrix );
	
				if ( capabilities.logarithmicDepthBuffer ) {
	
					p_uniforms.setValue( _gl, 'logDepthBufFC',
						2.0 / ( Math.log( camera.far + 1.0 ) / Math.LN2 ) );
	
				}
	
				if ( _currentCamera !== camera ) {
	
					_currentCamera = camera;
	
					// lighting uniforms depend on the camera so enforce an update
					// now, in case this material supports lights - or later, when
					// the next material that does gets activated:
	
					refreshMaterial = true;		// set to true on material change
					refreshLights = true;		// remains set until update done
	
				}
	
				// load material specific uniforms
				// (shader material also gets them for the sake of genericity)
	
				if ( material.isShaderMaterial ||
					material.isMeshPhongMaterial ||
					material.isMeshStandardMaterial ||
					material.envMap ) {
	
					var uCamPos = p_uniforms.map.cameraPosition;
	
					if ( uCamPos !== undefined ) {
	
						uCamPos.setValue( _gl,
							_vector3.setFromMatrixPosition( camera.matrixWorld ) );
	
					}
	
				}
	
				if ( material.isMeshPhongMaterial ||
					material.isMeshLambertMaterial ||
					material.isMeshBasicMaterial ||
					material.isMeshStandardMaterial ||
					material.isShaderMaterial ||
					material.skinning ) {
	
					p_uniforms.setValue( _gl, 'viewMatrix', camera.matrixWorldInverse );
	
				}
	
			}
	
			// skinning uniforms must be set even if material didn't change
			// auto-setting of texture unit for bone texture must go before other textures
			// not sure why, but otherwise weird things happen
	
			if ( material.skinning ) {
	
				p_uniforms.setOptional( _gl, object, 'bindMatrix' );
				p_uniforms.setOptional( _gl, object, 'bindMatrixInverse' );
	
				var skeleton = object.skeleton;
	
				if ( skeleton ) {
	
					var bones = skeleton.bones;
	
					if ( capabilities.floatVertexTextures ) {
	
						if ( skeleton.boneTexture === undefined ) {
	
							// layout (1 matrix = 4 pixels)
							//      RGBA RGBA RGBA RGBA (=> column1, column2, column3, column4)
							//  with  8x8  pixel texture max   16 bones * 4 pixels =  (8 * 8)
							//       16x16 pixel texture max   64 bones * 4 pixels = (16 * 16)
							//       32x32 pixel texture max  256 bones * 4 pixels = (32 * 32)
							//       64x64 pixel texture max 1024 bones * 4 pixels = (64 * 64)
	
	
							var size = Math.sqrt( bones.length * 4 ); // 4 pixels needed for 1 matrix
							size = _Math.ceilPowerOfTwo( size );
							size = Math.max( size, 4 );
	
							var boneMatrices = new Float32Array( size * size * 4 ); // 4 floats per RGBA pixel
							boneMatrices.set( skeleton.boneMatrices ); // copy current values
	
							var boneTexture = new DataTexture( boneMatrices, size, size, RGBAFormat, FloatType );
							boneTexture.needsUpdate = true;
	
							skeleton.boneMatrices = boneMatrices;
							skeleton.boneTexture = boneTexture;
							skeleton.boneTextureSize = size;
	
						}
	
						p_uniforms.setValue( _gl, 'boneTexture', skeleton.boneTexture );
						p_uniforms.setValue( _gl, 'boneTextureSize', skeleton.boneTextureSize );
	
					} else {
	
						p_uniforms.setOptional( _gl, skeleton, 'boneMatrices' );
	
					}
	
				}
	
			}
	
			if ( refreshMaterial ) {
	
				p_uniforms.setValue( _gl, 'toneMappingExposure', _this.toneMappingExposure );
				p_uniforms.setValue( _gl, 'toneMappingWhitePoint', _this.toneMappingWhitePoint );
	
				if ( material.lights ) {
	
					// the current material requires lighting info
	
					// note: all lighting uniforms are always set correctly
					// they simply reference the renderer's state for their
					// values
					//
					// use the current material's .needsUpdate flags to set
					// the GL state when required
	
					markUniformsLightsNeedsUpdate( m_uniforms, refreshLights );
	
				}
	
				// refresh uniforms common to several materials
	
				if ( fog && material.fog ) {
	
					refreshUniformsFog( m_uniforms, fog );
	
				}
	
				if ( material.isMeshBasicMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
				} else if ( material.isMeshLambertMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsLambert( m_uniforms, material );
	
				} else if ( material.isMeshPhongMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
					if ( material.isMeshToonMaterial ) {
	
						refreshUniformsToon( m_uniforms, material );
	
					} else {
	
						refreshUniformsPhong( m_uniforms, material );
	
					}
	
				} else if ( material.isMeshStandardMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
					if ( material.isMeshPhysicalMaterial ) {
	
						refreshUniformsPhysical( m_uniforms, material );
	
					} else {
	
						refreshUniformsStandard( m_uniforms, material );
	
					}
	
				} else if ( material.isMeshMatcapMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
	
					refreshUniformsMatcap( m_uniforms, material );
	
				} else if ( material.isMeshDepthMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDepth( m_uniforms, material );
	
				} else if ( material.isMeshDistanceMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsDistance( m_uniforms, material );
	
				} else if ( material.isMeshNormalMaterial ) {
	
					refreshUniformsCommon( m_uniforms, material );
					refreshUniformsNormal( m_uniforms, material );
	
				} else if ( material.isLineBasicMaterial ) {
	
					refreshUniformsLine( m_uniforms, material );
	
					if ( material.isLineDashedMaterial ) {
	
						refreshUniformsDash( m_uniforms, material );
	
					}
	
				} else if ( material.isPointsMaterial ) {
	
					refreshUniformsPoints( m_uniforms, material );
	
				} else if ( material.isSpriteMaterial ) {
	
					refreshUniformsSprites( m_uniforms, material );
	
				} else if ( material.isShadowMaterial ) {
	
					m_uniforms.color.value = material.color;
					m_uniforms.opacity.value = material.opacity;
	
				}
	
				// RectAreaLight Texture
				// TODO (mrdoob): Find a nicer implementation
	
				if ( m_uniforms.ltc_1 !== undefined ) m_uniforms.ltc_1.value = UniformsLib.LTC_1;
				if ( m_uniforms.ltc_2 !== undefined ) m_uniforms.ltc_2.value = UniformsLib.LTC_2;
	
				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
	
			}
	
			if ( material.isShaderMaterial && material.uniformsNeedUpdate === true ) {
	
				WebGLUniforms.upload( _gl, materialProperties.uniformsList, m_uniforms, _this );
				material.uniformsNeedUpdate = false;
	
			}
	
			if ( material.isSpriteMaterial ) {
	
				p_uniforms.setValue( _gl, 'center', object.center );
	
			}
	
			// common matrices
	
			p_uniforms.setValue( _gl, 'modelViewMatrix', object.modelViewMatrix );
			p_uniforms.setValue( _gl, 'normalMatrix', object.normalMatrix );
			p_uniforms.setValue( _gl, 'modelMatrix', object.matrixWorld );
	
			return program;
	
		}
	
		// Uniforms (refresh uniforms objects)
	
		function refreshUniformsCommon( uniforms, material ) {
	
			uniforms.opacity.value = material.opacity;
	
			if ( material.color ) {
	
				uniforms.diffuse.value = material.color;
	
			}
	
			if ( material.emissive ) {
	
				uniforms.emissive.value.copy( material.emissive ).multiplyScalar( material.emissiveIntensity );
	
			}
	
			if ( material.map ) {
	
				uniforms.map.value = material.map;
	
			}
	
			if ( material.alphaMap ) {
	
				uniforms.alphaMap.value = material.alphaMap;
	
			}
	
			if ( material.specularMap ) {
	
				uniforms.specularMap.value = material.specularMap;
	
			}
	
			if ( material.envMap ) {
	
				uniforms.envMap.value = material.envMap;
	
				// don't flip CubeTexture envMaps, flip everything else:
				//  WebGLRenderTargetCube will be flipped for backwards compatibility
				//  WebGLRenderTargetCube.texture will be flipped because it's a Texture and NOT a CubeTexture
				// this check must be handled differently, or removed entirely, if WebGLRenderTargetCube uses a CubeTexture in the future
				uniforms.flipEnvMap.value = material.envMap.isCubeTexture ? - 1 : 1;
	
				uniforms.reflectivity.value = material.reflectivity;
				uniforms.refractionRatio.value = material.refractionRatio;
	
				uniforms.maxMipLevel.value = properties.get( material.envMap ).__maxMipLevel;
	
			}
	
			if ( material.lightMap ) {
	
				uniforms.lightMap.value = material.lightMap;
				uniforms.lightMapIntensity.value = material.lightMapIntensity;
	
			}
	
			if ( material.aoMap ) {
	
				uniforms.aoMap.value = material.aoMap;
				uniforms.aoMapIntensity.value = material.aoMapIntensity;
	
			}
	
			// uv repeat and offset setting priorities
			// 1. color map
			// 2. specular map
			// 3. normal map
			// 4. bump map
			// 5. alpha map
			// 6. emissive map
	
			var uvScaleMap;
	
			if ( material.map ) {
	
				uvScaleMap = material.map;
	
			} else if ( material.specularMap ) {
	
				uvScaleMap = material.specularMap;
	
			} else if ( material.displacementMap ) {
	
				uvScaleMap = material.displacementMap;
	
			} else if ( material.normalMap ) {
	
				uvScaleMap = material.normalMap;
	
			} else if ( material.bumpMap ) {
	
				uvScaleMap = material.bumpMap;
	
			} else if ( material.roughnessMap ) {
	
				uvScaleMap = material.roughnessMap;
	
			} else if ( material.metalnessMap ) {
	
				uvScaleMap = material.metalnessMap;
	
			} else if ( material.alphaMap ) {
	
				uvScaleMap = material.alphaMap;
	
			} else if ( material.emissiveMap ) {
	
				uvScaleMap = material.emissiveMap;
	
			}
	
			if ( uvScaleMap !== undefined ) {
	
				// backwards compatibility
				if ( uvScaleMap.isWebGLRenderTarget ) {
	
					uvScaleMap = uvScaleMap.texture;
	
				}
	
				if ( uvScaleMap.matrixAutoUpdate === true ) {
	
					uvScaleMap.updateMatrix();
	
				}
	
				uniforms.uvTransform.value.copy( uvScaleMap.matrix );
	
			}
	
		}
	
		function refreshUniformsLine( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
	
		}
	
		function refreshUniformsDash( uniforms, material ) {
	
			uniforms.dashSize.value = material.dashSize;
			uniforms.totalSize.value = material.dashSize + material.gapSize;
			uniforms.scale.value = material.scale;
	
		}
	
		function refreshUniformsPoints( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.size.value = material.size * _pixelRatio;
			uniforms.scale.value = _height * 0.5;
	
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				if ( material.map.matrixAutoUpdate === true ) {
	
					material.map.updateMatrix();
	
				}
	
				uniforms.uvTransform.value.copy( material.map.matrix );
	
			}
	
		}
	
		function refreshUniformsSprites( uniforms, material ) {
	
			uniforms.diffuse.value = material.color;
			uniforms.opacity.value = material.opacity;
			uniforms.rotation.value = material.rotation;
			uniforms.map.value = material.map;
	
			if ( material.map !== null ) {
	
				if ( material.map.matrixAutoUpdate === true ) {
	
					material.map.updateMatrix();
	
				}
	
				uniforms.uvTransform.value.copy( material.map.matrix );
	
			}
	
		}
	
		function refreshUniformsFog( uniforms, fog ) {
	
			uniforms.fogColor.value = fog.color;
	
			if ( fog.isFog ) {
	
				uniforms.fogNear.value = fog.near;
				uniforms.fogFar.value = fog.far;
	
			} else if ( fog.isFogExp2 ) {
	
				uniforms.fogDensity.value = fog.density;
	
			}
	
		}
	
		function refreshUniformsLambert( uniforms, material ) {
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
		}
	
		function refreshUniformsPhong( uniforms, material ) {
	
			uniforms.specular.value = material.specular;
			uniforms.shininess.value = Math.max( material.shininess, 1e-4 ); // to prevent pow( 0.0, 0.0 )
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsToon( uniforms, material ) {
	
			refreshUniformsPhong( uniforms, material );
	
			if ( material.gradientMap ) {
	
				uniforms.gradientMap.value = material.gradientMap;
	
			}
	
		}
	
		function refreshUniformsStandard( uniforms, material ) {
	
			uniforms.roughness.value = material.roughness;
			uniforms.metalness.value = material.metalness;
	
			if ( material.roughnessMap ) {
	
				uniforms.roughnessMap.value = material.roughnessMap;
	
			}
	
			if ( material.metalnessMap ) {
	
				uniforms.metalnessMap.value = material.metalnessMap;
	
			}
	
			if ( material.emissiveMap ) {
	
				uniforms.emissiveMap.value = material.emissiveMap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
			if ( material.envMap ) {
	
				//uniforms.envMap.value = material.envMap; // part of uniforms common
				uniforms.envMapIntensity.value = material.envMapIntensity;
	
			}
	
		}
	
		function refreshUniformsPhysical( uniforms, material ) {
	
			refreshUniformsStandard( uniforms, material );
	
			uniforms.reflectivity.value = material.reflectivity; // also part of uniforms common
	
			uniforms.clearCoat.value = material.clearCoat;
			uniforms.clearCoatRoughness.value = material.clearCoatRoughness;
	
		}
	
		function refreshUniformsMatcap( uniforms, material ) {
	
			if ( material.matcap ) {
	
				uniforms.matcap.value = material.matcap;
	
			}
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsDepth( uniforms, material ) {
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		function refreshUniformsDistance( uniforms, material ) {
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
			uniforms.referencePosition.value.copy( material.referencePosition );
			uniforms.nearDistance.value = material.nearDistance;
			uniforms.farDistance.value = material.farDistance;
	
		}
	
		function refreshUniformsNormal( uniforms, material ) {
	
			if ( material.bumpMap ) {
	
				uniforms.bumpMap.value = material.bumpMap;
				uniforms.bumpScale.value = material.bumpScale;
				if ( material.side === BackSide ) uniforms.bumpScale.value *= - 1;
	
			}
	
			if ( material.normalMap ) {
	
				uniforms.normalMap.value = material.normalMap;
				uniforms.normalScale.value.copy( material.normalScale );
				if ( material.side === BackSide ) uniforms.normalScale.value.negate();
	
			}
	
			if ( material.displacementMap ) {
	
				uniforms.displacementMap.value = material.displacementMap;
				uniforms.displacementScale.value = material.displacementScale;
				uniforms.displacementBias.value = material.displacementBias;
	
			}
	
		}
	
		// If uniforms are marked as clean, they don't need to be loaded to the GPU.
	
		function markUniformsLightsNeedsUpdate( uniforms, value ) {
	
			uniforms.ambientLightColor.needsUpdate = value;
	
			uniforms.directionalLights.needsUpdate = value;
			uniforms.pointLights.needsUpdate = value;
			uniforms.spotLights.needsUpdate = value;
			uniforms.rectAreaLights.needsUpdate = value;
			uniforms.hemisphereLights.needsUpdate = value;
	
		}
	
		// Textures
	
		function allocTextureUnit() {
	
			var textureUnit = _usedTextureUnits;
	
			if ( textureUnit >= capabilities.maxTextures ) {
	
				console.warn( 'THREE.WebGLRenderer: Trying to use ' + textureUnit + ' texture units while this GPU supports only ' + capabilities.maxTextures );
	
			}
	
			_usedTextureUnits += 1;
	
			return textureUnit;
	
		}
	
		this.allocTextureUnit = allocTextureUnit;
	
		// this.setTexture2D = setTexture2D;
		this.setTexture2D = ( function () {
	
			var warned = false;
	
			// backwards compatibility: peel texture.texture
			return function setTexture2D( texture, slot ) {
	
				if ( texture && texture.isWebGLRenderTarget ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer.setTexture2D: don't use render targets as textures. Use their .texture property instead." );
						warned = true;
	
					}
	
					texture = texture.texture;
	
				}
	
				textures.setTexture2D( texture, slot );
	
			};
	
		}() );
	
		this.setTexture3D = ( function () {
	
			// backwards compatibility: peel texture.texture
			return function setTexture3D( texture, slot ) {
	
				textures.setTexture3D( texture, slot );
	
			};
	
		}() );
	
		this.setTexture = ( function () {
	
			var warned = false;
	
			return function setTexture( texture, slot ) {
	
				if ( ! warned ) {
	
					console.warn( "THREE.WebGLRenderer: .setTexture is deprecated, use setTexture2D instead." );
					warned = true;
	
				}
	
				textures.setTexture2D( texture, slot );
	
			};
	
		}() );
	
		this.setTextureCube = ( function () {
	
			var warned = false;
	
			return function setTextureCube( texture, slot ) {
	
				// backwards compatibility: peel texture.texture
				if ( texture && texture.isWebGLRenderTargetCube ) {
	
					if ( ! warned ) {
	
						console.warn( "THREE.WebGLRenderer.setTextureCube: don't use cube render targets as textures. Use their .texture property instead." );
						warned = true;
	
					}
	
					texture = texture.texture;
	
				}
	
				// currently relying on the fact that WebGLRenderTargetCube.texture is a Texture and NOT a CubeTexture
				// TODO: unify these code paths
				if ( ( texture && texture.isCubeTexture ) ||
					( Array.isArray( texture.image ) && texture.image.length === 6 ) ) {
	
					// CompressedTexture can have Array in image :/
	
					// this function alone should take care of cube textures
					textures.setTextureCube( texture, slot );
	
				} else {
	
					// assumed: texture property of THREE.WebGLRenderTargetCube
	
					textures.setTextureCubeDynamic( texture, slot );
	
				}
	
			};
	
		}() );
	
		//
	
		this.setFramebuffer = function ( value ) {
	
			_framebuffer = value;
	
		};
	
		this.getRenderTarget = function () {
	
			return _currentRenderTarget;
	
		};
	
		this.setRenderTarget = function ( renderTarget ) {
	
			_currentRenderTarget = renderTarget;
	
			if ( renderTarget && properties.get( renderTarget ).__webglFramebuffer === undefined ) {
	
				textures.setupRenderTarget( renderTarget );
	
			}
	
			var framebuffer = _framebuffer;
			var isCube = false;
	
			if ( renderTarget ) {
	
				var __webglFramebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
				if ( renderTarget.isWebGLRenderTargetCube ) {
	
					framebuffer = __webglFramebuffer[ renderTarget.activeCubeFace ];
					isCube = true;
	
				} else if ( renderTarget.isWebGLMultisampleRenderTarget ) {
	
					framebuffer = properties.get( renderTarget ).__webglMultisampledFramebuffer;
	
				} else {
	
					framebuffer = __webglFramebuffer;
	
				}
	
				_currentViewport.copy( renderTarget.viewport );
				_currentScissor.copy( renderTarget.scissor );
				_currentScissorTest = renderTarget.scissorTest;
	
			} else {
	
				_currentViewport.copy( _viewport ).multiplyScalar( _pixelRatio );
				_currentScissor.copy( _scissor ).multiplyScalar( _pixelRatio );
				_currentScissorTest = _scissorTest;
	
			}
	
			if ( _currentFramebuffer !== framebuffer ) {
	
				_gl.bindFramebuffer( 36160, framebuffer );
				_currentFramebuffer = framebuffer;
	
			}
	
			state.viewport( _currentViewport );
			state.scissor( _currentScissor );
			state.setScissorTest( _currentScissorTest );
	
			if ( isCube ) {
	
				var textureProperties = properties.get( renderTarget.texture );
				_gl.framebufferTexture2D( 36160, 36064, 34069 + renderTarget.activeCubeFace, textureProperties.__webglTexture, renderTarget.activeMipMapLevel );
	
			}
	
		};
	
		this.readRenderTargetPixels = function ( renderTarget, x, y, width, height, buffer ) {
	
			if ( ! ( renderTarget && renderTarget.isWebGLRenderTarget ) ) {
	
				console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not THREE.WebGLRenderTarget.' );
				return;
	
			}
	
			var framebuffer = properties.get( renderTarget ).__webglFramebuffer;
	
			if ( framebuffer ) {
	
				var restore = false;
	
				if ( framebuffer !== _currentFramebuffer ) {
	
					_gl.bindFramebuffer( 36160, framebuffer );
	
					restore = true;
	
				}
	
				try {
	
					var texture = renderTarget.texture;
					var textureFormat = texture.format;
					var textureType = texture.type;
	
					if ( textureFormat !== RGBAFormat && utils.convert( textureFormat ) !== _gl.getParameter( 35739 ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in RGBA or implementation defined format.' );
						return;
	
					}
	
					if ( textureType !== UnsignedByteType && utils.convert( textureType ) !== _gl.getParameter( 35738 ) && // IE11, Edge and Chrome Mac < 52 (#9513)
						! ( textureType === FloatType && ( capabilities.isWebGL2 || extensions.get( 'OES_texture_float' ) || extensions.get( 'WEBGL_color_buffer_float' ) ) ) && // Chrome Mac >= 52 and Firefox
						! ( textureType === HalfFloatType && ( capabilities.isWebGL2 ? extensions.get( 'EXT_color_buffer_float' ) : extensions.get( 'EXT_color_buffer_half_float' ) ) ) ) {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: renderTarget is not in UnsignedByteType or implementation defined type.' );
						return;
	
					}
	
					if ( _gl.checkFramebufferStatus( 36160 ) === 36053 ) {
	
						// the following if statement ensures valid read requests (no out-of-bounds pixels, see #8604)
	
						if ( ( x >= 0 && x <= ( renderTarget.width - width ) ) && ( y >= 0 && y <= ( renderTarget.height - height ) ) ) {
	
							_gl.readPixels( x, y, width, height, utils.convert( textureFormat ), utils.convert( textureType ), buffer );
	
						}
	
					} else {
	
						console.error( 'THREE.WebGLRenderer.readRenderTargetPixels: readPixels from renderTarget failed. Framebuffer not complete.' );
	
					}
	
				} finally {
	
					if ( restore ) {
	
						_gl.bindFramebuffer( 36160, _currentFramebuffer );
	
					}
	
				}
	
			}
	
		};
	
		this.copyFramebufferToTexture = function ( position, texture, level ) {
	
			var width = texture.image.width;
			var height = texture.image.height;
			var glFormat = utils.convert( texture.format );
	
			this.setTexture2D( texture, 0 );
	
			_gl.copyTexImage2D( 3553, level || 0, glFormat, position.x, position.y, width, height, 0 );
	
		};
	
		this.copyTextureToTexture = function ( position, srcTexture, dstTexture, level ) {
	
			var width = srcTexture.image.width;
			var height = srcTexture.image.height;
			var glFormat = utils.convert( dstTexture.format );
			var glType = utils.convert( dstTexture.type );
	
			this.setTexture2D( dstTexture, 0 );
	
			if ( srcTexture.isDataTexture ) {
	
				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, width, height, glFormat, glType, srcTexture.image.data );
	
			} else {
	
				_gl.texSubImage2D( 3553, level || 0, position.x, position.y, glFormat, glType, srcTexture.image );
	
			}
	
		};
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function FogExp2( color, density ) {
	
		this.name = '';
	
		this.color = new Color( color );
		this.density = ( density !== undefined ) ? density : 0.00025;
	
	}
	
	FogExp2.prototype.isFogExp2 = true;
	
	FogExp2.prototype.clone = function () {
	
		return new FogExp2( this.color, this.density );
	
	};
	
	FogExp2.prototype.toJSON = function ( /* meta */ ) {
	
		return {
			type: 'FogExp2',
			color: this.color.getHex(),
			density: this.density
		};
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function Fog( color, near, far ) {
	
		this.name = '';
	
		this.color = new Color( color );
	
		this.near = ( near !== undefined ) ? near : 1;
		this.far = ( far !== undefined ) ? far : 1000;
	
	}
	
	Fog.prototype.isFog = true;
	
	Fog.prototype.clone = function () {
	
		return new Fog( this.color, this.near, this.far );
	
	};
	
	Fog.prototype.toJSON = function ( /* meta */ ) {
	
		return {
			type: 'Fog',
			color: this.color.getHex(),
			near: this.near,
			far: this.far
		};
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Scene() {
	
		Object3D.call( this );
	
		this.type = 'Scene';
	
		this.background = null;
		this.fog = null;
		this.overrideMaterial = null;
	
		this.autoUpdate = true; // checked by the renderer
	
	}
	
	Scene.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Scene,
	
		isScene: true,
	
		copy: function ( source, recursive ) {
	
			Object3D.prototype.copy.call( this, source, recursive );
	
			if ( source.background !== null ) this.background = source.background.clone();
			if ( source.fog !== null ) this.fog = source.fog.clone();
			if ( source.overrideMaterial !== null ) this.overrideMaterial = source.overrideMaterial.clone();
	
			this.autoUpdate = source.autoUpdate;
			this.matrixAutoUpdate = source.matrixAutoUpdate;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			if ( this.background !== null ) data.object.background = this.background.toJSON( meta );
			if ( this.fog !== null ) data.object.fog = this.fog.toJSON();
	
			return data;
	
		},
	
		dispose: function () {
	
			this.dispatchEvent( { type: 'dispose' } );
	
		}
	
	} );
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	function InterleavedBuffer( array, stride ) {
	
		this.array = array;
		this.stride = stride;
		this.count = array !== undefined ? array.length / stride : 0;
	
		this.dynamic = false;
		this.updateRange = { offset: 0, count: - 1 };
	
		this.version = 0;
	
	}
	
	Object.defineProperty( InterleavedBuffer.prototype, 'needsUpdate', {
	
		set: function ( value ) {
	
			if ( value === true ) this.version ++;
	
		}
	
	} );
	
	Object.assign( InterleavedBuffer.prototype, {
	
		isInterleavedBuffer: true,
	
		onUploadCallback: function () {},
	
		setArray: function ( array ) {
	
			if ( Array.isArray( array ) ) {
	
				throw new TypeError( 'THREE.BufferAttribute: array should be a Typed Array.' );
	
			}
	
			this.count = array !== undefined ? array.length / this.stride : 0;
			this.array = array;
	
			return this;
	
		},
	
		setDynamic: function ( value ) {
	
			this.dynamic = value;
	
			return this;
	
		},
	
		copy: function ( source ) {
	
			this.array = new source.array.constructor( source.array );
			this.count = source.count;
			this.stride = source.stride;
			this.dynamic = source.dynamic;
	
			return this;
	
		},
	
		copyAt: function ( index1, attribute, index2 ) {
	
			index1 *= this.stride;
			index2 *= attribute.stride;
	
			for ( var i = 0, l = this.stride; i < l; i ++ ) {
	
				this.array[ index1 + i ] = attribute.array[ index2 + i ];
	
			}
	
			return this;
	
		},
	
		set: function ( value, offset ) {
	
			if ( offset === undefined ) offset = 0;
	
			this.array.set( value, offset );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		onUpload: function ( callback ) {
	
			this.onUploadCallback = callback;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	function InterleavedBufferAttribute( interleavedBuffer, itemSize, offset, normalized ) {
	
		this.data = interleavedBuffer;
		this.itemSize = itemSize;
		this.offset = offset;
	
		this.normalized = normalized === true;
	
	}
	
	Object.defineProperties( InterleavedBufferAttribute.prototype, {
	
		count: {
	
			get: function () {
	
				return this.data.count;
	
			}
	
		},
	
		array: {
	
			get: function () {
	
				return this.data.array;
	
			}
	
		}
	
	} );
	
	Object.assign( InterleavedBufferAttribute.prototype, {
	
		isInterleavedBufferAttribute: true,
	
		setX: function ( index, x ) {
	
			this.data.array[ index * this.data.stride + this.offset ] = x;
	
			return this;
	
		},
	
		setY: function ( index, y ) {
	
			this.data.array[ index * this.data.stride + this.offset + 1 ] = y;
	
			return this;
	
		},
	
		setZ: function ( index, z ) {
	
			this.data.array[ index * this.data.stride + this.offset + 2 ] = z;
	
			return this;
	
		},
	
		setW: function ( index, w ) {
	
			this.data.array[ index * this.data.stride + this.offset + 3 ] = w;
	
			return this;
	
		},
	
		getX: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset ];
	
		},
	
		getY: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 1 ];
	
		},
	
		getZ: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 2 ];
	
		},
	
		getW: function ( index ) {
	
			return this.data.array[ index * this.data.stride + this.offset + 3 ];
	
		},
	
		setXY: function ( index, x, y ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
	
			return this;
	
		},
	
		setXYZ: function ( index, x, y, z ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
	
			return this;
	
		},
	
		setXYZW: function ( index, x, y, z, w ) {
	
			index = index * this.data.stride + this.offset;
	
			this.data.array[ index + 0 ] = x;
			this.data.array[ index + 1 ] = y;
			this.data.array[ index + 2 ] = z;
			this.data.array[ index + 3 ] = w;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  map: new THREE.Texture( <Image> ),
	 *  rotation: <float>,
	 *  sizeAttenuation: <bool>
	 * }
	 */
	
	function SpriteMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'SpriteMaterial';
	
		this.color = new Color( 0xffffff );
		this.map = null;
	
		this.rotation = 0;
	
		this.sizeAttenuation = true;
	
		this.lights = false;
		this.transparent = true;
	
		this.setValues( parameters );
	
	}
	
	SpriteMaterial.prototype = Object.create( Material.prototype );
	SpriteMaterial.prototype.constructor = SpriteMaterial;
	SpriteMaterial.prototype.isSpriteMaterial = true;
	
	SpriteMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.map = source.map;
	
		this.rotation = source.rotation;
	
		this.sizeAttenuation = source.sizeAttenuation;
	
		return this;
	
	};
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	var geometry;
	
	function Sprite( material ) {
	
		Object3D.call( this );
	
		this.type = 'Sprite';
	
		if ( geometry === undefined ) {
	
			geometry = new BufferGeometry();
	
			var float32Array = new Float32Array( [
				- 0.5, - 0.5, 0, 0, 0,
				0.5, - 0.5, 0, 1, 0,
				0.5, 0.5, 0, 1, 1,
				- 0.5, 0.5, 0, 0, 1
			] );
	
			var interleavedBuffer = new InterleavedBuffer( float32Array, 5 );
	
			geometry.setIndex( [ 0, 1, 2,	0, 2, 3 ] );
			geometry.addAttribute( 'position', new InterleavedBufferAttribute( interleavedBuffer, 3, 0, false ) );
			geometry.addAttribute( 'uv', new InterleavedBufferAttribute( interleavedBuffer, 2, 3, false ) );
	
		}
	
		this.geometry = geometry;
		this.material = ( material !== undefined ) ? material : new SpriteMaterial();
	
		this.center = new Vector2( 0.5, 0.5 );
	
	}
	
	Sprite.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Sprite,
	
		isSprite: true,
	
		raycast: ( function () {
	
			var intersectPoint = new Vector3();
			var worldScale = new Vector3();
			var mvPosition = new Vector3();
	
			var alignedPosition = new Vector2();
			var rotatedPosition = new Vector2();
			var viewWorldMatrix = new Matrix4();
	
			var vA = new Vector3();
			var vB = new Vector3();
			var vC = new Vector3();
	
			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();
	
			function transformVertex( vertexPosition, mvPosition, center, scale, sin, cos ) {
	
				// compute position in camera space
				alignedPosition.subVectors( vertexPosition, center ).addScalar( 0.5 ).multiply( scale );
	
				// to check if rotation is not zero
				if ( sin !== undefined ) {
	
					rotatedPosition.x = ( cos * alignedPosition.x ) - ( sin * alignedPosition.y );
					rotatedPosition.y = ( sin * alignedPosition.x ) + ( cos * alignedPosition.y );
	
				} else {
	
					rotatedPosition.copy( alignedPosition );
	
				}
	
	
				vertexPosition.copy( mvPosition );
				vertexPosition.x += rotatedPosition.x;
				vertexPosition.y += rotatedPosition.y;
	
				// transform to world space
				vertexPosition.applyMatrix4( viewWorldMatrix );
	
			}
	
			return function raycast( raycaster, intersects ) {
	
				worldScale.setFromMatrixScale( this.matrixWorld );
				viewWorldMatrix.getInverse( this.modelViewMatrix ).premultiply( this.matrixWorld );
				mvPosition.setFromMatrixPosition( this.modelViewMatrix );
	
				var rotation = this.material.rotation;
				var sin, cos;
				if ( rotation !== 0 ) {
	
					cos = Math.cos( rotation );
					sin = Math.sin( rotation );
	
				}
	
				var center = this.center;
	
				transformVertex( vA.set( - 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vB.set( 0.5, - 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
				transformVertex( vC.set( 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
	
				uvA.set( 0, 0 );
				uvB.set( 1, 0 );
				uvC.set( 1, 1 );
	
				// check first triangle
				var intersect = raycaster.ray.intersectTriangle( vA, vB, vC, false, intersectPoint );
	
				if ( intersect === null ) {
	
					// check second triangle
					transformVertex( vB.set( - 0.5, 0.5, 0 ), mvPosition, center, worldScale, sin, cos );
					uvB.set( 0, 1 );
	
					intersect = raycaster.ray.intersectTriangle( vA, vC, vB, false, intersectPoint );
					if ( intersect === null ) {
	
						return;
	
					}
	
				}
	
				var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
				if ( distance < raycaster.near || distance > raycaster.far ) return;
	
				intersects.push( {
	
					distance: distance,
					point: intersectPoint.clone(),
					uv: Triangle.getUV( intersectPoint, vA, vB, vC, uvA, uvB, uvC, new Vector2() ),
					face: null,
					object: this
	
				} );
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.material ).copy( this );
	
		},
	
		copy: function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			if ( source.center !== undefined ) this.center.copy( source.center );
	
			return this;
	
		}
	
	
	} );
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function LOD() {
	
		Object3D.call( this );
	
		this.type = 'LOD';
	
		Object.defineProperties( this, {
			levels: {
				enumerable: true,
				value: []
			}
		} );
	
	}
	
	LOD.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: LOD,
	
		copy: function ( source ) {
	
			Object3D.prototype.copy.call( this, source, false );
	
			var levels = source.levels;
	
			for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
				var level = levels[ i ];
	
				this.addLevel( level.object.clone(), level.distance );
	
			}
	
			return this;
	
		},
	
		addLevel: function ( object, distance ) {
	
			if ( distance === undefined ) distance = 0;
	
			distance = Math.abs( distance );
	
			var levels = this.levels;
	
			for ( var l = 0; l < levels.length; l ++ ) {
	
				if ( distance < levels[ l ].distance ) {
	
					break;
	
				}
	
			}
	
			levels.splice( l, 0, { distance: distance, object: object } );
	
			this.add( object );
	
		},
	
		getObjectForDistance: function ( distance ) {
	
			var levels = this.levels;
	
			for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
				if ( distance < levels[ i ].distance ) {
	
					break;
	
				}
	
			}
	
			return levels[ i - 1 ].object;
	
		},
	
		raycast: ( function () {
	
			var matrixPosition = new Vector3();
	
			return function raycast( raycaster, intersects ) {
	
				matrixPosition.setFromMatrixPosition( this.matrixWorld );
	
				var distance = raycaster.ray.origin.distanceTo( matrixPosition );
	
				this.getObjectForDistance( distance ).raycast( raycaster, intersects );
	
			};
	
		}() ),
	
		update: function () {
	
			var v1 = new Vector3();
			var v2 = new Vector3();
	
			return function update( camera ) {
	
				var levels = this.levels;
	
				if ( levels.length > 1 ) {
	
					v1.setFromMatrixPosition( camera.matrixWorld );
					v2.setFromMatrixPosition( this.matrixWorld );
	
					var distance = v1.distanceTo( v2 );
	
					levels[ 0 ].object.visible = true;
	
					for ( var i = 1, l = levels.length; i < l; i ++ ) {
	
						if ( distance >= levels[ i ].distance ) {
	
							levels[ i - 1 ].object.visible = false;
							levels[ i ].object.visible = true;
	
						} else {
	
							break;
	
						}
	
					}
	
					for ( ; i < l; i ++ ) {
	
						levels[ i ].object.visible = false;
	
					}
	
				}
	
			};
	
		}(),
	
		toJSON: function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			data.object.levels = [];
	
			var levels = this.levels;
	
			for ( var i = 0, l = levels.length; i < l; i ++ ) {
	
				var level = levels[ i ];
	
				data.object.levels.push( {
					object: level.object.uuid,
					distance: level.distance
				} );
	
			}
	
			return data;
	
		}
	
	} );
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	function SkinnedMesh( geometry, material ) {
	
		if ( geometry && geometry.isGeometry ) {
	
			console.error( 'THREE.SkinnedMesh no longer supports THREE.Geometry. Use THREE.BufferGeometry instead.' );
	
		}
	
		Mesh.call( this, geometry, material );
	
		this.type = 'SkinnedMesh';
	
		this.bindMode = 'attached';
		this.bindMatrix = new Matrix4();
		this.bindMatrixInverse = new Matrix4();
	
	}
	
	SkinnedMesh.prototype = Object.assign( Object.create( Mesh.prototype ), {
	
		constructor: SkinnedMesh,
	
		isSkinnedMesh: true,
	
		bind: function ( skeleton, bindMatrix ) {
	
			this.skeleton = skeleton;
	
			if ( bindMatrix === undefined ) {
	
				this.updateMatrixWorld( true );
	
				this.skeleton.calculateInverses();
	
				bindMatrix = this.matrixWorld;
	
			}
	
			this.bindMatrix.copy( bindMatrix );
			this.bindMatrixInverse.getInverse( bindMatrix );
	
		},
	
		pose: function () {
	
			this.skeleton.pose();
	
		},
	
		normalizeSkinWeights: function () {
	
			var vector = new Vector4();
	
			var skinWeight = this.geometry.attributes.skinWeight;
	
			for ( var i = 0, l = skinWeight.count; i < l; i ++ ) {
	
				vector.x = skinWeight.getX( i );
				vector.y = skinWeight.getY( i );
				vector.z = skinWeight.getZ( i );
				vector.w = skinWeight.getW( i );
	
				var scale = 1.0 / vector.manhattanLength();
	
				if ( scale !== Infinity ) {
	
					vector.multiplyScalar( scale );
	
				} else {
	
					vector.set( 1, 0, 0, 0 ); // do something reasonable
	
				}
	
				skinWeight.setXYZW( i, vector.x, vector.y, vector.z, vector.w );
	
			}
	
		},
	
		updateMatrixWorld: function ( force ) {
	
			Mesh.prototype.updateMatrixWorld.call( this, force );
	
			if ( this.bindMode === 'attached' ) {
	
				this.bindMatrixInverse.getInverse( this.matrixWorld );
	
			} else if ( this.bindMode === 'detached' ) {
	
				this.bindMatrixInverse.getInverse( this.bindMatrix );
	
			} else {
	
				console.warn( 'THREE.SkinnedMesh: Unrecognized bindMode: ' + this.bindMode );
	
			}
	
		},
	
		clone: function () {
	
			return new this.constructor( this.geometry, this.material ).copy( this );
	
		}
	
	} );
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author michael guerrero / http://realitymeltdown.com
	 * @author ikerr / http://verold.com
	 */
	
	function Skeleton( bones, boneInverses ) {
	
		// copy the bone array
	
		bones = bones || [];
	
		this.bones = bones.slice( 0 );
		this.boneMatrices = new Float32Array( this.bones.length * 16 );
	
		// use the supplied bone inverses or calculate the inverses
	
		if ( boneInverses === undefined ) {
	
			this.calculateInverses();
	
		} else {
	
			if ( this.bones.length === boneInverses.length ) {
	
				this.boneInverses = boneInverses.slice( 0 );
	
			} else {
	
				console.warn( 'THREE.Skeleton boneInverses is the wrong length.' );
	
				this.boneInverses = [];
	
				for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
	
					this.boneInverses.push( new Matrix4() );
	
				}
	
			}
	
		}
	
	}
	
	Object.assign( Skeleton.prototype, {
	
		calculateInverses: function () {
	
			this.boneInverses = [];
	
			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
	
				var inverse = new Matrix4();
	
				if ( this.bones[ i ] ) {
	
					inverse.getInverse( this.bones[ i ].matrixWorld );
	
				}
	
				this.boneInverses.push( inverse );
	
			}
	
		},
	
		pose: function () {
	
			var bone, i, il;
	
			// recover the bind-time world matrices
	
			for ( i = 0, il = this.bones.length; i < il; i ++ ) {
	
				bone = this.bones[ i ];
	
				if ( bone ) {
	
					bone.matrixWorld.getInverse( this.boneInverses[ i ] );
	
				}
	
			}
	
			// compute the local matrices, positions, rotations and scales
	
			for ( i = 0, il = this.bones.length; i < il; i ++ ) {
	
				bone = this.bones[ i ];
	
				if ( bone ) {
	
					if ( bone.parent && bone.parent.isBone ) {
	
						bone.matrix.getInverse( bone.parent.matrixWorld );
						bone.matrix.multiply( bone.matrixWorld );
	
					} else {
	
						bone.matrix.copy( bone.matrixWorld );
	
					}
	
					bone.matrix.decompose( bone.position, bone.quaternion, bone.scale );
	
				}
	
			}
	
		},
	
		update: ( function () {
	
			var offsetMatrix = new Matrix4();
			var identityMatrix = new Matrix4();
	
			return function update() {
	
				var bones = this.bones;
				var boneInverses = this.boneInverses;
				var boneMatrices = this.boneMatrices;
				var boneTexture = this.boneTexture;
	
				// flatten bone matrices to array
	
				for ( var i = 0, il = bones.length; i < il; i ++ ) {
	
					// compute the offset between the current and the original transform
	
					var matrix = bones[ i ] ? bones[ i ].matrixWorld : identityMatrix;
	
					offsetMatrix.multiplyMatrices( matrix, boneInverses[ i ] );
					offsetMatrix.toArray( boneMatrices, i * 16 );
	
				}
	
				if ( boneTexture !== undefined ) {
	
					boneTexture.needsUpdate = true;
	
				}
	
			};
	
		} )(),
	
		clone: function () {
	
			return new Skeleton( this.bones, this.boneInverses );
	
		},
	
		getBoneByName: function ( name ) {
	
			for ( var i = 0, il = this.bones.length; i < il; i ++ ) {
	
				var bone = this.bones[ i ];
	
				if ( bone.name === name ) {
	
					return bone;
	
				}
	
			}
	
			return undefined;
	
		}
	
	} );
	
	/**
	 * @author mikael emtinger / http://gomo.se/
	 * @author alteredq / http://alteredqualia.com/
	 * @author ikerr / http://verold.com
	 */
	
	function Bone() {
	
		Object3D.call( this );
	
		this.type = 'Bone';
	
	}
	
	Bone.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Bone,
	
		isBone: true
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *  linecap: "round",
	 *  linejoin: "round"
	 * }
	 */
	
	function LineBasicMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'LineBasicMaterial';
	
		this.color = new Color( 0xffffff );
	
		this.linewidth = 1;
		this.linecap = 'round';
		this.linejoin = 'round';
	
		this.lights = false;
	
		this.setValues( parameters );
	
	}
	
	LineBasicMaterial.prototype = Object.create( Material.prototype );
	LineBasicMaterial.prototype.constructor = LineBasicMaterial;
	
	LineBasicMaterial.prototype.isLineBasicMaterial = true;
	
	LineBasicMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.linewidth = source.linewidth;
		this.linecap = source.linecap;
		this.linejoin = source.linejoin;
	
		return this;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Line( geometry, material, mode ) {
	
		if ( mode === 1 ) {
	
			console.error( 'THREE.Line: parameter THREE.LinePieces no longer supported. Use THREE.LineSegments instead.' );
	
		}
	
		Object3D.call( this );
	
		this.type = 'Line';
	
		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new LineBasicMaterial( { color: Math.random() * 0xffffff } );
	
	}
	
	Line.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Line,
	
		isLine: true,
	
		computeLineDistances: ( function () {
	
			var start = new Vector3();
			var end = new Vector3();
	
			return function computeLineDistances() {
	
				var geometry = this.geometry;
	
				if ( geometry.isBufferGeometry ) {
	
					// we assume non-indexed geometry
	
					if ( geometry.index === null ) {
	
						var positionAttribute = geometry.attributes.position;
						var lineDistances = [ 0 ];
	
						for ( var i = 1, l = positionAttribute.count; i < l; i ++ ) {
	
							start.fromBufferAttribute( positionAttribute, i - 1 );
							end.fromBufferAttribute( positionAttribute, i );
	
							lineDistances[ i ] = lineDistances[ i - 1 ];
							lineDistances[ i ] += start.distanceTo( end );
	
						}
	
						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
	
					} else {
	
						console.warn( 'THREE.Line.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
	
					}
	
				} else if ( geometry.isGeometry ) {
	
					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;
	
					lineDistances[ 0 ] = 0;
	
					for ( var i = 1, l = vertices.length; i < l; i ++ ) {
	
						lineDistances[ i ] = lineDistances[ i - 1 ];
						lineDistances[ i ] += vertices[ i - 1 ].distanceTo( vertices[ i ] );
	
					}
	
				}
	
				return this;
	
			};
	
		}() ),
	
		raycast: ( function () {
	
			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();
	
			return function raycast( raycaster, intersects ) {
	
				var precision = raycaster.linePrecision;
	
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += precision;
	
				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
				//
	
				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				var localPrecision = precision / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localPrecisionSq = localPrecision * localPrecision;
	
				var vStart = new Vector3();
				var vEnd = new Vector3();
				var interSegment = new Vector3();
				var interRay = new Vector3();
				var step = ( this && this.isLineSegments ) ? 2 : 1;
	
				if ( geometry.isBufferGeometry ) {
	
					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
	
					if ( index !== null ) {
	
						var indices = index.array;
	
						for ( var i = 0, l = indices.length - 1; i < l; i += step ) {
	
							var a = indices[ i ];
							var b = indices[ i + 1 ];
	
							vStart.fromArray( positions, a * 3 );
							vEnd.fromArray( positions, b * 3 );
	
							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
							if ( distSq > localPrecisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					} else {
	
						for ( var i = 0, l = positions.length / 3 - 1; i < l; i += step ) {
	
							vStart.fromArray( positions, 3 * i );
							vEnd.fromArray( positions, 3 * i + 3 );
	
							var distSq = ray.distanceSqToSegment( vStart, vEnd, interRay, interSegment );
	
							if ( distSq > localPrecisionSq ) continue;
	
							interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
							var distance = raycaster.ray.origin.distanceTo( interRay );
	
							if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
							intersects.push( {
	
								distance: distance,
								// What do we want? intersection point on the ray or on the segment??
								// point: raycaster.ray.at( distance ),
								point: interSegment.clone().applyMatrix4( this.matrixWorld ),
								index: i,
								face: null,
								faceIndex: null,
								object: this
	
							} );
	
						}
	
					}
	
				} else if ( geometry.isGeometry ) {
	
					var vertices = geometry.vertices;
					var nbVertices = vertices.length;
	
					for ( var i = 0; i < nbVertices - 1; i += step ) {
	
						var distSq = ray.distanceSqToSegment( vertices[ i ], vertices[ i + 1 ], interRay, interSegment );
	
						if ( distSq > localPrecisionSq ) continue;
	
						interRay.applyMatrix4( this.matrixWorld ); //Move back to world space for distance calculation
	
						var distance = raycaster.ray.origin.distanceTo( interRay );
	
						if ( distance < raycaster.near || distance > raycaster.far ) continue;
	
						intersects.push( {
	
							distance: distance,
							// What do we want? intersection point on the ray or on the segment??
							// point: raycaster.ray.at( distance ),
							point: interSegment.clone().applyMatrix4( this.matrixWorld ),
							index: i,
							face: null,
							faceIndex: null,
							object: this
	
						} );
	
					}
	
				}
	
			};
	
		}() ),
	
		copy: function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			this.geometry.copy( source.geometry );
			this.material.copy( source.material );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function LineSegments( geometry, material ) {
	
		Line.call( this, geometry, material );
	
		this.type = 'LineSegments';
	
	}
	
	LineSegments.prototype = Object.assign( Object.create( Line.prototype ), {
	
		constructor: LineSegments,
	
		isLineSegments: true,
	
		computeLineDistances: ( function () {
	
			var start = new Vector3();
			var end = new Vector3();
	
			return function computeLineDistances() {
	
				var geometry = this.geometry;
	
				if ( geometry.isBufferGeometry ) {
	
					// we assume non-indexed geometry
	
					if ( geometry.index === null ) {
	
						var positionAttribute = geometry.attributes.position;
						var lineDistances = [];
	
						for ( var i = 0, l = positionAttribute.count; i < l; i += 2 ) {
	
							start.fromBufferAttribute( positionAttribute, i );
							end.fromBufferAttribute( positionAttribute, i + 1 );
	
							lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
							lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );
	
						}
	
						geometry.addAttribute( 'lineDistance', new Float32BufferAttribute( lineDistances, 1 ) );
	
					} else {
	
						console.warn( 'THREE.LineSegments.computeLineDistances(): Computation only possible with non-indexed BufferGeometry.' );
	
					}
	
				} else if ( geometry.isGeometry ) {
	
					var vertices = geometry.vertices;
					var lineDistances = geometry.lineDistances;
	
					for ( var i = 0, l = vertices.length; i < l; i += 2 ) {
	
						start.copy( vertices[ i ] );
						end.copy( vertices[ i + 1 ] );
	
						lineDistances[ i ] = ( i === 0 ) ? 0 : lineDistances[ i - 1 ];
						lineDistances[ i + 1 ] = lineDistances[ i ] + start.distanceTo( end );
	
					}
	
				}
	
				return this;
	
			};
	
		}() )
	
	} );
	
	/**
	 * @author mgreter / http://github.com/mgreter
	 */
	
	function LineLoop( geometry, material ) {
	
		Line.call( this, geometry, material );
	
		this.type = 'LineLoop';
	
	}
	
	LineLoop.prototype = Object.assign( Object.create( Line.prototype ), {
	
		constructor: LineLoop,
	
		isLineLoop: true,
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  size: <float>,
	 *  sizeAttenuation: <bool>
	 *
	 *  morphTargets: <bool>
	 * }
	 */
	
	function PointsMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'PointsMaterial';
	
		this.color = new Color( 0xffffff );
	
		this.map = null;
	
		this.size = 1;
		this.sizeAttenuation = true;
	
		this.morphTargets = false;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	}
	
	PointsMaterial.prototype = Object.create( Material.prototype );
	PointsMaterial.prototype.constructor = PointsMaterial;
	
	PointsMaterial.prototype.isPointsMaterial = true;
	
	PointsMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.size = source.size;
		this.sizeAttenuation = source.sizeAttenuation;
	
		this.morphTargets = source.morphTargets;
	
		return this;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function Points( geometry, material ) {
	
		Object3D.call( this );
	
		this.type = 'Points';
	
		this.geometry = geometry !== undefined ? geometry : new BufferGeometry();
		this.material = material !== undefined ? material : new PointsMaterial( { color: Math.random() * 0xffffff } );
	
	}
	
	Points.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Points,
	
		isPoints: true,
	
		raycast: ( function () {
	
			var inverseMatrix = new Matrix4();
			var ray = new Ray();
			var sphere = new Sphere();
	
			return function raycast( raycaster, intersects ) {
	
				var object = this;
				var geometry = this.geometry;
				var matrixWorld = this.matrixWorld;
				var threshold = raycaster.params.Points.threshold;
	
				// Checking boundingSphere distance to ray
	
				if ( geometry.boundingSphere === null ) geometry.computeBoundingSphere();
	
				sphere.copy( geometry.boundingSphere );
				sphere.applyMatrix4( matrixWorld );
				sphere.radius += threshold;
	
				if ( raycaster.ray.intersectsSphere( sphere ) === false ) return;
	
				//
	
				inverseMatrix.getInverse( matrixWorld );
				ray.copy( raycaster.ray ).applyMatrix4( inverseMatrix );
	
				var localThreshold = threshold / ( ( this.scale.x + this.scale.y + this.scale.z ) / 3 );
				var localThresholdSq = localThreshold * localThreshold;
				var position = new Vector3();
				var intersectPoint = new Vector3();
	
				function testPoint( point, index ) {
	
					var rayPointDistanceSq = ray.distanceSqToPoint( point );
	
					if ( rayPointDistanceSq < localThresholdSq ) {
	
						ray.closestPointToPoint( point, intersectPoint );
						intersectPoint.applyMatrix4( matrixWorld );
	
						var distance = raycaster.ray.origin.distanceTo( intersectPoint );
	
						if ( distance < raycaster.near || distance > raycaster.far ) return;
	
						intersects.push( {
	
							distance: distance,
							distanceToRay: Math.sqrt( rayPointDistanceSq ),
							point: intersectPoint.clone(),
							index: index,
							face: null,
							object: object
	
						} );
	
					}
	
				}
	
				if ( geometry.isBufferGeometry ) {
	
					var index = geometry.index;
					var attributes = geometry.attributes;
					var positions = attributes.position.array;
	
					if ( index !== null ) {
	
						var indices = index.array;
	
						for ( var i = 0, il = indices.length; i < il; i ++ ) {
	
							var a = indices[ i ];
	
							position.fromArray( positions, a * 3 );
	
							testPoint( position, a );
	
						}
	
					} else {
	
						for ( var i = 0, l = positions.length / 3; i < l; i ++ ) {
	
							position.fromArray( positions, i * 3 );
	
							testPoint( position, i );
	
						}
	
					}
	
				} else {
	
					var vertices = geometry.vertices;
	
					for ( var i = 0, l = vertices.length; i < l; i ++ ) {
	
						testPoint( vertices[ i ], i );
	
					}
	
				}
	
			};
	
		}() ),
	
		clone: function () {
	
			return new this.constructor( this.geometry, this.material ).copy( this );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function VideoTexture( video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		Texture.call( this, video, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.format = format !== undefined ? format : RGBFormat;
	
		this.minFilter = minFilter !== undefined ? minFilter : LinearFilter;
		this.magFilter = magFilter !== undefined ? magFilter : LinearFilter;
	
		this.generateMipmaps = false;
	
	}
	
	VideoTexture.prototype = Object.assign( Object.create( Texture.prototype ), {
	
		constructor: VideoTexture,
	
		isVideoTexture: true,
	
		update: function () {
	
			var video = this.image;
	
			if ( video.readyState >= video.HAVE_CURRENT_DATA ) {
	
				this.needsUpdate = true;
	
			}
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function CompressedTexture( mipmaps, width, height, format, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, encoding ) {
	
		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy, encoding );
	
		this.image = { width: width, height: height };
		this.mipmaps = mipmaps;
	
		// no flipping for cube textures
		// (also flipping doesn't work for compressed textures )
	
		this.flipY = false;
	
		// can't generate mipmaps for compressed textures
		// mips must be embedded in DDS files
	
		this.generateMipmaps = false;
	
	}
	
	CompressedTexture.prototype = Object.create( Texture.prototype );
	CompressedTexture.prototype.constructor = CompressedTexture;
	
	CompressedTexture.prototype.isCompressedTexture = true;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function CanvasTexture( canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy ) {
	
		Texture.call( this, canvas, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.needsUpdate = true;
	
	}
	
	CanvasTexture.prototype = Object.create( Texture.prototype );
	CanvasTexture.prototype.constructor = CanvasTexture;
	CanvasTexture.prototype.isCanvasTexture = true;
	
	/**
	 * @author Matt DesLauriers / @mattdesl
	 * @author atix / arthursilber.de
	 */
	
	function DepthTexture( width, height, type, mapping, wrapS, wrapT, magFilter, minFilter, anisotropy, format ) {
	
		format = format !== undefined ? format : DepthFormat;
	
		if ( format !== DepthFormat && format !== DepthStencilFormat ) {
	
			throw new Error( 'DepthTexture format must be either THREE.DepthFormat or THREE.DepthStencilFormat' );
	
		}
	
		if ( type === undefined && format === DepthFormat ) type = UnsignedShortType;
		if ( type === undefined && format === DepthStencilFormat ) type = UnsignedInt248Type;
	
		Texture.call( this, null, mapping, wrapS, wrapT, magFilter, minFilter, format, type, anisotropy );
	
		this.image = { width: width, height: height };
	
		this.magFilter = magFilter !== undefined ? magFilter : NearestFilter;
		this.minFilter = minFilter !== undefined ? minFilter : NearestFilter;
	
		this.flipY = false;
		this.generateMipmaps	= false;
	
	}
	
	DepthTexture.prototype = Object.create( Texture.prototype );
	DepthTexture.prototype.constructor = DepthTexture;
	DepthTexture.prototype.isDepthTexture = true;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	function WireframeGeometry( geometry ) {
	
		BufferGeometry.call( this );
	
		this.type = 'WireframeGeometry';
	
		// buffer
	
		var vertices = [];
	
		// helper variables
	
		var i, j, l, o, ol;
		var edge = [ 0, 0 ], edges = {}, e, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
		var vertex;
	
		// different logic for Geometry and BufferGeometry
	
		if ( geometry && geometry.isGeometry ) {
	
			// create a data structure that contains all edges without duplicates
	
			var faces = geometry.faces;
	
			for ( i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				for ( j = 0; j < 3; j ++ ) {
	
					edge1 = face[ keys[ j ] ];
					edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
					edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
					edge[ 1 ] = Math.max( edge1, edge2 );
	
					key = edge[ 0 ] + ',' + edge[ 1 ];
	
					if ( edges[ key ] === undefined ) {
	
						edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
					}
	
				}
	
			}
	
			// generate vertices
	
			for ( key in edges ) {
	
				e = edges[ key ];
	
				vertex = geometry.vertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				vertex = geometry.vertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
		} else if ( geometry && geometry.isBufferGeometry ) {
	
			var position, indices, groups;
			var group, start, count;
			var index1, index2;
	
			vertex = new Vector3();
	
			if ( geometry.index !== null ) {
	
				// indexed BufferGeometry
	
				position = geometry.attributes.position;
				indices = geometry.index;
				groups = geometry.groups;
	
				if ( groups.length === 0 ) {
	
					groups = [ { start: 0, count: indices.count, materialIndex: 0 } ];
	
				}
	
				// create a data structure that contains all eges without duplicates
	
				for ( o = 0, ol = groups.length; o < ol; ++ o ) {
	
					group = groups[ o ];
	
					start = group.start;
					count = group.count;
	
					for ( i = start, l = ( start + count ); i < l; i += 3 ) {
	
						for ( j = 0; j < 3; j ++ ) {
	
							edge1 = indices.getX( i + j );
							edge2 = indices.getX( i + ( j + 1 ) % 3 );
							edge[ 0 ] = Math.min( edge1, edge2 ); // sorting prevents duplicates
							edge[ 1 ] = Math.max( edge1, edge2 );
	
							key = edge[ 0 ] + ',' + edge[ 1 ];
	
							if ( edges[ key ] === undefined ) {
	
								edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ] };
	
							}
	
						}
	
					}
	
				}
	
				// generate vertices
	
				for ( key in edges ) {
	
					e = edges[ key ];
	
					vertex.fromBufferAttribute( position, e.index1 );
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					vertex.fromBufferAttribute( position, e.index2 );
					vertices.push( vertex.x, vertex.y, vertex.z );
	
				}
	
			} else {
	
				// non-indexed BufferGeometry
	
				position = geometry.attributes.position;
	
				for ( i = 0, l = ( position.count / 3 ); i < l; i ++ ) {
	
					for ( j = 0; j < 3; j ++ ) {
	
						// three edges per triangle, an edge is represented as (index1, index2)
						// e.g. the first triangle has the following edges: (0,1),(1,2),(2,0)
	
						index1 = 3 * i + j;
						vertex.fromBufferAttribute( position, index1 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
						index2 = 3 * i + ( ( j + 1 ) % 3 );
						vertex.fromBufferAttribute( position, index2 );
						vertices.push( vertex.x, vertex.y, vertex.z );
	
					}
	
				}
	
			}
	
		}
	
		// build geometry
	
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
	}
	
	WireframeGeometry.prototype = Object.create( BufferGeometry.prototype );
	WireframeGeometry.prototype.constructor = WireframeGeometry;
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Parametric Surfaces Geometry
	 * based on the brilliant article by @prideout http://prideout.net/blog/?p=44
	 */
	
	// ParametricGeometry
	
	function ParametricGeometry( func, slices, stacks ) {
	
		Geometry.call( this );
	
		this.type = 'ParametricGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		this.fromBufferGeometry( new ParametricBufferGeometry( func, slices, stacks ) );
		this.mergeVertices();
	
	}
	
	ParametricGeometry.prototype = Object.create( Geometry.prototype );
	ParametricGeometry.prototype.constructor = ParametricGeometry;
	
	// ParametricBufferGeometry
	
	function ParametricBufferGeometry( func, slices, stacks ) {
	
		BufferGeometry.call( this );
	
		this.type = 'ParametricBufferGeometry';
	
		this.parameters = {
			func: func,
			slices: slices,
			stacks: stacks
		};
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		var EPS = 0.00001;
	
		var normal = new Vector3();
	
		var p0 = new Vector3(), p1 = new Vector3();
		var pu = new Vector3(), pv = new Vector3();
	
		var i, j;
	
		if ( func.length < 3 ) {
	
			console.error( 'THREE.ParametricGeometry: Function must now modify a Vector3 as third parameter.' );
	
		}
	
		// generate vertices, normals and uvs
	
		var sliceCount = slices + 1;
	
		for ( i = 0; i <= stacks; i ++ ) {
	
			var v = i / stacks;
	
			for ( j = 0; j <= slices; j ++ ) {
	
				var u = j / slices;
	
				// vertex
	
				func( u, v, p0 );
				vertices.push( p0.x, p0.y, p0.z );
	
				// normal
	
				// approximate tangent vectors via finite differences
	
				if ( u - EPS >= 0 ) {
	
					func( u - EPS, v, p1 );
					pu.subVectors( p0, p1 );
	
				} else {
	
					func( u + EPS, v, p1 );
					pu.subVectors( p1, p0 );
	
				}
	
				if ( v - EPS >= 0 ) {
	
					func( u, v - EPS, p1 );
					pv.subVectors( p0, p1 );
	
				} else {
	
					func( u, v + EPS, p1 );
					pv.subVectors( p1, p0 );
	
				}
	
				// cross product of tangent vectors returns surface normal
	
				normal.crossVectors( pu, pv ).normalize();
				normals.push( normal.x, normal.y, normal.z );
	
				// uv
	
				uvs.push( u, v );
	
			}
	
		}
	
		// generate indices
	
		for ( i = 0; i < stacks; i ++ ) {
	
			for ( j = 0; j < slices; j ++ ) {
	
				var a = i * sliceCount + j;
				var b = i * sliceCount + j + 1;
				var c = ( i + 1 ) * sliceCount + j + 1;
				var d = ( i + 1 ) * sliceCount + j;
	
				// faces one and two
	
				indices.push( a, b, d );
				indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	}
	
	ParametricBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ParametricBufferGeometry.prototype.constructor = ParametricBufferGeometry;
	
	/**
	 * @author clockworkgeek / https://github.com/clockworkgeek
	 * @author timothypratley / https://github.com/timothypratley
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// PolyhedronGeometry
	
	function PolyhedronGeometry( vertices, indices, radius, detail ) {
	
		Geometry.call( this );
	
		this.type = 'PolyhedronGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		this.fromBufferGeometry( new PolyhedronBufferGeometry( vertices, indices, radius, detail ) );
		this.mergeVertices();
	
	}
	
	PolyhedronGeometry.prototype = Object.create( Geometry.prototype );
	PolyhedronGeometry.prototype.constructor = PolyhedronGeometry;
	
	// PolyhedronBufferGeometry
	
	function PolyhedronBufferGeometry( vertices, indices, radius, detail ) {
	
		BufferGeometry.call( this );
	
		this.type = 'PolyhedronBufferGeometry';
	
		this.parameters = {
			vertices: vertices,
			indices: indices,
			radius: radius,
			detail: detail
		};
	
		radius = radius || 1;
		detail = detail || 0;
	
		// default buffer data
	
		var vertexBuffer = [];
		var uvBuffer = [];
	
		// the subdivision creates the vertex buffer data
	
		subdivide( detail );
	
		// all vertices should lie on a conceptual sphere with a given radius
	
		appplyRadius( radius );
	
		// finally, create the uv data
	
		generateUVs();
	
		// build non-indexed geometry
	
		this.addAttribute( 'position', new Float32BufferAttribute( vertexBuffer, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( vertexBuffer.slice(), 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvBuffer, 2 ) );
	
		if ( detail === 0 ) {
	
			this.computeVertexNormals(); // flat normals
	
		} else {
	
			this.normalizeNormals(); // smooth normals
	
		}
	
		// helper functions
	
		function subdivide( detail ) {
	
			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();
	
			// iterate over all faces and apply a subdivison with the given detail value
	
			for ( var i = 0; i < indices.length; i += 3 ) {
	
				// get the vertices of the face
	
				getVertexByIndex( indices[ i + 0 ], a );
				getVertexByIndex( indices[ i + 1 ], b );
				getVertexByIndex( indices[ i + 2 ], c );
	
				// perform subdivision
	
				subdivideFace( a, b, c, detail );
	
			}
	
		}
	
		function subdivideFace( a, b, c, detail ) {
	
			var cols = Math.pow( 2, detail );
	
			// we use this multidimensional array as a data structure for creating the subdivision
	
			var v = [];
	
			var i, j;
	
			// construct all of the vertices for this subdivision
	
			for ( i = 0; i <= cols; i ++ ) {
	
				v[ i ] = [];
	
				var aj = a.clone().lerp( c, i / cols );
				var bj = b.clone().lerp( c, i / cols );
	
				var rows = cols - i;
	
				for ( j = 0; j <= rows; j ++ ) {
	
					if ( j === 0 && i === cols ) {
	
						v[ i ][ j ] = aj;
	
					} else {
	
						v[ i ][ j ] = aj.clone().lerp( bj, j / rows );
	
					}
	
				}
	
			}
	
			// construct all of the faces
	
			for ( i = 0; i < cols; i ++ ) {
	
				for ( j = 0; j < 2 * ( cols - i ) - 1; j ++ ) {
	
					var k = Math.floor( j / 2 );
	
					if ( j % 2 === 0 ) {
	
						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
						pushVertex( v[ i ][ k ] );
	
					} else {
	
						pushVertex( v[ i ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k + 1 ] );
						pushVertex( v[ i + 1 ][ k ] );
	
					}
	
				}
	
			}
	
		}
	
		function appplyRadius( radius ) {
	
			var vertex = new Vector3();
	
			// iterate over the entire buffer and apply the radius to each vertex
	
			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];
	
				vertex.normalize().multiplyScalar( radius );
	
				vertexBuffer[ i + 0 ] = vertex.x;
				vertexBuffer[ i + 1 ] = vertex.y;
				vertexBuffer[ i + 2 ] = vertex.z;
	
			}
	
		}
	
		function generateUVs() {
	
			var vertex = new Vector3();
	
			for ( var i = 0; i < vertexBuffer.length; i += 3 ) {
	
				vertex.x = vertexBuffer[ i + 0 ];
				vertex.y = vertexBuffer[ i + 1 ];
				vertex.z = vertexBuffer[ i + 2 ];
	
				var u = azimuth( vertex ) / 2 / Math.PI + 0.5;
				var v = inclination( vertex ) / Math.PI + 0.5;
				uvBuffer.push( u, 1 - v );
	
			}
	
			correctUVs();
	
			correctSeam();
	
		}
	
		function correctSeam() {
	
			// handle case when face straddles the seam, see #3269
	
			for ( var i = 0; i < uvBuffer.length; i += 6 ) {
	
				// uv data of a single face
	
				var x0 = uvBuffer[ i + 0 ];
				var x1 = uvBuffer[ i + 2 ];
				var x2 = uvBuffer[ i + 4 ];
	
				var max = Math.max( x0, x1, x2 );
				var min = Math.min( x0, x1, x2 );
	
				// 0.9 is somewhat arbitrary
	
				if ( max > 0.9 && min < 0.1 ) {
	
					if ( x0 < 0.2 ) uvBuffer[ i + 0 ] += 1;
					if ( x1 < 0.2 ) uvBuffer[ i + 2 ] += 1;
					if ( x2 < 0.2 ) uvBuffer[ i + 4 ] += 1;
	
				}
	
			}
	
		}
	
		function pushVertex( vertex ) {
	
			vertexBuffer.push( vertex.x, vertex.y, vertex.z );
	
		}
	
		function getVertexByIndex( index, vertex ) {
	
			var stride = index * 3;
	
			vertex.x = vertices[ stride + 0 ];
			vertex.y = vertices[ stride + 1 ];
			vertex.z = vertices[ stride + 2 ];
	
		}
	
		function correctUVs() {
	
			var a = new Vector3();
			var b = new Vector3();
			var c = new Vector3();
	
			var centroid = new Vector3();
	
			var uvA = new Vector2();
			var uvB = new Vector2();
			var uvC = new Vector2();
	
			for ( var i = 0, j = 0; i < vertexBuffer.length; i += 9, j += 6 ) {
	
				a.set( vertexBuffer[ i + 0 ], vertexBuffer[ i + 1 ], vertexBuffer[ i + 2 ] );
				b.set( vertexBuffer[ i + 3 ], vertexBuffer[ i + 4 ], vertexBuffer[ i + 5 ] );
				c.set( vertexBuffer[ i + 6 ], vertexBuffer[ i + 7 ], vertexBuffer[ i + 8 ] );
	
				uvA.set( uvBuffer[ j + 0 ], uvBuffer[ j + 1 ] );
				uvB.set( uvBuffer[ j + 2 ], uvBuffer[ j + 3 ] );
				uvC.set( uvBuffer[ j + 4 ], uvBuffer[ j + 5 ] );
	
				centroid.copy( a ).add( b ).add( c ).divideScalar( 3 );
	
				var azi = azimuth( centroid );
	
				correctUV( uvA, j + 0, a, azi );
				correctUV( uvB, j + 2, b, azi );
				correctUV( uvC, j + 4, c, azi );
	
			}
	
		}
	
		function correctUV( uv, stride, vector, azimuth ) {
	
			if ( ( azimuth < 0 ) && ( uv.x === 1 ) ) {
	
				uvBuffer[ stride ] = uv.x - 1;
	
			}
	
			if ( ( vector.x === 0 ) && ( vector.z === 0 ) ) {
	
				uvBuffer[ stride ] = azimuth / 2 / Math.PI + 0.5;
	
			}
	
		}
	
		// Angle around the Y axis, counter-clockwise when looking from above.
	
		function azimuth( vector ) {
	
			return Math.atan2( vector.z, - vector.x );
	
		}
	
	
		// Angle above the XZ plane.
	
		function inclination( vector ) {
	
			return Math.atan2( - vector.y, Math.sqrt( ( vector.x * vector.x ) + ( vector.z * vector.z ) ) );
	
		}
	
	}
	
	PolyhedronBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	PolyhedronBufferGeometry.prototype.constructor = PolyhedronBufferGeometry;
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// TetrahedronGeometry
	
	function TetrahedronGeometry( radius, detail ) {
	
		Geometry.call( this );
	
		this.type = 'TetrahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
		this.fromBufferGeometry( new TetrahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
	
	}
	
	TetrahedronGeometry.prototype = Object.create( Geometry.prototype );
	TetrahedronGeometry.prototype.constructor = TetrahedronGeometry;
	
	// TetrahedronBufferGeometry
	
	function TetrahedronBufferGeometry( radius, detail ) {
	
		var vertices = [
			1, 1, 1, 	- 1, - 1, 1, 	- 1, 1, - 1, 	1, - 1, - 1
		];
	
		var indices = [
			2, 1, 0, 	0, 3, 2,	1, 3, 0,	2, 3, 1
		];
	
		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'TetrahedronBufferGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	}
	
	TetrahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	TetrahedronBufferGeometry.prototype.constructor = TetrahedronBufferGeometry;
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// OctahedronGeometry
	
	function OctahedronGeometry( radius, detail ) {
	
		Geometry.call( this );
	
		this.type = 'OctahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
		this.fromBufferGeometry( new OctahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
	
	}
	
	OctahedronGeometry.prototype = Object.create( Geometry.prototype );
	OctahedronGeometry.prototype.constructor = OctahedronGeometry;
	
	// OctahedronBufferGeometry
	
	function OctahedronBufferGeometry( radius, detail ) {
	
		var vertices = [
			1, 0, 0, 	- 1, 0, 0,	0, 1, 0,
			0, - 1, 0, 	0, 0, 1,	0, 0, - 1
		];
	
		var indices = [
			0, 2, 4,	0, 4, 3,	0, 3, 5,
			0, 5, 2,	1, 2, 5,	1, 5, 3,
			1, 3, 4,	1, 4, 2
		];
	
		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'OctahedronBufferGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	}
	
	OctahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	OctahedronBufferGeometry.prototype.constructor = OctahedronBufferGeometry;
	
	/**
	 * @author timothypratley / https://github.com/timothypratley
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// IcosahedronGeometry
	
	function IcosahedronGeometry( radius, detail ) {
	
		Geometry.call( this );
	
		this.type = 'IcosahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
		this.fromBufferGeometry( new IcosahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
	
	}
	
	IcosahedronGeometry.prototype = Object.create( Geometry.prototype );
	IcosahedronGeometry.prototype.constructor = IcosahedronGeometry;
	
	// IcosahedronBufferGeometry
	
	function IcosahedronBufferGeometry( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
	
		var vertices = [
			- 1, t, 0, 	1, t, 0, 	- 1, - t, 0, 	1, - t, 0,
			 0, - 1, t, 	0, 1, t,	0, - 1, - t, 	0, 1, - t,
			 t, 0, - 1, 	t, 0, 1, 	- t, 0, - 1, 	- t, 0, 1
		];
	
		var indices = [
			 0, 11, 5, 	0, 5, 1, 	0, 1, 7, 	0, 7, 10, 	0, 10, 11,
			 1, 5, 9, 	5, 11, 4,	11, 10, 2,	10, 7, 6,	7, 1, 8,
			 3, 9, 4, 	3, 4, 2,	3, 2, 6,	3, 6, 8,	3, 8, 9,
			 4, 9, 5, 	2, 4, 11,	6, 2, 10,	8, 6, 7,	9, 8, 1
		];
	
		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'IcosahedronBufferGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	}
	
	IcosahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	IcosahedronBufferGeometry.prototype.constructor = IcosahedronBufferGeometry;
	
	/**
	 * @author Abe Pazos / https://hamoid.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// DodecahedronGeometry
	
	function DodecahedronGeometry( radius, detail ) {
	
		Geometry.call( this );
	
		this.type = 'DodecahedronGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
		this.fromBufferGeometry( new DodecahedronBufferGeometry( radius, detail ) );
		this.mergeVertices();
	
	}
	
	DodecahedronGeometry.prototype = Object.create( Geometry.prototype );
	DodecahedronGeometry.prototype.constructor = DodecahedronGeometry;
	
	// DodecahedronBufferGeometry
	
	function DodecahedronBufferGeometry( radius, detail ) {
	
		var t = ( 1 + Math.sqrt( 5 ) ) / 2;
		var r = 1 / t;
	
		var vertices = [
	
			// (1, 1, 1)
			- 1, - 1, - 1,	- 1, - 1, 1,
			- 1, 1, - 1, - 1, 1, 1,
			1, - 1, - 1, 1, - 1, 1,
			1, 1, - 1, 1, 1, 1,
	
			// (0, 1/, )
			 0, - r, - t, 0, - r, t,
			 0, r, - t, 0, r, t,
	
			// (1/, , 0)
			- r, - t, 0, - r, t, 0,
			 r, - t, 0, r, t, 0,
	
			// (, 0, 1/)
			- t, 0, - r, t, 0, - r,
			- t, 0, r, t, 0, r
		];
	
		var indices = [
			3, 11, 7, 	3, 7, 15, 	3, 15, 13,
			7, 19, 17, 	7, 17, 6, 	7, 6, 15,
			17, 4, 8, 	17, 8, 10, 	17, 10, 6,
			8, 0, 16, 	8, 16, 2, 	8, 2, 10,
			0, 12, 1, 	0, 1, 18, 	0, 18, 16,
			6, 10, 2, 	6, 2, 13, 	6, 13, 15,
			2, 16, 18, 	2, 18, 3, 	2, 3, 13,
			18, 1, 9, 	18, 9, 11, 	18, 11, 3,
			4, 14, 12, 	4, 12, 0, 	4, 0, 8,
			11, 9, 5, 	11, 5, 19, 	11, 19, 7,
			19, 5, 14, 	19, 14, 4, 	19, 4, 17,
			1, 12, 14, 	1, 14, 5, 	1, 5, 9
		];
	
		PolyhedronBufferGeometry.call( this, vertices, indices, radius, detail );
	
		this.type = 'DodecahedronBufferGeometry';
	
		this.parameters = {
			radius: radius,
			detail: detail
		};
	
	}
	
	DodecahedronBufferGeometry.prototype = Object.create( PolyhedronBufferGeometry.prototype );
	DodecahedronBufferGeometry.prototype.constructor = DodecahedronBufferGeometry;
	
	/**
	 * @author oosmoxiecode / https://github.com/oosmoxiecode
	 * @author WestLangley / https://github.com/WestLangley
	 * @author zz85 / https://github.com/zz85
	 * @author miningold / https://github.com/miningold
	 * @author jonobr1 / https://github.com/jonobr1
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 */
	
	// TubeGeometry
	
	function TubeGeometry( path, tubularSegments, radius, radialSegments, closed, taper ) {
	
		Geometry.call( this );
	
		this.type = 'TubeGeometry';
	
		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};
	
		if ( taper !== undefined ) console.warn( 'THREE.TubeGeometry: taper has been removed.' );
	
		var bufferGeometry = new TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed );
	
		// expose internals
	
		this.tangents = bufferGeometry.tangents;
		this.normals = bufferGeometry.normals;
		this.binormals = bufferGeometry.binormals;
	
		// create geometry
	
		this.fromBufferGeometry( bufferGeometry );
		this.mergeVertices();
	
	}
	
	TubeGeometry.prototype = Object.create( Geometry.prototype );
	TubeGeometry.prototype.constructor = TubeGeometry;
	
	// TubeBufferGeometry
	
	function TubeBufferGeometry( path, tubularSegments, radius, radialSegments, closed ) {
	
		BufferGeometry.call( this );
	
		this.type = 'TubeBufferGeometry';
	
		this.parameters = {
			path: path,
			tubularSegments: tubularSegments,
			radius: radius,
			radialSegments: radialSegments,
			closed: closed
		};
	
		tubularSegments = tubularSegments || 64;
		radius = radius || 1;
		radialSegments = radialSegments || 8;
		closed = closed || false;
	
		var frames = path.computeFrenetFrames( tubularSegments, closed );
	
		// expose internals
	
		this.tangents = frames.tangents;
		this.normals = frames.normals;
		this.binormals = frames.binormals;
	
		// helper variables
	
		var vertex = new Vector3();
		var normal = new Vector3();
		var uv = new Vector2();
		var P = new Vector3();
	
		var i, j;
	
		// buffer
	
		var vertices = [];
		var normals = [];
		var uvs = [];
		var indices = [];
	
		// create buffer data
	
		generateBufferData();
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		// functions
	
		function generateBufferData() {
	
			for ( i = 0; i < tubularSegments; i ++ ) {
	
				generateSegment( i );
	
			}
	
			// if the geometry is not closed, generate the last row of vertices and normals
			// at the regular position on the given path
			//
			// if the geometry is closed, duplicate the first row of vertices and normals (uvs will differ)
	
			generateSegment( ( closed === false ) ? tubularSegments : 0 );
	
			// uvs are generated in a separate function.
			// this makes it easy compute correct values for closed geometries
	
			generateUVs();
	
			// finally create faces
	
			generateIndices();
	
		}
	
		function generateSegment( i ) {
	
			// we use getPointAt to sample evenly distributed points from the given path
	
			P = path.getPointAt( i / tubularSegments, P );
	
			// retrieve corresponding normal and binormal
	
			var N = frames.normals[ i ];
			var B = frames.binormals[ i ];
	
			// generate normals and vertices for the current segment
	
			for ( j = 0; j <= radialSegments; j ++ ) {
	
				var v = j / radialSegments * Math.PI * 2;
	
				var sin = Math.sin( v );
				var cos = - Math.cos( v );
	
				// normal
	
				normal.x = ( cos * N.x + sin * B.x );
				normal.y = ( cos * N.y + sin * B.y );
				normal.z = ( cos * N.z + sin * B.z );
				normal.normalize();
	
				normals.push( normal.x, normal.y, normal.z );
	
				// vertex
	
				vertex.x = P.x + radius * normal.x;
				vertex.y = P.y + radius * normal.y;
				vertex.z = P.z + radius * normal.z;
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
		}
	
		function generateIndices() {
	
			for ( j = 1; j <= tubularSegments; j ++ ) {
	
				for ( i = 1; i <= radialSegments; i ++ ) {
	
					var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
					var b = ( radialSegments + 1 ) * j + ( i - 1 );
					var c = ( radialSegments + 1 ) * j + i;
					var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
				}
	
			}
	
		}
	
		function generateUVs() {
	
			for ( i = 0; i <= tubularSegments; i ++ ) {
	
				for ( j = 0; j <= radialSegments; j ++ ) {
	
					uv.x = i / tubularSegments;
					uv.y = j / radialSegments;
	
					uvs.push( uv.x, uv.y );
	
				}
	
			}
	
		}
	
	}
	
	TubeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TubeBufferGeometry.prototype.constructor = TubeBufferGeometry;
	
	/**
	 * @author oosmoxiecode
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * based on http://www.blackpawn.com/texts/pqtorus/
	 */
	
	// TorusKnotGeometry
	
	function TorusKnotGeometry( radius, tube, tubularSegments, radialSegments, p, q, heightScale ) {
	
		Geometry.call( this );
	
		this.type = 'TorusKnotGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
	
		if ( heightScale !== undefined ) console.warn( 'THREE.TorusKnotGeometry: heightScale has been deprecated. Use .scale( x, y, z ) instead.' );
	
		this.fromBufferGeometry( new TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) );
		this.mergeVertices();
	
	}
	
	TorusKnotGeometry.prototype = Object.create( Geometry.prototype );
	TorusKnotGeometry.prototype.constructor = TorusKnotGeometry;
	
	// TorusKnotBufferGeometry
	
	function TorusKnotBufferGeometry( radius, tube, tubularSegments, radialSegments, p, q ) {
	
		BufferGeometry.call( this );
	
		this.type = 'TorusKnotBufferGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			tubularSegments: tubularSegments,
			radialSegments: radialSegments,
			p: p,
			q: q
		};
	
		radius = radius || 1;
		tube = tube || 0.4;
		tubularSegments = Math.floor( tubularSegments ) || 64;
		radialSegments = Math.floor( radialSegments ) || 8;
		p = p || 2;
		q = q || 3;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// helper variables
	
		var i, j;
	
		var vertex = new Vector3();
		var normal = new Vector3();
	
		var P1 = new Vector3();
		var P2 = new Vector3();
	
		var B = new Vector3();
		var T = new Vector3();
		var N = new Vector3();
	
		// generate vertices, normals and uvs
	
		for ( i = 0; i <= tubularSegments; ++ i ) {
	
			// the radian "u" is used to calculate the position on the torus curve of the current tubular segement
	
			var u = i / tubularSegments * p * Math.PI * 2;
	
			// now we calculate two points. P1 is our current position on the curve, P2 is a little farther ahead.
			// these points are used to create a special "coordinate space", which is necessary to calculate the correct vertex positions
	
			calculatePositionOnCurve( u, p, q, radius, P1 );
			calculatePositionOnCurve( u + 0.01, p, q, radius, P2 );
	
			// calculate orthonormal basis
	
			T.subVectors( P2, P1 );
			N.addVectors( P2, P1 );
			B.crossVectors( T, N );
			N.crossVectors( B, T );
	
			// normalize B, N. T can be ignored, we don't use it
	
			B.normalize();
			N.normalize();
	
			for ( j = 0; j <= radialSegments; ++ j ) {
	
				// now calculate the vertices. they are nothing more than an extrusion of the torus curve.
				// because we extrude a shape in the xy-plane, there is no need to calculate a z-value.
	
				var v = j / radialSegments * Math.PI * 2;
				var cx = - tube * Math.cos( v );
				var cy = tube * Math.sin( v );
	
				// now calculate the final vertex position.
				// first we orient the extrusion with our basis vectos, then we add it to the current position on the curve
	
				vertex.x = P1.x + ( cx * N.x + cy * B.x );
				vertex.y = P1.y + ( cx * N.y + cy * B.y );
				vertex.z = P1.z + ( cx * N.z + cy * B.z );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal (P1 is always the center/origin of the extrusion, thus we can use it to calculate the normal)
	
				normal.subVectors( vertex, P1 ).normalize();
	
				normals.push( normal.x, normal.y, normal.z );
	
				// uv
	
				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );
	
			}
	
		}
	
		// generate indices
	
		for ( j = 1; j <= tubularSegments; j ++ ) {
	
			for ( i = 1; i <= radialSegments; i ++ ) {
	
				// indices
	
				var a = ( radialSegments + 1 ) * ( j - 1 ) + ( i - 1 );
				var b = ( radialSegments + 1 ) * j + ( i - 1 );
				var c = ( radialSegments + 1 ) * j + i;
				var d = ( radialSegments + 1 ) * ( j - 1 ) + i;
	
				// faces
	
				indices.push( a, b, d );
				indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		// this function calculates the current position on the torus curve
	
		function calculatePositionOnCurve( u, p, q, radius, position ) {
	
			var cu = Math.cos( u );
			var su = Math.sin( u );
			var quOverP = q / p * u;
			var cs = Math.cos( quOverP );
	
			position.x = radius * ( 2 + cs ) * 0.5 * cu;
			position.y = radius * ( 2 + cs ) * su * 0.5;
			position.z = radius * Math.sin( quOverP ) * 0.5;
	
		}
	
	}
	
	TorusKnotBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusKnotBufferGeometry.prototype.constructor = TorusKnotBufferGeometry;
	
	/**
	 * @author oosmoxiecode
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// TorusGeometry
	
	function TorusGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
		Geometry.call( this );
	
		this.type = 'TorusGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		this.fromBufferGeometry( new TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) );
		this.mergeVertices();
	
	}
	
	TorusGeometry.prototype = Object.create( Geometry.prototype );
	TorusGeometry.prototype.constructor = TorusGeometry;
	
	// TorusBufferGeometry
	
	function TorusBufferGeometry( radius, tube, radialSegments, tubularSegments, arc ) {
	
		BufferGeometry.call( this );
	
		this.type = 'TorusBufferGeometry';
	
		this.parameters = {
			radius: radius,
			tube: tube,
			radialSegments: radialSegments,
			tubularSegments: tubularSegments,
			arc: arc
		};
	
		radius = radius || 1;
		tube = tube || 0.4;
		radialSegments = Math.floor( radialSegments ) || 8;
		tubularSegments = Math.floor( tubularSegments ) || 6;
		arc = arc || Math.PI * 2;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// helper variables
	
		var center = new Vector3();
		var vertex = new Vector3();
		var normal = new Vector3();
	
		var j, i;
	
		// generate vertices, normals and uvs
	
		for ( j = 0; j <= radialSegments; j ++ ) {
	
			for ( i = 0; i <= tubularSegments; i ++ ) {
	
				var u = i / tubularSegments * arc;
				var v = j / radialSegments * Math.PI * 2;
	
				// vertex
	
				vertex.x = ( radius + tube * Math.cos( v ) ) * Math.cos( u );
				vertex.y = ( radius + tube * Math.cos( v ) ) * Math.sin( u );
				vertex.z = tube * Math.sin( v );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				center.x = radius * Math.cos( u );
				center.y = radius * Math.sin( u );
				normal.subVectors( vertex, center ).normalize();
	
				normals.push( normal.x, normal.y, normal.z );
	
				// uv
	
				uvs.push( i / tubularSegments );
				uvs.push( j / radialSegments );
	
			}
	
		}
	
		// generate indices
	
		for ( j = 1; j <= radialSegments; j ++ ) {
	
			for ( i = 1; i <= tubularSegments; i ++ ) {
	
				// indices
	
				var a = ( tubularSegments + 1 ) * j + i - 1;
				var b = ( tubularSegments + 1 ) * ( j - 1 ) + i - 1;
				var c = ( tubularSegments + 1 ) * ( j - 1 ) + i;
				var d = ( tubularSegments + 1 ) * j + i;
	
				// faces
	
				indices.push( a, b, d );
				indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	}
	
	TorusBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	TorusBufferGeometry.prototype.constructor = TorusBufferGeometry;
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 * Port from https://github.com/mapbox/earcut (v2.1.2)
	 */
	
	var Earcut = {
	
		triangulate: function ( data, holeIndices, dim ) {
	
			dim = dim || 2;
	
			var hasHoles = holeIndices && holeIndices.length,
				outerLen = hasHoles ? holeIndices[ 0 ] * dim : data.length,
				outerNode = linkedList( data, 0, outerLen, dim, true ),
				triangles = [];
	
			if ( ! outerNode ) return triangles;
	
			var minX, minY, maxX, maxY, x, y, invSize;
	
			if ( hasHoles ) outerNode = eliminateHoles( data, holeIndices, outerNode, dim );
	
			// if the shape is not too simple, we'll use z-order curve hash later; calculate polygon bbox
	
			if ( data.length > 80 * dim ) {
	
				minX = maxX = data[ 0 ];
				minY = maxY = data[ 1 ];
	
				for ( var i = dim; i < outerLen; i += dim ) {
	
					x = data[ i ];
					y = data[ i + 1 ];
					if ( x < minX ) minX = x;
					if ( y < minY ) minY = y;
					if ( x > maxX ) maxX = x;
					if ( y > maxY ) maxY = y;
	
				}
	
				// minX, minY and invSize are later used to transform coords into integers for z-order calculation
	
				invSize = Math.max( maxX - minX, maxY - minY );
				invSize = invSize !== 0 ? 1 / invSize : 0;
	
			}
	
			earcutLinked( outerNode, triangles, dim, minX, minY, invSize );
	
			return triangles;
	
		}
	
	};
	
	// create a circular doubly linked list from polygon points in the specified winding order
	
	function linkedList( data, start, end, dim, clockwise ) {
	
		var i, last;
	
		if ( clockwise === ( signedArea( data, start, end, dim ) > 0 ) ) {
	
			for ( i = start; i < end; i += dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );
	
		} else {
	
			for ( i = end - dim; i >= start; i -= dim ) last = insertNode( i, data[ i ], data[ i + 1 ], last );
	
		}
	
		if ( last && equals( last, last.next ) ) {
	
			removeNode( last );
			last = last.next;
	
		}
	
		return last;
	
	}
	
	// eliminate colinear or duplicate points
	
	function filterPoints( start, end ) {
	
		if ( ! start ) return start;
		if ( ! end ) end = start;
	
		var p = start, again;
	
		do {
	
			again = false;
	
			if ( ! p.steiner && ( equals( p, p.next ) || area( p.prev, p, p.next ) === 0 ) ) {
	
				removeNode( p );
				p = end = p.prev;
				if ( p === p.next ) break;
				again = true;
	
			} else {
	
				p = p.next;
	
			}
	
		} while ( again || p !== end );
	
		return end;
	
	}
	
	// main ear slicing loop which triangulates a polygon (given as a linked list)
	
	function earcutLinked( ear, triangles, dim, minX, minY, invSize, pass ) {
	
		if ( ! ear ) return;
	
		// interlink polygon nodes in z-order
	
		if ( ! pass && invSize ) indexCurve( ear, minX, minY, invSize );
	
		var stop = ear, prev, next;
	
		// iterate through ears, slicing them one by one
	
		while ( ear.prev !== ear.next ) {
	
			prev = ear.prev;
			next = ear.next;
	
			if ( invSize ? isEarHashed( ear, minX, minY, invSize ) : isEar( ear ) ) {
	
				// cut off the triangle
				triangles.push( prev.i / dim );
				triangles.push( ear.i / dim );
				triangles.push( next.i / dim );
	
				removeNode( ear );
	
				// skipping the next vertice leads to less sliver triangles
				ear = next.next;
				stop = next.next;
	
				continue;
	
			}
	
			ear = next;
	
			// if we looped through the whole remaining polygon and can't find any more ears
	
			if ( ear === stop ) {
	
				// try filtering points and slicing again
	
				if ( ! pass ) {
	
					earcutLinked( filterPoints( ear ), triangles, dim, minX, minY, invSize, 1 );
	
					// if this didn't work, try curing all small self-intersections locally
	
				} else if ( pass === 1 ) {
	
					ear = cureLocalIntersections( ear, triangles, dim );
					earcutLinked( ear, triangles, dim, minX, minY, invSize, 2 );
	
					// as a last resort, try splitting the remaining polygon into two
	
				} else if ( pass === 2 ) {
	
					splitEarcut( ear, triangles, dim, minX, minY, invSize );
	
				}
	
				break;
	
			}
	
		}
	
	}
	
	// check whether a polygon node forms a valid ear with adjacent nodes
	
	function isEar( ear ) {
	
		var a = ear.prev,
			b = ear,
			c = ear.next;
	
		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear
	
		// now make sure we don't have other points inside the potential ear
		var p = ear.next.next;
	
		while ( p !== ear.prev ) {
	
			if ( pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) && area( p.prev, p, p.next ) >= 0 ) {
	
				return false;
	
			}
	
			p = p.next;
	
		}
	
		return true;
	
	}
	
	function isEarHashed( ear, minX, minY, invSize ) {
	
		var a = ear.prev,
			b = ear,
			c = ear.next;
	
		if ( area( a, b, c ) >= 0 ) return false; // reflex, can't be an ear
	
		// triangle bbox; min & max are calculated like this for speed
	
		var minTX = a.x < b.x ? ( a.x < c.x ? a.x : c.x ) : ( b.x < c.x ? b.x : c.x ),
			minTY = a.y < b.y ? ( a.y < c.y ? a.y : c.y ) : ( b.y < c.y ? b.y : c.y ),
			maxTX = a.x > b.x ? ( a.x > c.x ? a.x : c.x ) : ( b.x > c.x ? b.x : c.x ),
			maxTY = a.y > b.y ? ( a.y > c.y ? a.y : c.y ) : ( b.y > c.y ? b.y : c.y );
	
		// z-order range for the current triangle bbox;
	
		var minZ = zOrder( minTX, minTY, minX, minY, invSize ),
			maxZ = zOrder( maxTX, maxTY, minX, minY, invSize );
	
		// first look for points inside the triangle in increasing z-order
	
		var p = ear.nextZ;
	
		while ( p && p.z <= maxZ ) {
	
			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
			p = p.nextZ;
	
		}
	
		// then look for points in decreasing z-order
	
		p = ear.prevZ;
	
		while ( p && p.z >= minZ ) {
	
			if ( p !== ear.prev && p !== ear.next &&
					pointInTriangle( a.x, a.y, b.x, b.y, c.x, c.y, p.x, p.y ) &&
					area( p.prev, p, p.next ) >= 0 ) return false;
	
			p = p.prevZ;
	
		}
	
		return true;
	
	}
	
	// go through all polygon nodes and cure small local self-intersections
	
	function cureLocalIntersections( start, triangles, dim ) {
	
		var p = start;
	
		do {
	
			var a = p.prev, b = p.next.next;
	
			if ( ! equals( a, b ) && intersects( a, p, p.next, b ) && locallyInside( a, b ) && locallyInside( b, a ) ) {
	
				triangles.push( a.i / dim );
				triangles.push( p.i / dim );
				triangles.push( b.i / dim );
	
				// remove two nodes involved
	
				removeNode( p );
				removeNode( p.next );
	
				p = start = b;
	
			}
	
			p = p.next;
	
		} while ( p !== start );
	
		return p;
	
	}
	
	// try splitting polygon into two and triangulate them independently
	
	function splitEarcut( start, triangles, dim, minX, minY, invSize ) {
	
		// look for a valid diagonal that divides the polygon into two
	
		var a = start;
	
		do {
	
			var b = a.next.next;
	
			while ( b !== a.prev ) {
	
				if ( a.i !== b.i && isValidDiagonal( a, b ) ) {
	
					// split the polygon in two by the diagonal
	
					var c = splitPolygon( a, b );
	
					// filter colinear points around the cuts
	
					a = filterPoints( a, a.next );
					c = filterPoints( c, c.next );
	
					// run earcut on each half
	
					earcutLinked( a, triangles, dim, minX, minY, invSize );
					earcutLinked( c, triangles, dim, minX, minY, invSize );
					return;
	
				}
	
				b = b.next;
	
			}
	
			a = a.next;
	
		} while ( a !== start );
	
	}
	
	// link every hole into the outer loop, producing a single-ring polygon without holes
	
	function eliminateHoles( data, holeIndices, outerNode, dim ) {
	
		var queue = [], i, len, start, end, list;
	
		for ( i = 0, len = holeIndices.length; i < len; i ++ ) {
	
			start = holeIndices[ i ] * dim;
			end = i < len - 1 ? holeIndices[ i + 1 ] * dim : data.length;
			list = linkedList( data, start, end, dim, false );
			if ( list === list.next ) list.steiner = true;
			queue.push( getLeftmost( list ) );
	
		}
	
		queue.sort( compareX );
	
		// process holes from left to right
	
		for ( i = 0; i < queue.length; i ++ ) {
	
			eliminateHole( queue[ i ], outerNode );
			outerNode = filterPoints( outerNode, outerNode.next );
	
		}
	
		return outerNode;
	
	}
	
	function compareX( a, b ) {
	
		return a.x - b.x;
	
	}
	
	// find a bridge between vertices that connects hole with an outer ring and and link it
	
	function eliminateHole( hole, outerNode ) {
	
		outerNode = findHoleBridge( hole, outerNode );
	
		if ( outerNode ) {
	
			var b = splitPolygon( outerNode, hole );
	
			filterPoints( b, b.next );
	
		}
	
	}
	
	// David Eberly's algorithm for finding a bridge between hole and outer polygon
	
	function findHoleBridge( hole, outerNode ) {
	
		var p = outerNode,
			hx = hole.x,
			hy = hole.y,
			qx = - Infinity,
			m;
	
		// find a segment intersected by a ray from the hole's leftmost point to the left;
		// segment's endpoint with lesser x will be potential connection point
	
		do {
	
			if ( hy <= p.y && hy >= p.next.y && p.next.y !== p.y ) {
	
				var x = p.x + ( hy - p.y ) * ( p.next.x - p.x ) / ( p.next.y - p.y );
	
				if ( x <= hx && x > qx ) {
	
					qx = x;
	
					if ( x === hx ) {
	
						if ( hy === p.y ) return p;
						if ( hy === p.next.y ) return p.next;
	
					}
	
					m = p.x < p.next.x ? p : p.next;
	
				}
	
			}
	
			p = p.next;
	
		} while ( p !== outerNode );
	
		if ( ! m ) return null;
	
		if ( hx === qx ) return m.prev; // hole touches outer segment; pick lower endpoint
	
		// look for points inside the triangle of hole point, segment intersection and endpoint;
		// if there are no points found, we have a valid connection;
		// otherwise choose the point of the minimum angle with the ray as connection point
	
		var stop = m,
			mx = m.x,
			my = m.y,
			tanMin = Infinity,
			tan;
	
		p = m.next;
	
		while ( p !== stop ) {
	
			if ( hx >= p.x && p.x >= mx && hx !== p.x &&
							pointInTriangle( hy < my ? hx : qx, hy, mx, my, hy < my ? qx : hx, hy, p.x, p.y ) ) {
	
				tan = Math.abs( hy - p.y ) / ( hx - p.x ); // tangential
	
				if ( ( tan < tanMin || ( tan === tanMin && p.x > m.x ) ) && locallyInside( p, hole ) ) {
	
					m = p;
					tanMin = tan;
	
				}
	
			}
	
			p = p.next;
	
		}
	
		return m;
	
	}
	
	// interlink polygon nodes in z-order
	
	function indexCurve( start, minX, minY, invSize ) {
	
		var p = start;
	
		do {
	
			if ( p.z === null ) p.z = zOrder( p.x, p.y, minX, minY, invSize );
			p.prevZ = p.prev;
			p.nextZ = p.next;
			p = p.next;
	
		} while ( p !== start );
	
		p.prevZ.nextZ = null;
		p.prevZ = null;
	
		sortLinked( p );
	
	}
	
	// Simon Tatham's linked list merge sort algorithm
	// http://www.chiark.greenend.org.uk/~sgtatham/algorithms/listsort.html
	
	function sortLinked( list ) {
	
		var i, p, q, e, tail, numMerges, pSize, qSize, inSize = 1;
	
		do {
	
			p = list;
			list = null;
			tail = null;
			numMerges = 0;
	
			while ( p ) {
	
				numMerges ++;
				q = p;
				pSize = 0;
	
				for ( i = 0; i < inSize; i ++ ) {
	
					pSize ++;
					q = q.nextZ;
					if ( ! q ) break;
	
				}
	
				qSize = inSize;
	
				while ( pSize > 0 || ( qSize > 0 && q ) ) {
	
					if ( pSize !== 0 && ( qSize === 0 || ! q || p.z <= q.z ) ) {
	
						e = p;
						p = p.nextZ;
						pSize --;
	
					} else {
	
						e = q;
						q = q.nextZ;
						qSize --;
	
					}
	
					if ( tail ) tail.nextZ = e;
					else list = e;
	
					e.prevZ = tail;
					tail = e;
	
				}
	
				p = q;
	
			}
	
			tail.nextZ = null;
			inSize *= 2;
	
		} while ( numMerges > 1 );
	
		return list;
	
	}
	
	// z-order of a point given coords and inverse of the longer side of data bbox
	
	function zOrder( x, y, minX, minY, invSize ) {
	
		// coords are transformed into non-negative 15-bit integer range
	
		x = 32767 * ( x - minX ) * invSize;
		y = 32767 * ( y - minY ) * invSize;
	
		x = ( x | ( x << 8 ) ) & 0x00FF00FF;
		x = ( x | ( x << 4 ) ) & 0x0F0F0F0F;
		x = ( x | ( x << 2 ) ) & 0x33333333;
		x = ( x | ( x << 1 ) ) & 0x55555555;
	
		y = ( y | ( y << 8 ) ) & 0x00FF00FF;
		y = ( y | ( y << 4 ) ) & 0x0F0F0F0F;
		y = ( y | ( y << 2 ) ) & 0x33333333;
		y = ( y | ( y << 1 ) ) & 0x55555555;
	
		return x | ( y << 1 );
	
	}
	
	// find the leftmost node of a polygon ring
	
	function getLeftmost( start ) {
	
		var p = start, leftmost = start;
	
		do {
	
			if ( p.x < leftmost.x ) leftmost = p;
			p = p.next;
	
		} while ( p !== start );
	
		return leftmost;
	
	}
	
	// check if a point lies within a convex triangle
	
	function pointInTriangle( ax, ay, bx, by, cx, cy, px, py ) {
	
		return ( cx - px ) * ( ay - py ) - ( ax - px ) * ( cy - py ) >= 0 &&
		 ( ax - px ) * ( by - py ) - ( bx - px ) * ( ay - py ) >= 0 &&
		 ( bx - px ) * ( cy - py ) - ( cx - px ) * ( by - py ) >= 0;
	
	}
	
	// check if a diagonal between two polygon nodes is valid (lies in polygon interior)
	
	function isValidDiagonal( a, b ) {
	
		return a.next.i !== b.i && a.prev.i !== b.i && ! intersectsPolygon( a, b ) &&
			locallyInside( a, b ) && locallyInside( b, a ) && middleInside( a, b );
	
	}
	
	// signed area of a triangle
	
	function area( p, q, r ) {
	
		return ( q.y - p.y ) * ( r.x - q.x ) - ( q.x - p.x ) * ( r.y - q.y );
	
	}
	
	// check if two points are equal
	
	function equals( p1, p2 ) {
	
		return p1.x === p2.x && p1.y === p2.y;
	
	}
	
	// check if two segments intersect
	
	function intersects( p1, q1, p2, q2 ) {
	
		if ( ( equals( p1, q1 ) && equals( p2, q2 ) ) ||
				( equals( p1, q2 ) && equals( p2, q1 ) ) ) return true;
	
		return area( p1, q1, p2 ) > 0 !== area( p1, q1, q2 ) > 0 &&
					 area( p2, q2, p1 ) > 0 !== area( p2, q2, q1 ) > 0;
	
	}
	
	// check if a polygon diagonal intersects any polygon segments
	
	function intersectsPolygon( a, b ) {
	
		var p = a;
	
		do {
	
			if ( p.i !== a.i && p.next.i !== a.i && p.i !== b.i && p.next.i !== b.i &&
							intersects( p, p.next, a, b ) ) {
	
				return true;
	
			}
	
			p = p.next;
	
		} while ( p !== a );
	
		return false;
	
	}
	
	// check if a polygon diagonal is locally inside the polygon
	
	function locallyInside( a, b ) {
	
		return area( a.prev, a, a.next ) < 0 ?
			area( a, b, a.next ) >= 0 && area( a, a.prev, b ) >= 0 :
			area( a, b, a.prev ) < 0 || area( a, a.next, b ) < 0;
	
	}
	
	// check if the middle point of a polygon diagonal is inside the polygon
	
	function middleInside( a, b ) {
	
		var p = a,
			inside = false,
			px = ( a.x + b.x ) / 2,
			py = ( a.y + b.y ) / 2;
	
		do {
	
			if ( ( ( p.y > py ) !== ( p.next.y > py ) ) && p.next.y !== p.y &&
							( px < ( p.next.x - p.x ) * ( py - p.y ) / ( p.next.y - p.y ) + p.x ) ) {
	
				inside = ! inside;
	
			}
	
			p = p.next;
	
		} while ( p !== a );
	
		return inside;
	
	}
	
	// link two polygon vertices with a bridge; if the vertices belong to the same ring, it splits polygon into two;
	// if one belongs to the outer ring and another to a hole, it merges it into a single ring
	
	function splitPolygon( a, b ) {
	
		var a2 = new Node( a.i, a.x, a.y ),
			b2 = new Node( b.i, b.x, b.y ),
			an = a.next,
			bp = b.prev;
	
		a.next = b;
		b.prev = a;
	
		a2.next = an;
		an.prev = a2;
	
		b2.next = a2;
		a2.prev = b2;
	
		bp.next = b2;
		b2.prev = bp;
	
		return b2;
	
	}
	
	// create a node and optionally link it with previous one (in a circular doubly linked list)
	
	function insertNode( i, x, y, last ) {
	
		var p = new Node( i, x, y );
	
		if ( ! last ) {
	
			p.prev = p;
			p.next = p;
	
		} else {
	
			p.next = last.next;
			p.prev = last;
			last.next.prev = p;
			last.next = p;
	
		}
	
		return p;
	
	}
	
	function removeNode( p ) {
	
		p.next.prev = p.prev;
		p.prev.next = p.next;
	
		if ( p.prevZ ) p.prevZ.nextZ = p.nextZ;
		if ( p.nextZ ) p.nextZ.prevZ = p.prevZ;
	
	}
	
	function Node( i, x, y ) {
	
		// vertice index in coordinates array
		this.i = i;
	
		// vertex coordinates
		this.x = x;
		this.y = y;
	
		// previous and next vertice nodes in a polygon ring
		this.prev = null;
		this.next = null;
	
		// z-order curve value
		this.z = null;
	
		// previous and next nodes in z-order
		this.prevZ = null;
		this.nextZ = null;
	
		// indicates whether this is a steiner point
		this.steiner = false;
	
	}
	
	function signedArea( data, start, end, dim ) {
	
		var sum = 0;
	
		for ( var i = start, j = end - dim; i < end; i += dim ) {
	
			sum += ( data[ j ] - data[ i ] ) * ( data[ i + 1 ] + data[ j + 1 ] );
			j = i;
	
		}
	
		return sum;
	
	}
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 */
	
	var ShapeUtils = {
	
		// calculate area of the contour polygon
	
		area: function ( contour ) {
	
			var n = contour.length;
			var a = 0.0;
	
			for ( var p = n - 1, q = 0; q < n; p = q ++ ) {
	
				a += contour[ p ].x * contour[ q ].y - contour[ q ].x * contour[ p ].y;
	
			}
	
			return a * 0.5;
	
		},
	
		isClockWise: function ( pts ) {
	
			return ShapeUtils.area( pts ) < 0;
	
		},
	
		triangulateShape: function ( contour, holes ) {
	
			var vertices = []; // flat array of vertices like [ x0,y0, x1,y1, x2,y2, ... ]
			var holeIndices = []; // array of hole indices
			var faces = []; // final array of vertex indices like [ [ a,b,d ], [ b,c,d ] ]
	
			removeDupEndPts( contour );
			addContour( vertices, contour );
	
			//
	
			var holeIndex = contour.length;
	
			holes.forEach( removeDupEndPts );
	
			for ( var i = 0; i < holes.length; i ++ ) {
	
				holeIndices.push( holeIndex );
				holeIndex += holes[ i ].length;
				addContour( vertices, holes[ i ] );
	
			}
	
			//
	
			var triangles = Earcut.triangulate( vertices, holeIndices );
	
			//
	
			for ( var i = 0; i < triangles.length; i += 3 ) {
	
				faces.push( triangles.slice( i, i + 3 ) );
	
			}
	
			return faces;
	
		}
	
	};
	
	function removeDupEndPts( points ) {
	
		var l = points.length;
	
		if ( l > 2 && points[ l - 1 ].equals( points[ 0 ] ) ) {
	
			points.pop();
	
		}
	
	}
	
	function addContour( vertices, contour ) {
	
		for ( var i = 0; i < contour.length; i ++ ) {
	
			vertices.push( contour[ i ].x );
			vertices.push( contour[ i ].y );
	
		}
	
	}
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Creates extruded geometry from a path shape.
	 *
	 * parameters = {
	 *
	 *  curveSegments: <int>, // number of points on the curves
	 *  steps: <int>, // number of points for z-side extrusions / used for subdividing segments of extrude spline too
	 *  depth: <float>, // Depth to extrude the shape
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into the original shape bevel goes
	 *  bevelSize: <float>, // how far from shape outline is bevel
	 *  bevelSegments: <int>, // number of bevel layers
	 *
	 *  extrudePath: <THREE.Curve> // curve to extrude shape along
	 *
	 *  UVGenerator: <Object> // object that provides UV generator functions
	 *
	 * }
	 */
	
	// ExtrudeGeometry
	
	function ExtrudeGeometry( shapes, options ) {
	
		Geometry.call( this );
	
		this.type = 'ExtrudeGeometry';
	
		this.parameters = {
			shapes: shapes,
			options: options
		};
	
		this.fromBufferGeometry( new ExtrudeBufferGeometry( shapes, options ) );
		this.mergeVertices();
	
	}
	
	ExtrudeGeometry.prototype = Object.create( Geometry.prototype );
	ExtrudeGeometry.prototype.constructor = ExtrudeGeometry;
	
	ExtrudeGeometry.prototype.toJSON = function () {
	
		var data = Geometry.prototype.toJSON.call( this );
	
		var shapes = this.parameters.shapes;
		var options = this.parameters.options;
	
		return toJSON( shapes, options, data );
	
	};
	
	// ExtrudeBufferGeometry
	
	function ExtrudeBufferGeometry( shapes, options ) {
	
		BufferGeometry.call( this );
	
		this.type = 'ExtrudeBufferGeometry';
	
		this.parameters = {
			shapes: shapes,
			options: options
		};
	
		shapes = Array.isArray( shapes ) ? shapes : [ shapes ];
	
		var scope = this;
	
		var verticesArray = [];
		var uvArray = [];
	
		for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
			var shape = shapes[ i ];
			addShape( shape );
	
		}
	
		// build geometry
	
		this.addAttribute( 'position', new Float32BufferAttribute( verticesArray, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvArray, 2 ) );
	
		this.computeVertexNormals();
	
		// functions
	
		function addShape( shape ) {
	
			var placeholder = [];
	
			// options
	
			var curveSegments = options.curveSegments !== undefined ? options.curveSegments : 12;
			var steps = options.steps !== undefined ? options.steps : 1;
			var depth = options.depth !== undefined ? options.depth : 100;
	
			var bevelEnabled = options.bevelEnabled !== undefined ? options.bevelEnabled : true;
			var bevelThickness = options.bevelThickness !== undefined ? options.bevelThickness : 6;
			var bevelSize = options.bevelSize !== undefined ? options.bevelSize : bevelThickness - 2;
			var bevelSegments = options.bevelSegments !== undefined ? options.bevelSegments : 3;
	
			var extrudePath = options.extrudePath;
	
			var uvgen = options.UVGenerator !== undefined ? options.UVGenerator : WorldUVGenerator;
	
			// deprecated options
	
			if ( options.amount !== undefined ) {
	
				console.warn( 'THREE.ExtrudeBufferGeometry: amount has been renamed to depth.' );
				depth = options.amount;
	
			}
	
			//
	
			var extrudePts, extrudeByPath = false;
			var splineTube, binormal, normal, position2;
	
			if ( extrudePath ) {
	
				extrudePts = extrudePath.getSpacedPoints( steps );
	
				extrudeByPath = true;
				bevelEnabled = false; // bevels not supported for path extrusion
	
				// SETUP TNB variables
	
				// TODO1 - have a .isClosed in spline?
	
				splineTube = extrudePath.computeFrenetFrames( steps, false );
	
				// console.log(splineTube, 'splineTube', splineTube.normals.length, 'steps', steps, 'extrudePts', extrudePts.length);
	
				binormal = new Vector3();
				normal = new Vector3();
				position2 = new Vector3();
	
			}
	
			// Safeguards if bevels are not enabled
	
			if ( ! bevelEnabled ) {
	
				bevelSegments = 0;
				bevelThickness = 0;
				bevelSize = 0;
	
			}
	
			// Variables initialization
	
			var ahole, h, hl; // looping of holes
	
			var shapePoints = shape.extractPoints( curveSegments );
	
			var vertices = shapePoints.shape;
			var holes = shapePoints.holes;
	
			var reverse = ! ShapeUtils.isClockWise( vertices );
	
			if ( reverse ) {
	
				vertices = vertices.reverse();
	
				// Maybe we should also check if holes are in the opposite direction, just to be safe ...
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
	
					if ( ShapeUtils.isClockWise( ahole ) ) {
	
						holes[ h ] = ahole.reverse();
	
					}
	
				}
	
			}
	
	
			var faces = ShapeUtils.triangulateShape( vertices, holes );
	
			/* Vertices */
	
			var contour = vertices; // vertices has all points but contour has only points of circumference
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				vertices = vertices.concat( ahole );
	
			}
	
	
			function scalePt2( pt, vec, size ) {
	
				if ( ! vec ) console.error( "THREE.ExtrudeGeometry: vec does not exist" );
	
				return vec.clone().multiplyScalar( size ).add( pt );
	
			}
	
			var b, bs, t, z,
				vert, vlen = vertices.length,
				face, flen = faces.length;
	
	
			// Find directions for point movement
	
	
			function getBevelVec( inPt, inPrev, inNext ) {
	
				// computes for inPt the corresponding point inPt' on a new contour
				//   shifted by 1 unit (length of normalized vector) to the left
				// if we walk along contour clockwise, this new contour is outside the old one
				//
				// inPt' is the intersection of the two lines parallel to the two
				//  adjacent edges of inPt at a distance of 1 unit on the left side.
	
				var v_trans_x, v_trans_y, shrink_by; // resulting translation vector for inPt
	
				// good reading for geometry algorithms (here: line-line intersection)
				// http://geomalgorithms.com/a05-_intersect-1.html
	
				var v_prev_x = inPt.x - inPrev.x,
					v_prev_y = inPt.y - inPrev.y;
				var v_next_x = inNext.x - inPt.x,
					v_next_y = inNext.y - inPt.y;
	
				var v_prev_lensq = ( v_prev_x * v_prev_x + v_prev_y * v_prev_y );
	
				// check for collinear edges
				var collinear0 = ( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
				if ( Math.abs( collinear0 ) > Number.EPSILON ) {
	
					// not collinear
	
					// length of vectors for normalizing
	
					var v_prev_len = Math.sqrt( v_prev_lensq );
					var v_next_len = Math.sqrt( v_next_x * v_next_x + v_next_y * v_next_y );
	
					// shift adjacent points by unit vectors to the left
	
					var ptPrevShift_x = ( inPrev.x - v_prev_y / v_prev_len );
					var ptPrevShift_y = ( inPrev.y + v_prev_x / v_prev_len );
	
					var ptNextShift_x = ( inNext.x - v_next_y / v_next_len );
					var ptNextShift_y = ( inNext.y + v_next_x / v_next_len );
	
					// scaling factor for v_prev to intersection point
	
					var sf = ( ( ptNextShift_x - ptPrevShift_x ) * v_next_y -
							( ptNextShift_y - ptPrevShift_y ) * v_next_x ) /
						( v_prev_x * v_next_y - v_prev_y * v_next_x );
	
					// vector from inPt to intersection point
	
					v_trans_x = ( ptPrevShift_x + v_prev_x * sf - inPt.x );
					v_trans_y = ( ptPrevShift_y + v_prev_y * sf - inPt.y );
	
					// Don't normalize!, otherwise sharp corners become ugly
					//  but prevent crazy spikes
					var v_trans_lensq = ( v_trans_x * v_trans_x + v_trans_y * v_trans_y );
					if ( v_trans_lensq <= 2 ) {
	
						return new Vector2( v_trans_x, v_trans_y );
	
					} else {
	
						shrink_by = Math.sqrt( v_trans_lensq / 2 );
	
					}
	
				} else {
	
					// handle special case of collinear edges
	
					var direction_eq = false; // assumes: opposite
					if ( v_prev_x > Number.EPSILON ) {
	
						if ( v_next_x > Number.EPSILON ) {
	
							direction_eq = true;
	
						}
	
					} else {
	
						if ( v_prev_x < - Number.EPSILON ) {
	
							if ( v_next_x < - Number.EPSILON ) {
	
								direction_eq = true;
	
							}
	
						} else {
	
							if ( Math.sign( v_prev_y ) === Math.sign( v_next_y ) ) {
	
								direction_eq = true;
	
							}
	
						}
	
					}
	
					if ( direction_eq ) {
	
						// console.log("Warning: lines are a straight sequence");
						v_trans_x = - v_prev_y;
						v_trans_y = v_prev_x;
						shrink_by = Math.sqrt( v_prev_lensq );
	
					} else {
	
						// console.log("Warning: lines are a straight spike");
						v_trans_x = v_prev_x;
						v_trans_y = v_prev_y;
						shrink_by = Math.sqrt( v_prev_lensq / 2 );
	
					}
	
				}
	
				return new Vector2( v_trans_x / shrink_by, v_trans_y / shrink_by );
	
			}
	
	
			var contourMovements = [];
	
			for ( var i = 0, il = contour.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
				if ( j === il ) j = 0;
				if ( k === il ) k = 0;
	
				//  (j)---(i)---(k)
				// console.log('i,j,k', i, j , k)
	
				contourMovements[ i ] = getBevelVec( contour[ i ], contour[ j ], contour[ k ] );
	
			}
	
			var holesMovements = [],
				oneHoleMovements, verticesMovements = contourMovements.concat();
	
			for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
				ahole = holes[ h ];
	
				oneHoleMovements = [];
	
				for ( i = 0, il = ahole.length, j = il - 1, k = i + 1; i < il; i ++, j ++, k ++ ) {
	
					if ( j === il ) j = 0;
					if ( k === il ) k = 0;
	
					//  (j)---(i)---(k)
					oneHoleMovements[ i ] = getBevelVec( ahole[ i ], ahole[ j ], ahole[ k ] );
	
				}
	
				holesMovements.push( oneHoleMovements );
				verticesMovements = verticesMovements.concat( oneHoleMovements );
	
			}
	
	
			// Loop bevelSegments, 1 for the front, 1 for the back
	
			for ( b = 0; b < bevelSegments; b ++ ) {
	
				//for ( b = bevelSegments; b > 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
	
					v( vert.x, vert.y, - z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						v( vert.x, vert.y, - z );
	
					}
	
				}
	
			}
	
			bs = bevelSize;
	
			// Back facing vertices
	
			for ( i = 0; i < vlen; i ++ ) {
	
				vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
				if ( ! extrudeByPath ) {
	
					v( vert.x, vert.y, 0 );
	
				} else {
	
					// v( vert.x, vert.y + extrudePts[ 0 ].y, extrudePts[ 0 ].x );
	
					normal.copy( splineTube.normals[ 0 ] ).multiplyScalar( vert.x );
					binormal.copy( splineTube.binormals[ 0 ] ).multiplyScalar( vert.y );
	
					position2.copy( extrudePts[ 0 ] ).add( normal ).add( binormal );
	
					v( position2.x, position2.y, position2.z );
	
				}
	
			}
	
			// Add stepped vertices...
			// Including front facing vertices
	
			var s;
	
			for ( s = 1; s <= steps; s ++ ) {
	
				for ( i = 0; i < vlen; i ++ ) {
	
					vert = bevelEnabled ? scalePt2( vertices[ i ], verticesMovements[ i ], bs ) : vertices[ i ];
	
					if ( ! extrudeByPath ) {
	
						v( vert.x, vert.y, depth / steps * s );
	
					} else {
	
						// v( vert.x, vert.y + extrudePts[ s - 1 ].y, extrudePts[ s - 1 ].x );
	
						normal.copy( splineTube.normals[ s ] ).multiplyScalar( vert.x );
						binormal.copy( splineTube.binormals[ s ] ).multiplyScalar( vert.y );
	
						position2.copy( extrudePts[ s ] ).add( normal ).add( binormal );
	
						v( position2.x, position2.y, position2.z );
	
					}
	
				}
	
			}
	
	
			// Add bevel segments planes
	
			//for ( b = 1; b <= bevelSegments; b ++ ) {
			for ( b = bevelSegments - 1; b >= 0; b -- ) {
	
				t = b / bevelSegments;
				z = bevelThickness * Math.cos( t * Math.PI / 2 );
				bs = bevelSize * Math.sin( t * Math.PI / 2 );
	
				// contract shape
	
				for ( i = 0, il = contour.length; i < il; i ++ ) {
	
					vert = scalePt2( contour[ i ], contourMovements[ i ], bs );
					v( vert.x, vert.y, depth + z );
	
				}
	
				// expand holes
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					oneHoleMovements = holesMovements[ h ];
	
					for ( i = 0, il = ahole.length; i < il; i ++ ) {
	
						vert = scalePt2( ahole[ i ], oneHoleMovements[ i ], bs );
	
						if ( ! extrudeByPath ) {
	
							v( vert.x, vert.y, depth + z );
	
						} else {
	
							v( vert.x, vert.y + extrudePts[ steps - 1 ].y, extrudePts[ steps - 1 ].x + z );
	
						}
	
					}
	
				}
	
			}
	
			/* Faces */
	
			// Top and bottom faces
	
			buildLidFaces();
	
			// Sides faces
	
			buildSideFaces();
	
	
			/////  Internal functions
	
			function buildLidFaces() {
	
				var start = verticesArray.length / 3;
	
				if ( bevelEnabled ) {
	
					var layer = 0; // steps + 1
					var offset = vlen * layer;
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ] + offset, face[ 1 ] + offset, face[ 0 ] + offset );
	
					}
	
					layer = steps + bevelSegments * 2;
					offset = vlen * layer;
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + offset, face[ 1 ] + offset, face[ 2 ] + offset );
	
					}
	
				} else {
	
					// Bottom faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 2 ], face[ 1 ], face[ 0 ] );
	
					}
	
					// Top faces
	
					for ( i = 0; i < flen; i ++ ) {
	
						face = faces[ i ];
						f3( face[ 0 ] + vlen * steps, face[ 1 ] + vlen * steps, face[ 2 ] + vlen * steps );
	
					}
	
				}
	
				scope.addGroup( start, verticesArray.length / 3 - start, 0 );
	
			}
	
			// Create faces for the z-sides of the shape
	
			function buildSideFaces() {
	
				var start = verticesArray.length / 3;
				var layeroffset = 0;
				sidewalls( contour, layeroffset );
				layeroffset += contour.length;
	
				for ( h = 0, hl = holes.length; h < hl; h ++ ) {
	
					ahole = holes[ h ];
					sidewalls( ahole, layeroffset );
	
					//, true
					layeroffset += ahole.length;
	
				}
	
	
				scope.addGroup( start, verticesArray.length / 3 - start, 1 );
	
	
			}
	
			function sidewalls( contour, layeroffset ) {
	
				var j, k;
				i = contour.length;
	
				while ( -- i >= 0 ) {
	
					j = i;
					k = i - 1;
					if ( k < 0 ) k = contour.length - 1;
	
					//console.log('b', i,j, i-1, k,vertices.length);
	
					var s = 0,
						sl = steps + bevelSegments * 2;
	
					for ( s = 0; s < sl; s ++ ) {
	
						var slen1 = vlen * s;
						var slen2 = vlen * ( s + 1 );
	
						var a = layeroffset + j + slen1,
							b = layeroffset + k + slen1,
							c = layeroffset + k + slen2,
							d = layeroffset + j + slen2;
	
						f4( a, b, c, d );
	
					}
	
				}
	
			}
	
			function v( x, y, z ) {
	
				placeholder.push( x );
				placeholder.push( y );
				placeholder.push( z );
	
			}
	
	
			function f3( a, b, c ) {
	
				addVertex( a );
				addVertex( b );
				addVertex( c );
	
				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateTopUV( scope, verticesArray, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
	
				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
	
			}
	
			function f4( a, b, c, d ) {
	
				addVertex( a );
				addVertex( b );
				addVertex( d );
	
				addVertex( b );
				addVertex( c );
				addVertex( d );
	
	
				var nextIndex = verticesArray.length / 3;
				var uvs = uvgen.generateSideWallUV( scope, verticesArray, nextIndex - 6, nextIndex - 3, nextIndex - 2, nextIndex - 1 );
	
				addUV( uvs[ 0 ] );
				addUV( uvs[ 1 ] );
				addUV( uvs[ 3 ] );
	
				addUV( uvs[ 1 ] );
				addUV( uvs[ 2 ] );
				addUV( uvs[ 3 ] );
	
			}
	
			function addVertex( index ) {
	
				verticesArray.push( placeholder[ index * 3 + 0 ] );
				verticesArray.push( placeholder[ index * 3 + 1 ] );
				verticesArray.push( placeholder[ index * 3 + 2 ] );
	
			}
	
	
			function addUV( vector2 ) {
	
				uvArray.push( vector2.x );
				uvArray.push( vector2.y );
	
			}
	
		}
	
	}
	
	ExtrudeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ExtrudeBufferGeometry.prototype.constructor = ExtrudeBufferGeometry;
	
	ExtrudeBufferGeometry.prototype.toJSON = function () {
	
		var data = BufferGeometry.prototype.toJSON.call( this );
	
		var shapes = this.parameters.shapes;
		var options = this.parameters.options;
	
		return toJSON( shapes, options, data );
	
	};
	
	//
	
	var WorldUVGenerator = {
	
		generateTopUV: function ( geometry, vertices, indexA, indexB, indexC ) {
	
			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
	
			return [
				new Vector2( a_x, a_y ),
				new Vector2( b_x, b_y ),
				new Vector2( c_x, c_y )
			];
	
		},
	
		generateSideWallUV: function ( geometry, vertices, indexA, indexB, indexC, indexD ) {
	
			var a_x = vertices[ indexA * 3 ];
			var a_y = vertices[ indexA * 3 + 1 ];
			var a_z = vertices[ indexA * 3 + 2 ];
			var b_x = vertices[ indexB * 3 ];
			var b_y = vertices[ indexB * 3 + 1 ];
			var b_z = vertices[ indexB * 3 + 2 ];
			var c_x = vertices[ indexC * 3 ];
			var c_y = vertices[ indexC * 3 + 1 ];
			var c_z = vertices[ indexC * 3 + 2 ];
			var d_x = vertices[ indexD * 3 ];
			var d_y = vertices[ indexD * 3 + 1 ];
			var d_z = vertices[ indexD * 3 + 2 ];
	
			if ( Math.abs( a_y - b_y ) < 0.01 ) {
	
				return [
					new Vector2( a_x, 1 - a_z ),
					new Vector2( b_x, 1 - b_z ),
					new Vector2( c_x, 1 - c_z ),
					new Vector2( d_x, 1 - d_z )
				];
	
			} else {
	
				return [
					new Vector2( a_y, 1 - a_z ),
					new Vector2( b_y, 1 - b_z ),
					new Vector2( c_y, 1 - c_z ),
					new Vector2( d_y, 1 - d_z )
				];
	
			}
	
		}
	};
	
	function toJSON( shapes, options, data ) {
	
		//
	
		data.shapes = [];
	
		if ( Array.isArray( shapes ) ) {
	
			for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
				var shape = shapes[ i ];
	
				data.shapes.push( shape.uuid );
	
			}
	
		} else {
	
			data.shapes.push( shapes.uuid );
	
		}
	
		//
	
		if ( options.extrudePath !== undefined ) data.options.extrudePath = options.extrudePath.toJSON();
	
		return data;
	
	}
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * Text = 3D Text
	 *
	 * parameters = {
	 *  font: <THREE.Font>, // font
	 *
	 *  size: <float>, // size of the text
	 *  height: <float>, // thickness to extrude text
	 *  curveSegments: <int>, // number of points on the curves
	 *
	 *  bevelEnabled: <bool>, // turn on bevel
	 *  bevelThickness: <float>, // how deep into text bevel goes
	 *  bevelSize: <float> // how far from text outline is bevel
	 * }
	 */
	
	// TextGeometry
	
	function TextGeometry( text, parameters ) {
	
		Geometry.call( this );
	
		this.type = 'TextGeometry';
	
		this.parameters = {
			text: text,
			parameters: parameters
		};
	
		this.fromBufferGeometry( new TextBufferGeometry( text, parameters ) );
		this.mergeVertices();
	
	}
	
	TextGeometry.prototype = Object.create( Geometry.prototype );
	TextGeometry.prototype.constructor = TextGeometry;
	
	// TextBufferGeometry
	
	function TextBufferGeometry( text, parameters ) {
	
		parameters = parameters || {};
	
		var font = parameters.font;
	
		if ( ! ( font && font.isFont ) ) {
	
			console.error( 'THREE.TextGeometry: font parameter is not an instance of THREE.Font.' );
			return new Geometry();
	
		}
	
		var shapes = font.generateShapes( text, parameters.size );
	
		// translate parameters to ExtrudeGeometry API
	
		parameters.depth = parameters.height !== undefined ? parameters.height : 50;
	
		// defaults
	
		if ( parameters.bevelThickness === undefined ) parameters.bevelThickness = 10;
		if ( parameters.bevelSize === undefined ) parameters.bevelSize = 8;
		if ( parameters.bevelEnabled === undefined ) parameters.bevelEnabled = false;
	
		ExtrudeBufferGeometry.call( this, shapes, parameters );
	
		this.type = 'TextBufferGeometry';
	
	}
	
	TextBufferGeometry.prototype = Object.create( ExtrudeBufferGeometry.prototype );
	TextBufferGeometry.prototype.constructor = TextBufferGeometry;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// SphereGeometry
	
	function SphereGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		Geometry.call( this );
	
		this.type = 'SphereGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) );
		this.mergeVertices();
	
	}
	
	SphereGeometry.prototype = Object.create( Geometry.prototype );
	SphereGeometry.prototype.constructor = SphereGeometry;
	
	// SphereBufferGeometry
	
	function SphereBufferGeometry( radius, widthSegments, heightSegments, phiStart, phiLength, thetaStart, thetaLength ) {
	
		BufferGeometry.call( this );
	
		this.type = 'SphereBufferGeometry';
	
		this.parameters = {
			radius: radius,
			widthSegments: widthSegments,
			heightSegments: heightSegments,
			phiStart: phiStart,
			phiLength: phiLength,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 1;
	
		widthSegments = Math.max( 3, Math.floor( widthSegments ) || 8 );
		heightSegments = Math.max( 2, Math.floor( heightSegments ) || 6 );
	
		phiStart = phiStart !== undefined ? phiStart : 0;
		phiLength = phiLength !== undefined ? phiLength : Math.PI * 2;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI;
	
		var thetaEnd = thetaStart + thetaLength;
	
		var ix, iy;
	
		var index = 0;
		var grid = [];
	
		var vertex = new Vector3();
		var normal = new Vector3();
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// generate vertices, normals and uvs
	
		for ( iy = 0; iy <= heightSegments; iy ++ ) {
	
			var verticesRow = [];
	
			var v = iy / heightSegments;
	
			for ( ix = 0; ix <= widthSegments; ix ++ ) {
	
				var u = ix / widthSegments;
	
				// vertex
	
				vertex.x = - radius * Math.cos( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
				vertex.y = radius * Math.cos( thetaStart + v * thetaLength );
				vertex.z = radius * Math.sin( phiStart + u * phiLength ) * Math.sin( thetaStart + v * thetaLength );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				normal.set( vertex.x, vertex.y, vertex.z ).normalize();
				normals.push( normal.x, normal.y, normal.z );
	
				// uv
	
				uvs.push( u, 1 - v );
	
				verticesRow.push( index ++ );
	
			}
	
			grid.push( verticesRow );
	
		}
	
		// indices
	
		for ( iy = 0; iy < heightSegments; iy ++ ) {
	
			for ( ix = 0; ix < widthSegments; ix ++ ) {
	
				var a = grid[ iy ][ ix + 1 ];
				var b = grid[ iy ][ ix ];
				var c = grid[ iy + 1 ][ ix ];
				var d = grid[ iy + 1 ][ ix + 1 ];
	
				if ( iy !== 0 || thetaStart > 0 ) indices.push( a, b, d );
				if ( iy !== heightSegments - 1 || thetaEnd < Math.PI ) indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	}
	
	SphereBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	SphereBufferGeometry.prototype.constructor = SphereBufferGeometry;
	
	/**
	 * @author Kaleb Murphy
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// RingGeometry
	
	function RingGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		Geometry.call( this );
	
		this.type = 'RingGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) );
		this.mergeVertices();
	
	}
	
	RingGeometry.prototype = Object.create( Geometry.prototype );
	RingGeometry.prototype.constructor = RingGeometry;
	
	// RingBufferGeometry
	
	function RingBufferGeometry( innerRadius, outerRadius, thetaSegments, phiSegments, thetaStart, thetaLength ) {
	
		BufferGeometry.call( this );
	
		this.type = 'RingBufferGeometry';
	
		this.parameters = {
			innerRadius: innerRadius,
			outerRadius: outerRadius,
			thetaSegments: thetaSegments,
			phiSegments: phiSegments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		innerRadius = innerRadius || 0.5;
		outerRadius = outerRadius || 1;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		thetaSegments = thetaSegments !== undefined ? Math.max( 3, thetaSegments ) : 8;
		phiSegments = phiSegments !== undefined ? Math.max( 1, phiSegments ) : 1;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// some helper variables
	
		var segment;
		var radius = innerRadius;
		var radiusStep = ( ( outerRadius - innerRadius ) / phiSegments );
		var vertex = new Vector3();
		var uv = new Vector2();
		var j, i;
	
		// generate vertices, normals and uvs
	
		for ( j = 0; j <= phiSegments; j ++ ) {
	
			for ( i = 0; i <= thetaSegments; i ++ ) {
	
				// values are generate from the inside of the ring to the outside
	
				segment = thetaStart + i / thetaSegments * thetaLength;
	
				// vertex
	
				vertex.x = radius * Math.cos( segment );
				vertex.y = radius * Math.sin( segment );
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				normals.push( 0, 0, 1 );
	
				// uv
	
				uv.x = ( vertex.x / outerRadius + 1 ) / 2;
				uv.y = ( vertex.y / outerRadius + 1 ) / 2;
	
				uvs.push( uv.x, uv.y );
	
			}
	
			// increase the radius for next row of vertices
	
			radius += radiusStep;
	
		}
	
		// indices
	
		for ( j = 0; j < phiSegments; j ++ ) {
	
			var thetaSegmentLevel = j * ( thetaSegments + 1 );
	
			for ( i = 0; i < thetaSegments; i ++ ) {
	
				segment = i + thetaSegmentLevel;
	
				var a = segment;
				var b = segment + thetaSegments + 1;
				var c = segment + thetaSegments + 2;
				var d = segment + 1;
	
				// faces
	
				indices.push( a, b, d );
				indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	}
	
	RingBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	RingBufferGeometry.prototype.constructor = RingBufferGeometry;
	
	/**
	 * @author zz85 / https://github.com/zz85
	 * @author bhouston / http://clara.io
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// LatheGeometry
	
	function LatheGeometry( points, segments, phiStart, phiLength ) {
	
		Geometry.call( this );
	
		this.type = 'LatheGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		this.fromBufferGeometry( new LatheBufferGeometry( points, segments, phiStart, phiLength ) );
		this.mergeVertices();
	
	}
	
	LatheGeometry.prototype = Object.create( Geometry.prototype );
	LatheGeometry.prototype.constructor = LatheGeometry;
	
	// LatheBufferGeometry
	
	function LatheBufferGeometry( points, segments, phiStart, phiLength ) {
	
		BufferGeometry.call( this );
	
		this.type = 'LatheBufferGeometry';
	
		this.parameters = {
			points: points,
			segments: segments,
			phiStart: phiStart,
			phiLength: phiLength
		};
	
		segments = Math.floor( segments ) || 12;
		phiStart = phiStart || 0;
		phiLength = phiLength || Math.PI * 2;
	
		// clamp phiLength so it's in range of [ 0, 2PI ]
	
		phiLength = _Math.clamp( phiLength, 0, Math.PI * 2 );
	
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var uvs = [];
	
		// helper variables
	
		var base;
		var inverseSegments = 1.0 / segments;
		var vertex = new Vector3();
		var uv = new Vector2();
		var i, j;
	
		// generate vertices and uvs
	
		for ( i = 0; i <= segments; i ++ ) {
	
			var phi = phiStart + i * inverseSegments * phiLength;
	
			var sin = Math.sin( phi );
			var cos = Math.cos( phi );
	
			for ( j = 0; j <= ( points.length - 1 ); j ++ ) {
	
				// vertex
	
				vertex.x = points[ j ].x * sin;
				vertex.y = points[ j ].y;
				vertex.z = points[ j ].x * cos;
	
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// uv
	
				uv.x = i / segments;
				uv.y = j / ( points.length - 1 );
	
				uvs.push( uv.x, uv.y );
	
	
			}
	
		}
	
		// indices
	
		for ( i = 0; i < segments; i ++ ) {
	
			for ( j = 0; j < ( points.length - 1 ); j ++ ) {
	
				base = j + i * points.length;
	
				var a = base;
				var b = base + points.length;
				var c = base + points.length + 1;
				var d = base + 1;
	
				// faces
	
				indices.push( a, b, d );
				indices.push( b, c, d );
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		// generate normals
	
		this.computeVertexNormals();
	
		// if the geometry is closed, we need to average the normals along the seam.
		// because the corresponding vertices are identical (but still have different UVs).
	
		if ( phiLength === Math.PI * 2 ) {
	
			var normals = this.attributes.normal.array;
			var n1 = new Vector3();
			var n2 = new Vector3();
			var n = new Vector3();
	
			// this is the buffer offset for the last line of vertices
	
			base = segments * points.length * 3;
	
			for ( i = 0, j = 0; i < points.length; i ++, j += 3 ) {
	
				// select the normal of the vertex in the first line
	
				n1.x = normals[ j + 0 ];
				n1.y = normals[ j + 1 ];
				n1.z = normals[ j + 2 ];
	
				// select the normal of the vertex in the last line
	
				n2.x = normals[ base + j + 0 ];
				n2.y = normals[ base + j + 1 ];
				n2.z = normals[ base + j + 2 ];
	
				// average normals
	
				n.addVectors( n1, n2 ).normalize();
	
				// assign the new values to both normals
	
				normals[ j + 0 ] = normals[ base + j + 0 ] = n.x;
				normals[ j + 1 ] = normals[ base + j + 1 ] = n.y;
				normals[ j + 2 ] = normals[ base + j + 2 ] = n.z;
	
			}
	
		}
	
	}
	
	LatheBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	LatheBufferGeometry.prototype.constructor = LatheBufferGeometry;
	
	/**
	 * @author jonobr1 / http://jonobr1.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// ShapeGeometry
	
	function ShapeGeometry( shapes, curveSegments ) {
	
		Geometry.call( this );
	
		this.type = 'ShapeGeometry';
	
		if ( typeof curveSegments === 'object' ) {
	
			console.warn( 'THREE.ShapeGeometry: Options parameter has been removed.' );
	
			curveSegments = curveSegments.curveSegments;
	
		}
	
		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};
	
		this.fromBufferGeometry( new ShapeBufferGeometry( shapes, curveSegments ) );
		this.mergeVertices();
	
	}
	
	ShapeGeometry.prototype = Object.create( Geometry.prototype );
	ShapeGeometry.prototype.constructor = ShapeGeometry;
	
	ShapeGeometry.prototype.toJSON = function () {
	
		var data = Geometry.prototype.toJSON.call( this );
	
		var shapes = this.parameters.shapes;
	
		return toJSON$1( shapes, data );
	
	};
	
	// ShapeBufferGeometry
	
	function ShapeBufferGeometry( shapes, curveSegments ) {
	
		BufferGeometry.call( this );
	
		this.type = 'ShapeBufferGeometry';
	
		this.parameters = {
			shapes: shapes,
			curveSegments: curveSegments
		};
	
		curveSegments = curveSegments || 12;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// helper variables
	
		var groupStart = 0;
		var groupCount = 0;
	
		// allow single and array values for "shapes" parameter
	
		if ( Array.isArray( shapes ) === false ) {
	
			addShape( shapes );
	
		} else {
	
			for ( var i = 0; i < shapes.length; i ++ ) {
	
				addShape( shapes[ i ] );
	
				this.addGroup( groupStart, groupCount, i ); // enables MultiMaterial support
	
				groupStart += groupCount;
				groupCount = 0;
	
			}
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	
		// helper functions
	
		function addShape( shape ) {
	
			var i, l, shapeHole;
	
			var indexOffset = vertices.length / 3;
			var points = shape.extractPoints( curveSegments );
	
			var shapeVertices = points.shape;
			var shapeHoles = points.holes;
	
			// check direction of vertices
	
			if ( ShapeUtils.isClockWise( shapeVertices ) === false ) {
	
				shapeVertices = shapeVertices.reverse();
	
			}
	
			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
				shapeHole = shapeHoles[ i ];
	
				if ( ShapeUtils.isClockWise( shapeHole ) === true ) {
	
					shapeHoles[ i ] = shapeHole.reverse();
	
				}
	
			}
	
			var faces = ShapeUtils.triangulateShape( shapeVertices, shapeHoles );
	
			// join vertices of inner and outer paths to a single array
	
			for ( i = 0, l = shapeHoles.length; i < l; i ++ ) {
	
				shapeHole = shapeHoles[ i ];
				shapeVertices = shapeVertices.concat( shapeHole );
	
			}
	
			// vertices, normals, uvs
	
			for ( i = 0, l = shapeVertices.length; i < l; i ++ ) {
	
				var vertex = shapeVertices[ i ];
	
				vertices.push( vertex.x, vertex.y, 0 );
				normals.push( 0, 0, 1 );
				uvs.push( vertex.x, vertex.y ); // world uvs
	
			}
	
			// incides
	
			for ( i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				var a = face[ 0 ] + indexOffset;
				var b = face[ 1 ] + indexOffset;
				var c = face[ 2 ] + indexOffset;
	
				indices.push( a, b, c );
				groupCount += 3;
	
			}
	
		}
	
	}
	
	ShapeBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	ShapeBufferGeometry.prototype.constructor = ShapeBufferGeometry;
	
	ShapeBufferGeometry.prototype.toJSON = function () {
	
		var data = BufferGeometry.prototype.toJSON.call( this );
	
		var shapes = this.parameters.shapes;
	
		return toJSON$1( shapes, data );
	
	};
	
	//
	
	function toJSON$1( shapes, data ) {
	
		data.shapes = [];
	
		if ( Array.isArray( shapes ) ) {
	
			for ( var i = 0, l = shapes.length; i < l; i ++ ) {
	
				var shape = shapes[ i ];
	
				data.shapes.push( shape.uuid );
	
			}
	
		} else {
	
			data.shapes.push( shapes.uuid );
	
		}
	
		return data;
	
	}
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	function EdgesGeometry( geometry, thresholdAngle ) {
	
		BufferGeometry.call( this );
	
		this.type = 'EdgesGeometry';
	
		this.parameters = {
			thresholdAngle: thresholdAngle
		};
	
		thresholdAngle = ( thresholdAngle !== undefined ) ? thresholdAngle : 1;
	
		// buffer
	
		var vertices = [];
	
		// helper variables
	
		var thresholdDot = Math.cos( _Math.DEG2RAD * thresholdAngle );
		var edge = [ 0, 0 ], edges = {}, edge1, edge2;
		var key, keys = [ 'a', 'b', 'c' ];
	
		// prepare source geometry
	
		var geometry2;
	
		if ( geometry.isBufferGeometry ) {
	
			geometry2 = new Geometry();
			geometry2.fromBufferGeometry( geometry );
	
		} else {
	
			geometry2 = geometry.clone();
	
		}
	
		geometry2.mergeVertices();
		geometry2.computeFaceNormals();
	
		var sourceVertices = geometry2.vertices;
		var faces = geometry2.faces;
	
		// now create a data structure where each entry represents an edge with its adjoining faces
	
		for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
			var face = faces[ i ];
	
			for ( var j = 0; j < 3; j ++ ) {
	
				edge1 = face[ keys[ j ] ];
				edge2 = face[ keys[ ( j + 1 ) % 3 ] ];
				edge[ 0 ] = Math.min( edge1, edge2 );
				edge[ 1 ] = Math.max( edge1, edge2 );
	
				key = edge[ 0 ] + ',' + edge[ 1 ];
	
				if ( edges[ key ] === undefined ) {
	
					edges[ key ] = { index1: edge[ 0 ], index2: edge[ 1 ], face1: i, face2: undefined };
	
				} else {
	
					edges[ key ].face2 = i;
	
				}
	
			}
	
		}
	
		// generate vertices
	
		for ( key in edges ) {
	
			var e = edges[ key ];
	
			// an edge is only rendered if the angle (in degrees) between the face normals of the adjoining faces exceeds this value. default = 1 degree.
	
			if ( e.face2 === undefined || faces[ e.face1 ].normal.dot( faces[ e.face2 ].normal ) <= thresholdDot ) {
	
				var vertex = sourceVertices[ e.index1 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				vertex = sourceVertices[ e.index2 ];
				vertices.push( vertex.x, vertex.y, vertex.z );
	
			}
	
		}
	
		// build geometry
	
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
	
	}
	
	EdgesGeometry.prototype = Object.create( BufferGeometry.prototype );
	EdgesGeometry.prototype.constructor = EdgesGeometry;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	// CylinderGeometry
	
	function CylinderGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		Geometry.call( this );
	
		this.type = 'CylinderGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) );
		this.mergeVertices();
	
	}
	
	CylinderGeometry.prototype = Object.create( Geometry.prototype );
	CylinderGeometry.prototype.constructor = CylinderGeometry;
	
	// CylinderBufferGeometry
	
	function CylinderBufferGeometry( radiusTop, radiusBottom, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		BufferGeometry.call( this );
	
		this.type = 'CylinderBufferGeometry';
	
		this.parameters = {
			radiusTop: radiusTop,
			radiusBottom: radiusBottom,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		var scope = this;
	
		radiusTop = radiusTop !== undefined ? radiusTop : 1;
		radiusBottom = radiusBottom !== undefined ? radiusBottom : 1;
		height = height || 1;
	
		radialSegments = Math.floor( radialSegments ) || 8;
		heightSegments = Math.floor( heightSegments ) || 1;
	
		openEnded = openEnded !== undefined ? openEnded : false;
		thetaStart = thetaStart !== undefined ? thetaStart : 0.0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// helper variables
	
		var index = 0;
		var indexArray = [];
		var halfHeight = height / 2;
		var groupStart = 0;
	
		// generate geometry
	
		generateTorso();
	
		if ( openEnded === false ) {
	
			if ( radiusTop > 0 ) generateCap( true );
			if ( radiusBottom > 0 ) generateCap( false );
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
		function generateTorso() {
	
			var x, y;
			var normal = new Vector3();
			var vertex = new Vector3();
	
			var groupCount = 0;
	
			// this will be used to calculate the normal
			var slope = ( radiusBottom - radiusTop ) / height;
	
			// generate vertices, normals and uvs
	
			for ( y = 0; y <= heightSegments; y ++ ) {
	
				var indexRow = [];
	
				var v = y / heightSegments;
	
				// calculate the radius of the current row
	
				var radius = v * ( radiusBottom - radiusTop ) + radiusTop;
	
				for ( x = 0; x <= radialSegments; x ++ ) {
	
					var u = x / radialSegments;
	
					var theta = u * thetaLength + thetaStart;
	
					var sinTheta = Math.sin( theta );
					var cosTheta = Math.cos( theta );
	
					// vertex
	
					vertex.x = radius * sinTheta;
					vertex.y = - v * height + halfHeight;
					vertex.z = radius * cosTheta;
					vertices.push( vertex.x, vertex.y, vertex.z );
	
					// normal
	
					normal.set( sinTheta, slope, cosTheta ).normalize();
					normals.push( normal.x, normal.y, normal.z );
	
					// uv
	
					uvs.push( u, 1 - v );
	
					// save index of vertex in respective row
	
					indexRow.push( index ++ );
	
				}
	
				// now save vertices of the row in our index array
	
				indexArray.push( indexRow );
	
			}
	
			// generate indices
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				for ( y = 0; y < heightSegments; y ++ ) {
	
					// we use the index array to access the correct indices
	
					var a = indexArray[ y ][ x ];
					var b = indexArray[ y + 1 ][ x ];
					var c = indexArray[ y + 1 ][ x + 1 ];
					var d = indexArray[ y ][ x + 1 ];
	
					// faces
	
					indices.push( a, b, d );
					indices.push( b, c, d );
	
					// update group counter
	
					groupCount += 6;
	
				}
	
			}
	
			// add a group to the geometry. this will ensure multi material support
	
			scope.addGroup( groupStart, groupCount, 0 );
	
			// calculate new start value for groups
	
			groupStart += groupCount;
	
		}
	
		function generateCap( top ) {
	
			var x, centerIndexStart, centerIndexEnd;
	
			var uv = new Vector2();
			var vertex = new Vector3();
	
			var groupCount = 0;
	
			var radius = ( top === true ) ? radiusTop : radiusBottom;
			var sign = ( top === true ) ? 1 : - 1;
	
			// save the index of the first center vertex
			centerIndexStart = index;
	
			// first we generate the center vertex data of the cap.
			// because the geometry needs one set of uvs per face,
			// we must generate a center vertex per face/segment
	
			for ( x = 1; x <= radialSegments; x ++ ) {
	
				// vertex
	
				vertices.push( 0, halfHeight * sign, 0 );
	
				// normal
	
				normals.push( 0, sign, 0 );
	
				// uv
	
				uvs.push( 0.5, 0.5 );
	
				// increase index
	
				index ++;
	
			}
	
			// save the index of the last center vertex
	
			centerIndexEnd = index;
	
			// now we generate the surrounding vertices, normals and uvs
	
			for ( x = 0; x <= radialSegments; x ++ ) {
	
				var u = x / radialSegments;
				var theta = u * thetaLength + thetaStart;
	
				var cosTheta = Math.cos( theta );
				var sinTheta = Math.sin( theta );
	
				// vertex
	
				vertex.x = radius * sinTheta;
				vertex.y = halfHeight * sign;
				vertex.z = radius * cosTheta;
				vertices.push( vertex.x, vertex.y, vertex.z );
	
				// normal
	
				normals.push( 0, sign, 0 );
	
				// uv
	
				uv.x = ( cosTheta * 0.5 ) + 0.5;
				uv.y = ( sinTheta * 0.5 * sign ) + 0.5;
				uvs.push( uv.x, uv.y );
	
				// increase index
	
				index ++;
	
			}
	
			// generate indices
	
			for ( x = 0; x < radialSegments; x ++ ) {
	
				var c = centerIndexStart + x;
				var i = centerIndexEnd + x;
	
				if ( top === true ) {
	
					// face top
	
					indices.push( i, i + 1, c );
	
				} else {
	
					// face bottom
	
					indices.push( i + 1, i, c );
	
				}
	
				groupCount += 3;
	
			}
	
			// add a group to the geometry. this will ensure multi material support
	
			scope.addGroup( groupStart, groupCount, top === true ? 1 : 2 );
	
			// calculate new start value for groups
	
			groupStart += groupCount;
	
		}
	
	}
	
	CylinderBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CylinderBufferGeometry.prototype.constructor = CylinderBufferGeometry;
	
	/**
	 * @author abelnation / http://github.com/abelnation
	 */
	
	// ConeGeometry
	
	function ConeGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		CylinderGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
		this.type = 'ConeGeometry';
	
		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
	}
	
	ConeGeometry.prototype = Object.create( CylinderGeometry.prototype );
	ConeGeometry.prototype.constructor = ConeGeometry;
	
	// ConeBufferGeometry
	
	function ConeBufferGeometry( radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength ) {
	
		CylinderBufferGeometry.call( this, 0, radius, height, radialSegments, heightSegments, openEnded, thetaStart, thetaLength );
	
		this.type = 'ConeBufferGeometry';
	
		this.parameters = {
			radius: radius,
			height: height,
			radialSegments: radialSegments,
			heightSegments: heightSegments,
			openEnded: openEnded,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
	}
	
	ConeBufferGeometry.prototype = Object.create( CylinderBufferGeometry.prototype );
	ConeBufferGeometry.prototype.constructor = ConeBufferGeometry;
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 * @author Mugen87 / https://github.com/Mugen87
	 * @author hughes
	 */
	
	// CircleGeometry
	
	function CircleGeometry( radius, segments, thetaStart, thetaLength ) {
	
		Geometry.call( this );
	
		this.type = 'CircleGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		this.fromBufferGeometry( new CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) );
		this.mergeVertices();
	
	}
	
	CircleGeometry.prototype = Object.create( Geometry.prototype );
	CircleGeometry.prototype.constructor = CircleGeometry;
	
	// CircleBufferGeometry
	
	function CircleBufferGeometry( radius, segments, thetaStart, thetaLength ) {
	
		BufferGeometry.call( this );
	
		this.type = 'CircleBufferGeometry';
	
		this.parameters = {
			radius: radius,
			segments: segments,
			thetaStart: thetaStart,
			thetaLength: thetaLength
		};
	
		radius = radius || 1;
		segments = segments !== undefined ? Math.max( 3, segments ) : 8;
	
		thetaStart = thetaStart !== undefined ? thetaStart : 0;
		thetaLength = thetaLength !== undefined ? thetaLength : Math.PI * 2;
	
		// buffers
	
		var indices = [];
		var vertices = [];
		var normals = [];
		var uvs = [];
	
		// helper variables
	
		var i, s;
		var vertex = new Vector3();
		var uv = new Vector2();
	
		// center point
	
		vertices.push( 0, 0, 0 );
		normals.push( 0, 0, 1 );
		uvs.push( 0.5, 0.5 );
	
		for ( s = 0, i = 3; s <= segments; s ++, i += 3 ) {
	
			var segment = thetaStart + s / segments * thetaLength;
	
			// vertex
	
			vertex.x = radius * Math.cos( segment );
			vertex.y = radius * Math.sin( segment );
	
			vertices.push( vertex.x, vertex.y, vertex.z );
	
			// normal
	
			normals.push( 0, 0, 1 );
	
			// uvs
	
			uv.x = ( vertices[ i ] / radius + 1 ) / 2;
			uv.y = ( vertices[ i + 1 ] / radius + 1 ) / 2;
	
			uvs.push( uv.x, uv.y );
	
		}
	
		// indices
	
		for ( i = 1; i <= segments; i ++ ) {
	
			indices.push( i, i + 1, 0 );
	
		}
	
		// build geometry
	
		this.setIndex( indices );
		this.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		this.addAttribute( 'normal', new Float32BufferAttribute( normals, 3 ) );
		this.addAttribute( 'uv', new Float32BufferAttribute( uvs, 2 ) );
	
	}
	
	CircleBufferGeometry.prototype = Object.create( BufferGeometry.prototype );
	CircleBufferGeometry.prototype.constructor = CircleBufferGeometry;
	
	
	
	var Geometries = /*#__PURE__*/Object.freeze({
		WireframeGeometry: WireframeGeometry,
		ParametricGeometry: ParametricGeometry,
		ParametricBufferGeometry: ParametricBufferGeometry,
		TetrahedronGeometry: TetrahedronGeometry,
		TetrahedronBufferGeometry: TetrahedronBufferGeometry,
		OctahedronGeometry: OctahedronGeometry,
		OctahedronBufferGeometry: OctahedronBufferGeometry,
		IcosahedronGeometry: IcosahedronGeometry,
		IcosahedronBufferGeometry: IcosahedronBufferGeometry,
		DodecahedronGeometry: DodecahedronGeometry,
		DodecahedronBufferGeometry: DodecahedronBufferGeometry,
		PolyhedronGeometry: PolyhedronGeometry,
		PolyhedronBufferGeometry: PolyhedronBufferGeometry,
		TubeGeometry: TubeGeometry,
		TubeBufferGeometry: TubeBufferGeometry,
		TorusKnotGeometry: TorusKnotGeometry,
		TorusKnotBufferGeometry: TorusKnotBufferGeometry,
		TorusGeometry: TorusGeometry,
		TorusBufferGeometry: TorusBufferGeometry,
		TextGeometry: TextGeometry,
		TextBufferGeometry: TextBufferGeometry,
		SphereGeometry: SphereGeometry,
		SphereBufferGeometry: SphereBufferGeometry,
		RingGeometry: RingGeometry,
		RingBufferGeometry: RingBufferGeometry,
		PlaneGeometry: PlaneGeometry,
		PlaneBufferGeometry: PlaneBufferGeometry,
		LatheGeometry: LatheGeometry,
		LatheBufferGeometry: LatheBufferGeometry,
		ShapeGeometry: ShapeGeometry,
		ShapeBufferGeometry: ShapeBufferGeometry,
		ExtrudeGeometry: ExtrudeGeometry,
		ExtrudeBufferGeometry: ExtrudeBufferGeometry,
		EdgesGeometry: EdgesGeometry,
		ConeGeometry: ConeGeometry,
		ConeBufferGeometry: ConeBufferGeometry,
		CylinderGeometry: CylinderGeometry,
		CylinderBufferGeometry: CylinderBufferGeometry,
		CircleGeometry: CircleGeometry,
		CircleBufferGeometry: CircleBufferGeometry,
		BoxGeometry: BoxGeometry,
		BoxBufferGeometry: BoxBufferGeometry
	});
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * parameters = {
	 *  color: <THREE.Color>
	 * }
	 */
	
	function ShadowMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'ShadowMaterial';
	
		this.color = new Color( 0x000000 );
		this.transparent = true;
	
		this.setValues( parameters );
	
	}
	
	ShadowMaterial.prototype = Object.create( Material.prototype );
	ShadowMaterial.prototype.constructor = ShadowMaterial;
	
	ShadowMaterial.prototype.isShadowMaterial = true;
	
	ShadowMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		return this;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function RawShaderMaterial( parameters ) {
	
		ShaderMaterial.call( this, parameters );
	
		this.type = 'RawShaderMaterial';
	
	}
	
	RawShaderMaterial.prototype = Object.create( ShaderMaterial.prototype );
	RawShaderMaterial.prototype.constructor = RawShaderMaterial;
	
	RawShaderMaterial.prototype.isRawShaderMaterial = true;
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  roughness: <float>,
	 *  metalness: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  roughnessMap: new THREE.Texture( <Image> ),
	 *
	 *  metalnessMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  envMapIntensity: <float>
	 *
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	function MeshStandardMaterial( parameters ) {
	
		Material.call( this );
	
		this.defines = { 'STANDARD': '' };
	
		this.type = 'MeshStandardMaterial';
	
		this.color = new Color( 0xffffff ); // diffuse
		this.roughness = 0.5;
		this.metalness = 0.5;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.roughnessMap = null;
	
		this.metalnessMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.envMapIntensity = 1.0;
	
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	}
	
	MeshStandardMaterial.prototype = Object.create( Material.prototype );
	MeshStandardMaterial.prototype.constructor = MeshStandardMaterial;
	
	MeshStandardMaterial.prototype.isMeshStandardMaterial = true;
	
	MeshStandardMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.defines = { 'STANDARD': '' };
	
		this.color.copy( source.color );
		this.roughness = source.roughness;
		this.metalness = source.metalness;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.roughnessMap = source.roughnessMap;
	
		this.metalnessMap = source.metalnessMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.envMapIntensity = source.envMapIntensity;
	
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  reflectivity: <float>
	 *  clearCoat: <float>
	 *  clearCoatRoughness: <float>
	 * }
	 */
	
	function MeshPhysicalMaterial( parameters ) {
	
		MeshStandardMaterial.call( this );
	
		this.defines = { 'PHYSICAL': '' };
	
		this.type = 'MeshPhysicalMaterial';
	
		this.reflectivity = 0.5; // maps to F0 = 0.04
	
		this.clearCoat = 0.0;
		this.clearCoatRoughness = 0.0;
	
		this.setValues( parameters );
	
	}
	
	MeshPhysicalMaterial.prototype = Object.create( MeshStandardMaterial.prototype );
	MeshPhysicalMaterial.prototype.constructor = MeshPhysicalMaterial;
	
	MeshPhysicalMaterial.prototype.isMeshPhysicalMaterial = true;
	
	MeshPhysicalMaterial.prototype.copy = function ( source ) {
	
		MeshStandardMaterial.prototype.copy.call( this, source );
	
		this.defines = { 'PHYSICAL': '' };
	
		this.reflectivity = source.reflectivity;
	
		this.clearCoat = source.clearCoat;
		this.clearCoatRoughness = source.clearCoatRoughness;
	
		return this;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  specular: <hex>,
	 *  shininess: <float>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	function MeshPhongMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'MeshPhongMaterial';
	
		this.color = new Color( 0xffffff ); // diffuse
		this.specular = new Color( 0x111111 );
		this.shininess = 30;
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	}
	
	MeshPhongMaterial.prototype = Object.create( Material.prototype );
	MeshPhongMaterial.prototype.constructor = MeshPhongMaterial;
	
	MeshPhongMaterial.prototype.isMeshPhongMaterial = true;
	
	MeshPhongMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
		this.specular.copy( source.specular );
		this.shininess = source.shininess;
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	/**
	 * @author takahirox / http://github.com/takahirox
	 *
	 * parameters = {
	 *  gradientMap: new THREE.Texture( <Image> )
	 * }
	 */
	
	function MeshToonMaterial( parameters ) {
	
		MeshPhongMaterial.call( this );
	
		this.defines = { 'TOON': '' };
	
		this.type = 'MeshToonMaterial';
	
		this.gradientMap = null;
	
		this.setValues( parameters );
	
	}
	
	MeshToonMaterial.prototype = Object.create( MeshPhongMaterial.prototype );
	MeshToonMaterial.prototype.constructor = MeshToonMaterial;
	
	MeshToonMaterial.prototype.isMeshToonMaterial = true;
	
	MeshToonMaterial.prototype.copy = function ( source ) {
	
		MeshPhongMaterial.prototype.copy.call( this, source );
	
		this.gradientMap = source.gradientMap;
	
		return this;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  opacity: <float>,
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	function MeshNormalMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'MeshNormalMaterial';
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
	
		this.fog = false;
		this.lights = false;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	}
	
	MeshNormalMaterial.prototype = Object.create( Material.prototype );
	MeshNormalMaterial.prototype.constructor = MeshNormalMaterial;
	
	MeshNormalMaterial.prototype.isMeshNormalMaterial = true;
	
	MeshNormalMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  lightMap: new THREE.Texture( <Image> ),
	 *  lightMapIntensity: <float>
	 *
	 *  aoMap: new THREE.Texture( <Image> ),
	 *  aoMapIntensity: <float>
	 *
	 *  emissive: <hex>,
	 *  emissiveIntensity: <float>
	 *  emissiveMap: new THREE.Texture( <Image> ),
	 *
	 *  specularMap: new THREE.Texture( <Image> ),
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  envMap: new THREE.CubeTexture( [posx, negx, posy, negy, posz, negz] ),
	 *  combine: THREE.Multiply,
	 *  reflectivity: <float>,
	 *  refractionRatio: <float>,
	 *
	 *  wireframe: <boolean>,
	 *  wireframeLinewidth: <float>,
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	function MeshLambertMaterial( parameters ) {
	
		Material.call( this );
	
		this.type = 'MeshLambertMaterial';
	
		this.color = new Color( 0xffffff ); // diffuse
	
		this.map = null;
	
		this.lightMap = null;
		this.lightMapIntensity = 1.0;
	
		this.aoMap = null;
		this.aoMapIntensity = 1.0;
	
		this.emissive = new Color( 0x000000 );
		this.emissiveIntensity = 1.0;
		this.emissiveMap = null;
	
		this.specularMap = null;
	
		this.alphaMap = null;
	
		this.envMap = null;
		this.combine = MultiplyOperation;
		this.reflectivity = 1;
		this.refractionRatio = 0.98;
	
		this.wireframe = false;
		this.wireframeLinewidth = 1;
		this.wireframeLinecap = 'round';
		this.wireframeLinejoin = 'round';
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.setValues( parameters );
	
	}
	
	MeshLambertMaterial.prototype = Object.create( Material.prototype );
	MeshLambertMaterial.prototype.constructor = MeshLambertMaterial;
	
	MeshLambertMaterial.prototype.isMeshLambertMaterial = true;
	
	MeshLambertMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.color.copy( source.color );
	
		this.map = source.map;
	
		this.lightMap = source.lightMap;
		this.lightMapIntensity = source.lightMapIntensity;
	
		this.aoMap = source.aoMap;
		this.aoMapIntensity = source.aoMapIntensity;
	
		this.emissive.copy( source.emissive );
		this.emissiveMap = source.emissiveMap;
		this.emissiveIntensity = source.emissiveIntensity;
	
		this.specularMap = source.specularMap;
	
		this.alphaMap = source.alphaMap;
	
		this.envMap = source.envMap;
		this.combine = source.combine;
		this.reflectivity = source.reflectivity;
		this.refractionRatio = source.refractionRatio;
	
		this.wireframe = source.wireframe;
		this.wireframeLinewidth = source.wireframeLinewidth;
		this.wireframeLinecap = source.wireframeLinecap;
		this.wireframeLinejoin = source.wireframeLinejoin;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  matcap: new THREE.Texture( <Image> ),
	 *
	 *  map: new THREE.Texture( <Image> ),
	 *
	 *  bumpMap: new THREE.Texture( <Image> ),
	 *  bumpScale: <float>,
	 *
	 *  normalMap: new THREE.Texture( <Image> ),
	 *  normalMapType: THREE.TangentSpaceNormalMap,
	 *  normalScale: <Vector2>,
	 *
	 *  displacementMap: new THREE.Texture( <Image> ),
	 *  displacementScale: <float>,
	 *  displacementBias: <float>,
	 *
	 *  alphaMap: new THREE.Texture( <Image> ),
	 *
	 *  skinning: <bool>,
	 *  morphTargets: <bool>,
	 *  morphNormals: <bool>
	 * }
	 */
	
	function MeshMatcapMaterial( parameters ) {
	
		Material.call( this );
	
		this.defines = { 'MATCAP': '' };
	
		this.type = 'MeshMatcapMaterial';
	
		this.color = new Color( 0xffffff ); // diffuse
	
		this.matcap = null;
	
		this.map = null;
	
		this.bumpMap = null;
		this.bumpScale = 1;
	
		this.normalMap = null;
		this.normalMapType = TangentSpaceNormalMap;
		this.normalScale = new Vector2( 1, 1 );
	
		this.displacementMap = null;
		this.displacementScale = 1;
		this.displacementBias = 0;
	
		this.alphaMap = null;
	
		this.skinning = false;
		this.morphTargets = false;
		this.morphNormals = false;
	
		this.lights = false;
	
		this.setValues( parameters );
	
	}
	
	MeshMatcapMaterial.prototype = Object.create( Material.prototype );
	MeshMatcapMaterial.prototype.constructor = MeshMatcapMaterial;
	
	MeshMatcapMaterial.prototype.isMeshMatcapMaterial = true;
	
	MeshMatcapMaterial.prototype.copy = function ( source ) {
	
		Material.prototype.copy.call( this, source );
	
		this.defines = { 'MATCAP': '' };
	
		this.color.copy( source.color );
	
		this.matcap = source.matcap;
	
		this.map = source.map;
	
		this.bumpMap = source.bumpMap;
		this.bumpScale = source.bumpScale;
	
		this.normalMap = source.normalMap;
		this.normalMapType = source.normalMapType;
		this.normalScale.copy( source.normalScale );
	
		this.displacementMap = source.displacementMap;
		this.displacementScale = source.displacementScale;
		this.displacementBias = source.displacementBias;
	
		this.alphaMap = source.alphaMap;
	
		this.skinning = source.skinning;
		this.morphTargets = source.morphTargets;
		this.morphNormals = source.morphNormals;
	
		return this;
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 *
	 * parameters = {
	 *  color: <hex>,
	 *  opacity: <float>,
	 *
	 *  linewidth: <float>,
	 *
	 *  scale: <float>,
	 *  dashSize: <float>,
	 *  gapSize: <float>
	 * }
	 */
	
	function LineDashedMaterial( parameters ) {
	
		LineBasicMaterial.call( this );
	
		this.type = 'LineDashedMaterial';
	
		this.scale = 1;
		this.dashSize = 3;
		this.gapSize = 1;
	
		this.setValues( parameters );
	
	}
	
	LineDashedMaterial.prototype = Object.create( LineBasicMaterial.prototype );
	LineDashedMaterial.prototype.constructor = LineDashedMaterial;
	
	LineDashedMaterial.prototype.isLineDashedMaterial = true;
	
	LineDashedMaterial.prototype.copy = function ( source ) {
	
		LineBasicMaterial.prototype.copy.call( this, source );
	
		this.scale = source.scale;
		this.dashSize = source.dashSize;
		this.gapSize = source.gapSize;
	
		return this;
	
	};
	
	
	
	var Materials = /*#__PURE__*/Object.freeze({
		ShadowMaterial: ShadowMaterial,
		SpriteMaterial: SpriteMaterial,
		RawShaderMaterial: RawShaderMaterial,
		ShaderMaterial: ShaderMaterial,
		PointsMaterial: PointsMaterial,
		MeshPhysicalMaterial: MeshPhysicalMaterial,
		MeshStandardMaterial: MeshStandardMaterial,
		MeshPhongMaterial: MeshPhongMaterial,
		MeshToonMaterial: MeshToonMaterial,
		MeshNormalMaterial: MeshNormalMaterial,
		MeshLambertMaterial: MeshLambertMaterial,
		MeshDepthMaterial: MeshDepthMaterial,
		MeshDistanceMaterial: MeshDistanceMaterial,
		MeshBasicMaterial: MeshBasicMaterial,
		MeshMatcapMaterial: MeshMatcapMaterial,
		LineDashedMaterial: LineDashedMaterial,
		LineBasicMaterial: LineBasicMaterial,
		Material: Material
	});
	
	/**
	 * @author tschw
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	var AnimationUtils = {
	
		// same as Array.prototype.slice, but also works on typed arrays
		arraySlice: function ( array, from, to ) {
	
			if ( AnimationUtils.isTypedArray( array ) ) {
	
				// in ios9 array.subarray(from, undefined) will return empty array
				// but array.subarray(from) or array.subarray(from, len) is correct
				return new array.constructor( array.subarray( from, to !== undefined ? to : array.length ) );
	
			}
	
			return array.slice( from, to );
	
		},
	
		// converts an array to a specific type
		convertArray: function ( array, type, forceClone ) {
	
			if ( ! array || // let 'undefined' and 'null' pass
				! forceClone && array.constructor === type ) return array;
	
			if ( typeof type.BYTES_PER_ELEMENT === 'number' ) {
	
				return new type( array ); // create typed array
	
			}
	
			return Array.prototype.slice.call( array ); // create Array
	
		},
	
		isTypedArray: function ( object ) {
	
			return ArrayBuffer.isView( object ) &&
				! ( object instanceof DataView );
	
		},
	
		// returns an array by which times and values can be sorted
		getKeyframeOrder: function ( times ) {
	
			function compareTime( i, j ) {
	
				return times[ i ] - times[ j ];
	
			}
	
			var n = times.length;
			var result = new Array( n );
			for ( var i = 0; i !== n; ++ i ) result[ i ] = i;
	
			result.sort( compareTime );
	
			return result;
	
		},
	
		// uses the array previously returned by 'getKeyframeOrder' to sort data
		sortedArray: function ( values, stride, order ) {
	
			var nValues = values.length;
			var result = new values.constructor( nValues );
	
			for ( var i = 0, dstOffset = 0; dstOffset !== nValues; ++ i ) {
	
				var srcOffset = order[ i ] * stride;
	
				for ( var j = 0; j !== stride; ++ j ) {
	
					result[ dstOffset ++ ] = values[ srcOffset + j ];
	
				}
	
			}
	
			return result;
	
		},
	
		// function for parsing AOS keyframe formats
		flattenJSON: function ( jsonKeys, times, values, valuePropertyName ) {
	
			var i = 1, key = jsonKeys[ 0 ];
	
			while ( key !== undefined && key[ valuePropertyName ] === undefined ) {
	
				key = jsonKeys[ i ++ ];
	
			}
	
			if ( key === undefined ) return; // no data
	
			var value = key[ valuePropertyName ];
			if ( value === undefined ) return; // no data
	
			if ( Array.isArray( value ) ) {
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push.apply( values, value ); // push all elements
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else if ( value.toArray !== undefined ) {
	
				// ...assume THREE.Math-ish
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						value.toArray( values, values.length );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			} else {
	
				// otherwise push as-is
	
				do {
	
					value = key[ valuePropertyName ];
	
					if ( value !== undefined ) {
	
						times.push( key.time );
						values.push( value );
	
					}
	
					key = jsonKeys[ i ++ ];
	
				} while ( key !== undefined );
	
			}
	
		}
	
	};
	
	/**
	 * Abstract base class of interpolants over parametric samples.
	 *
	 * The parameter domain is one dimensional, typically the time or a path
	 * along a curve defined by the data.
	 *
	 * The sample values can have any dimensionality and derived classes may
	 * apply special interpretations to the data.
	 *
	 * This class provides the interval seek in a Template Method, deferring
	 * the actual interpolation to derived classes.
	 *
	 * Time complexity is O(1) for linear access crossing at most two points
	 * and O(log N) for random access, where N is the number of positions.
	 *
	 * References:
	 *
	 * 		http://www.oodesign.com/template-method-pattern.html
	 *
	 * @author tschw
	 */
	
	function Interpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		this.parameterPositions = parameterPositions;
		this._cachedIndex = 0;
	
		this.resultBuffer = resultBuffer !== undefined ?
			resultBuffer : new sampleValues.constructor( sampleSize );
		this.sampleValues = sampleValues;
		this.valueSize = sampleSize;
	
	}
	
	Object.assign( Interpolant.prototype, {
	
		evaluate: function ( t ) {
	
			var pp = this.parameterPositions,
				i1 = this._cachedIndex,
	
				t1 = pp[ i1 ],
				t0 = pp[ i1 - 1 ];
	
			validate_interval: {
	
				seek: {
	
					var right;
	
					linear_scan: {
	
						//- See http://jsperf.com/comparison-to-undefined/3
						//- slower code:
						//-
						//- 				if ( t >= t1 || t1 === undefined ) {
						forward_scan: if ( ! ( t < t1 ) ) {
	
							for ( var giveUpAt = i1 + 2; ; ) {
	
								if ( t1 === undefined ) {
	
									if ( t < t0 ) break forward_scan;
	
									// after end
	
									i1 = pp.length;
									this._cachedIndex = i1;
									return this.afterEnd_( i1 - 1, t, t0 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t0 = t1;
								t1 = pp[ ++ i1 ];
	
								if ( t < t1 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the right side of the index
							right = pp.length;
							break linear_scan;
	
						}
	
						//- slower code:
						//-					if ( t < t0 || t0 === undefined ) {
						if ( ! ( t >= t0 ) ) {
	
							// looping?
	
							var t1global = pp[ 1 ];
	
							if ( t < t1global ) {
	
								i1 = 2; // + 1, using the scan for the details
								t0 = t1global;
	
							}
	
							// linear reverse scan
	
							for ( var giveUpAt = i1 - 2; ; ) {
	
								if ( t0 === undefined ) {
	
									// before start
	
									this._cachedIndex = 0;
									return this.beforeStart_( 0, t, t1 );
	
								}
	
								if ( i1 === giveUpAt ) break; // this loop
	
								t1 = t0;
								t0 = pp[ -- i1 - 1 ];
	
								if ( t >= t0 ) {
	
									// we have arrived at the sought interval
									break seek;
	
								}
	
							}
	
							// prepare binary search on the left side of the index
							right = i1;
							i1 = 0;
							break linear_scan;
	
						}
	
						// the interval is valid
	
						break validate_interval;
	
					} // linear scan
	
					// binary search
	
					while ( i1 < right ) {
	
						var mid = ( i1 + right ) >>> 1;
	
						if ( t < pp[ mid ] ) {
	
							right = mid;
	
						} else {
	
							i1 = mid + 1;
	
						}
	
					}
	
					t1 = pp[ i1 ];
					t0 = pp[ i1 - 1 ];
	
					// check boundary cases, again
	
					if ( t0 === undefined ) {
	
						this._cachedIndex = 0;
						return this.beforeStart_( 0, t, t1 );
	
					}
	
					if ( t1 === undefined ) {
	
						i1 = pp.length;
						this._cachedIndex = i1;
						return this.afterEnd_( i1 - 1, t0, t );
	
					}
	
				} // seek
	
				this._cachedIndex = i1;
	
				this.intervalChanged_( i1, t0, t1 );
	
			} // validate_interval
	
			return this.interpolate_( i1, t0, t, t1 );
	
		},
	
		settings: null, // optional, subclass-specific settings structure
		// Note: The indirection allows central control of many interpolants.
	
		// --- Protected interface
	
		DefaultSettings_: {},
	
		getSettings_: function () {
	
			return this.settings || this.DefaultSettings_;
	
		},
	
		copySampleValue_: function ( index ) {
	
			// copies a sample value to the result buffer
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
				offset = index * stride;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] = values[ offset + i ];
	
			}
	
			return result;
	
		},
	
		// Template methods for derived classes:
	
		interpolate_: function ( /* i1, t0, t, t1 */ ) {
	
			throw new Error( 'call to abstract method' );
			// implementations shall return this.resultBuffer
	
		},
	
		intervalChanged_: function ( /* i1, t0, t1 */ ) {
	
			// empty
	
		}
	
	} );
	
	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( Interpolant.prototype, {
	
		//( 0, t, t0 ), returns this.resultBuffer
		beforeStart_: Interpolant.prototype.copySampleValue_,
	
		//( N-1, tN-1, t ), returns this.resultBuffer
		afterEnd_: Interpolant.prototype.copySampleValue_,
	
	} );
	
	/**
	 * Fast and simple cubic spline interpolant.
	 *
	 * It was derived from a Hermitian construction setting the first derivative
	 * at each sample position to the linear slope between neighboring positions
	 * over their parameter interval.
	 *
	 * @author tschw
	 */
	
	function CubicInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
		this._weightPrev = - 0;
		this._offsetPrev = - 0;
		this._weightNext = - 0;
		this._offsetNext = - 0;
	
	}
	
	CubicInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
		constructor: CubicInterpolant,
	
		DefaultSettings_: {
	
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
	
		},
	
		intervalChanged_: function ( i1, t0, t1 ) {
	
			var pp = this.parameterPositions,
				iPrev = i1 - 2,
				iNext = i1 + 1,
	
				tPrev = pp[ iPrev ],
				tNext = pp[ iNext ];
	
			if ( tPrev === undefined ) {
	
				switch ( this.getSettings_().endingStart ) {
	
					case ZeroSlopeEnding:
	
						// f'(t0) = 0
						iPrev = i1;
						tPrev = 2 * t0 - t1;
	
						break;
	
					case WrapAroundEnding:
	
						// use the other end of the curve
						iPrev = pp.length - 2;
						tPrev = t0 + pp[ iPrev ] - pp[ iPrev + 1 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(t0) = 0 a.k.a. Natural Spline
						iPrev = i1;
						tPrev = t1;
	
				}
	
			}
	
			if ( tNext === undefined ) {
	
				switch ( this.getSettings_().endingEnd ) {
	
					case ZeroSlopeEnding:
	
						// f'(tN) = 0
						iNext = i1;
						tNext = 2 * t1 - t0;
	
						break;
	
					case WrapAroundEnding:
	
						// use the other end of the curve
						iNext = 1;
						tNext = t1 + pp[ 1 ] - pp[ 0 ];
	
						break;
	
					default: // ZeroCurvatureEnding
	
						// f''(tN) = 0, a.k.a. Natural Spline
						iNext = i1 - 1;
						tNext = t0;
	
				}
	
			}
	
			var halfDt = ( t1 - t0 ) * 0.5,
				stride = this.valueSize;
	
			this._weightPrev = halfDt / ( t0 - tPrev );
			this._weightNext = halfDt / ( tNext - t1 );
			this._offsetPrev = iPrev * stride;
			this._offsetNext = iNext * stride;
	
		},
	
		interpolate_: function ( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				o1 = i1 * stride,		o0 = o1 - stride,
				oP = this._offsetPrev, 	oN = this._offsetNext,
				wP = this._weightPrev,	wN = this._weightNext,
	
				p = ( t - t0 ) / ( t1 - t0 ),
				pp = p * p,
				ppp = pp * p;
	
			// evaluate polynomials
	
			var sP = - wP * ppp + 2 * wP * pp - wP * p;
			var s0 = ( 1 + wP ) * ppp + ( - 1.5 - 2 * wP ) * pp + ( - 0.5 + wP ) * p + 1;
			var s1 = ( - 1 - wN ) * ppp + ( 1.5 + wN ) * pp + 0.5 * p;
			var sN = wN * ppp - wN * pp;
	
			// combine data linearly
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						sP * values[ oP + i ] +
						s0 * values[ o0 + i ] +
						s1 * values[ o1 + i ] +
						sN * values[ oN + i ];
	
			}
	
			return result;
	
		}
	
	} );
	
	/**
	 * @author tschw
	 */
	
	function LinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	}
	
	LinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
		constructor: LinearInterpolant,
	
		interpolate_: function ( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset1 = i1 * stride,
				offset0 = offset1 - stride,
	
				weight1 = ( t - t0 ) / ( t1 - t0 ),
				weight0 = 1 - weight1;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				result[ i ] =
						values[ offset0 + i ] * weight0 +
						values[ offset1 + i ] * weight1;
	
			}
	
			return result;
	
		}
	
	} );
	
	/**
	 *
	 * Interpolant that evaluates to the sample value at the position preceeding
	 * the parameter.
	 *
	 * @author tschw
	 */
	
	function DiscreteInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	}
	
	DiscreteInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
		constructor: DiscreteInterpolant,
	
		interpolate_: function ( i1 /*, t0, t, t1 */ ) {
	
			return this.copySampleValue_( i1 - 1 );
	
		}
	
	} );
	
	/**
	 *
	 * A timed sequence of keyframes for a specific property.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function KeyframeTrack( name, times, values, interpolation ) {
	
		if ( name === undefined ) throw new Error( 'THREE.KeyframeTrack: track name is undefined' );
		if ( times === undefined || times.length === 0 ) throw new Error( 'THREE.KeyframeTrack: no keyframes in track named ' + name );
	
		this.name = name;
	
		this.times = AnimationUtils.convertArray( times, this.TimeBufferType );
		this.values = AnimationUtils.convertArray( values, this.ValueBufferType );
	
		this.setInterpolation( interpolation || this.DefaultInterpolation );
	
	}
	
	// Static methods
	
	Object.assign( KeyframeTrack, {
	
		// Serialization (in static context, because of constructor invocation
		// and automatic invocation of .toJSON):
	
		toJSON: function ( track ) {
	
			var trackType = track.constructor;
	
			var json;
	
			// derived classes can define a static toJSON method
			if ( trackType.toJSON !== undefined ) {
	
				json = trackType.toJSON( track );
	
			} else {
	
				// by default, we assume the data can be serialized as-is
				json = {
	
					'name': track.name,
					'times': AnimationUtils.convertArray( track.times, Array ),
					'values': AnimationUtils.convertArray( track.values, Array )
	
				};
	
				var interpolation = track.getInterpolation();
	
				if ( interpolation !== track.DefaultInterpolation ) {
	
					json.interpolation = interpolation;
	
				}
	
			}
	
			json.type = track.ValueTypeName; // mandatory
	
			return json;
	
		}
	
	} );
	
	Object.assign( KeyframeTrack.prototype, {
	
		constructor: KeyframeTrack,
	
		TimeBufferType: Float32Array,
	
		ValueBufferType: Float32Array,
	
		DefaultInterpolation: InterpolateLinear,
	
		InterpolantFactoryMethodDiscrete: function ( result ) {
	
			return new DiscreteInterpolant( this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodLinear: function ( result ) {
	
			return new LinearInterpolant( this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: function ( result ) {
	
			return new CubicInterpolant( this.times, this.values, this.getValueSize(), result );
	
		},
	
		setInterpolation: function ( interpolation ) {
	
			var factoryMethod;
	
			switch ( interpolation ) {
	
				case InterpolateDiscrete:
	
					factoryMethod = this.InterpolantFactoryMethodDiscrete;
	
					break;
	
				case InterpolateLinear:
	
					factoryMethod = this.InterpolantFactoryMethodLinear;
	
					break;
	
				case InterpolateSmooth:
	
					factoryMethod = this.InterpolantFactoryMethodSmooth;
	
					break;
	
			}
	
			if ( factoryMethod === undefined ) {
	
				var message = "unsupported interpolation for " +
					this.ValueTypeName + " keyframe track named " + this.name;
	
				if ( this.createInterpolant === undefined ) {
	
					// fall back to default, unless the default itself is messed up
					if ( interpolation !== this.DefaultInterpolation ) {
	
						this.setInterpolation( this.DefaultInterpolation );
	
					} else {
	
						throw new Error( message ); // fatal, in this case
	
					}
	
				}
	
				console.warn( 'THREE.KeyframeTrack:', message );
				return this;
	
			}
	
			this.createInterpolant = factoryMethod;
	
			return this;
	
		},
	
		getInterpolation: function () {
	
			switch ( this.createInterpolant ) {
	
				case this.InterpolantFactoryMethodDiscrete:
	
					return InterpolateDiscrete;
	
				case this.InterpolantFactoryMethodLinear:
	
					return InterpolateLinear;
	
				case this.InterpolantFactoryMethodSmooth:
	
					return InterpolateSmooth;
	
			}
	
		},
	
		getValueSize: function () {
	
			return this.values.length / this.times.length;
	
		},
	
		// move all keyframes either forwards or backwards in time
		shift: function ( timeOffset ) {
	
			if ( timeOffset !== 0.0 ) {
	
				var times = this.times;
	
				for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] += timeOffset;
	
				}
	
			}
	
			return this;
	
		},
	
		// scale all keyframe times by a factor (useful for frame <-> seconds conversions)
		scale: function ( timeScale ) {
	
			if ( timeScale !== 1.0 ) {
	
				var times = this.times;
	
				for ( var i = 0, n = times.length; i !== n; ++ i ) {
	
					times[ i ] *= timeScale;
	
				}
	
			}
	
			return this;
	
		},
	
		// removes keyframes before and after animation without changing any values within the range [startTime, endTime].
		// IMPORTANT: We do not shift around keys to the start of the track time, because for interpolated keys this will change their values
		trim: function ( startTime, endTime ) {
	
			var times = this.times,
				nKeys = times.length,
				from = 0,
				to = nKeys - 1;
	
			while ( from !== nKeys && times[ from ] < startTime ) {
	
				++ from;
	
			}
	
			while ( to !== - 1 && times[ to ] > endTime ) {
	
				-- to;
	
			}
	
			++ to; // inclusive -> exclusive bound
	
			if ( from !== 0 || to !== nKeys ) {
	
				// empty tracks are forbidden, so keep at least one keyframe
				if ( from >= to ) to = Math.max( to, 1 ), from = to - 1;
	
				var stride = this.getValueSize();
				this.times = AnimationUtils.arraySlice( times, from, to );
				this.values = AnimationUtils.arraySlice( this.values, from * stride, to * stride );
	
			}
	
			return this;
	
		},
	
		// ensure we do not get a GarbageInGarbageOut situation, make sure tracks are at least minimally viable
		validate: function () {
	
			var valid = true;
	
			var valueSize = this.getValueSize();
			if ( valueSize - Math.floor( valueSize ) !== 0 ) {
	
				console.error( 'THREE.KeyframeTrack: Invalid value size in track.', this );
				valid = false;
	
			}
	
			var times = this.times,
				values = this.values,
	
				nKeys = times.length;
	
			if ( nKeys === 0 ) {
	
				console.error( 'THREE.KeyframeTrack: Track is empty.', this );
				valid = false;
	
			}
	
			var prevTime = null;
	
			for ( var i = 0; i !== nKeys; i ++ ) {
	
				var currTime = times[ i ];
	
				if ( typeof currTime === 'number' && isNaN( currTime ) ) {
	
					console.error( 'THREE.KeyframeTrack: Time is not a valid number.', this, i, currTime );
					valid = false;
					break;
	
				}
	
				if ( prevTime !== null && prevTime > currTime ) {
	
					console.error( 'THREE.KeyframeTrack: Out of order keys.', this, i, currTime, prevTime );
					valid = false;
					break;
	
				}
	
				prevTime = currTime;
	
			}
	
			if ( values !== undefined ) {
	
				if ( AnimationUtils.isTypedArray( values ) ) {
	
					for ( var i = 0, n = values.length; i !== n; ++ i ) {
	
						var value = values[ i ];
	
						if ( isNaN( value ) ) {
	
							console.error( 'THREE.KeyframeTrack: Value is not a valid number.', this, i, value );
							valid = false;
							break;
	
						}
	
					}
	
				}
	
			}
	
			return valid;
	
		},
	
		// removes equivalent sequential keys as common in morph target sequences
		// (0,0,0,0,1,1,1,0,0,0,0,0,0,0) --> (0,0,1,1,0,0)
		optimize: function () {
	
			var times = this.times,
				values = this.values,
				stride = this.getValueSize(),
	
				smoothInterpolation = this.getInterpolation() === InterpolateSmooth,
	
				writeIndex = 1,
				lastIndex = times.length - 1;
	
			for ( var i = 1; i < lastIndex; ++ i ) {
	
				var keep = false;
	
				var time = times[ i ];
				var timeNext = times[ i + 1 ];
	
				// remove adjacent keyframes scheduled at the same time
	
				if ( time !== timeNext && ( i !== 1 || time !== time[ 0 ] ) ) {
	
					if ( ! smoothInterpolation ) {
	
						// remove unnecessary keyframes same as their neighbors
	
						var offset = i * stride,
							offsetP = offset - stride,
							offsetN = offset + stride;
	
						for ( var j = 0; j !== stride; ++ j ) {
	
							var value = values[ offset + j ];
	
							if ( value !== values[ offsetP + j ] ||
								value !== values[ offsetN + j ] ) {
	
								keep = true;
								break;
	
							}
	
						}
	
					} else {
	
						keep = true;
	
					}
	
				}
	
				// in-place compaction
	
				if ( keep ) {
	
					if ( i !== writeIndex ) {
	
						times[ writeIndex ] = times[ i ];
	
						var readOffset = i * stride,
							writeOffset = writeIndex * stride;
	
						for ( var j = 0; j !== stride; ++ j ) {
	
							values[ writeOffset + j ] = values[ readOffset + j ];
	
						}
	
					}
	
					++ writeIndex;
	
				}
	
			}
	
			// flush last keyframe (compaction looks ahead)
	
			if ( lastIndex > 0 ) {
	
				times[ writeIndex ] = times[ lastIndex ];
	
				for ( var readOffset = lastIndex * stride, writeOffset = writeIndex * stride, j = 0; j !== stride; ++ j ) {
	
					values[ writeOffset + j ] = values[ readOffset + j ];
	
				}
	
				++ writeIndex;
	
			}
	
			if ( writeIndex !== times.length ) {
	
				this.times = AnimationUtils.arraySlice( times, 0, writeIndex );
				this.values = AnimationUtils.arraySlice( values, 0, writeIndex * stride );
	
			}
	
			return this;
	
		},
	
		clone: function () {
	
			var times = AnimationUtils.arraySlice( this.times, 0 );
			var values = AnimationUtils.arraySlice( this.values, 0 );
	
			var TypedKeyframeTrack = this.constructor;
			var track = new TypedKeyframeTrack( this.name, times, values );
	
			// Interpolant argument to constructor is not saved, so copy the factory method directly.
			track.createInterpolant = this.createInterpolant;
	
			return track;
	
		}
	
	} );
	
	/**
	 *
	 * A Track of Boolean keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function BooleanKeyframeTrack( name, times, values ) {
	
		KeyframeTrack.call( this, name, times, values );
	
	}
	
	BooleanKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
	
		constructor: BooleanKeyframeTrack,
	
		ValueTypeName: 'bool',
		ValueBufferType: Array,
	
		DefaultInterpolation: InterpolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
		InterpolantFactoryMethodSmooth: undefined
	
		// Note: Actually this track could have a optimized / compressed
		// representation of a single value and a custom interpolant that
		// computes "firstValue ^ isOdd( index )".
	
	} );
	
	/**
	 *
	 * A Track of keyframe values that represent color.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function ColorKeyframeTrack( name, times, values, interpolation ) {
	
		KeyframeTrack.call( this, name, times, values, interpolation );
	
	}
	
	ColorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
	
		constructor: ColorKeyframeTrack,
	
		ValueTypeName: 'color'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
		// Note: Very basic implementation and nothing special yet.
		// However, this is the place for color space parameterization.
	
	} );
	
	/**
	 *
	 * A Track of numeric keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function NumberKeyframeTrack( name, times, values, interpolation ) {
	
		KeyframeTrack.call( this, name, times, values, interpolation );
	
	}
	
	NumberKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
	
		constructor: NumberKeyframeTrack,
	
		ValueTypeName: 'number'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	/**
	 * Spherical linear unit quaternion interpolant.
	 *
	 * @author tschw
	 */
	
	function QuaternionLinearInterpolant( parameterPositions, sampleValues, sampleSize, resultBuffer ) {
	
		Interpolant.call( this, parameterPositions, sampleValues, sampleSize, resultBuffer );
	
	}
	
	QuaternionLinearInterpolant.prototype = Object.assign( Object.create( Interpolant.prototype ), {
	
		constructor: QuaternionLinearInterpolant,
	
		interpolate_: function ( i1, t0, t, t1 ) {
	
			var result = this.resultBuffer,
				values = this.sampleValues,
				stride = this.valueSize,
	
				offset = i1 * stride,
	
				alpha = ( t - t0 ) / ( t1 - t0 );
	
			for ( var end = offset + stride; offset !== end; offset += 4 ) {
	
				Quaternion.slerpFlat( result, 0, values, offset - stride, values, offset, alpha );
	
			}
	
			return result;
	
		}
	
	} );
	
	/**
	 *
	 * A Track of quaternion keyframe values.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function QuaternionKeyframeTrack( name, times, values, interpolation ) {
	
		KeyframeTrack.call( this, name, times, values, interpolation );
	
	}
	
	QuaternionKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
	
		constructor: QuaternionKeyframeTrack,
	
		ValueTypeName: 'quaternion',
	
		// ValueBufferType is inherited
	
		DefaultInterpolation: InterpolateLinear,
	
		InterpolantFactoryMethodLinear: function ( result ) {
	
			return new QuaternionLinearInterpolant( this.times, this.values, this.getValueSize(), result );
	
		},
	
		InterpolantFactoryMethodSmooth: undefined // not yet implemented
	
	} );
	
	/**
	 *
	 * A Track that interpolates Strings
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function StringKeyframeTrack( name, times, values, interpolation ) {
	
		KeyframeTrack.call( this, name, times, values, interpolation );
	
	}
	
	StringKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
	
		constructor: StringKeyframeTrack,
	
		ValueTypeName: 'string',
		ValueBufferType: Array,
	
		DefaultInterpolation: InterpolateDiscrete,
	
		InterpolantFactoryMethodLinear: undefined,
	
		InterpolantFactoryMethodSmooth: undefined
	
	} );
	
	/**
	 *
	 * A Track of vectored keyframe values.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function VectorKeyframeTrack( name, times, values, interpolation ) {
	
		KeyframeTrack.call( this, name, times, values, interpolation );
	
	}
	
	VectorKeyframeTrack.prototype = Object.assign( Object.create( KeyframeTrack.prototype ), {
	
		constructor: VectorKeyframeTrack,
	
		ValueTypeName: 'vector'
	
		// ValueBufferType is inherited
	
		// DefaultInterpolation is inherited
	
	} );
	
	/**
	 *
	 * Reusable set of Tracks that represent an animation.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 */
	
	function AnimationClip( name, duration, tracks ) {
	
		this.name = name;
		this.tracks = tracks;
		this.duration = ( duration !== undefined ) ? duration : - 1;
	
		this.uuid = _Math.generateUUID();
	
		// this means it should figure out its duration by scanning the tracks
		if ( this.duration < 0 ) {
	
			this.resetDuration();
	
		}
	
	}
	
	function getTrackTypeForValueTypeName( typeName ) {
	
		switch ( typeName.toLowerCase() ) {
	
			case 'scalar':
			case 'double':
			case 'float':
			case 'number':
			case 'integer':
	
				return NumberKeyframeTrack;
	
			case 'vector':
			case 'vector2':
			case 'vector3':
			case 'vector4':
	
				return VectorKeyframeTrack;
	
			case 'color':
	
				return ColorKeyframeTrack;
	
			case 'quaternion':
	
				return QuaternionKeyframeTrack;
	
			case 'bool':
			case 'boolean':
	
				return BooleanKeyframeTrack;
	
			case 'string':
	
				return StringKeyframeTrack;
	
		}
	
		throw new Error( 'THREE.KeyframeTrack: Unsupported typeName: ' + typeName );
	
	}
	
	function parseKeyframeTrack( json ) {
	
		if ( json.type === undefined ) {
	
			throw new Error( 'THREE.KeyframeTrack: track type undefined, can not parse' );
	
		}
	
		var trackType = getTrackTypeForValueTypeName( json.type );
	
		if ( json.times === undefined ) {
	
			var times = [], values = [];
	
			AnimationUtils.flattenJSON( json.keys, times, values, 'value' );
	
			json.times = times;
			json.values = values;
	
		}
	
		// derived classes can define a static parse method
		if ( trackType.parse !== undefined ) {
	
			return trackType.parse( json );
	
		} else {
	
			// by default, we assume a constructor compatible with the base
			return new trackType( json.name, json.times, json.values, json.interpolation );
	
		}
	
	}
	
	Object.assign( AnimationClip, {
	
		parse: function ( json ) {
	
			var tracks = [],
				jsonTracks = json.tracks,
				frameTime = 1.0 / ( json.fps || 1.0 );
	
			for ( var i = 0, n = jsonTracks.length; i !== n; ++ i ) {
	
				tracks.push( parseKeyframeTrack( jsonTracks[ i ] ).scale( frameTime ) );
	
			}
	
			return new AnimationClip( json.name, json.duration, tracks );
	
		},
	
		toJSON: function ( clip ) {
	
			var tracks = [],
				clipTracks = clip.tracks;
	
			var json = {
	
				'name': clip.name,
				'duration': clip.duration,
				'tracks': tracks,
				'uuid': clip.uuid
	
			};
	
			for ( var i = 0, n = clipTracks.length; i !== n; ++ i ) {
	
				tracks.push( KeyframeTrack.toJSON( clipTracks[ i ] ) );
	
			}
	
			return json;
	
		},
	
		CreateFromMorphTargetSequence: function ( name, morphTargetSequence, fps, noLoop ) {
	
			var numMorphTargets = morphTargetSequence.length;
			var tracks = [];
	
			for ( var i = 0; i < numMorphTargets; i ++ ) {
	
				var times = [];
				var values = [];
	
				times.push(
					( i + numMorphTargets - 1 ) % numMorphTargets,
					i,
					( i + 1 ) % numMorphTargets );
	
				values.push( 0, 1, 0 );
	
				var order = AnimationUtils.getKeyframeOrder( times );
				times = AnimationUtils.sortedArray( times, 1, order );
				values = AnimationUtils.sortedArray( values, 1, order );
	
				// if there is a key at the first frame, duplicate it as the
				// last frame as well for perfect loop.
				if ( ! noLoop && times[ 0 ] === 0 ) {
	
					times.push( numMorphTargets );
					values.push( values[ 0 ] );
	
				}
	
				tracks.push(
					new NumberKeyframeTrack(
						'.morphTargetInfluences[' + morphTargetSequence[ i ].name + ']',
						times, values
					).scale( 1.0 / fps ) );
	
			}
	
			return new AnimationClip( name, - 1, tracks );
	
		},
	
		findByName: function ( objectOrClipArray, name ) {
	
			var clipArray = objectOrClipArray;
	
			if ( ! Array.isArray( objectOrClipArray ) ) {
	
				var o = objectOrClipArray;
				clipArray = o.geometry && o.geometry.animations || o.animations;
	
			}
	
			for ( var i = 0; i < clipArray.length; i ++ ) {
	
				if ( clipArray[ i ].name === name ) {
	
					return clipArray[ i ];
	
				}
	
			}
	
			return null;
	
		},
	
		CreateClipsFromMorphTargetSequences: function ( morphTargets, fps, noLoop ) {
	
			var animationToMorphTargets = {};
	
			// tested with https://regex101.com/ on trick sequences
			// such flamingo_flyA_003, flamingo_run1_003, crdeath0059
			var pattern = /^([\w-]*?)([\d]+)$/;
	
			// sort morph target names into animation groups based
			// patterns like Walk_001, Walk_002, Run_001, Run_002
			for ( var i = 0, il = morphTargets.length; i < il; i ++ ) {
	
				var morphTarget = morphTargets[ i ];
				var parts = morphTarget.name.match( pattern );
	
				if ( parts && parts.length > 1 ) {
	
					var name = parts[ 1 ];
	
					var animationMorphTargets = animationToMorphTargets[ name ];
					if ( ! animationMorphTargets ) {
	
						animationToMorphTargets[ name ] = animationMorphTargets = [];
	
					}
	
					animationMorphTargets.push( morphTarget );
	
				}
	
			}
	
			var clips = [];
	
			for ( var name in animationToMorphTargets ) {
	
				clips.push( AnimationClip.CreateFromMorphTargetSequence( name, animationToMorphTargets[ name ], fps, noLoop ) );
	
			}
	
			return clips;
	
		},
	
		// parse the animation.hierarchy format
		parseAnimation: function ( animation, bones ) {
	
			if ( ! animation ) {
	
				console.error( 'THREE.AnimationClip: No animation in JSONLoader data.' );
				return null;
	
			}
	
			var addNonemptyTrack = function ( trackType, trackName, animationKeys, propertyName, destTracks ) {
	
				// only return track if there are actually keys.
				if ( animationKeys.length !== 0 ) {
	
					var times = [];
					var values = [];
	
					AnimationUtils.flattenJSON( animationKeys, times, values, propertyName );
	
					// empty keys are filtered out, so check again
					if ( times.length !== 0 ) {
	
						destTracks.push( new trackType( trackName, times, values ) );
	
					}
	
				}
	
			};
	
			var tracks = [];
	
			var clipName = animation.name || 'default';
			// automatic length determination in AnimationClip.
			var duration = animation.length || - 1;
			var fps = animation.fps || 30;
	
			var hierarchyTracks = animation.hierarchy || [];
	
			for ( var h = 0; h < hierarchyTracks.length; h ++ ) {
	
				var animationKeys = hierarchyTracks[ h ].keys;
	
				// skip empty tracks
				if ( ! animationKeys || animationKeys.length === 0 ) continue;
	
				// process morph targets
				if ( animationKeys[ 0 ].morphTargets ) {
	
					// figure out all morph targets used in this track
					var morphTargetNames = {};
	
					for ( var k = 0; k < animationKeys.length; k ++ ) {
	
						if ( animationKeys[ k ].morphTargets ) {
	
							for ( var m = 0; m < animationKeys[ k ].morphTargets.length; m ++ ) {
	
								morphTargetNames[ animationKeys[ k ].morphTargets[ m ] ] = - 1;
	
							}
	
						}
	
					}
	
					// create a track for each morph target with all zero
					// morphTargetInfluences except for the keys in which
					// the morphTarget is named.
					for ( var morphTargetName in morphTargetNames ) {
	
						var times = [];
						var values = [];
	
						for ( var m = 0; m !== animationKeys[ k ].morphTargets.length; ++ m ) {
	
							var animationKey = animationKeys[ k ];
	
							times.push( animationKey.time );
							values.push( ( animationKey.morphTarget === morphTargetName ) ? 1 : 0 );
	
						}
	
						tracks.push( new NumberKeyframeTrack( '.morphTargetInfluence[' + morphTargetName + ']', times, values ) );
	
					}
	
					duration = morphTargetNames.length * ( fps || 1.0 );
	
				} else {
	
					// ...assume skeletal animation
	
					var boneName = '.bones[' + bones[ h ].name + ']';
	
					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.position',
						animationKeys, 'pos', tracks );
	
					addNonemptyTrack(
						QuaternionKeyframeTrack, boneName + '.quaternion',
						animationKeys, 'rot', tracks );
	
					addNonemptyTrack(
						VectorKeyframeTrack, boneName + '.scale',
						animationKeys, 'scl', tracks );
	
				}
	
			}
	
			if ( tracks.length === 0 ) {
	
				return null;
	
			}
	
			var clip = new AnimationClip( clipName, duration, tracks );
	
			return clip;
	
		}
	
	} );
	
	Object.assign( AnimationClip.prototype, {
	
		resetDuration: function () {
	
			var tracks = this.tracks, duration = 0;
	
			for ( var i = 0, n = tracks.length; i !== n; ++ i ) {
	
				var track = this.tracks[ i ];
	
				duration = Math.max( duration, track.times[ track.times.length - 1 ] );
	
			}
	
			this.duration = duration;
	
			return this;
	
		},
	
		trim: function () {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].trim( 0, this.duration );
	
			}
	
			return this;
	
		},
	
		validate: function () {
	
			var valid = true;
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				valid = valid && this.tracks[ i ].validate();
	
			}
	
			return valid;
	
		},
	
		optimize: function () {
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				this.tracks[ i ].optimize();
	
			}
	
			return this;
	
		},
	
	
		clone: function () {
	
			var tracks = [];
	
			for ( var i = 0; i < this.tracks.length; i ++ ) {
	
				tracks.push( this.tracks[ i ].clone() );
	
			}
	
			return new AnimationClip( this.name, this.duration, tracks );
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var Cache = {
	
		enabled: false,
	
		files: {},
	
		add: function ( key, file ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Adding key:', key );
	
			this.files[ key ] = file;
	
		},
	
		get: function ( key ) {
	
			if ( this.enabled === false ) return;
	
			// console.log( 'THREE.Cache', 'Checking key:', key );
	
			return this.files[ key ];
	
		},
	
		remove: function ( key ) {
	
			delete this.files[ key ];
	
		},
	
		clear: function () {
	
			this.files = {};
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function LoadingManager( onLoad, onProgress, onError ) {
	
		var scope = this;
	
		var isLoading = false;
		var itemsLoaded = 0;
		var itemsTotal = 0;
		var urlModifier = undefined;
	
		// Refer to #5689 for the reason why we don't set .onStart
		// in the constructor
	
		this.onStart = undefined;
		this.onLoad = onLoad;
		this.onProgress = onProgress;
		this.onError = onError;
	
		this.itemStart = function ( url ) {
	
			itemsTotal ++;
	
			if ( isLoading === false ) {
	
				if ( scope.onStart !== undefined ) {
	
					scope.onStart( url, itemsLoaded, itemsTotal );
	
				}
	
			}
	
			isLoading = true;
	
		};
	
		this.itemEnd = function ( url ) {
	
			itemsLoaded ++;
	
			if ( scope.onProgress !== undefined ) {
	
				scope.onProgress( url, itemsLoaded, itemsTotal );
	
			}
	
			if ( itemsLoaded === itemsTotal ) {
	
				isLoading = false;
	
				if ( scope.onLoad !== undefined ) {
	
					scope.onLoad();
	
				}
	
			}
	
		};
	
		this.itemError = function ( url ) {
	
			if ( scope.onError !== undefined ) {
	
				scope.onError( url );
	
			}
	
		};
	
		this.resolveURL = function ( url ) {
	
			if ( urlModifier ) {
	
				return urlModifier( url );
	
			}
	
			return url;
	
		};
	
		this.setURLModifier = function ( transform ) {
	
			urlModifier = transform;
			return this;
	
		};
	
	}
	
	var DefaultLoadingManager = new LoadingManager();
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var loading = {};
	
	function FileLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( FileLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( url === undefined ) url = '';
	
			if ( this.path !== undefined ) url = this.path + url;
	
			url = this.manager.resolveURL( url );
	
			var scope = this;
	
			var cached = Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				setTimeout( function () {
	
					if ( onLoad ) onLoad( cached );
	
					scope.manager.itemEnd( url );
	
				}, 0 );
	
				return cached;
	
			}
	
			// Check if request is duplicate
	
			if ( loading[ url ] !== undefined ) {
	
				loading[ url ].push( {
	
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
	
				} );
	
				return;
	
			}
	
			// Check for data: URI
			var dataUriRegex = /^data:(.*?)(;base64)?,(.*)$/;
			var dataUriRegexResult = url.match( dataUriRegex );
	
			// Safari can not handle Data URIs through XMLHttpRequest so process manually
			if ( dataUriRegexResult ) {
	
				var mimeType = dataUriRegexResult[ 1 ];
				var isBase64 = !! dataUriRegexResult[ 2 ];
				var data = dataUriRegexResult[ 3 ];
	
				data = decodeURIComponent( data );
	
				if ( isBase64 ) data = atob( data );
	
				try {
	
					var response;
					var responseType = ( this.responseType || '' ).toLowerCase();
	
					switch ( responseType ) {
	
						case 'arraybuffer':
						case 'blob':
	
							var view = new Uint8Array( data.length );
	
							for ( var i = 0; i < data.length; i ++ ) {
	
								view[ i ] = data.charCodeAt( i );
	
							}
	
							if ( responseType === 'blob' ) {
	
								response = new Blob( [ view.buffer ], { type: mimeType } );
	
							} else {
	
								response = view.buffer;
	
							}
	
							break;
	
						case 'document':
	
							var parser = new DOMParser();
							response = parser.parseFromString( data, mimeType );
	
							break;
	
						case 'json':
	
							response = JSON.parse( data );
	
							break;
	
						default: // 'text' or other
	
							response = data;
	
							break;
	
					}
	
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {
	
						if ( onLoad ) onLoad( response );
	
						scope.manager.itemEnd( url );
	
					}, 0 );
	
				} catch ( error ) {
	
					// Wait for next browser tick like standard XMLHttpRequest event dispatching does
					setTimeout( function () {
	
						if ( onError ) onError( error );
	
						scope.manager.itemError( url );
						scope.manager.itemEnd( url );
	
					}, 0 );
	
				}
	
			} else {
	
				// Initialise array for duplicate requests
	
				loading[ url ] = [];
	
				loading[ url ].push( {
	
					onLoad: onLoad,
					onProgress: onProgress,
					onError: onError
	
				} );
	
				var request = new XMLHttpRequest();
	
				request.open( 'GET', url, true );
	
				request.addEventListener( 'load', function ( event ) {
	
					var response = this.response;
	
					Cache.add( url, response );
	
					var callbacks = loading[ url ];
	
					delete loading[ url ];
	
					if ( this.status === 200 || this.status === 0 ) {
	
						// Some browsers return HTTP Status 0 when using non-http protocol
						// e.g. 'file://' or 'data://'. Handle as success.
	
						if ( this.status === 0 ) console.warn( 'THREE.FileLoader: HTTP Status 0 received.' );
	
						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
	
							var callback = callbacks[ i ];
							if ( callback.onLoad ) callback.onLoad( response );
	
						}
	
						scope.manager.itemEnd( url );
	
					} else {
	
						for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
	
							var callback = callbacks[ i ];
							if ( callback.onError ) callback.onError( event );
	
						}
	
						scope.manager.itemError( url );
						scope.manager.itemEnd( url );
	
					}
	
				}, false );
	
				request.addEventListener( 'progress', function ( event ) {
	
					var callbacks = loading[ url ];
	
					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
	
						var callback = callbacks[ i ];
						if ( callback.onProgress ) callback.onProgress( event );
	
					}
	
				}, false );
	
				request.addEventListener( 'error', function ( event ) {
	
					var callbacks = loading[ url ];
	
					delete loading[ url ];
	
					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
	
						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );
	
					}
	
					scope.manager.itemError( url );
					scope.manager.itemEnd( url );
	
				}, false );
	
				request.addEventListener( 'abort', function ( event ) {
	
					var callbacks = loading[ url ];
	
					delete loading[ url ];
	
					for ( var i = 0, il = callbacks.length; i < il; i ++ ) {
	
						var callback = callbacks[ i ];
						if ( callback.onError ) callback.onError( event );
	
					}
	
					scope.manager.itemError( url );
					scope.manager.itemEnd( url );
	
				}, false );
	
				if ( this.responseType !== undefined ) request.responseType = this.responseType;
				if ( this.withCredentials !== undefined ) request.withCredentials = this.withCredentials;
	
				if ( request.overrideMimeType ) request.overrideMimeType( this.mimeType !== undefined ? this.mimeType : 'text/plain' );
	
				for ( var header in this.requestHeader ) {
	
					request.setRequestHeader( header, this.requestHeader[ header ] );
	
				}
	
				request.send( null );
	
			}
	
			scope.manager.itemStart( url );
	
			return request;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		},
	
		setResponseType: function ( value ) {
	
			this.responseType = value;
			return this;
	
		},
	
		setWithCredentials: function ( value ) {
	
			this.withCredentials = value;
			return this;
	
		},
	
		setMimeType: function ( value ) {
	
			this.mimeType = value;
			return this;
	
		},
	
		setRequestHeader: function ( value ) {
	
			this.requestHeader = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io/
	 */
	
	function AnimationLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( AnimationLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json, onLoad ) {
	
			var animations = [];
	
			for ( var i = 0; i < json.length; i ++ ) {
	
				var clip = AnimationClip.parse( json[ i ] );
	
				animations.push( clip );
	
			}
	
			onLoad( animations );
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 *
	 * Abstract Base class to block based textures loader (dds, pvr, ...)
	 */
	
	function CompressedTextureLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	}
	
	Object.assign( CompressedTextureLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var images = [];
	
			var texture = new CompressedTexture();
			texture.image = images;
	
			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.setResponseType( 'arraybuffer' );
	
			function loadTexture( i ) {
	
				loader.load( url[ i ], function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					images[ i ] = {
						width: texDatas.width,
						height: texDatas.height,
						format: texDatas.format,
						mipmaps: texDatas.mipmaps
					};
	
					loaded += 1;
	
					if ( loaded === 6 ) {
	
						if ( texDatas.mipmapCount === 1 )
							texture.minFilter = LinearFilter;
	
						texture.format = texDatas.format;
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, onProgress, onError );
	
			}
	
			if ( Array.isArray( url ) ) {
	
				var loaded = 0;
	
				for ( var i = 0, il = url.length; i < il; ++ i ) {
	
					loadTexture( i );
	
				}
	
			} else {
	
				// compressed cubemap texture stored in a single DDS file
	
				loader.load( url, function ( buffer ) {
	
					var texDatas = scope._parser( buffer, true );
	
					if ( texDatas.isCubemap ) {
	
						var faces = texDatas.mipmaps.length / texDatas.mipmapCount;
	
						for ( var f = 0; f < faces; f ++ ) {
	
							images[ f ] = { mipmaps: [] };
	
							for ( var i = 0; i < texDatas.mipmapCount; i ++ ) {
	
								images[ f ].mipmaps.push( texDatas.mipmaps[ f * texDatas.mipmapCount + i ] );
								images[ f ].format = texDatas.format;
								images[ f ].width = texDatas.width;
								images[ f ].height = texDatas.height;
	
							}
	
						}
	
					} else {
	
						texture.image.width = texDatas.width;
						texture.image.height = texDatas.height;
						texture.mipmaps = texDatas.mipmaps;
	
					}
	
					if ( texDatas.mipmapCount === 1 ) {
	
						texture.minFilter = LinearFilter;
	
					}
	
					texture.format = texDatas.format;
					texture.needsUpdate = true;
	
					if ( onLoad ) onLoad( texture );
	
				}, onProgress, onError );
	
			}
	
			return texture;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author Nikos M. / https://github.com/foo123/
	 *
	 * Abstract Base class to load generic binary textures formats (rgbe, hdr, ...)
	 */
	
	function DataTextureLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
		// override in sub classes
		this._parser = null;
	
	}
	
	Object.assign( DataTextureLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var texture = new DataTexture();
	
			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.load( url, function ( buffer ) {
	
				var texData = scope._parser( buffer );
	
				if ( ! texData ) return;
	
				if ( texData.image !== undefined ) {
	
					texture.image = texData.image;
	
				} else if ( texData.data !== undefined ) {
	
					texture.image.width = texData.width;
					texture.image.height = texData.height;
					texture.image.data = texData.data;
	
				}
	
				texture.wrapS = texData.wrapS !== undefined ? texData.wrapS : ClampToEdgeWrapping;
				texture.wrapT = texData.wrapT !== undefined ? texData.wrapT : ClampToEdgeWrapping;
	
				texture.magFilter = texData.magFilter !== undefined ? texData.magFilter : LinearFilter;
				texture.minFilter = texData.minFilter !== undefined ? texData.minFilter : LinearMipMapLinearFilter;
	
				texture.anisotropy = texData.anisotropy !== undefined ? texData.anisotropy : 1;
	
				if ( texData.format !== undefined ) {
	
					texture.format = texData.format;
	
				}
				if ( texData.type !== undefined ) {
	
					texture.type = texData.type;
	
				}
	
				if ( texData.mipmaps !== undefined ) {
	
					texture.mipmaps = texData.mipmaps;
	
				}
	
				if ( texData.mipmapCount === 1 ) {
	
					texture.minFilter = LinearFilter;
	
				}
	
				texture.needsUpdate = true;
	
				if ( onLoad ) onLoad( texture, texData );
	
			}, onProgress, onError );
	
	
			return texture;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	function ImageLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( ImageLoader.prototype, {
	
		crossOrigin: 'anonymous',
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( url === undefined ) url = '';
	
			if ( this.path !== undefined ) url = this.path + url;
	
			url = this.manager.resolveURL( url );
	
			var scope = this;
	
			var cached = Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				setTimeout( function () {
	
					if ( onLoad ) onLoad( cached );
	
					scope.manager.itemEnd( url );
	
				}, 0 );
	
				return cached;
	
			}
	
			var image = document.createElementNS( 'http://www.w3.org/1999/xhtml', 'img' );
	
			function onImageLoad() {
	
				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );
	
				Cache.add( url, this );
	
				if ( onLoad ) onLoad( this );
	
				scope.manager.itemEnd( url );
	
			}
	
			function onImageError( event ) {
	
				image.removeEventListener( 'load', onImageLoad, false );
				image.removeEventListener( 'error', onImageError, false );
	
				if ( onError ) onError( event );
	
				scope.manager.itemError( url );
				scope.manager.itemEnd( url );
	
			}
	
			image.addEventListener( 'load', onImageLoad, false );
			image.addEventListener( 'error', onImageError, false );
	
			if ( url.substr( 0, 5 ) !== 'data:' ) {
	
				if ( this.crossOrigin !== undefined ) image.crossOrigin = this.crossOrigin;
	
			}
	
			scope.manager.itemStart( url );
	
			image.src = url;
	
			return image;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	function CubeTextureLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( CubeTextureLoader.prototype, {
	
		crossOrigin: 'anonymous',
	
		load: function ( urls, onLoad, onProgress, onError ) {
	
			var texture = new CubeTexture();
	
			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
	
			var loaded = 0;
	
			function loadTexture( i ) {
	
				loader.load( urls[ i ], function ( image ) {
	
					texture.images[ i ] = image;
	
					loaded ++;
	
					if ( loaded === 6 ) {
	
						texture.needsUpdate = true;
	
						if ( onLoad ) onLoad( texture );
	
					}
	
				}, undefined, onError );
	
			}
	
			for ( var i = 0; i < urls.length; ++ i ) {
	
				loadTexture( i );
	
			}
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	function TextureLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( TextureLoader.prototype, {
	
		crossOrigin: 'anonymous',
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var texture = new Texture();
	
			var loader = new ImageLoader( this.manager );
			loader.setCrossOrigin( this.crossOrigin );
			loader.setPath( this.path );
	
			loader.load( url, function ( image ) {
	
				texture.image = image;
	
				// JPEGs can't have an alpha channel, so memory can be saved by storing them as RGB.
				var isJPEG = url.search( /\.jpe?g($|\?)/i ) > 0 || url.search( /^data\:image\/jpeg/ ) === 0;
	
				texture.format = isJPEG ? RGBFormat : RGBAFormat;
				texture.needsUpdate = true;
	
				if ( onLoad !== undefined ) {
	
					onLoad( texture );
	
				}
	
			}, onProgress, onError );
	
			return texture;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Extensible curve object
	 *
	 * Some common of curve methods:
	 * .getPoint( t, optionalTarget ), .getTangent( t )
	 * .getPointAt( u, optionalTarget ), .getTangentAt( u )
	 * .getPoints(), .getSpacedPoints()
	 * .getLength()
	 * .updateArcLengths()
	 *
	 * This following curves inherit from THREE.Curve:
	 *
	 * -- 2D curves --
	 * THREE.ArcCurve
	 * THREE.CubicBezierCurve
	 * THREE.EllipseCurve
	 * THREE.LineCurve
	 * THREE.QuadraticBezierCurve
	 * THREE.SplineCurve
	 *
	 * -- 3D curves --
	 * THREE.CatmullRomCurve3
	 * THREE.CubicBezierCurve3
	 * THREE.LineCurve3
	 * THREE.QuadraticBezierCurve3
	 *
	 * A series of curves can be represented as a THREE.CurvePath.
	 *
	 **/
	
	/**************************************************************
	 *	Abstract Curve base class
	 **************************************************************/
	
	function Curve() {
	
		this.type = 'Curve';
	
		this.arcLengthDivisions = 200;
	
	}
	
	Object.assign( Curve.prototype, {
	
		// Virtual base class method to overwrite and implement in subclasses
		//	- t [0 .. 1]
	
		getPoint: function ( /* t, optionalTarget */ ) {
	
			console.warn( 'THREE.Curve: .getPoint() not implemented.' );
			return null;
	
		},
	
		// Get point at relative position in curve according to arc length
		// - u [0 .. 1]
	
		getPointAt: function ( u, optionalTarget ) {
	
			var t = this.getUtoTmapping( u );
			return this.getPoint( t, optionalTarget );
	
		},
	
		// Get sequence of points using getPoint( t )
	
		getPoints: function ( divisions ) {
	
			if ( divisions === undefined ) divisions = 5;
	
			var points = [];
	
			for ( var d = 0; d <= divisions; d ++ ) {
	
				points.push( this.getPoint( d / divisions ) );
	
			}
	
			return points;
	
		},
	
		// Get sequence of points using getPointAt( u )
	
		getSpacedPoints: function ( divisions ) {
	
			if ( divisions === undefined ) divisions = 5;
	
			var points = [];
	
			for ( var d = 0; d <= divisions; d ++ ) {
	
				points.push( this.getPointAt( d / divisions ) );
	
			}
	
			return points;
	
		},
	
		// Get total curve arc length
	
		getLength: function () {
	
			var lengths = this.getLengths();
			return lengths[ lengths.length - 1 ];
	
		},
	
		// Get list of cumulative segment lengths
	
		getLengths: function ( divisions ) {
	
			if ( divisions === undefined ) divisions = this.arcLengthDivisions;
	
			if ( this.cacheArcLengths &&
				( this.cacheArcLengths.length === divisions + 1 ) &&
				! this.needsUpdate ) {
	
				return this.cacheArcLengths;
	
			}
	
			this.needsUpdate = false;
	
			var cache = [];
			var current, last = this.getPoint( 0 );
			var p, sum = 0;
	
			cache.push( 0 );
	
			for ( p = 1; p <= divisions; p ++ ) {
	
				current = this.getPoint( p / divisions );
				sum += current.distanceTo( last );
				cache.push( sum );
				last = current;
	
			}
	
			this.cacheArcLengths = cache;
	
			return cache; // { sums: cache, sum: sum }; Sum is in the last element.
	
		},
	
		updateArcLengths: function () {
	
			this.needsUpdate = true;
			this.getLengths();
	
		},
	
		// Given u ( 0 .. 1 ), get a t to find p. This gives you points which are equidistant
	
		getUtoTmapping: function ( u, distance ) {
	
			var arcLengths = this.getLengths();
	
			var i = 0, il = arcLengths.length;
	
			var targetArcLength; // The targeted u distance value to get
	
			if ( distance ) {
	
				targetArcLength = distance;
	
			} else {
	
				targetArcLength = u * arcLengths[ il - 1 ];
	
			}
	
			// binary search for the index with largest value smaller than target u distance
	
			var low = 0, high = il - 1, comparison;
	
			while ( low <= high ) {
	
				i = Math.floor( low + ( high - low ) / 2 ); // less likely to overflow, though probably not issue here, JS doesn't really have integers, all numbers are floats
	
				comparison = arcLengths[ i ] - targetArcLength;
	
				if ( comparison < 0 ) {
	
					low = i + 1;
	
				} else if ( comparison > 0 ) {
	
					high = i - 1;
	
				} else {
	
					high = i;
					break;
	
					// DONE
	
				}
	
			}
	
			i = high;
	
			if ( arcLengths[ i ] === targetArcLength ) {
	
				return i / ( il - 1 );
	
			}
	
			// we could get finer grain at lengths, or use simple interpolation between two points
	
			var lengthBefore = arcLengths[ i ];
			var lengthAfter = arcLengths[ i + 1 ];
	
			var segmentLength = lengthAfter - lengthBefore;
	
			// determine where we are between the 'before' and 'after' points
	
			var segmentFraction = ( targetArcLength - lengthBefore ) / segmentLength;
	
			// add that fractional amount to t
	
			var t = ( i + segmentFraction ) / ( il - 1 );
	
			return t;
	
		},
	
		// Returns a unit vector tangent at t
		// In case any sub curve does not implement its tangent derivation,
		// 2 points a small delta apart will be used to find its gradient
		// which seems to give a reasonable approximation
	
		getTangent: function ( t ) {
	
			var delta = 0.0001;
			var t1 = t - delta;
			var t2 = t + delta;
	
			// Capping in case of danger
	
			if ( t1 < 0 ) t1 = 0;
			if ( t2 > 1 ) t2 = 1;
	
			var pt1 = this.getPoint( t1 );
			var pt2 = this.getPoint( t2 );
	
			var vec = pt2.clone().sub( pt1 );
			return vec.normalize();
	
		},
	
		getTangentAt: function ( u ) {
	
			var t = this.getUtoTmapping( u );
			return this.getTangent( t );
	
		},
	
		computeFrenetFrames: function ( segments, closed ) {
	
			// see http://www.cs.indiana.edu/pub/techreports/TR425.pdf
	
			var normal = new Vector3();
	
			var tangents = [];
			var normals = [];
			var binormals = [];
	
			var vec = new Vector3();
			var mat = new Matrix4();
	
			var i, u, theta;
	
			// compute the tangent vectors for each segment on the curve
	
			for ( i = 0; i <= segments; i ++ ) {
	
				u = i / segments;
	
				tangents[ i ] = this.getTangentAt( u );
				tangents[ i ].normalize();
	
			}
	
			// select an initial normal vector perpendicular to the first tangent vector,
			// and in the direction of the minimum tangent xyz component
	
			normals[ 0 ] = new Vector3();
			binormals[ 0 ] = new Vector3();
			var min = Number.MAX_VALUE;
			var tx = Math.abs( tangents[ 0 ].x );
			var ty = Math.abs( tangents[ 0 ].y );
			var tz = Math.abs( tangents[ 0 ].z );
	
			if ( tx <= min ) {
	
				min = tx;
				normal.set( 1, 0, 0 );
	
			}
	
			if ( ty <= min ) {
	
				min = ty;
				normal.set( 0, 1, 0 );
	
			}
	
			if ( tz <= min ) {
	
				normal.set( 0, 0, 1 );
	
			}
	
			vec.crossVectors( tangents[ 0 ], normal ).normalize();
	
			normals[ 0 ].crossVectors( tangents[ 0 ], vec );
			binormals[ 0 ].crossVectors( tangents[ 0 ], normals[ 0 ] );
	
	
			// compute the slowly-varying normal and binormal vectors for each segment on the curve
	
			for ( i = 1; i <= segments; i ++ ) {
	
				normals[ i ] = normals[ i - 1 ].clone();
	
				binormals[ i ] = binormals[ i - 1 ].clone();
	
				vec.crossVectors( tangents[ i - 1 ], tangents[ i ] );
	
				if ( vec.length() > Number.EPSILON ) {
	
					vec.normalize();
	
					theta = Math.acos( _Math.clamp( tangents[ i - 1 ].dot( tangents[ i ] ), - 1, 1 ) ); // clamp for floating pt errors
	
					normals[ i ].applyMatrix4( mat.makeRotationAxis( vec, theta ) );
	
				}
	
				binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
			}
	
			// if the curve is closed, postprocess the vectors so the first and last normal vectors are the same
	
			if ( closed === true ) {
	
				theta = Math.acos( _Math.clamp( normals[ 0 ].dot( normals[ segments ] ), - 1, 1 ) );
				theta /= segments;
	
				if ( tangents[ 0 ].dot( vec.crossVectors( normals[ 0 ], normals[ segments ] ) ) > 0 ) {
	
					theta = - theta;
	
				}
	
				for ( i = 1; i <= segments; i ++ ) {
	
					// twist a little...
					normals[ i ].applyMatrix4( mat.makeRotationAxis( tangents[ i ], theta * i ) );
					binormals[ i ].crossVectors( tangents[ i ], normals[ i ] );
	
				}
	
			}
	
			return {
				tangents: tangents,
				normals: normals,
				binormals: binormals
			};
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( source ) {
	
			this.arcLengthDivisions = source.arcLengthDivisions;
	
			return this;
	
		},
	
		toJSON: function () {
	
			var data = {
				metadata: {
					version: 4.5,
					type: 'Curve',
					generator: 'Curve.toJSON'
				}
			};
	
			data.arcLengthDivisions = this.arcLengthDivisions;
			data.type = this.type;
	
			return data;
	
		},
	
		fromJSON: function ( json ) {
	
			this.arcLengthDivisions = json.arcLengthDivisions;
	
			return this;
	
		}
	
	} );
	
	function EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
		Curve.call( this );
	
		this.type = 'EllipseCurve';
	
		this.aX = aX || 0;
		this.aY = aY || 0;
	
		this.xRadius = xRadius || 1;
		this.yRadius = yRadius || 1;
	
		this.aStartAngle = aStartAngle || 0;
		this.aEndAngle = aEndAngle || 2 * Math.PI;
	
		this.aClockwise = aClockwise || false;
	
		this.aRotation = aRotation || 0;
	
	}
	
	EllipseCurve.prototype = Object.create( Curve.prototype );
	EllipseCurve.prototype.constructor = EllipseCurve;
	
	EllipseCurve.prototype.isEllipseCurve = true;
	
	EllipseCurve.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector2();
	
		var twoPi = Math.PI * 2;
		var deltaAngle = this.aEndAngle - this.aStartAngle;
		var samePoints = Math.abs( deltaAngle ) < Number.EPSILON;
	
		// ensures that deltaAngle is 0 .. 2 PI
		while ( deltaAngle < 0 ) deltaAngle += twoPi;
		while ( deltaAngle > twoPi ) deltaAngle -= twoPi;
	
		if ( deltaAngle < Number.EPSILON ) {
	
			if ( samePoints ) {
	
				deltaAngle = 0;
	
			} else {
	
				deltaAngle = twoPi;
	
			}
	
		}
	
		if ( this.aClockwise === true && ! samePoints ) {
	
			if ( deltaAngle === twoPi ) {
	
				deltaAngle = - twoPi;
	
			} else {
	
				deltaAngle = deltaAngle - twoPi;
	
			}
	
		}
	
		var angle = this.aStartAngle + t * deltaAngle;
		var x = this.aX + this.xRadius * Math.cos( angle );
		var y = this.aY + this.yRadius * Math.sin( angle );
	
		if ( this.aRotation !== 0 ) {
	
			var cos = Math.cos( this.aRotation );
			var sin = Math.sin( this.aRotation );
	
			var tx = x - this.aX;
			var ty = y - this.aY;
	
			// Rotate the point about the center of the ellipse.
			x = tx * cos - ty * sin + this.aX;
			y = tx * sin + ty * cos + this.aY;
	
		}
	
		return point.set( x, y );
	
	};
	
	EllipseCurve.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.aX = source.aX;
		this.aY = source.aY;
	
		this.xRadius = source.xRadius;
		this.yRadius = source.yRadius;
	
		this.aStartAngle = source.aStartAngle;
		this.aEndAngle = source.aEndAngle;
	
		this.aClockwise = source.aClockwise;
	
		this.aRotation = source.aRotation;
	
		return this;
	
	};
	
	
	EllipseCurve.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.aX = this.aX;
		data.aY = this.aY;
	
		data.xRadius = this.xRadius;
		data.yRadius = this.yRadius;
	
		data.aStartAngle = this.aStartAngle;
		data.aEndAngle = this.aEndAngle;
	
		data.aClockwise = this.aClockwise;
	
		data.aRotation = this.aRotation;
	
		return data;
	
	};
	
	EllipseCurve.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.aX = json.aX;
		this.aY = json.aY;
	
		this.xRadius = json.xRadius;
		this.yRadius = json.yRadius;
	
		this.aStartAngle = json.aStartAngle;
		this.aEndAngle = json.aEndAngle;
	
		this.aClockwise = json.aClockwise;
	
		this.aRotation = json.aRotation;
	
		return this;
	
	};
	
	function ArcCurve( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
		EllipseCurve.call( this, aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		this.type = 'ArcCurve';
	
	}
	
	ArcCurve.prototype = Object.create( EllipseCurve.prototype );
	ArcCurve.prototype.constructor = ArcCurve;
	
	ArcCurve.prototype.isArcCurve = true;
	
	/**
	 * @author zz85 https://github.com/zz85
	 *
	 * Centripetal CatmullRom Curve - which is useful for avoiding
	 * cusps and self-intersections in non-uniform catmull rom curves.
	 * http://www.cemyuksel.com/research/catmullrom_param/catmullrom.pdf
	 *
	 * curve.type accepts centripetal(default), chordal and catmullrom
	 * curve.tension is used for catmullrom which defaults to 0.5
	 */
	
	
	/*
	Based on an optimized c++ solution in
	 - http://stackoverflow.com/questions/9489736/catmull-rom-curve-with-no-cusps-and-no-self-intersections/
	 - http://ideone.com/NoEbVM
	
	This CubicPoly class could be used for reusing some variables and calculations,
	but for three.js curve use, it could be possible inlined and flatten into a single function call
	which can be placed in CurveUtils.
	*/
	
	function CubicPoly() {
	
		var c0 = 0, c1 = 0, c2 = 0, c3 = 0;
	
		/*
		 * Compute coefficients for a cubic polynomial
		 *   p(s) = c0 + c1*s + c2*s^2 + c3*s^3
		 * such that
		 *   p(0) = x0, p(1) = x1
		 *  and
		 *   p'(0) = t0, p'(1) = t1.
		 */
		function init( x0, x1, t0, t1 ) {
	
			c0 = x0;
			c1 = t0;
			c2 = - 3 * x0 + 3 * x1 - 2 * t0 - t1;
			c3 = 2 * x0 - 2 * x1 + t0 + t1;
	
		}
	
		return {
	
			initCatmullRom: function ( x0, x1, x2, x3, tension ) {
	
				init( x1, x2, tension * ( x2 - x0 ), tension * ( x3 - x1 ) );
	
			},
	
			initNonuniformCatmullRom: function ( x0, x1, x2, x3, dt0, dt1, dt2 ) {
	
				// compute tangents when parameterized in [t1,t2]
				var t1 = ( x1 - x0 ) / dt0 - ( x2 - x0 ) / ( dt0 + dt1 ) + ( x2 - x1 ) / dt1;
				var t2 = ( x2 - x1 ) / dt1 - ( x3 - x1 ) / ( dt1 + dt2 ) + ( x3 - x2 ) / dt2;
	
				// rescale tangents for parametrization in [0,1]
				t1 *= dt1;
				t2 *= dt1;
	
				init( x1, x2, t1, t2 );
	
			},
	
			calc: function ( t ) {
	
				var t2 = t * t;
				var t3 = t2 * t;
				return c0 + c1 * t + c2 * t2 + c3 * t3;
	
			}
	
		};
	
	}
	
	//
	
	var tmp = new Vector3();
	var px = new CubicPoly(), py = new CubicPoly(), pz = new CubicPoly();
	
	function CatmullRomCurve3( points, closed, curveType, tension ) {
	
		Curve.call( this );
	
		this.type = 'CatmullRomCurve3';
	
		this.points = points || [];
		this.closed = closed || false;
		this.curveType = curveType || 'centripetal';
		this.tension = tension || 0.5;
	
	}
	
	CatmullRomCurve3.prototype = Object.create( Curve.prototype );
	CatmullRomCurve3.prototype.constructor = CatmullRomCurve3;
	
	CatmullRomCurve3.prototype.isCatmullRomCurve3 = true;
	
	CatmullRomCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector3();
	
		var points = this.points;
		var l = points.length;
	
		var p = ( l - ( this.closed ? 0 : 1 ) ) * t;
		var intPoint = Math.floor( p );
		var weight = p - intPoint;
	
		if ( this.closed ) {
	
			intPoint += intPoint > 0 ? 0 : ( Math.floor( Math.abs( intPoint ) / l ) + 1 ) * l;
	
		} else if ( weight === 0 && intPoint === l - 1 ) {
	
			intPoint = l - 2;
			weight = 1;
	
		}
	
		var p0, p1, p2, p3; // 4 points
	
		if ( this.closed || intPoint > 0 ) {
	
			p0 = points[ ( intPoint - 1 ) % l ];
	
		} else {
	
			// extrapolate first point
			tmp.subVectors( points[ 0 ], points[ 1 ] ).add( points[ 0 ] );
			p0 = tmp;
	
		}
	
		p1 = points[ intPoint % l ];
		p2 = points[ ( intPoint + 1 ) % l ];
	
		if ( this.closed || intPoint + 2 < l ) {
	
			p3 = points[ ( intPoint + 2 ) % l ];
	
		} else {
	
			// extrapolate last point
			tmp.subVectors( points[ l - 1 ], points[ l - 2 ] ).add( points[ l - 1 ] );
			p3 = tmp;
	
		}
	
		if ( this.curveType === 'centripetal' || this.curveType === 'chordal' ) {
	
			// init Centripetal / Chordal Catmull-Rom
			var pow = this.curveType === 'chordal' ? 0.5 : 0.25;
			var dt0 = Math.pow( p0.distanceToSquared( p1 ), pow );
			var dt1 = Math.pow( p1.distanceToSquared( p2 ), pow );
			var dt2 = Math.pow( p2.distanceToSquared( p3 ), pow );
	
			// safety check for repeated points
			if ( dt1 < 1e-4 ) dt1 = 1.0;
			if ( dt0 < 1e-4 ) dt0 = dt1;
			if ( dt2 < 1e-4 ) dt2 = dt1;
	
			px.initNonuniformCatmullRom( p0.x, p1.x, p2.x, p3.x, dt0, dt1, dt2 );
			py.initNonuniformCatmullRom( p0.y, p1.y, p2.y, p3.y, dt0, dt1, dt2 );
			pz.initNonuniformCatmullRom( p0.z, p1.z, p2.z, p3.z, dt0, dt1, dt2 );
	
		} else if ( this.curveType === 'catmullrom' ) {
	
			px.initCatmullRom( p0.x, p1.x, p2.x, p3.x, this.tension );
			py.initCatmullRom( p0.y, p1.y, p2.y, p3.y, this.tension );
			pz.initCatmullRom( p0.z, p1.z, p2.z, p3.z, this.tension );
	
		}
	
		point.set(
			px.calc( weight ),
			py.calc( weight ),
			pz.calc( weight )
		);
	
		return point;
	
	};
	
	CatmullRomCurve3.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.points = [];
	
		for ( var i = 0, l = source.points.length; i < l; i ++ ) {
	
			var point = source.points[ i ];
	
			this.points.push( point.clone() );
	
		}
	
		this.closed = source.closed;
		this.curveType = source.curveType;
		this.tension = source.tension;
	
		return this;
	
	};
	
	CatmullRomCurve3.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.points = [];
	
		for ( var i = 0, l = this.points.length; i < l; i ++ ) {
	
			var point = this.points[ i ];
			data.points.push( point.toArray() );
	
		}
	
		data.closed = this.closed;
		data.curveType = this.curveType;
		data.tension = this.tension;
	
		return data;
	
	};
	
	CatmullRomCurve3.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.points = [];
	
		for ( var i = 0, l = json.points.length; i < l; i ++ ) {
	
			var point = json.points[ i ];
			this.points.push( new Vector3().fromArray( point ) );
	
		}
	
		this.closed = json.closed;
		this.curveType = json.curveType;
		this.tension = json.tension;
	
		return this;
	
	};
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 * Bezier Curves formulas obtained from
	 * http://en.wikipedia.org/wiki/Bzier_curve
	 */
	
	function CatmullRom( t, p0, p1, p2, p3 ) {
	
		var v0 = ( p2 - p0 ) * 0.5;
		var v1 = ( p3 - p1 ) * 0.5;
		var t2 = t * t;
		var t3 = t * t2;
		return ( 2 * p1 - 2 * p2 + v0 + v1 ) * t3 + ( - 3 * p1 + 3 * p2 - 2 * v0 - v1 ) * t2 + v0 * t + p1;
	
	}
	
	//
	
	function QuadraticBezierP0( t, p ) {
	
		var k = 1 - t;
		return k * k * p;
	
	}
	
	function QuadraticBezierP1( t, p ) {
	
		return 2 * ( 1 - t ) * t * p;
	
	}
	
	function QuadraticBezierP2( t, p ) {
	
		return t * t * p;
	
	}
	
	function QuadraticBezier( t, p0, p1, p2 ) {
	
		return QuadraticBezierP0( t, p0 ) + QuadraticBezierP1( t, p1 ) +
			QuadraticBezierP2( t, p2 );
	
	}
	
	//
	
	function CubicBezierP0( t, p ) {
	
		var k = 1 - t;
		return k * k * k * p;
	
	}
	
	function CubicBezierP1( t, p ) {
	
		var k = 1 - t;
		return 3 * k * k * t * p;
	
	}
	
	function CubicBezierP2( t, p ) {
	
		return 3 * ( 1 - t ) * t * t * p;
	
	}
	
	function CubicBezierP3( t, p ) {
	
		return t * t * t * p;
	
	}
	
	function CubicBezier( t, p0, p1, p2, p3 ) {
	
		return CubicBezierP0( t, p0 ) + CubicBezierP1( t, p1 ) + CubicBezierP2( t, p2 ) +
			CubicBezierP3( t, p3 );
	
	}
	
	function CubicBezierCurve( v0, v1, v2, v3 ) {
	
		Curve.call( this );
	
		this.type = 'CubicBezierCurve';
	
		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
		this.v3 = v3 || new Vector2();
	
	}
	
	CubicBezierCurve.prototype = Object.create( Curve.prototype );
	CubicBezierCurve.prototype.constructor = CubicBezierCurve;
	
	CubicBezierCurve.prototype.isCubicBezierCurve = true;
	
	CubicBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector2();
	
		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y )
		);
	
		return point;
	
	};
	
	CubicBezierCurve.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );
	
		return this;
	
	};
	
	CubicBezierCurve.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
	
		return data;
	
	};
	
	CubicBezierCurve.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );
	
		return this;
	
	};
	
	function CubicBezierCurve3( v0, v1, v2, v3 ) {
	
		Curve.call( this );
	
		this.type = 'CubicBezierCurve3';
	
		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
		this.v3 = v3 || new Vector3();
	
	}
	
	CubicBezierCurve3.prototype = Object.create( Curve.prototype );
	CubicBezierCurve3.prototype.constructor = CubicBezierCurve3;
	
	CubicBezierCurve3.prototype.isCubicBezierCurve3 = true;
	
	CubicBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector3();
	
		var v0 = this.v0, v1 = this.v1, v2 = this.v2, v3 = this.v3;
	
		point.set(
			CubicBezier( t, v0.x, v1.x, v2.x, v3.x ),
			CubicBezier( t, v0.y, v1.y, v2.y, v3.y ),
			CubicBezier( t, v0.z, v1.z, v2.z, v3.z )
		);
	
		return point;
	
	};
	
	CubicBezierCurve3.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
		this.v3.copy( source.v3 );
	
		return this;
	
	};
	
	CubicBezierCurve3.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
		data.v3 = this.v3.toArray();
	
		return data;
	
	};
	
	CubicBezierCurve3.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
		this.v3.fromArray( json.v3 );
	
		return this;
	
	};
	
	function LineCurve( v1, v2 ) {
	
		Curve.call( this );
	
		this.type = 'LineCurve';
	
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
	
	}
	
	LineCurve.prototype = Object.create( Curve.prototype );
	LineCurve.prototype.constructor = LineCurve;
	
	LineCurve.prototype.isLineCurve = true;
	
	LineCurve.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector2();
	
		if ( t === 1 ) {
	
			point.copy( this.v2 );
	
		} else {
	
			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
	
		}
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	LineCurve.prototype.getPointAt = function ( u, optionalTarget ) {
	
		return this.getPoint( u, optionalTarget );
	
	};
	
	LineCurve.prototype.getTangent = function ( /* t */ ) {
	
		var tangent = this.v2.clone().sub( this.v1 );
	
		return tangent.normalize();
	
	};
	
	LineCurve.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
	
		return this;
	
	};
	
	LineCurve.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
	
		return data;
	
	};
	
	LineCurve.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
	
		return this;
	
	};
	
	function LineCurve3( v1, v2 ) {
	
		Curve.call( this );
	
		this.type = 'LineCurve3';
	
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
	
	}
	
	LineCurve3.prototype = Object.create( Curve.prototype );
	LineCurve3.prototype.constructor = LineCurve3;
	
	LineCurve3.prototype.isLineCurve3 = true;
	
	LineCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector3();
	
		if ( t === 1 ) {
	
			point.copy( this.v2 );
	
		} else {
	
			point.copy( this.v2 ).sub( this.v1 );
			point.multiplyScalar( t ).add( this.v1 );
	
		}
	
		return point;
	
	};
	
	// Line curve is linear, so we can overwrite default getPointAt
	
	LineCurve3.prototype.getPointAt = function ( u, optionalTarget ) {
	
		return this.getPoint( u, optionalTarget );
	
	};
	
	LineCurve3.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
	
		return this;
	
	};
	
	LineCurve3.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
	
		return data;
	
	};
	
	LineCurve3.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
	
		return this;
	
	};
	
	function QuadraticBezierCurve( v0, v1, v2 ) {
	
		Curve.call( this );
	
		this.type = 'QuadraticBezierCurve';
	
		this.v0 = v0 || new Vector2();
		this.v1 = v1 || new Vector2();
		this.v2 = v2 || new Vector2();
	
	}
	
	QuadraticBezierCurve.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve.prototype.constructor = QuadraticBezierCurve;
	
	QuadraticBezierCurve.prototype.isQuadraticBezierCurve = true;
	
	QuadraticBezierCurve.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector2();
	
		var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y )
		);
	
		return point;
	
	};
	
	QuadraticBezierCurve.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
	
		return this;
	
	};
	
	QuadraticBezierCurve.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
	
		return data;
	
	};
	
	QuadraticBezierCurve.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
	
		return this;
	
	};
	
	function QuadraticBezierCurve3( v0, v1, v2 ) {
	
		Curve.call( this );
	
		this.type = 'QuadraticBezierCurve3';
	
		this.v0 = v0 || new Vector3();
		this.v1 = v1 || new Vector3();
		this.v2 = v2 || new Vector3();
	
	}
	
	QuadraticBezierCurve3.prototype = Object.create( Curve.prototype );
	QuadraticBezierCurve3.prototype.constructor = QuadraticBezierCurve3;
	
	QuadraticBezierCurve3.prototype.isQuadraticBezierCurve3 = true;
	
	QuadraticBezierCurve3.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector3();
	
		var v0 = this.v0, v1 = this.v1, v2 = this.v2;
	
		point.set(
			QuadraticBezier( t, v0.x, v1.x, v2.x ),
			QuadraticBezier( t, v0.y, v1.y, v2.y ),
			QuadraticBezier( t, v0.z, v1.z, v2.z )
		);
	
		return point;
	
	};
	
	QuadraticBezierCurve3.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.v0.copy( source.v0 );
		this.v1.copy( source.v1 );
		this.v2.copy( source.v2 );
	
		return this;
	
	};
	
	QuadraticBezierCurve3.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.v0 = this.v0.toArray();
		data.v1 = this.v1.toArray();
		data.v2 = this.v2.toArray();
	
		return data;
	
	};
	
	QuadraticBezierCurve3.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.v0.fromArray( json.v0 );
		this.v1.fromArray( json.v1 );
		this.v2.fromArray( json.v2 );
	
		return this;
	
	};
	
	function SplineCurve( points /* array of Vector2 */ ) {
	
		Curve.call( this );
	
		this.type = 'SplineCurve';
	
		this.points = points || [];
	
	}
	
	SplineCurve.prototype = Object.create( Curve.prototype );
	SplineCurve.prototype.constructor = SplineCurve;
	
	SplineCurve.prototype.isSplineCurve = true;
	
	SplineCurve.prototype.getPoint = function ( t, optionalTarget ) {
	
		var point = optionalTarget || new Vector2();
	
		var points = this.points;
		var p = ( points.length - 1 ) * t;
	
		var intPoint = Math.floor( p );
		var weight = p - intPoint;
	
		var p0 = points[ intPoint === 0 ? intPoint : intPoint - 1 ];
		var p1 = points[ intPoint ];
		var p2 = points[ intPoint > points.length - 2 ? points.length - 1 : intPoint + 1 ];
		var p3 = points[ intPoint > points.length - 3 ? points.length - 1 : intPoint + 2 ];
	
		point.set(
			CatmullRom( weight, p0.x, p1.x, p2.x, p3.x ),
			CatmullRom( weight, p0.y, p1.y, p2.y, p3.y )
		);
	
		return point;
	
	};
	
	SplineCurve.prototype.copy = function ( source ) {
	
		Curve.prototype.copy.call( this, source );
	
		this.points = [];
	
		for ( var i = 0, l = source.points.length; i < l; i ++ ) {
	
			var point = source.points[ i ];
	
			this.points.push( point.clone() );
	
		}
	
		return this;
	
	};
	
	SplineCurve.prototype.toJSON = function () {
	
		var data = Curve.prototype.toJSON.call( this );
	
		data.points = [];
	
		for ( var i = 0, l = this.points.length; i < l; i ++ ) {
	
			var point = this.points[ i ];
			data.points.push( point.toArray() );
	
		}
	
		return data;
	
	};
	
	SplineCurve.prototype.fromJSON = function ( json ) {
	
		Curve.prototype.fromJSON.call( this, json );
	
		this.points = [];
	
		for ( var i = 0, l = json.points.length; i < l; i ++ ) {
	
			var point = json.points[ i ];
			this.points.push( new Vector2().fromArray( point ) );
	
		}
	
		return this;
	
	};
	
	
	
	var Curves = /*#__PURE__*/Object.freeze({
		ArcCurve: ArcCurve,
		CatmullRomCurve3: CatmullRomCurve3,
		CubicBezierCurve: CubicBezierCurve,
		CubicBezierCurve3: CubicBezierCurve3,
		EllipseCurve: EllipseCurve,
		LineCurve: LineCurve,
		LineCurve3: LineCurve3,
		QuadraticBezierCurve: QuadraticBezierCurve,
		QuadraticBezierCurve3: QuadraticBezierCurve3,
		SplineCurve: SplineCurve
	});
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 *
	 **/
	
	/**************************************************************
	 *	Curved Path - a curve path is simply a array of connected
	 *  curves, but retains the api of a curve
	 **************************************************************/
	
	function CurvePath() {
	
		Curve.call( this );
	
		this.type = 'CurvePath';
	
		this.curves = [];
		this.autoClose = false; // Automatically closes the path
	
	}
	
	CurvePath.prototype = Object.assign( Object.create( Curve.prototype ), {
	
		constructor: CurvePath,
	
		add: function ( curve ) {
	
			this.curves.push( curve );
	
		},
	
		closePath: function () {
	
			// Add a line curve if start and end of lines are not connected
			var startPoint = this.curves[ 0 ].getPoint( 0 );
			var endPoint = this.curves[ this.curves.length - 1 ].getPoint( 1 );
	
			if ( ! startPoint.equals( endPoint ) ) {
	
				this.curves.push( new LineCurve( endPoint, startPoint ) );
	
			}
	
		},
	
		// To get accurate point with reference to
		// entire path distance at time t,
		// following has to be done:
	
		// 1. Length of each sub path have to be known
		// 2. Locate and identify type of curve
		// 3. Get t for the curve
		// 4. Return curve.getPointAt(t')
	
		getPoint: function ( t ) {
	
			var d = t * this.getLength();
			var curveLengths = this.getCurveLengths();
			var i = 0;
	
			// To think about boundaries points.
	
			while ( i < curveLengths.length ) {
	
				if ( curveLengths[ i ] >= d ) {
	
					var diff = curveLengths[ i ] - d;
					var curve = this.curves[ i ];
	
					var segmentLength = curve.getLength();
					var u = segmentLength === 0 ? 0 : 1 - diff / segmentLength;
	
					return curve.getPointAt( u );
	
				}
	
				i ++;
	
			}
	
			return null;
	
			// loop where sum != 0, sum > d , sum+1 <d
	
		},
	
		// We cannot use the default THREE.Curve getPoint() with getLength() because in
		// THREE.Curve, getLength() depends on getPoint() but in THREE.CurvePath
		// getPoint() depends on getLength
	
		getLength: function () {
	
			var lens = this.getCurveLengths();
			return lens[ lens.length - 1 ];
	
		},
	
		// cacheLengths must be recalculated.
		updateArcLengths: function () {
	
			this.needsUpdate = true;
			this.cacheLengths = null;
			this.getCurveLengths();
	
		},
	
		// Compute lengths and cache them
		// We cannot overwrite getLengths() because UtoT mapping uses it.
	
		getCurveLengths: function () {
	
			// We use cache values if curves and cache array are same length
	
			if ( this.cacheLengths && this.cacheLengths.length === this.curves.length ) {
	
				return this.cacheLengths;
	
			}
	
			// Get length of sub-curve
			// Push sums into cached array
	
			var lengths = [], sums = 0;
	
			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
				sums += this.curves[ i ].getLength();
				lengths.push( sums );
	
			}
	
			this.cacheLengths = lengths;
	
			return lengths;
	
		},
	
		getSpacedPoints: function ( divisions ) {
	
			if ( divisions === undefined ) divisions = 40;
	
			var points = [];
	
			for ( var i = 0; i <= divisions; i ++ ) {
	
				points.push( this.getPoint( i / divisions ) );
	
			}
	
			if ( this.autoClose ) {
	
				points.push( points[ 0 ] );
	
			}
	
			return points;
	
		},
	
		getPoints: function ( divisions ) {
	
			divisions = divisions || 12;
	
			var points = [], last;
	
			for ( var i = 0, curves = this.curves; i < curves.length; i ++ ) {
	
				var curve = curves[ i ];
				var resolution = ( curve && curve.isEllipseCurve ) ? divisions * 2
					: ( curve && ( curve.isLineCurve || curve.isLineCurve3 ) ) ? 1
						: ( curve && curve.isSplineCurve ) ? divisions * curve.points.length
							: divisions;
	
				var pts = curve.getPoints( resolution );
	
				for ( var j = 0; j < pts.length; j ++ ) {
	
					var point = pts[ j ];
	
					if ( last && last.equals( point ) ) continue; // ensures no consecutive points are duplicates
	
					points.push( point );
					last = point;
	
				}
	
			}
	
			if ( this.autoClose && points.length > 1 && ! points[ points.length - 1 ].equals( points[ 0 ] ) ) {
	
				points.push( points[ 0 ] );
	
			}
	
			return points;
	
		},
	
		copy: function ( source ) {
	
			Curve.prototype.copy.call( this, source );
	
			this.curves = [];
	
			for ( var i = 0, l = source.curves.length; i < l; i ++ ) {
	
				var curve = source.curves[ i ];
	
				this.curves.push( curve.clone() );
	
			}
	
			this.autoClose = source.autoClose;
	
			return this;
	
		},
	
		toJSON: function () {
	
			var data = Curve.prototype.toJSON.call( this );
	
			data.autoClose = this.autoClose;
			data.curves = [];
	
			for ( var i = 0, l = this.curves.length; i < l; i ++ ) {
	
				var curve = this.curves[ i ];
				data.curves.push( curve.toJSON() );
	
			}
	
			return data;
	
		},
	
		fromJSON: function ( json ) {
	
			Curve.prototype.fromJSON.call( this, json );
	
			this.autoClose = json.autoClose;
			this.curves = [];
	
			for ( var i = 0, l = json.curves.length; i < l; i ++ ) {
	
				var curve = json.curves[ i ];
				this.curves.push( new Curves[ curve.type ]().fromJSON( curve ) );
	
			}
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Creates free form 2d path using series of points, lines or curves.
	 **/
	
	function Path( points ) {
	
		CurvePath.call( this );
	
		this.type = 'Path';
	
		this.currentPoint = new Vector2();
	
		if ( points ) {
	
			this.setFromPoints( points );
	
		}
	
	}
	
	Path.prototype = Object.assign( Object.create( CurvePath.prototype ), {
	
		constructor: Path,
	
		setFromPoints: function ( points ) {
	
			this.moveTo( points[ 0 ].x, points[ 0 ].y );
	
			for ( var i = 1, l = points.length; i < l; i ++ ) {
	
				this.lineTo( points[ i ].x, points[ i ].y );
	
			}
	
		},
	
		moveTo: function ( x, y ) {
	
			this.currentPoint.set( x, y ); // TODO consider referencing vectors instead of copying?
	
		},
	
		lineTo: function ( x, y ) {
	
			var curve = new LineCurve( this.currentPoint.clone(), new Vector2( x, y ) );
			this.curves.push( curve );
	
			this.currentPoint.set( x, y );
	
		},
	
		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
			var curve = new QuadraticBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCPx, aCPy ),
				new Vector2( aX, aY )
			);
	
			this.curves.push( curve );
	
			this.currentPoint.set( aX, aY );
	
		},
	
		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
			var curve = new CubicBezierCurve(
				this.currentPoint.clone(),
				new Vector2( aCP1x, aCP1y ),
				new Vector2( aCP2x, aCP2y ),
				new Vector2( aX, aY )
			);
	
			this.curves.push( curve );
	
			this.currentPoint.set( aX, aY );
	
		},
	
		splineThru: function ( pts /*Array of Vector*/ ) {
	
			var npts = [ this.currentPoint.clone() ].concat( pts );
	
			var curve = new SplineCurve( npts );
			this.curves.push( curve );
	
			this.currentPoint.copy( pts[ pts.length - 1 ] );
	
		},
	
		arc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
	
			this.absarc( aX + x0, aY + y0, aRadius,
				aStartAngle, aEndAngle, aClockwise );
	
		},
	
		absarc: function ( aX, aY, aRadius, aStartAngle, aEndAngle, aClockwise ) {
	
			this.absellipse( aX, aY, aRadius, aRadius, aStartAngle, aEndAngle, aClockwise );
	
		},
	
		ellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			var x0 = this.currentPoint.x;
			var y0 = this.currentPoint.y;
	
			this.absellipse( aX + x0, aY + y0, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
		},
	
		absellipse: function ( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation ) {
	
			var curve = new EllipseCurve( aX, aY, xRadius, yRadius, aStartAngle, aEndAngle, aClockwise, aRotation );
	
			if ( this.curves.length > 0 ) {
	
				// if a previous curve is present, attempt to join
				var firstPoint = curve.getPoint( 0 );
	
				if ( ! firstPoint.equals( this.currentPoint ) ) {
	
					this.lineTo( firstPoint.x, firstPoint.y );
	
				}
	
			}
	
			this.curves.push( curve );
	
			var lastPoint = curve.getPoint( 1 );
			this.currentPoint.copy( lastPoint );
	
		},
	
		copy: function ( source ) {
	
			CurvePath.prototype.copy.call( this, source );
	
			this.currentPoint.copy( source.currentPoint );
	
			return this;
	
		},
	
		toJSON: function () {
	
			var data = CurvePath.prototype.toJSON.call( this );
	
			data.currentPoint = this.currentPoint.toArray();
	
			return data;
	
		},
	
		fromJSON: function ( json ) {
	
			CurvePath.prototype.fromJSON.call( this, json );
	
			this.currentPoint.fromArray( json.currentPoint );
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * Defines a 2d shape plane using paths.
	 **/
	
	// STEP 1 Create a path.
	// STEP 2 Turn path into shape.
	// STEP 3 ExtrudeGeometry takes in Shape/Shapes
	// STEP 3a - Extract points from each shape, turn to vertices
	// STEP 3b - Triangulate each shape, add faces.
	
	function Shape( points ) {
	
		Path.call( this, points );
	
		this.uuid = _Math.generateUUID();
	
		this.type = 'Shape';
	
		this.holes = [];
	
	}
	
	Shape.prototype = Object.assign( Object.create( Path.prototype ), {
	
		constructor: Shape,
	
		getPointsHoles: function ( divisions ) {
	
			var holesPts = [];
	
			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
				holesPts[ i ] = this.holes[ i ].getPoints( divisions );
	
			}
	
			return holesPts;
	
		},
	
		// get points of shape and holes (keypoints based on segments parameter)
	
		extractPoints: function ( divisions ) {
	
			return {
	
				shape: this.getPoints( divisions ),
				holes: this.getPointsHoles( divisions )
	
			};
	
		},
	
		copy: function ( source ) {
	
			Path.prototype.copy.call( this, source );
	
			this.holes = [];
	
			for ( var i = 0, l = source.holes.length; i < l; i ++ ) {
	
				var hole = source.holes[ i ];
	
				this.holes.push( hole.clone() );
	
			}
	
			return this;
	
		},
	
		toJSON: function () {
	
			var data = Path.prototype.toJSON.call( this );
	
			data.uuid = this.uuid;
			data.holes = [];
	
			for ( var i = 0, l = this.holes.length; i < l; i ++ ) {
	
				var hole = this.holes[ i ];
				data.holes.push( hole.toJSON() );
	
			}
	
			return data;
	
		},
	
		fromJSON: function ( json ) {
	
			Path.prototype.fromJSON.call( this, json );
	
			this.uuid = json.uuid;
			this.holes = [];
	
			for ( var i = 0, l = json.holes.length; i < l; i ++ ) {
	
				var hole = json.holes[ i ];
				this.holes.push( new Path().fromJSON( hole ) );
	
			}
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function Light( color, intensity ) {
	
		Object3D.call( this );
	
		this.type = 'Light';
	
		this.color = new Color( color );
		this.intensity = intensity !== undefined ? intensity : 1;
	
		this.receiveShadow = undefined;
	
	}
	
	Light.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Light,
	
		isLight: true,
	
		copy: function ( source ) {
	
			Object3D.prototype.copy.call( this, source );
	
			this.color.copy( source.color );
			this.intensity = source.intensity;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			data.object.color = this.color.getHex();
			data.object.intensity = this.intensity;
	
			if ( this.groundColor !== undefined ) data.object.groundColor = this.groundColor.getHex();
	
			if ( this.distance !== undefined ) data.object.distance = this.distance;
			if ( this.angle !== undefined ) data.object.angle = this.angle;
			if ( this.decay !== undefined ) data.object.decay = this.decay;
			if ( this.penumbra !== undefined ) data.object.penumbra = this.penumbra;
	
			if ( this.shadow !== undefined ) data.object.shadow = this.shadow.toJSON();
	
			return data;
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function HemisphereLight( skyColor, groundColor, intensity ) {
	
		Light.call( this, skyColor, intensity );
	
		this.type = 'HemisphereLight';
	
		this.castShadow = undefined;
	
		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();
	
		this.groundColor = new Color( groundColor );
	
	}
	
	HemisphereLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
		constructor: HemisphereLight,
	
		isHemisphereLight: true,
	
		copy: function ( source ) {
	
			Light.prototype.copy.call( this, source );
	
			this.groundColor.copy( source.groundColor );
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function LightShadow( camera ) {
	
		this.camera = camera;
	
		this.bias = 0;
		this.radius = 1;
	
		this.mapSize = new Vector2( 512, 512 );
	
		this.map = null;
		this.matrix = new Matrix4();
	
	}
	
	Object.assign( LightShadow.prototype, {
	
		copy: function ( source ) {
	
			this.camera = source.camera.clone();
	
			this.bias = source.bias;
			this.radius = source.radius;
	
			this.mapSize.copy( source.mapSize );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		toJSON: function () {
	
			var object = {};
	
			if ( this.bias !== 0 ) object.bias = this.bias;
			if ( this.radius !== 1 ) object.radius = this.radius;
			if ( this.mapSize.x !== 512 || this.mapSize.y !== 512 ) object.mapSize = this.mapSize.toArray();
	
			object.camera = this.camera.toJSON( false ).object;
			delete object.camera.matrix;
	
			return object;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function SpotLightShadow() {
	
		LightShadow.call( this, new PerspectiveCamera( 50, 1, 0.5, 500 ) );
	
	}
	
	SpotLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
		constructor: SpotLightShadow,
	
		isSpotLightShadow: true,
	
		update: function ( light ) {
	
			var camera = this.camera;
	
			var fov = _Math.RAD2DEG * 2 * light.angle;
			var aspect = this.mapSize.width / this.mapSize.height;
			var far = light.distance || camera.far;
	
			if ( fov !== camera.fov || aspect !== camera.aspect || far !== camera.far ) {
	
				camera.fov = fov;
				camera.aspect = aspect;
				camera.far = far;
				camera.updateProjectionMatrix();
	
			}
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function SpotLight( color, intensity, distance, angle, penumbra, decay ) {
	
		Light.call( this, color, intensity );
	
		this.type = 'SpotLight';
	
		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();
	
		this.target = new Object3D();
	
		Object.defineProperty( this, 'power', {
			get: function () {
	
				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * Math.PI;
	
			},
			set: function ( power ) {
	
				// intensity = power per solid angle.
				// ref: equation (17) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / Math.PI;
	
			}
		} );
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.angle = ( angle !== undefined ) ? angle : Math.PI / 3;
		this.penumbra = ( penumbra !== undefined ) ? penumbra : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new SpotLightShadow();
	
	}
	
	SpotLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
		constructor: SpotLight,
	
		isSpotLight: true,
	
		copy: function ( source ) {
	
			Light.prototype.copy.call( this, source );
	
			this.distance = source.distance;
			this.angle = source.angle;
			this.penumbra = source.penumbra;
			this.decay = source.decay;
	
			this.target = source.target.clone();
	
			this.shadow = source.shadow.clone();
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	function PointLight( color, intensity, distance, decay ) {
	
		Light.call( this, color, intensity );
	
		this.type = 'PointLight';
	
		Object.defineProperty( this, 'power', {
			get: function () {
	
				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				return this.intensity * 4 * Math.PI;
	
			},
			set: function ( power ) {
	
				// intensity = power per solid angle.
				// ref: equation (15) from https://seblagarde.files.wordpress.com/2015/07/course_notes_moving_frostbite_to_pbr_v32.pdf
				this.intensity = power / ( 4 * Math.PI );
	
			}
		} );
	
		this.distance = ( distance !== undefined ) ? distance : 0;
		this.decay = ( decay !== undefined ) ? decay : 1;	// for physically correct lights, should be 2.
	
		this.shadow = new LightShadow( new PerspectiveCamera( 90, 1, 0.5, 500 ) );
	
	}
	
	PointLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
		constructor: PointLight,
	
		isPointLight: true,
	
		copy: function ( source ) {
	
			Light.prototype.copy.call( this, source );
	
			this.distance = source.distance;
			this.decay = source.decay;
	
			this.shadow = source.shadow.clone();
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author arose / http://github.com/arose
	 */
	
	function OrthographicCamera( left, right, top, bottom, near, far ) {
	
		Camera.call( this );
	
		this.type = 'OrthographicCamera';
	
		this.zoom = 1;
		this.view = null;
	
		this.left = ( left !== undefined ) ? left : - 1;
		this.right = ( right !== undefined ) ? right : 1;
		this.top = ( top !== undefined ) ? top : 1;
		this.bottom = ( bottom !== undefined ) ? bottom : - 1;
	
		this.near = ( near !== undefined ) ? near : 0.1;
		this.far = ( far !== undefined ) ? far : 2000;
	
		this.updateProjectionMatrix();
	
	}
	
	OrthographicCamera.prototype = Object.assign( Object.create( Camera.prototype ), {
	
		constructor: OrthographicCamera,
	
		isOrthographicCamera: true,
	
		copy: function ( source, recursive ) {
	
			Camera.prototype.copy.call( this, source, recursive );
	
			this.left = source.left;
			this.right = source.right;
			this.top = source.top;
			this.bottom = source.bottom;
			this.near = source.near;
			this.far = source.far;
	
			this.zoom = source.zoom;
			this.view = source.view === null ? null : Object.assign( {}, source.view );
	
			return this;
	
		},
	
		setViewOffset: function ( fullWidth, fullHeight, x, y, width, height ) {
	
			if ( this.view === null ) {
	
				this.view = {
					enabled: true,
					fullWidth: 1,
					fullHeight: 1,
					offsetX: 0,
					offsetY: 0,
					width: 1,
					height: 1
				};
	
			}
	
			this.view.enabled = true;
			this.view.fullWidth = fullWidth;
			this.view.fullHeight = fullHeight;
			this.view.offsetX = x;
			this.view.offsetY = y;
			this.view.width = width;
			this.view.height = height;
	
			this.updateProjectionMatrix();
	
		},
	
		clearViewOffset: function () {
	
			if ( this.view !== null ) {
	
				this.view.enabled = false;
	
			}
	
			this.updateProjectionMatrix();
	
		},
	
		updateProjectionMatrix: function () {
	
			var dx = ( this.right - this.left ) / ( 2 * this.zoom );
			var dy = ( this.top - this.bottom ) / ( 2 * this.zoom );
			var cx = ( this.right + this.left ) / 2;
			var cy = ( this.top + this.bottom ) / 2;
	
			var left = cx - dx;
			var right = cx + dx;
			var top = cy + dy;
			var bottom = cy - dy;
	
			if ( this.view !== null && this.view.enabled ) {
	
				var zoomW = this.zoom / ( this.view.width / this.view.fullWidth );
				var zoomH = this.zoom / ( this.view.height / this.view.fullHeight );
				var scaleW = ( this.right - this.left ) / this.view.width;
				var scaleH = ( this.top - this.bottom ) / this.view.height;
	
				left += scaleW * ( this.view.offsetX / zoomW );
				right = left + scaleW * ( this.view.width / zoomW );
				top -= scaleH * ( this.view.offsetY / zoomH );
				bottom = top - scaleH * ( this.view.height / zoomH );
	
			}
	
			this.projectionMatrix.makeOrthographic( left, right, top, bottom, this.near, this.far );
	
			this.projectionMatrixInverse.getInverse( this.projectionMatrix );
	
		},
	
		toJSON: function ( meta ) {
	
			var data = Object3D.prototype.toJSON.call( this, meta );
	
			data.object.zoom = this.zoom;
			data.object.left = this.left;
			data.object.right = this.right;
			data.object.top = this.top;
			data.object.bottom = this.bottom;
			data.object.near = this.near;
			data.object.far = this.far;
	
			if ( this.view !== null ) data.object.view = Object.assign( {}, this.view );
	
			return data;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function DirectionalLightShadow( ) {
	
		LightShadow.call( this, new OrthographicCamera( - 5, 5, 5, - 5, 0.5, 500 ) );
	
	}
	
	DirectionalLightShadow.prototype = Object.assign( Object.create( LightShadow.prototype ), {
	
		constructor: DirectionalLightShadow
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function DirectionalLight( color, intensity ) {
	
		Light.call( this, color, intensity );
	
		this.type = 'DirectionalLight';
	
		this.position.copy( Object3D.DefaultUp );
		this.updateMatrix();
	
		this.target = new Object3D();
	
		this.shadow = new DirectionalLightShadow();
	
	}
	
	DirectionalLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
		constructor: DirectionalLight,
	
		isDirectionalLight: true,
	
		copy: function ( source ) {
	
			Light.prototype.copy.call( this, source );
	
			this.target = source.target.clone();
	
			this.shadow = source.shadow.clone();
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function AmbientLight( color, intensity ) {
	
		Light.call( this, color, intensity );
	
		this.type = 'AmbientLight';
	
		this.castShadow = undefined;
	
	}
	
	AmbientLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
		constructor: AmbientLight,
	
		isAmbientLight: true
	
	} );
	
	/**
	 * @author abelnation / http://github.com/abelnation
	 */
	
	function RectAreaLight( color, intensity, width, height ) {
	
		Light.call( this, color, intensity );
	
		this.type = 'RectAreaLight';
	
		this.width = ( width !== undefined ) ? width : 10;
		this.height = ( height !== undefined ) ? height : 10;
	
	}
	
	RectAreaLight.prototype = Object.assign( Object.create( Light.prototype ), {
	
		constructor: RectAreaLight,
	
		isRectAreaLight: true,
	
		copy: function ( source ) {
	
			Light.prototype.copy.call( this, source );
	
			this.width = source.width;
			this.height = source.height;
	
			return this;
	
		},
	
		toJSON: function ( meta ) {
	
			var data = Light.prototype.toJSON.call( this, meta );
	
			data.object.width = this.width;
			data.object.height = this.height;
	
			return data;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function MaterialLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.textures = {};
	
	}
	
	Object.assign( MaterialLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			var textures = this.textures;
	
			function getTexture( name ) {
	
				if ( textures[ name ] === undefined ) {
	
					console.warn( 'THREE.MaterialLoader: Undefined texture', name );
	
				}
	
				return textures[ name ];
	
			}
	
			var material = new Materials[ json.type ]();
	
			if ( json.uuid !== undefined ) material.uuid = json.uuid;
			if ( json.name !== undefined ) material.name = json.name;
			if ( json.color !== undefined ) material.color.setHex( json.color );
			if ( json.roughness !== undefined ) material.roughness = json.roughness;
			if ( json.metalness !== undefined ) material.metalness = json.metalness;
			if ( json.emissive !== undefined ) material.emissive.setHex( json.emissive );
			if ( json.specular !== undefined ) material.specular.setHex( json.specular );
			if ( json.shininess !== undefined ) material.shininess = json.shininess;
			if ( json.clearCoat !== undefined ) material.clearCoat = json.clearCoat;
			if ( json.clearCoatRoughness !== undefined ) material.clearCoatRoughness = json.clearCoatRoughness;
			if ( json.vertexColors !== undefined ) material.vertexColors = json.vertexColors;
			if ( json.fog !== undefined ) material.fog = json.fog;
			if ( json.flatShading !== undefined ) material.flatShading = json.flatShading;
			if ( json.blending !== undefined ) material.blending = json.blending;
			if ( json.combine !== undefined ) material.combine = json.combine;
			if ( json.side !== undefined ) material.side = json.side;
			if ( json.opacity !== undefined ) material.opacity = json.opacity;
			if ( json.transparent !== undefined ) material.transparent = json.transparent;
			if ( json.alphaTest !== undefined ) material.alphaTest = json.alphaTest;
			if ( json.depthTest !== undefined ) material.depthTest = json.depthTest;
			if ( json.depthWrite !== undefined ) material.depthWrite = json.depthWrite;
			if ( json.colorWrite !== undefined ) material.colorWrite = json.colorWrite;
			if ( json.wireframe !== undefined ) material.wireframe = json.wireframe;
			if ( json.wireframeLinewidth !== undefined ) material.wireframeLinewidth = json.wireframeLinewidth;
			if ( json.wireframeLinecap !== undefined ) material.wireframeLinecap = json.wireframeLinecap;
			if ( json.wireframeLinejoin !== undefined ) material.wireframeLinejoin = json.wireframeLinejoin;
	
			if ( json.rotation !== undefined ) material.rotation = json.rotation;
	
			if ( json.linewidth !== 1 ) material.linewidth = json.linewidth;
			if ( json.dashSize !== undefined ) material.dashSize = json.dashSize;
			if ( json.gapSize !== undefined ) material.gapSize = json.gapSize;
			if ( json.scale !== undefined ) material.scale = json.scale;
	
			if ( json.polygonOffset !== undefined ) material.polygonOffset = json.polygonOffset;
			if ( json.polygonOffsetFactor !== undefined ) material.polygonOffsetFactor = json.polygonOffsetFactor;
			if ( json.polygonOffsetUnits !== undefined ) material.polygonOffsetUnits = json.polygonOffsetUnits;
	
			if ( json.skinning !== undefined ) material.skinning = json.skinning;
			if ( json.morphTargets !== undefined ) material.morphTargets = json.morphTargets;
			if ( json.dithering !== undefined ) material.dithering = json.dithering;
	
			if ( json.visible !== undefined ) material.visible = json.visible;
			if ( json.userData !== undefined ) material.userData = json.userData;
	
			// Shader Material
	
			if ( json.uniforms !== undefined ) {
	
				for ( var name in json.uniforms ) {
	
					var uniform = json.uniforms[ name ];
	
					material.uniforms[ name ] = {};
	
					switch ( uniform.type ) {
	
						case 't':
							material.uniforms[ name ].value = getTexture( uniform.value );
							break;
	
						case 'c':
							material.uniforms[ name ].value = new Color().setHex( uniform.value );
							break;
	
						case 'v2':
							material.uniforms[ name ].value = new Vector2().fromArray( uniform.value );
							break;
	
						case 'v3':
							material.uniforms[ name ].value = new Vector3().fromArray( uniform.value );
							break;
	
						case 'v4':
							material.uniforms[ name ].value = new Vector4().fromArray( uniform.value );
							break;
	
						case 'm3':
							material.uniforms[ name ].value = new Matrix3().fromArray( uniform.value );
	
						case 'm4':
							material.uniforms[ name ].value = new Matrix4().fromArray( uniform.value );
							break;
	
						default:
							material.uniforms[ name ].value = uniform.value;
	
					}
	
				}
	
			}
	
			if ( json.defines !== undefined ) material.defines = json.defines;
			if ( json.vertexShader !== undefined ) material.vertexShader = json.vertexShader;
			if ( json.fragmentShader !== undefined ) material.fragmentShader = json.fragmentShader;
	
			if ( json.extensions !== undefined ) {
	
				for ( var key in json.extensions ) {
	
					material.extensions[ key ] = json.extensions[ key ];
	
				}
	
			}
	
			// Deprecated
	
			if ( json.shading !== undefined ) material.flatShading = json.shading === 1; // THREE.FlatShading
	
			// for PointsMaterial
	
			if ( json.size !== undefined ) material.size = json.size;
			if ( json.sizeAttenuation !== undefined ) material.sizeAttenuation = json.sizeAttenuation;
	
			// maps
	
			if ( json.map !== undefined ) material.map = getTexture( json.map );
	
			if ( json.alphaMap !== undefined ) {
	
				material.alphaMap = getTexture( json.alphaMap );
				material.transparent = true;
	
			}
	
			if ( json.bumpMap !== undefined ) material.bumpMap = getTexture( json.bumpMap );
			if ( json.bumpScale !== undefined ) material.bumpScale = json.bumpScale;
	
			if ( json.normalMap !== undefined ) material.normalMap = getTexture( json.normalMap );
			if ( json.normalMapType !== undefined ) material.normalMapType = json.normalMapType;
			if ( json.normalScale !== undefined ) {
	
				var normalScale = json.normalScale;
	
				if ( Array.isArray( normalScale ) === false ) {
	
					// Blender exporter used to export a scalar. See #7459
	
					normalScale = [ normalScale, normalScale ];
	
				}
	
				material.normalScale = new Vector2().fromArray( normalScale );
	
			}
	
			if ( json.displacementMap !== undefined ) material.displacementMap = getTexture( json.displacementMap );
			if ( json.displacementScale !== undefined ) material.displacementScale = json.displacementScale;
			if ( json.displacementBias !== undefined ) material.displacementBias = json.displacementBias;
	
			if ( json.roughnessMap !== undefined ) material.roughnessMap = getTexture( json.roughnessMap );
			if ( json.metalnessMap !== undefined ) material.metalnessMap = getTexture( json.metalnessMap );
	
			if ( json.emissiveMap !== undefined ) material.emissiveMap = getTexture( json.emissiveMap );
			if ( json.emissiveIntensity !== undefined ) material.emissiveIntensity = json.emissiveIntensity;
	
			if ( json.specularMap !== undefined ) material.specularMap = getTexture( json.specularMap );
	
			if ( json.envMap !== undefined ) material.envMap = getTexture( json.envMap );
			if ( json.envMapIntensity !== undefined ) material.envMapIntensity = json.envMapIntensity;
	
			if ( json.reflectivity !== undefined ) material.reflectivity = json.reflectivity;
	
			if ( json.lightMap !== undefined ) material.lightMap = getTexture( json.lightMap );
			if ( json.lightMapIntensity !== undefined ) material.lightMapIntensity = json.lightMapIntensity;
	
			if ( json.aoMap !== undefined ) material.aoMap = getTexture( json.aoMap );
			if ( json.aoMapIntensity !== undefined ) material.aoMapIntensity = json.aoMapIntensity;
	
			if ( json.gradientMap !== undefined ) material.gradientMap = getTexture( json.gradientMap );
	
			return material;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		},
	
		setTextures: function ( value ) {
	
			this.textures = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author Don McCurdy / https://www.donmccurdy.com
	 */
	
	var LoaderUtils = {
	
		decodeText: function ( array ) {
	
			if ( typeof TextDecoder !== 'undefined' ) {
	
				return new TextDecoder().decode( array );
	
			}
	
			// Avoid the String.fromCharCode.apply(null, array) shortcut, which
			// throws a "maximum call stack size exceeded" error for large arrays.
	
			var s = '';
	
			for ( var i = 0, il = array.length; i < il; i ++ ) {
	
				// Implicitly assumes little-endian.
				s += String.fromCharCode( array[ i ] );
	
			}
	
			// Merges multi-byte utf-8 characters.
			return decodeURIComponent( escape( s ) );
	
		},
	
		extractUrlBase: function ( url ) {
	
			var index = url.lastIndexOf( '/' );
	
			if ( index === - 1 ) return './';
	
			return url.substr( 0, index + 1 );
	
		}
	
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function BufferGeometryLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( BufferGeometryLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new FileLoader( scope.manager );
			loader.setPath( scope.path );
			loader.load( url, function ( text ) {
	
				onLoad( scope.parse( JSON.parse( text ) ) );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			var geometry = new BufferGeometry();
	
			var index = json.data.index;
	
			if ( index !== undefined ) {
	
				var typedArray = new TYPED_ARRAYS[ index.type ]( index.array );
				geometry.setIndex( new BufferAttribute( typedArray, 1 ) );
	
			}
	
			var attributes = json.data.attributes;
	
			for ( var key in attributes ) {
	
				var attribute = attributes[ key ];
				var typedArray = new TYPED_ARRAYS[ attribute.type ]( attribute.array );
	
				geometry.addAttribute( key, new BufferAttribute( typedArray, attribute.itemSize, attribute.normalized ) );
	
			}
	
			var groups = json.data.groups || json.data.drawcalls || json.data.offsets;
	
			if ( groups !== undefined ) {
	
				for ( var i = 0, n = groups.length; i !== n; ++ i ) {
	
					var group = groups[ i ];
	
					geometry.addGroup( group.start, group.count, group.materialIndex );
	
				}
	
			}
	
			var boundingSphere = json.data.boundingSphere;
	
			if ( boundingSphere !== undefined ) {
	
				var center = new Vector3();
	
				if ( boundingSphere.center !== undefined ) {
	
					center.fromArray( boundingSphere.center );
	
				}
	
				geometry.boundingSphere = new Sphere( center, boundingSphere.radius );
	
			}
	
			if ( json.name ) geometry.name = json.name;
			if ( json.userData ) geometry.userData = json.userData;
	
			return geometry;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	var TYPED_ARRAYS = {
		Int8Array: Int8Array,
		Uint8Array: Uint8Array,
		// Workaround for IE11 pre KB2929437. See #11440
		Uint8ClampedArray: typeof Uint8ClampedArray !== 'undefined' ? Uint8ClampedArray : Uint8Array,
		Int16Array: Int16Array,
		Uint16Array: Uint16Array,
		Int32Array: Int32Array,
		Uint32Array: Uint32Array,
		Float32Array: Float32Array,
		Float64Array: Float64Array
	};
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function ObjectLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
		this.resourcePath = '';
	
	}
	
	Object.assign( ObjectLoader.prototype, {
	
		crossOrigin: 'anonymous',
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var path = ( this.path === undefined ) ? LoaderUtils.extractUrlBase( url ) : this.path;
			this.resourcePath = this.resourcePath || path;
	
			var loader = new FileLoader( scope.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {
	
				var json = null;
	
				try {
	
					json = JSON.parse( text );
	
				} catch ( error ) {
	
					if ( onError !== undefined ) onError( error );
	
					console.error( 'THREE:ObjectLoader: Can\'t parse ' + url + '.', error.message );
	
					return;
	
				}
	
				var metadata = json.metadata;
	
				if ( metadata === undefined || metadata.type === undefined || metadata.type.toLowerCase() === 'geometry' ) {
	
					console.error( 'THREE.ObjectLoader: Can\'t load ' + url );
					return;
	
				}
	
				scope.parse( json, onLoad );
	
			}, onProgress, onError );
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		},
	
		setResourcePath: function ( value ) {
	
			this.resourcePath = value;
			return this;
	
		},
	
		setCrossOrigin: function ( value ) {
	
			this.crossOrigin = value;
			return this;
	
		},
	
		parse: function ( json, onLoad ) {
	
			var shapes = this.parseShape( json.shapes );
			var geometries = this.parseGeometries( json.geometries, shapes );
	
			var images = this.parseImages( json.images, function () {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			} );
	
			var textures = this.parseTextures( json.textures, images );
			var materials = this.parseMaterials( json.materials, textures );
	
			var object = this.parseObject( json.object, geometries, materials );
	
			if ( json.animations ) {
	
				object.animations = this.parseAnimations( json.animations );
	
			}
	
			if ( json.images === undefined || json.images.length === 0 ) {
	
				if ( onLoad !== undefined ) onLoad( object );
	
			}
	
			return object;
	
		},
	
		parseShape: function ( json ) {
	
			var shapes = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var shape = new Shape().fromJSON( json[ i ] );
	
					shapes[ shape.uuid ] = shape;
	
				}
	
			}
	
			return shapes;
	
		},
	
		parseGeometries: function ( json, shapes ) {
	
			var geometries = {};
	
			if ( json !== undefined ) {
	
				var bufferGeometryLoader = new BufferGeometryLoader();
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var geometry;
					var data = json[ i ];
	
					switch ( data.type ) {
	
						case 'PlaneGeometry':
						case 'PlaneBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.widthSegments,
								data.heightSegments
							);
	
							break;
	
						case 'BoxGeometry':
						case 'BoxBufferGeometry':
						case 'CubeGeometry': // backwards compatible
	
							geometry = new Geometries[ data.type ](
								data.width,
								data.height,
								data.depth,
								data.widthSegments,
								data.heightSegments,
								data.depthSegments
							);
	
							break;
	
						case 'CircleGeometry':
						case 'CircleBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radius,
								data.segments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'CylinderGeometry':
						case 'CylinderBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radiusTop,
								data.radiusBottom,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'ConeGeometry':
						case 'ConeBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radius,
								data.height,
								data.radialSegments,
								data.heightSegments,
								data.openEnded,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'SphereGeometry':
						case 'SphereBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radius,
								data.widthSegments,
								data.heightSegments,
								data.phiStart,
								data.phiLength,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'DodecahedronGeometry':
						case 'DodecahedronBufferGeometry':
						case 'IcosahedronGeometry':
						case 'IcosahedronBufferGeometry':
						case 'OctahedronGeometry':
						case 'OctahedronBufferGeometry':
						case 'TetrahedronGeometry':
						case 'TetrahedronBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radius,
								data.detail
							);
	
							break;
	
						case 'RingGeometry':
						case 'RingBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.innerRadius,
								data.outerRadius,
								data.thetaSegments,
								data.phiSegments,
								data.thetaStart,
								data.thetaLength
							);
	
							break;
	
						case 'TorusGeometry':
						case 'TorusBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.radialSegments,
								data.tubularSegments,
								data.arc
							);
	
							break;
	
						case 'TorusKnotGeometry':
						case 'TorusKnotBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.radius,
								data.tube,
								data.tubularSegments,
								data.radialSegments,
								data.p,
								data.q
							);
	
							break;
	
						case 'LatheGeometry':
						case 'LatheBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.points,
								data.segments,
								data.phiStart,
								data.phiLength
							);
	
							break;
	
						case 'PolyhedronGeometry':
						case 'PolyhedronBufferGeometry':
	
							geometry = new Geometries[ data.type ](
								data.vertices,
								data.indices,
								data.radius,
								data.details
							);
	
							break;
	
						case 'ShapeGeometry':
						case 'ShapeBufferGeometry':
	
							var geometryShapes = [];
	
							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {
	
								var shape = shapes[ data.shapes[ j ] ];
	
								geometryShapes.push( shape );
	
							}
	
							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.curveSegments
							);
	
							break;
	
	
						case 'ExtrudeGeometry':
						case 'ExtrudeBufferGeometry':
	
							var geometryShapes = [];
	
							for ( var j = 0, jl = data.shapes.length; j < jl; j ++ ) {
	
								var shape = shapes[ data.shapes[ j ] ];
	
								geometryShapes.push( shape );
	
							}
	
							var extrudePath = data.options.extrudePath;
	
							if ( extrudePath !== undefined ) {
	
								data.options.extrudePath = new Curves[ extrudePath.type ]().fromJSON( extrudePath );
	
							}
	
							geometry = new Geometries[ data.type ](
								geometryShapes,
								data.options
							);
	
							break;
	
						case 'BufferGeometry':
	
							geometry = bufferGeometryLoader.parse( data );
	
							break;
	
						case 'Geometry':
	
							if ( 'THREE' in window && 'LegacyJSONLoader' in THREE ) {
	
								var geometryLoader = new THREE.LegacyJSONLoader();
								geometry = geometryLoader.parse( data, this.resourcePath ).geometry;
	
	
							} else {
	
								console.error( 'THREE.ObjectLoader: You have to import LegacyJSONLoader in order load geometry data of type "Geometry".' );
	
							}
	
							break;
	
						default:
	
							console.warn( 'THREE.ObjectLoader: Unsupported geometry type "' + data.type + '"' );
	
							continue;
	
					}
	
					geometry.uuid = data.uuid;
	
					if ( data.name !== undefined ) geometry.name = data.name;
					if ( geometry.isBufferGeometry === true && data.userData !== undefined ) geometry.userData = data.userData;
	
					geometries[ data.uuid ] = geometry;
	
				}
	
			}
	
			return geometries;
	
		},
	
		parseMaterials: function ( json, textures ) {
	
			var cache = {}; // MultiMaterial
			var materials = {};
	
			if ( json !== undefined ) {
	
				var loader = new MaterialLoader();
				loader.setTextures( textures );
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.type === 'MultiMaterial' ) {
	
						// Deprecated
	
						var array = [];
	
						for ( var j = 0; j < data.materials.length; j ++ ) {
	
							var material = data.materials[ j ];
	
							if ( cache[ material.uuid ] === undefined ) {
	
								cache[ material.uuid ] = loader.parse( material );
	
							}
	
							array.push( cache[ material.uuid ] );
	
						}
	
						materials[ data.uuid ] = array;
	
					} else {
	
						if ( cache[ data.uuid ] === undefined ) {
	
							cache[ data.uuid ] = loader.parse( data );
	
						}
	
						materials[ data.uuid ] = cache[ data.uuid ];
	
					}
	
				}
	
			}
	
			return materials;
	
		},
	
		parseAnimations: function ( json ) {
	
			var animations = [];
	
			for ( var i = 0; i < json.length; i ++ ) {
	
				var data = json[ i ];
	
				var clip = AnimationClip.parse( data );
	
				if ( data.uuid !== undefined ) clip.uuid = data.uuid;
	
				animations.push( clip );
	
			}
	
			return animations;
	
		},
	
		parseImages: function ( json, onLoad ) {
	
			var scope = this;
			var images = {};
	
			function loadImage( url ) {
	
				scope.manager.itemStart( url );
	
				return loader.load( url, function () {
	
					scope.manager.itemEnd( url );
	
				}, undefined, function () {
	
					scope.manager.itemError( url );
					scope.manager.itemEnd( url );
	
				} );
	
			}
	
			if ( json !== undefined && json.length > 0 ) {
	
				var manager = new LoadingManager( onLoad );
	
				var loader = new ImageLoader( manager );
				loader.setCrossOrigin( this.crossOrigin );
	
				for ( var i = 0, il = json.length; i < il; i ++ ) {
	
					var image = json[ i ];
					var url = image.url;
	
					if ( Array.isArray( url ) ) {
	
						// load array of images e.g CubeTexture
	
						images[ image.uuid ] = [];
	
						for ( var j = 0, jl = url.length; j < jl; j ++ ) {
	
							var currentUrl = url[ j ];
	
							var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( currentUrl ) ? currentUrl : scope.resourcePath + currentUrl;
	
							images[ image.uuid ].push( loadImage( path ) );
	
						}
	
					} else {
	
						// load single image
	
						var path = /^(\/\/)|([a-z]+:(\/\/)?)/i.test( image.url ) ? image.url : scope.resourcePath + image.url;
	
						images[ image.uuid ] = loadImage( path );
	
					}
	
				}
	
			}
	
			return images;
	
		},
	
		parseTextures: function ( json, images ) {
	
			function parseConstant( value, type ) {
	
				if ( typeof value === 'number' ) return value;
	
				console.warn( 'THREE.ObjectLoader.parseTexture: Constant should be in numeric form.', value );
	
				return type[ value ];
	
			}
	
			var textures = {};
	
			if ( json !== undefined ) {
	
				for ( var i = 0, l = json.length; i < l; i ++ ) {
	
					var data = json[ i ];
	
					if ( data.image === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: No "image" specified for', data.uuid );
	
					}
	
					if ( images[ data.image ] === undefined ) {
	
						console.warn( 'THREE.ObjectLoader: Undefined image', data.image );
	
					}
	
					var texture;
	
					if ( Array.isArray( images[ data.image ] ) ) {
	
						texture = new CubeTexture( images[ data.image ] );
	
					} else {
	
						texture = new Texture( images[ data.image ] );
	
					}
	
					texture.needsUpdate = true;
	
					texture.uuid = data.uuid;
	
					if ( data.name !== undefined ) texture.name = data.name;
	
					if ( data.mapping !== undefined ) texture.mapping = parseConstant( data.mapping, TEXTURE_MAPPING );
	
					if ( data.offset !== undefined ) texture.offset.fromArray( data.offset );
					if ( data.repeat !== undefined ) texture.repeat.fromArray( data.repeat );
					if ( data.center !== undefined ) texture.center.fromArray( data.center );
					if ( data.rotation !== undefined ) texture.rotation = data.rotation;
	
					if ( data.wrap !== undefined ) {
	
						texture.wrapS = parseConstant( data.wrap[ 0 ], TEXTURE_WRAPPING );
						texture.wrapT = parseConstant( data.wrap[ 1 ], TEXTURE_WRAPPING );
	
					}
	
					if ( data.format !== undefined ) texture.format = data.format;
					if ( data.type !== undefined ) texture.type = data.type;
					if ( data.encoding !== undefined ) texture.encoding = data.encoding;
	
					if ( data.minFilter !== undefined ) texture.minFilter = parseConstant( data.minFilter, TEXTURE_FILTER );
					if ( data.magFilter !== undefined ) texture.magFilter = parseConstant( data.magFilter, TEXTURE_FILTER );
					if ( data.anisotropy !== undefined ) texture.anisotropy = data.anisotropy;
	
					if ( data.flipY !== undefined ) texture.flipY = data.flipY;
	
					if ( data.premultiplyAlpha !== undefined ) texture.premultiplyAlpha = data.premultiplyAlpha;
					if ( data.unpackAlignment !== undefined ) texture.unpackAlignment = data.unpackAlignment;
	
					textures[ data.uuid ] = texture;
	
				}
	
			}
	
			return textures;
	
		},
	
		parseObject: function ( data, geometries, materials ) {
	
			var object;
	
			function getGeometry( name ) {
	
				if ( geometries[ name ] === undefined ) {
	
					console.warn( 'THREE.ObjectLoader: Undefined geometry', name );
	
				}
	
				return geometries[ name ];
	
			}
	
			function getMaterial( name ) {
	
				if ( name === undefined ) return undefined;
	
				if ( Array.isArray( name ) ) {
	
					var array = [];
	
					for ( var i = 0, l = name.length; i < l; i ++ ) {
	
						var uuid = name[ i ];
	
						if ( materials[ uuid ] === undefined ) {
	
							console.warn( 'THREE.ObjectLoader: Undefined material', uuid );
	
						}
	
						array.push( materials[ uuid ] );
	
					}
	
					return array;
	
				}
	
				if ( materials[ name ] === undefined ) {
	
					console.warn( 'THREE.ObjectLoader: Undefined material', name );
	
				}
	
				return materials[ name ];
	
			}
	
			switch ( data.type ) {
	
				case 'Scene':
	
					object = new Scene();
	
					if ( data.background !== undefined ) {
	
						if ( Number.isInteger( data.background ) ) {
	
							object.background = new Color( data.background );
	
						}
	
					}
	
					if ( data.fog !== undefined ) {
	
						if ( data.fog.type === 'Fog' ) {
	
							object.fog = new Fog( data.fog.color, data.fog.near, data.fog.far );
	
						} else if ( data.fog.type === 'FogExp2' ) {
	
							object.fog = new FogExp2( data.fog.color, data.fog.density );
	
						}
	
					}
	
					break;
	
				case 'PerspectiveCamera':
	
					object = new PerspectiveCamera( data.fov, data.aspect, data.near, data.far );
	
					if ( data.focus !== undefined ) object.focus = data.focus;
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.filmGauge !== undefined ) object.filmGauge = data.filmGauge;
					if ( data.filmOffset !== undefined ) object.filmOffset = data.filmOffset;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
					break;
	
				case 'OrthographicCamera':
	
					object = new OrthographicCamera( data.left, data.right, data.top, data.bottom, data.near, data.far );
	
					if ( data.zoom !== undefined ) object.zoom = data.zoom;
					if ( data.view !== undefined ) object.view = Object.assign( {}, data.view );
	
					break;
	
				case 'AmbientLight':
	
					object = new AmbientLight( data.color, data.intensity );
	
					break;
	
				case 'DirectionalLight':
	
					object = new DirectionalLight( data.color, data.intensity );
	
					break;
	
				case 'PointLight':
	
					object = new PointLight( data.color, data.intensity, data.distance, data.decay );
	
					break;
	
				case 'RectAreaLight':
	
					object = new RectAreaLight( data.color, data.intensity, data.width, data.height );
	
					break;
	
				case 'SpotLight':
	
					object = new SpotLight( data.color, data.intensity, data.distance, data.angle, data.penumbra, data.decay );
	
					break;
	
				case 'HemisphereLight':
	
					object = new HemisphereLight( data.color, data.groundColor, data.intensity );
	
					break;
	
				case 'SkinnedMesh':
	
					console.warn( 'THREE.ObjectLoader.parseObject() does not support SkinnedMesh yet.' );
	
				case 'Mesh':
	
					var geometry = getGeometry( data.geometry );
					var material = getMaterial( data.material );
	
					if ( geometry.bones && geometry.bones.length > 0 ) {
	
						object = new SkinnedMesh( geometry, material );
	
					} else {
	
						object = new Mesh( geometry, material );
	
					}
	
					if ( data.drawMode !== undefined ) object.setDrawMode( data.drawMode );
	
					break;
	
				case 'LOD':
	
					object = new LOD();
	
					break;
	
				case 'Line':
	
					object = new Line( getGeometry( data.geometry ), getMaterial( data.material ), data.mode );
	
					break;
	
				case 'LineLoop':
	
					object = new LineLoop( getGeometry( data.geometry ), getMaterial( data.material ) );
	
					break;
	
				case 'LineSegments':
	
					object = new LineSegments( getGeometry( data.geometry ), getMaterial( data.material ) );
	
					break;
	
				case 'PointCloud':
				case 'Points':
	
					object = new Points( getGeometry( data.geometry ), getMaterial( data.material ) );
	
					break;
	
				case 'Sprite':
	
					object = new Sprite( getMaterial( data.material ) );
	
					break;
	
				case 'Group':
	
					object = new Group();
	
					break;
	
				default:
	
					object = new Object3D();
	
			}
	
			object.uuid = data.uuid;
	
			if ( data.name !== undefined ) object.name = data.name;
	
			if ( data.matrix !== undefined ) {
	
				object.matrix.fromArray( data.matrix );
	
				if ( data.matrixAutoUpdate !== undefined ) object.matrixAutoUpdate = data.matrixAutoUpdate;
				if ( object.matrixAutoUpdate ) object.matrix.decompose( object.position, object.quaternion, object.scale );
	
			} else {
	
				if ( data.position !== undefined ) object.position.fromArray( data.position );
				if ( data.rotation !== undefined ) object.rotation.fromArray( data.rotation );
				if ( data.quaternion !== undefined ) object.quaternion.fromArray( data.quaternion );
				if ( data.scale !== undefined ) object.scale.fromArray( data.scale );
	
			}
	
			if ( data.castShadow !== undefined ) object.castShadow = data.castShadow;
			if ( data.receiveShadow !== undefined ) object.receiveShadow = data.receiveShadow;
	
			if ( data.shadow ) {
	
				if ( data.shadow.bias !== undefined ) object.shadow.bias = data.shadow.bias;
				if ( data.shadow.radius !== undefined ) object.shadow.radius = data.shadow.radius;
				if ( data.shadow.mapSize !== undefined ) object.shadow.mapSize.fromArray( data.shadow.mapSize );
				if ( data.shadow.camera !== undefined ) object.shadow.camera = this.parseObject( data.shadow.camera );
	
			}
	
			if ( data.visible !== undefined ) object.visible = data.visible;
			if ( data.frustumCulled !== undefined ) object.frustumCulled = data.frustumCulled;
			if ( data.renderOrder !== undefined ) object.renderOrder = data.renderOrder;
			if ( data.userData !== undefined ) object.userData = data.userData;
			if ( data.layers !== undefined ) object.layers.mask = data.layers;
	
			if ( data.children !== undefined ) {
	
				var children = data.children;
	
				for ( var i = 0; i < children.length; i ++ ) {
	
					object.add( this.parseObject( children[ i ], geometries, materials ) );
	
				}
	
			}
	
			if ( data.type === 'LOD' ) {
	
				var levels = data.levels;
	
				for ( var l = 0; l < levels.length; l ++ ) {
	
					var level = levels[ l ];
					var child = object.getObjectByProperty( 'uuid', level.object );
	
					if ( child !== undefined ) {
	
						object.addLevel( child, level.distance );
	
					}
	
				}
	
			}
	
			return object;
	
		}
	
	} );
	
	var TEXTURE_MAPPING = {
		UVMapping: UVMapping,
		CubeReflectionMapping: CubeReflectionMapping,
		CubeRefractionMapping: CubeRefractionMapping,
		EquirectangularReflectionMapping: EquirectangularReflectionMapping,
		EquirectangularRefractionMapping: EquirectangularRefractionMapping,
		SphericalReflectionMapping: SphericalReflectionMapping,
		CubeUVReflectionMapping: CubeUVReflectionMapping,
		CubeUVRefractionMapping: CubeUVRefractionMapping
	};
	
	var TEXTURE_WRAPPING = {
		RepeatWrapping: RepeatWrapping,
		ClampToEdgeWrapping: ClampToEdgeWrapping,
		MirroredRepeatWrapping: MirroredRepeatWrapping
	};
	
	var TEXTURE_FILTER = {
		NearestFilter: NearestFilter,
		NearestMipMapNearestFilter: NearestMipMapNearestFilter,
		NearestMipMapLinearFilter: NearestMipMapLinearFilter,
		LinearFilter: LinearFilter,
		LinearMipMapNearestFilter: LinearMipMapNearestFilter,
		LinearMipMapLinearFilter: LinearMipMapLinearFilter
	};
	
	/**
	 * @author thespite / http://clicktorelease.com/
	 */
	
	
	function ImageBitmapLoader( manager ) {
	
		if ( typeof createImageBitmap === 'undefined' ) {
	
			console.warn( 'THREE.ImageBitmapLoader: createImageBitmap() not supported.' );
	
		}
	
		if ( typeof fetch === 'undefined' ) {
	
			console.warn( 'THREE.ImageBitmapLoader: fetch() not supported.' );
	
		}
	
		this.manager = manager !== undefined ? manager : DefaultLoadingManager;
		this.options = undefined;
	
	}
	
	ImageBitmapLoader.prototype = {
	
		constructor: ImageBitmapLoader,
	
		setOptions: function setOptions( options ) {
	
			this.options = options;
	
			return this;
	
		},
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			if ( url === undefined ) url = '';
	
			if ( this.path !== undefined ) url = this.path + url;
	
			url = this.manager.resolveURL( url );
	
			var scope = this;
	
			var cached = Cache.get( url );
	
			if ( cached !== undefined ) {
	
				scope.manager.itemStart( url );
	
				setTimeout( function () {
	
					if ( onLoad ) onLoad( cached );
	
					scope.manager.itemEnd( url );
	
				}, 0 );
	
				return cached;
	
			}
	
			fetch( url ).then( function ( res ) {
	
				return res.blob();
	
			} ).then( function ( blob ) {
	
				return createImageBitmap( blob, scope.options );
	
			} ).then( function ( imageBitmap ) {
	
				Cache.add( url, imageBitmap );
	
				if ( onLoad ) onLoad( imageBitmap );
	
				scope.manager.itemEnd( url );
	
			} ).catch( function ( e ) {
	
				if ( onError ) onError( e );
	
				scope.manager.itemError( url );
				scope.manager.itemEnd( url );
	
			} );
	
		},
	
		setCrossOrigin: function ( /* value */ ) {
	
			return this;
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	};
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * minimal class for proxing functions to Path. Replaces old "extractSubpaths()"
	 **/
	
	function ShapePath() {
	
		this.type = 'ShapePath';
	
		this.color = new Color();
	
		this.subPaths = [];
		this.currentPath = null;
	
	}
	
	Object.assign( ShapePath.prototype, {
	
		moveTo: function ( x, y ) {
	
			this.currentPath = new Path();
			this.subPaths.push( this.currentPath );
			this.currentPath.moveTo( x, y );
	
		},
	
		lineTo: function ( x, y ) {
	
			this.currentPath.lineTo( x, y );
	
		},
	
		quadraticCurveTo: function ( aCPx, aCPy, aX, aY ) {
	
			this.currentPath.quadraticCurveTo( aCPx, aCPy, aX, aY );
	
		},
	
		bezierCurveTo: function ( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY ) {
	
			this.currentPath.bezierCurveTo( aCP1x, aCP1y, aCP2x, aCP2y, aX, aY );
	
		},
	
		splineThru: function ( pts ) {
	
			this.currentPath.splineThru( pts );
	
		},
	
		toShapes: function ( isCCW, noHoles ) {
	
			function toShapesNoHoles( inSubpaths ) {
	
				var shapes = [];
	
				for ( var i = 0, l = inSubpaths.length; i < l; i ++ ) {
	
					var tmpPath = inSubpaths[ i ];
	
					var tmpShape = new Shape();
					tmpShape.curves = tmpPath.curves;
	
					shapes.push( tmpShape );
	
				}
	
				return shapes;
	
			}
	
			function isPointInsidePolygon( inPt, inPolygon ) {
	
				var polyLen = inPolygon.length;
	
				// inPt on polygon contour => immediate success    or
				// toggling of inside/outside at every single! intersection point of an edge
				//  with the horizontal line through inPt, left of inPt
				//  not counting lowerY endpoints of edges and whole edges on that line
				var inside = false;
				for ( var p = polyLen - 1, q = 0; q < polyLen; p = q ++ ) {
	
					var edgeLowPt = inPolygon[ p ];
					var edgeHighPt = inPolygon[ q ];
	
					var edgeDx = edgeHighPt.x - edgeLowPt.x;
					var edgeDy = edgeHighPt.y - edgeLowPt.y;
	
					if ( Math.abs( edgeDy ) > Number.EPSILON ) {
	
						// not parallel
						if ( edgeDy < 0 ) {
	
							edgeLowPt = inPolygon[ q ]; edgeDx = - edgeDx;
							edgeHighPt = inPolygon[ p ]; edgeDy = - edgeDy;
	
						}
						if ( ( inPt.y < edgeLowPt.y ) || ( inPt.y > edgeHighPt.y ) ) 		continue;
	
						if ( inPt.y === edgeLowPt.y ) {
	
							if ( inPt.x === edgeLowPt.x )		return	true;		// inPt is on contour ?
							// continue;				// no intersection or edgeLowPt => doesn't count !!!
	
						} else {
	
							var perpEdge = edgeDy * ( inPt.x - edgeLowPt.x ) - edgeDx * ( inPt.y - edgeLowPt.y );
							if ( perpEdge === 0 )				return	true;		// inPt is on contour ?
							if ( perpEdge < 0 ) 				continue;
							inside = ! inside;		// true intersection left of inPt
	
						}
	
					} else {
	
						// parallel or collinear
						if ( inPt.y !== edgeLowPt.y ) 		continue;			// parallel
						// edge lies on the same horizontal line as inPt
						if ( ( ( edgeHighPt.x <= inPt.x ) && ( inPt.x <= edgeLowPt.x ) ) ||
							 ( ( edgeLowPt.x <= inPt.x ) && ( inPt.x <= edgeHighPt.x ) ) )		return	true;	// inPt: Point on contour !
						// continue;
	
					}
	
				}
	
				return	inside;
	
			}
	
			var isClockWise = ShapeUtils.isClockWise;
	
			var subPaths = this.subPaths;
			if ( subPaths.length === 0 ) return [];
	
			if ( noHoles === true )	return	toShapesNoHoles( subPaths );
	
	
			var solid, tmpPath, tmpShape, shapes = [];
	
			if ( subPaths.length === 1 ) {
	
				tmpPath = subPaths[ 0 ];
				tmpShape = new Shape();
				tmpShape.curves = tmpPath.curves;
				shapes.push( tmpShape );
				return shapes;
	
			}
	
			var holesFirst = ! isClockWise( subPaths[ 0 ].getPoints() );
			holesFirst = isCCW ? ! holesFirst : holesFirst;
	
			// console.log("Holes first", holesFirst);
	
			var betterShapeHoles = [];
			var newShapes = [];
			var newShapeHoles = [];
			var mainIdx = 0;
			var tmpPoints;
	
			newShapes[ mainIdx ] = undefined;
			newShapeHoles[ mainIdx ] = [];
	
			for ( var i = 0, l = subPaths.length; i < l; i ++ ) {
	
				tmpPath = subPaths[ i ];
				tmpPoints = tmpPath.getPoints();
				solid = isClockWise( tmpPoints );
				solid = isCCW ? ! solid : solid;
	
				if ( solid ) {
	
					if ( ( ! holesFirst ) && ( newShapes[ mainIdx ] ) )	mainIdx ++;
	
					newShapes[ mainIdx ] = { s: new Shape(), p: tmpPoints };
					newShapes[ mainIdx ].s.curves = tmpPath.curves;
	
					if ( holesFirst )	mainIdx ++;
					newShapeHoles[ mainIdx ] = [];
	
					//console.log('cw', i);
	
				} else {
	
					newShapeHoles[ mainIdx ].push( { h: tmpPath, p: tmpPoints[ 0 ] } );
	
					//console.log('ccw', i);
	
				}
	
			}
	
			// only Holes? -> probably all Shapes with wrong orientation
			if ( ! newShapes[ 0 ] )	return	toShapesNoHoles( subPaths );
	
	
			if ( newShapes.length > 1 ) {
	
				var ambiguous = false;
				var toChange = [];
	
				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
					betterShapeHoles[ sIdx ] = [];
	
				}
	
				for ( var sIdx = 0, sLen = newShapes.length; sIdx < sLen; sIdx ++ ) {
	
					var sho = newShapeHoles[ sIdx ];
	
					for ( var hIdx = 0; hIdx < sho.length; hIdx ++ ) {
	
						var ho = sho[ hIdx ];
						var hole_unassigned = true;
	
						for ( var s2Idx = 0; s2Idx < newShapes.length; s2Idx ++ ) {
	
							if ( isPointInsidePolygon( ho.p, newShapes[ s2Idx ].p ) ) {
	
								if ( sIdx !== s2Idx )	toChange.push( { froms: sIdx, tos: s2Idx, hole: hIdx } );
								if ( hole_unassigned ) {
	
									hole_unassigned = false;
									betterShapeHoles[ s2Idx ].push( ho );
	
								} else {
	
									ambiguous = true;
	
								}
	
							}
	
						}
						if ( hole_unassigned ) {
	
							betterShapeHoles[ sIdx ].push( ho );
	
						}
	
					}
	
				}
				// console.log("ambiguous: ", ambiguous);
				if ( toChange.length > 0 ) {
	
					// console.log("to change: ", toChange);
					if ( ! ambiguous )	newShapeHoles = betterShapeHoles;
	
				}
	
			}
	
			var tmpHoles;
	
			for ( var i = 0, il = newShapes.length; i < il; i ++ ) {
	
				tmpShape = newShapes[ i ].s;
				shapes.push( tmpShape );
				tmpHoles = newShapeHoles[ i ];
	
				for ( var j = 0, jl = tmpHoles.length; j < jl; j ++ ) {
	
					tmpShape.holes.push( tmpHoles[ j ].h );
	
				}
	
			}
	
			//console.log("shape", shapes);
	
			return shapes;
	
		}
	
	} );
	
	/**
	 * @author zz85 / http://www.lab4games.net/zz85/blog
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	
	function Font( data ) {
	
		this.type = 'Font';
	
		this.data = data;
	
	}
	
	Object.assign( Font.prototype, {
	
		isFont: true,
	
		generateShapes: function ( text, size ) {
	
			if ( size === undefined ) size = 100;
	
			var shapes = [];
			var paths = createPaths( text, size, this.data );
	
			for ( var p = 0, pl = paths.length; p < pl; p ++ ) {
	
				Array.prototype.push.apply( shapes, paths[ p ].toShapes() );
	
			}
	
			return shapes;
	
		}
	
	} );
	
	function createPaths( text, size, data ) {
	
		var chars = Array.from ? Array.from( text ) : String( text ).split( '' ); // see #13988
		var scale = size / data.resolution;
		var line_height = ( data.boundingBox.yMax - data.boundingBox.yMin + data.underlineThickness ) * scale;
	
		var paths = [];
	
		var offsetX = 0, offsetY = 0;
	
		for ( var i = 0; i < chars.length; i ++ ) {
	
			var char = chars[ i ];
	
			if ( char === '\n' ) {
	
				offsetX = 0;
				offsetY -= line_height;
	
			} else {
	
				var ret = createPath( char, scale, offsetX, offsetY, data );
				offsetX += ret.offsetX;
				paths.push( ret.path );
	
			}
	
		}
	
		return paths;
	
	}
	
	function createPath( char, scale, offsetX, offsetY, data ) {
	
		var glyph = data.glyphs[ char ] || data.glyphs[ '?' ];
	
		if ( ! glyph ) return;
	
		var path = new ShapePath();
	
		var x, y, cpx, cpy, cpx1, cpy1, cpx2, cpy2;
	
		if ( glyph.o ) {
	
			var outline = glyph._cachedOutline || ( glyph._cachedOutline = glyph.o.split( ' ' ) );
	
			for ( var i = 0, l = outline.length; i < l; ) {
	
				var action = outline[ i ++ ];
	
				switch ( action ) {
	
					case 'm': // moveTo
	
						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;
	
						path.moveTo( x, y );
	
						break;
	
					case 'l': // lineTo
	
						x = outline[ i ++ ] * scale + offsetX;
						y = outline[ i ++ ] * scale + offsetY;
	
						path.lineTo( x, y );
	
						break;
	
					case 'q': // quadraticCurveTo
	
						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
	
						path.quadraticCurveTo( cpx1, cpy1, cpx, cpy );
	
						break;
	
					case 'b': // bezierCurveTo
	
						cpx = outline[ i ++ ] * scale + offsetX;
						cpy = outline[ i ++ ] * scale + offsetY;
						cpx1 = outline[ i ++ ] * scale + offsetX;
						cpy1 = outline[ i ++ ] * scale + offsetY;
						cpx2 = outline[ i ++ ] * scale + offsetX;
						cpy2 = outline[ i ++ ] * scale + offsetY;
	
						path.bezierCurveTo( cpx1, cpy1, cpx2, cpy2, cpx, cpy );
	
						break;
	
				}
	
			}
	
		}
	
		return { offsetX: glyph.ha * scale, path: path };
	
	}
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function FontLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( FontLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var scope = this;
	
			var loader = new FileLoader( this.manager );
			loader.setPath( this.path );
			loader.load( url, function ( text ) {
	
				var json;
	
				try {
	
					json = JSON.parse( text );
	
				} catch ( e ) {
	
					console.warn( 'THREE.FontLoader: typeface.js support is being deprecated. Use typeface.json instead.' );
					json = JSON.parse( text.substring( 65, text.length - 2 ) );
	
				}
	
				var font = scope.parse( json );
	
				if ( onLoad ) onLoad( font );
	
			}, onProgress, onError );
	
		},
	
		parse: function ( json ) {
	
			return new Font( json );
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function Loader() {}
	
	Loader.Handlers = {
	
		handlers: [],
	
		add: function ( regex, loader ) {
	
			this.handlers.push( regex, loader );
	
		},
	
		get: function ( file ) {
	
			var handlers = this.handlers;
	
			for ( var i = 0, l = handlers.length; i < l; i += 2 ) {
	
				var regex = handlers[ i ];
				var loader = handlers[ i + 1 ];
	
				if ( regex.test( file ) ) {
	
					return loader;
	
				}
	
			}
	
			return null;
	
		}
	
	};
	
	Object.assign( Loader.prototype, {
	
		crossOrigin: 'anonymous',
	
		onLoadStart: function () {},
	
		onLoadProgress: function () {},
	
		onLoadComplete: function () {},
	
		initMaterials: function ( materials, texturePath, crossOrigin ) {
	
			var array = [];
	
			for ( var i = 0; i < materials.length; ++ i ) {
	
				array[ i ] = this.createMaterial( materials[ i ], texturePath, crossOrigin );
	
			}
	
			return array;
	
		},
	
		createMaterial: ( function () {
	
			var BlendingMode = {
				NoBlending: NoBlending,
				NormalBlending: NormalBlending,
				AdditiveBlending: AdditiveBlending,
				SubtractiveBlending: SubtractiveBlending,
				MultiplyBlending: MultiplyBlending,
				CustomBlending: CustomBlending
			};
	
			var color = new Color();
			var textureLoader = new TextureLoader();
			var materialLoader = new MaterialLoader();
	
			return function createMaterial( m, texturePath, crossOrigin ) {
	
				// convert from old material format
	
				var textures = {};
	
				function loadTexture( path, repeat, offset, wrap, anisotropy ) {
	
					var fullPath = texturePath + path;
					var loader = Loader.Handlers.get( fullPath );
	
					var texture;
	
					if ( loader !== null ) {
	
						texture = loader.load( fullPath );
	
					} else {
	
						textureLoader.setCrossOrigin( crossOrigin );
						texture = textureLoader.load( fullPath );
	
					}
	
					if ( repeat !== undefined ) {
	
						texture.repeat.fromArray( repeat );
	
						if ( repeat[ 0 ] !== 1 ) texture.wrapS = RepeatWrapping;
						if ( repeat[ 1 ] !== 1 ) texture.wrapT = RepeatWrapping;
	
					}
	
					if ( offset !== undefined ) {
	
						texture.offset.fromArray( offset );
	
					}
	
					if ( wrap !== undefined ) {
	
						if ( wrap[ 0 ] === 'repeat' ) texture.wrapS = RepeatWrapping;
						if ( wrap[ 0 ] === 'mirror' ) texture.wrapS = MirroredRepeatWrapping;
	
						if ( wrap[ 1 ] === 'repeat' ) texture.wrapT = RepeatWrapping;
						if ( wrap[ 1 ] === 'mirror' ) texture.wrapT = MirroredRepeatWrapping;
	
					}
	
					if ( anisotropy !== undefined ) {
	
						texture.anisotropy = anisotropy;
	
					}
	
					var uuid = _Math.generateUUID();
	
					textures[ uuid ] = texture;
	
					return uuid;
	
				}
	
				//
	
				var json = {
					uuid: _Math.generateUUID(),
					type: 'MeshLambertMaterial'
				};
	
				for ( var name in m ) {
	
					var value = m[ name ];
	
					switch ( name ) {
	
						case 'DbgColor':
						case 'DbgIndex':
						case 'opticalDensity':
						case 'illumination':
							break;
						case 'DbgName':
							json.name = value;
							break;
						case 'blending':
							json.blending = BlendingMode[ value ];
							break;
						case 'colorAmbient':
						case 'mapAmbient':
							console.warn( 'THREE.Loader.createMaterial:', name, 'is no longer supported.' );
							break;
						case 'colorDiffuse':
							json.color = color.fromArray( value ).getHex();
							break;
						case 'colorSpecular':
							json.specular = color.fromArray( value ).getHex();
							break;
						case 'colorEmissive':
							json.emissive = color.fromArray( value ).getHex();
							break;
						case 'specularCoef':
							json.shininess = value;
							break;
						case 'shading':
							if ( value.toLowerCase() === 'basic' ) json.type = 'MeshBasicMaterial';
							if ( value.toLowerCase() === 'phong' ) json.type = 'MeshPhongMaterial';
							if ( value.toLowerCase() === 'standard' ) json.type = 'MeshStandardMaterial';
							break;
						case 'mapDiffuse':
							json.map = loadTexture( value, m.mapDiffuseRepeat, m.mapDiffuseOffset, m.mapDiffuseWrap, m.mapDiffuseAnisotropy );
							break;
						case 'mapDiffuseRepeat':
						case 'mapDiffuseOffset':
						case 'mapDiffuseWrap':
						case 'mapDiffuseAnisotropy':
							break;
						case 'mapEmissive':
							json.emissiveMap = loadTexture( value, m.mapEmissiveRepeat, m.mapEmissiveOffset, m.mapEmissiveWrap, m.mapEmissiveAnisotropy );
							break;
						case 'mapEmissiveRepeat':
						case 'mapEmissiveOffset':
						case 'mapEmissiveWrap':
						case 'mapEmissiveAnisotropy':
							break;
						case 'mapLight':
							json.lightMap = loadTexture( value, m.mapLightRepeat, m.mapLightOffset, m.mapLightWrap, m.mapLightAnisotropy );
							break;
						case 'mapLightRepeat':
						case 'mapLightOffset':
						case 'mapLightWrap':
						case 'mapLightAnisotropy':
							break;
						case 'mapAO':
							json.aoMap = loadTexture( value, m.mapAORepeat, m.mapAOOffset, m.mapAOWrap, m.mapAOAnisotropy );
							break;
						case 'mapAORepeat':
						case 'mapAOOffset':
						case 'mapAOWrap':
						case 'mapAOAnisotropy':
							break;
						case 'mapBump':
							json.bumpMap = loadTexture( value, m.mapBumpRepeat, m.mapBumpOffset, m.mapBumpWrap, m.mapBumpAnisotropy );
							break;
						case 'mapBumpScale':
							json.bumpScale = value;
							break;
						case 'mapBumpRepeat':
						case 'mapBumpOffset':
						case 'mapBumpWrap':
						case 'mapBumpAnisotropy':
							break;
						case 'mapNormal':
							json.normalMap = loadTexture( value, m.mapNormalRepeat, m.mapNormalOffset, m.mapNormalWrap, m.mapNormalAnisotropy );
							break;
						case 'mapNormalFactor':
							json.normalScale = value;
							break;
						case 'mapNormalRepeat':
						case 'mapNormalOffset':
						case 'mapNormalWrap':
						case 'mapNormalAnisotropy':
							break;
						case 'mapSpecular':
							json.specularMap = loadTexture( value, m.mapSpecularRepeat, m.mapSpecularOffset, m.mapSpecularWrap, m.mapSpecularAnisotropy );
							break;
						case 'mapSpecularRepeat':
						case 'mapSpecularOffset':
						case 'mapSpecularWrap':
						case 'mapSpecularAnisotropy':
							break;
						case 'mapMetalness':
							json.metalnessMap = loadTexture( value, m.mapMetalnessRepeat, m.mapMetalnessOffset, m.mapMetalnessWrap, m.mapMetalnessAnisotropy );
							break;
						case 'mapMetalnessRepeat':
						case 'mapMetalnessOffset':
						case 'mapMetalnessWrap':
						case 'mapMetalnessAnisotropy':
							break;
						case 'mapRoughness':
							json.roughnessMap = loadTexture( value, m.mapRoughnessRepeat, m.mapRoughnessOffset, m.mapRoughnessWrap, m.mapRoughnessAnisotropy );
							break;
						case 'mapRoughnessRepeat':
						case 'mapRoughnessOffset':
						case 'mapRoughnessWrap':
						case 'mapRoughnessAnisotropy':
							break;
						case 'mapAlpha':
							json.alphaMap = loadTexture( value, m.mapAlphaRepeat, m.mapAlphaOffset, m.mapAlphaWrap, m.mapAlphaAnisotropy );
							break;
						case 'mapAlphaRepeat':
						case 'mapAlphaOffset':
						case 'mapAlphaWrap':
						case 'mapAlphaAnisotropy':
							break;
						case 'flipSided':
							json.side = BackSide;
							break;
						case 'doubleSided':
							json.side = DoubleSide;
							break;
						case 'transparency':
							console.warn( 'THREE.Loader.createMaterial: transparency has been renamed to opacity' );
							json.opacity = value;
							break;
						case 'depthTest':
						case 'depthWrite':
						case 'colorWrite':
						case 'opacity':
						case 'reflectivity':
						case 'transparent':
						case 'visible':
						case 'wireframe':
							json[ name ] = value;
							break;
						case 'vertexColors':
							if ( value === true ) json.vertexColors = VertexColors;
							if ( value === 'face' ) json.vertexColors = FaceColors;
							break;
						default:
							console.error( 'THREE.Loader.createMaterial: Unsupported', name, value );
							break;
	
					}
	
				}
	
				if ( json.type === 'MeshBasicMaterial' ) delete json.emissive;
				if ( json.type !== 'MeshPhongMaterial' ) delete json.specular;
	
				if ( json.opacity < 1 ) json.transparent = true;
	
				materialLoader.setTextures( textures );
	
				return materialLoader.parse( json );
	
			};
	
		} )()
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	var context;
	
	var AudioContext = {
	
		getContext: function () {
	
			if ( context === undefined ) {
	
				context = new ( window.AudioContext || window.webkitAudioContext )();
	
			}
	
			return context;
	
		},
	
		setContext: function ( value ) {
	
			context = value;
	
		}
	
	};
	
	/**
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */
	
	function AudioLoader( manager ) {
	
		this.manager = ( manager !== undefined ) ? manager : DefaultLoadingManager;
	
	}
	
	Object.assign( AudioLoader.prototype, {
	
		load: function ( url, onLoad, onProgress, onError ) {
	
			var loader = new FileLoader( this.manager );
			loader.setResponseType( 'arraybuffer' );
			loader.setPath( this.path );
			loader.load( url, function ( buffer ) {
	
				// Create a copy of the buffer. The `decodeAudioData` method
				// detaches the buffer when complete, preventing reuse.
				var bufferCopy = buffer.slice( 0 );
	
				var context = AudioContext.getContext();
				context.decodeAudioData( bufferCopy, function ( audioBuffer ) {
	
					onLoad( audioBuffer );
	
				} );
	
			}, onProgress, onError );
	
		},
	
		setPath: function ( value ) {
	
			this.path = value;
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function StereoCamera() {
	
		this.type = 'StereoCamera';
	
		this.aspect = 1;
	
		this.eyeSep = 0.064;
	
		this.cameraL = new PerspectiveCamera();
		this.cameraL.layers.enable( 1 );
		this.cameraL.matrixAutoUpdate = false;
	
		this.cameraR = new PerspectiveCamera();
		this.cameraR.layers.enable( 2 );
		this.cameraR.matrixAutoUpdate = false;
	
	}
	
	Object.assign( StereoCamera.prototype, {
	
		update: ( function () {
	
			var instance, focus, fov, aspect, near, far, zoom, eyeSep;
	
			var eyeRight = new Matrix4();
			var eyeLeft = new Matrix4();
	
			return function update( camera ) {
	
				var needsUpdate = instance !== this || focus !== camera.focus || fov !== camera.fov ||
													aspect !== camera.aspect * this.aspect || near !== camera.near ||
													far !== camera.far || zoom !== camera.zoom || eyeSep !== this.eyeSep;
	
				if ( needsUpdate ) {
	
					instance = this;
					focus = camera.focus;
					fov = camera.fov;
					aspect = camera.aspect * this.aspect;
					near = camera.near;
					far = camera.far;
					zoom = camera.zoom;
	
					// Off-axis stereoscopic effect based on
					// http://paulbourke.net/stereographics/stereorender/
	
					var projectionMatrix = camera.projectionMatrix.clone();
					eyeSep = this.eyeSep / 2;
					var eyeSepOnProjection = eyeSep * near / focus;
					var ymax = ( near * Math.tan( _Math.DEG2RAD * fov * 0.5 ) ) / zoom;
					var xmin, xmax;
	
					// translate xOffset
	
					eyeLeft.elements[ 12 ] = - eyeSep;
					eyeRight.elements[ 12 ] = eyeSep;
	
					// for left eye
	
					xmin = - ymax * aspect + eyeSepOnProjection;
					xmax = ymax * aspect + eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraL.projectionMatrix.copy( projectionMatrix );
	
					// for right eye
	
					xmin = - ymax * aspect - eyeSepOnProjection;
					xmax = ymax * aspect - eyeSepOnProjection;
	
					projectionMatrix.elements[ 0 ] = 2 * near / ( xmax - xmin );
					projectionMatrix.elements[ 8 ] = ( xmax + xmin ) / ( xmax - xmin );
	
					this.cameraR.projectionMatrix.copy( projectionMatrix );
	
				}
	
				this.cameraL.matrixWorld.copy( camera.matrixWorld ).multiply( eyeLeft );
				this.cameraR.matrixWorld.copy( camera.matrixWorld ).multiply( eyeRight );
	
			};
	
		} )()
	
	} );
	
	/**
	 * Camera for rendering cube maps
	 *	- renders scene into axis-aligned cube
	 *
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function CubeCamera( near, far, cubeResolution, options ) {
	
		Object3D.call( this );
	
		this.type = 'CubeCamera';
	
		var fov = 90, aspect = 1;
	
		var cameraPX = new PerspectiveCamera( fov, aspect, near, far );
		cameraPX.up.set( 0, - 1, 0 );
		cameraPX.lookAt( new Vector3( 1, 0, 0 ) );
		this.add( cameraPX );
	
		var cameraNX = new PerspectiveCamera( fov, aspect, near, far );
		cameraNX.up.set( 0, - 1, 0 );
		cameraNX.lookAt( new Vector3( - 1, 0, 0 ) );
		this.add( cameraNX );
	
		var cameraPY = new PerspectiveCamera( fov, aspect, near, far );
		cameraPY.up.set( 0, 0, 1 );
		cameraPY.lookAt( new Vector3( 0, 1, 0 ) );
		this.add( cameraPY );
	
		var cameraNY = new PerspectiveCamera( fov, aspect, near, far );
		cameraNY.up.set( 0, 0, - 1 );
		cameraNY.lookAt( new Vector3( 0, - 1, 0 ) );
		this.add( cameraNY );
	
		var cameraPZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraPZ.up.set( 0, - 1, 0 );
		cameraPZ.lookAt( new Vector3( 0, 0, 1 ) );
		this.add( cameraPZ );
	
		var cameraNZ = new PerspectiveCamera( fov, aspect, near, far );
		cameraNZ.up.set( 0, - 1, 0 );
		cameraNZ.lookAt( new Vector3( 0, 0, - 1 ) );
		this.add( cameraNZ );
	
		options = options || { format: RGBFormat, magFilter: LinearFilter, minFilter: LinearFilter };
	
		this.renderTarget = new WebGLRenderTargetCube( cubeResolution, cubeResolution, options );
		this.renderTarget.texture.name = "CubeCamera";
	
		this.update = function ( renderer, scene ) {
	
			if ( this.parent === null ) this.updateMatrixWorld();
	
			var currentRenderTarget = renderer.getRenderTarget();
	
			var renderTarget = this.renderTarget;
			var generateMipmaps = renderTarget.texture.generateMipmaps;
	
			renderTarget.texture.generateMipmaps = false;
	
			renderTarget.activeCubeFace = 0;
			renderer.render( scene, cameraPX, renderTarget );
	
			renderTarget.activeCubeFace = 1;
			renderer.render( scene, cameraNX, renderTarget );
	
			renderTarget.activeCubeFace = 2;
			renderer.render( scene, cameraPY, renderTarget );
	
			renderTarget.activeCubeFace = 3;
			renderer.render( scene, cameraNY, renderTarget );
	
			renderTarget.activeCubeFace = 4;
			renderer.render( scene, cameraPZ, renderTarget );
	
			renderTarget.texture.generateMipmaps = generateMipmaps;
	
			renderTarget.activeCubeFace = 5;
			renderer.render( scene, cameraNZ, renderTarget );
	
			renderer.setRenderTarget( currentRenderTarget );
	
		};
	
		this.clear = function ( renderer, color, depth, stencil ) {
	
			var currentRenderTarget = renderer.getRenderTarget();
	
			var renderTarget = this.renderTarget;
	
			for ( var i = 0; i < 6; i ++ ) {
	
				renderTarget.activeCubeFace = i;
				renderer.setRenderTarget( renderTarget );
	
				renderer.clear( color, depth, stencil );
	
			}
	
			renderer.setRenderTarget( currentRenderTarget );
	
		};
	
	}
	
	CubeCamera.prototype = Object.create( Object3D.prototype );
	CubeCamera.prototype.constructor = CubeCamera;
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function Clock( autoStart ) {
	
		this.autoStart = ( autoStart !== undefined ) ? autoStart : true;
	
		this.startTime = 0;
		this.oldTime = 0;
		this.elapsedTime = 0;
	
		this.running = false;
	
	}
	
	Object.assign( Clock.prototype, {
	
		start: function () {
	
			this.startTime = ( typeof performance === 'undefined' ? Date : performance ).now(); // see #10732
	
			this.oldTime = this.startTime;
			this.elapsedTime = 0;
			this.running = true;
	
		},
	
		stop: function () {
	
			this.getElapsedTime();
			this.running = false;
			this.autoStart = false;
	
		},
	
		getElapsedTime: function () {
	
			this.getDelta();
			return this.elapsedTime;
	
		},
	
		getDelta: function () {
	
			var diff = 0;
	
			if ( this.autoStart && ! this.running ) {
	
				this.start();
				return 0;
	
			}
	
			if ( this.running ) {
	
				var newTime = ( typeof performance === 'undefined' ? Date : performance ).now();
	
				diff = ( newTime - this.oldTime ) / 1000;
				this.oldTime = newTime;
	
				this.elapsedTime += diff;
	
			}
	
			return diff;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function AudioListener() {
	
		Object3D.call( this );
	
		this.type = 'AudioListener';
	
		this.context = AudioContext.getContext();
	
		this.gain = this.context.createGain();
		this.gain.connect( this.context.destination );
	
		this.filter = null;
	
		this.timeDelta = 0;
	
	}
	
	AudioListener.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: AudioListener,
	
		getInput: function () {
	
			return this.gain;
	
		},
	
		removeFilter: function ( ) {
	
			if ( this.filter !== null ) {
	
				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
				this.gain.connect( this.context.destination );
				this.filter = null;
	
			}
	
			return this;
	
		},
	
		getFilter: function () {
	
			return this.filter;
	
		},
	
		setFilter: function ( value ) {
	
			if ( this.filter !== null ) {
	
				this.gain.disconnect( this.filter );
				this.filter.disconnect( this.context.destination );
	
			} else {
	
				this.gain.disconnect( this.context.destination );
	
			}
	
			this.filter = value;
			this.gain.connect( this.filter );
			this.filter.connect( this.context.destination );
	
			return this;
	
		},
	
		getMasterVolume: function () {
	
			return this.gain.gain.value;
	
		},
	
		setMasterVolume: function ( value ) {
	
			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );
	
			return this;
	
		},
	
		updateMatrixWorld: ( function () {
	
			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();
	
			var orientation = new Vector3();
			var clock = new Clock();
	
			return function updateMatrixWorld( force ) {
	
				Object3D.prototype.updateMatrixWorld.call( this, force );
	
				var listener = this.context.listener;
				var up = this.up;
	
				this.timeDelta = clock.getDelta();
	
				this.matrixWorld.decompose( position, quaternion, scale );
	
				orientation.set( 0, 0, - 1 ).applyQuaternion( quaternion );
	
				if ( listener.positionX ) {
	
					// code path for Chrome (see #14393)
	
					var endTime = this.context.currentTime + this.timeDelta;
	
					listener.positionX.linearRampToValueAtTime( position.x, endTime );
					listener.positionY.linearRampToValueAtTime( position.y, endTime );
					listener.positionZ.linearRampToValueAtTime( position.z, endTime );
					listener.forwardX.linearRampToValueAtTime( orientation.x, endTime );
					listener.forwardY.linearRampToValueAtTime( orientation.y, endTime );
					listener.forwardZ.linearRampToValueAtTime( orientation.z, endTime );
					listener.upX.linearRampToValueAtTime( up.x, endTime );
					listener.upY.linearRampToValueAtTime( up.y, endTime );
					listener.upZ.linearRampToValueAtTime( up.z, endTime );
	
				} else {
	
					listener.setPosition( position.x, position.y, position.z );
					listener.setOrientation( orientation.x, orientation.y, orientation.z, up.x, up.y, up.z );
	
				}
	
			};
	
		} )()
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Reece Aaron Lecrivain / http://reecenotes.com/
	 */
	
	function Audio( listener ) {
	
		Object3D.call( this );
	
		this.type = 'Audio';
	
		this.listener = listener;
		this.context = listener.context;
	
		this.gain = this.context.createGain();
		this.gain.connect( listener.getInput() );
	
		this.autoplay = false;
	
		this.buffer = null;
		this.detune = 0;
		this.loop = false;
		this.startTime = 0;
		this.offset = 0;
		this.playbackRate = 1;
		this.isPlaying = false;
		this.hasPlaybackControl = true;
		this.sourceType = 'empty';
	
		this.filters = [];
	
	}
	
	Audio.prototype = Object.assign( Object.create( Object3D.prototype ), {
	
		constructor: Audio,
	
		getOutput: function () {
	
			return this.gain;
	
		},
	
		setNodeSource: function ( audioNode ) {
	
			this.hasPlaybackControl = false;
			this.sourceType = 'audioNode';
			this.source = audioNode;
			this.connect();
	
			return this;
	
		},
	
		setMediaElementSource: function ( mediaElement ) {
	
			this.hasPlaybackControl = false;
			this.sourceType = 'mediaNode';
			this.source = this.context.createMediaElementSource( mediaElement );
			this.connect();
	
			return this;
	
		},
	
		setBuffer: function ( audioBuffer ) {
	
			this.buffer = audioBuffer;
			this.sourceType = 'buffer';
	
			if ( this.autoplay ) this.play();
	
			return this;
	
		},
	
		play: function () {
	
			if ( this.isPlaying === true ) {
	
				console.warn( 'THREE.Audio: Audio is already playing.' );
				return;
	
			}
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			var source = this.context.createBufferSource();
	
			source.buffer = this.buffer;
			source.loop = this.loop;
			source.onended = this.onEnded.bind( this );
			this.startTime = this.context.currentTime;
			source.start( this.startTime, this.offset );
	
			this.isPlaying = true;
	
			this.source = source;
	
			this.setDetune( this.detune );
			this.setPlaybackRate( this.playbackRate );
	
			return this.connect();
	
		},
	
		pause: function () {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			if ( this.isPlaying === true ) {
	
				this.source.stop();
				this.source.onended = null;
				this.offset += ( this.context.currentTime - this.startTime ) * this.playbackRate;
				this.isPlaying = false;
	
			}
	
			return this;
	
		},
	
		stop: function () {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.source.stop();
			this.source.onended = null;
			this.offset = 0;
			this.isPlaying = false;
	
			return this;
	
		},
	
		connect: function () {
	
			if ( this.filters.length > 0 ) {
	
				this.source.connect( this.filters[ 0 ] );
	
				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
					this.filters[ i - 1 ].connect( this.filters[ i ] );
	
				}
	
				this.filters[ this.filters.length - 1 ].connect( this.getOutput() );
	
			} else {
	
				this.source.connect( this.getOutput() );
	
			}
	
			return this;
	
		},
	
		disconnect: function () {
	
			if ( this.filters.length > 0 ) {
	
				this.source.disconnect( this.filters[ 0 ] );
	
				for ( var i = 1, l = this.filters.length; i < l; i ++ ) {
	
					this.filters[ i - 1 ].disconnect( this.filters[ i ] );
	
				}
	
				this.filters[ this.filters.length - 1 ].disconnect( this.getOutput() );
	
			} else {
	
				this.source.disconnect( this.getOutput() );
	
			}
	
			return this;
	
		},
	
		getFilters: function () {
	
			return this.filters;
	
		},
	
		setFilters: function ( value ) {
	
			if ( ! value ) value = [];
	
			if ( this.isPlaying === true ) {
	
				this.disconnect();
				this.filters = value;
				this.connect();
	
			} else {
	
				this.filters = value;
	
			}
	
			return this;
	
		},
	
		setDetune: function ( value ) {
	
			this.detune = value;
	
			if ( this.source.detune === undefined ) return; // only set detune when available
	
			if ( this.isPlaying === true ) {
	
				this.source.detune.setTargetAtTime( this.detune, this.context.currentTime, 0.01 );
	
			}
	
			return this;
	
		},
	
		getDetune: function () {
	
			return this.detune;
	
		},
	
		getFilter: function () {
	
			return this.getFilters()[ 0 ];
	
		},
	
		setFilter: function ( filter ) {
	
			return this.setFilters( filter ? [ filter ] : [] );
	
		},
	
		setPlaybackRate: function ( value ) {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.playbackRate = value;
	
			if ( this.isPlaying === true ) {
	
				this.source.playbackRate.setTargetAtTime( this.playbackRate, this.context.currentTime, 0.01 );
	
			}
	
			return this;
	
		},
	
		getPlaybackRate: function () {
	
			return this.playbackRate;
	
		},
	
		onEnded: function () {
	
			this.isPlaying = false;
	
		},
	
		getLoop: function () {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return false;
	
			}
	
			return this.loop;
	
		},
	
		setLoop: function ( value ) {
	
			if ( this.hasPlaybackControl === false ) {
	
				console.warn( 'THREE.Audio: this Audio has no playback control.' );
				return;
	
			}
	
			this.loop = value;
	
			if ( this.isPlaying === true ) {
	
				this.source.loop = this.loop;
	
			}
	
			return this;
	
		},
	
		getVolume: function () {
	
			return this.gain.gain.value;
	
		},
	
		setVolume: function ( value ) {
	
			this.gain.gain.setTargetAtTime( value, this.context.currentTime, 0.01 );
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function PositionalAudio( listener ) {
	
		Audio.call( this, listener );
	
		this.panner = this.context.createPanner();
		this.panner.connect( this.gain );
	
	}
	
	PositionalAudio.prototype = Object.assign( Object.create( Audio.prototype ), {
	
		constructor: PositionalAudio,
	
		getOutput: function () {
	
			return this.panner;
	
		},
	
		getRefDistance: function () {
	
			return this.panner.refDistance;
	
		},
	
		setRefDistance: function ( value ) {
	
			this.panner.refDistance = value;
	
			return this;
	
		},
	
		getRolloffFactor: function () {
	
			return this.panner.rolloffFactor;
	
		},
	
		setRolloffFactor: function ( value ) {
	
			this.panner.rolloffFactor = value;
	
			return this;
	
		},
	
		getDistanceModel: function () {
	
			return this.panner.distanceModel;
	
		},
	
		setDistanceModel: function ( value ) {
	
			this.panner.distanceModel = value;
	
			return this;
	
		},
	
		getMaxDistance: function () {
	
			return this.panner.maxDistance;
	
		},
	
		setMaxDistance: function ( value ) {
	
			this.panner.maxDistance = value;
	
			return this;
	
		},
	
		setDirectionalCone: function ( coneInnerAngle, coneOuterAngle, coneOuterGain ) {
	
			this.panner.coneInnerAngle = coneInnerAngle;
			this.panner.coneOuterAngle = coneOuterAngle;
			this.panner.coneOuterGain = coneOuterGain;
	
			return this;
	
		},
	
		updateMatrixWorld: ( function () {
	
			var position = new Vector3();
			var quaternion = new Quaternion();
			var scale = new Vector3();
	
			var orientation = new Vector3();
	
			return function updateMatrixWorld( force ) {
	
				Object3D.prototype.updateMatrixWorld.call( this, force );
	
				if ( this.isPlaying === false ) return;
	
				this.matrixWorld.decompose( position, quaternion, scale );
	
				orientation.set( 0, 0, 1 ).applyQuaternion( quaternion );
	
				var panner = this.panner;
	
				if ( panner.positionX ) {
	
					// code path for Chrome and Firefox (see #14393)
	
					var endTime = this.context.currentTime + this.listener.timeDelta;
	
					panner.positionX.linearRampToValueAtTime( position.x, endTime );
					panner.positionY.linearRampToValueAtTime( position.y, endTime );
					panner.positionZ.linearRampToValueAtTime( position.z, endTime );
					panner.orientationX.linearRampToValueAtTime( orientation.x, endTime );
					panner.orientationY.linearRampToValueAtTime( orientation.y, endTime );
					panner.orientationZ.linearRampToValueAtTime( orientation.z, endTime );
	
				} else {
	
					panner.setPosition( position.x, position.y, position.z );
					panner.setOrientation( orientation.x, orientation.y, orientation.z );
	
				}
	
			};
	
		} )()
	
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function AudioAnalyser( audio, fftSize ) {
	
		this.analyser = audio.context.createAnalyser();
		this.analyser.fftSize = fftSize !== undefined ? fftSize : 2048;
	
		this.data = new Uint8Array( this.analyser.frequencyBinCount );
	
		audio.getOutput().connect( this.analyser );
	
	}
	
	Object.assign( AudioAnalyser.prototype, {
	
		getFrequencyData: function () {
	
			this.analyser.getByteFrequencyData( this.data );
	
			return this.data;
	
		},
	
		getAverageFrequency: function () {
	
			var value = 0, data = this.getFrequencyData();
	
			for ( var i = 0; i < data.length; i ++ ) {
	
				value += data[ i ];
	
			}
	
			return value / data.length;
	
		}
	
	} );
	
	/**
	 *
	 * Buffered scene graph property that allows weighted accumulation.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function PropertyMixer( binding, typeName, valueSize ) {
	
		this.binding = binding;
		this.valueSize = valueSize;
	
		var bufferType = Float64Array,
			mixFunction;
	
		switch ( typeName ) {
	
			case 'quaternion':
				mixFunction = this._slerp;
				break;
	
			case 'string':
			case 'bool':
				bufferType = Array;
				mixFunction = this._select;
				break;
	
			default:
				mixFunction = this._lerp;
	
		}
	
		this.buffer = new bufferType( valueSize * 4 );
		// layout: [ incoming | accu0 | accu1 | orig ]
		//
		// interpolators can use .buffer as their .result
		// the data then goes to 'incoming'
		//
		// 'accu0' and 'accu1' are used frame-interleaved for
		// the cumulative result and are compared to detect
		// changes
		//
		// 'orig' stores the original state of the property
	
		this._mixBufferRegion = mixFunction;
	
		this.cumulativeWeight = 0;
	
		this.useCount = 0;
		this.referenceCount = 0;
	
	}
	
	Object.assign( PropertyMixer.prototype, {
	
		// accumulate data in the 'incoming' region into 'accu<i>'
		accumulate: function ( accuIndex, weight ) {
	
			// note: happily accumulating nothing when weight = 0, the caller knows
			// the weight and shouldn't have made the call in the first place
	
			var buffer = this.buffer,
				stride = this.valueSize,
				offset = accuIndex * stride + stride,
	
				currentWeight = this.cumulativeWeight;
	
			if ( currentWeight === 0 ) {
	
				// accuN := incoming * weight
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ offset + i ] = buffer[ i ];
	
				}
	
				currentWeight = weight;
	
			} else {
	
				// accuN := accuN + incoming * weight
	
				currentWeight += weight;
				var mix = weight / currentWeight;
				this._mixBufferRegion( buffer, offset, 0, mix, stride );
	
			}
	
			this.cumulativeWeight = currentWeight;
	
		},
	
		// apply the state of 'accu<i>' to the binding when accus differ
		apply: function ( accuIndex ) {
	
			var stride = this.valueSize,
				buffer = this.buffer,
				offset = accuIndex * stride + stride,
	
				weight = this.cumulativeWeight,
	
				binding = this.binding;
	
			this.cumulativeWeight = 0;
	
			if ( weight < 1 ) {
	
				// accuN := accuN + original * ( 1 - cumulativeWeight )
	
				var originalValueOffset = stride * 3;
	
				this._mixBufferRegion(
					buffer, offset, originalValueOffset, 1 - weight, stride );
	
			}
	
			for ( var i = stride, e = stride + stride; i !== e; ++ i ) {
	
				if ( buffer[ i ] !== buffer[ i + stride ] ) {
	
					// value has changed -> update scene graph
	
					binding.setValue( buffer, offset );
					break;
	
				}
	
			}
	
		},
	
		// remember the state of the bound property and copy it to both accus
		saveOriginalState: function () {
	
			var binding = this.binding;
	
			var buffer = this.buffer,
				stride = this.valueSize,
	
				originalValueOffset = stride * 3;
	
			binding.getValue( buffer, originalValueOffset );
	
			// accu[0..1] := orig -- initially detect changes against the original
			for ( var i = stride, e = originalValueOffset; i !== e; ++ i ) {
	
				buffer[ i ] = buffer[ originalValueOffset + ( i % stride ) ];
	
			}
	
			this.cumulativeWeight = 0;
	
		},
	
		// apply the state previously taken via 'saveOriginalState' to the binding
		restoreOriginalState: function () {
	
			var originalValueOffset = this.valueSize * 3;
			this.binding.setValue( this.buffer, originalValueOffset );
	
		},
	
	
		// mix functions
	
		_select: function ( buffer, dstOffset, srcOffset, t, stride ) {
	
			if ( t >= 0.5 ) {
	
				for ( var i = 0; i !== stride; ++ i ) {
	
					buffer[ dstOffset + i ] = buffer[ srcOffset + i ];
	
				}
	
			}
	
		},
	
		_slerp: function ( buffer, dstOffset, srcOffset, t ) {
	
			Quaternion.slerpFlat( buffer, dstOffset, buffer, dstOffset, buffer, srcOffset, t );
	
		},
	
		_lerp: function ( buffer, dstOffset, srcOffset, t, stride ) {
	
			var s = 1 - t;
	
			for ( var i = 0; i !== stride; ++ i ) {
	
				var j = dstOffset + i;
	
				buffer[ j ] = buffer[ j ] * s + buffer[ srcOffset + i ] * t;
	
			}
	
		}
	
	} );
	
	/**
	 *
	 * A reference to a real property in the scene graph.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	// Characters [].:/ are reserved for track binding syntax.
	var RESERVED_CHARS_RE = '\\[\\]\\.:\\/';
	
	function Composite( targetGroup, path, optionalParsedPath ) {
	
		var parsedPath = optionalParsedPath || PropertyBinding.parseTrackName( path );
	
		this._targetGroup = targetGroup;
		this._bindings = targetGroup.subscribe_( path, parsedPath );
	
	}
	
	Object.assign( Composite.prototype, {
	
		getValue: function ( array, offset ) {
	
			this.bind(); // bind all binding
	
			var firstValidIndex = this._targetGroup.nCachedObjects_,
				binding = this._bindings[ firstValidIndex ];
	
			// and only call .getValue on the first
			if ( binding !== undefined ) binding.getValue( array, offset );
	
		},
	
		setValue: function ( array, offset ) {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].setValue( array, offset );
	
			}
	
		},
	
		bind: function () {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].bind();
	
			}
	
		},
	
		unbind: function () {
	
			var bindings = this._bindings;
	
			for ( var i = this._targetGroup.nCachedObjects_, n = bindings.length; i !== n; ++ i ) {
	
				bindings[ i ].unbind();
	
			}
	
		}
	
	} );
	
	
	function PropertyBinding( rootNode, path, parsedPath ) {
	
		this.path = path;
		this.parsedPath = parsedPath || PropertyBinding.parseTrackName( path );
	
		this.node = PropertyBinding.findNode( rootNode, this.parsedPath.nodeName ) || rootNode;
	
		this.rootNode = rootNode;
	
	}
	
	Object.assign( PropertyBinding, {
	
		Composite: Composite,
	
		create: function ( root, path, parsedPath ) {
	
			if ( ! ( root && root.isAnimationObjectGroup ) ) {
	
				return new PropertyBinding( root, path, parsedPath );
	
			} else {
	
				return new PropertyBinding.Composite( root, path, parsedPath );
	
			}
	
		},
	
		/**
		 * Replaces spaces with underscores and removes unsupported characters from
		 * node names, to ensure compatibility with parseTrackName().
		 *
		 * @param  {string} name Node name to be sanitized.
		 * @return {string}
		 */
		sanitizeNodeName: ( function () {
	
			var reservedRe = new RegExp( '[' + RESERVED_CHARS_RE + ']', 'g' );
	
			return function sanitizeNodeName( name ) {
	
				return name.replace( /\s/g, '_' ).replace( reservedRe, '' );
	
			};
	
		}() ),
	
		parseTrackName: function () {
	
			// Attempts to allow node names from any language. ES5's `\w` regexp matches
			// only latin characters, and the unicode \p{L} is not yet supported. So
			// instead, we exclude reserved characters and match everything else.
			var wordChar = '[^' + RESERVED_CHARS_RE + ']';
			var wordCharOrDot = '[^' + RESERVED_CHARS_RE.replace( '\\.', '' ) + ']';
	
			// Parent directories, delimited by '/' or ':'. Currently unused, but must
			// be matched to parse the rest of the track name.
			var directoryRe = /((?:WC+[\/:])*)/.source.replace( 'WC', wordChar );
	
			// Target node. May contain word characters (a-zA-Z0-9_) and '.' or '-'.
			var nodeRe = /(WCOD+)?/.source.replace( 'WCOD', wordCharOrDot );
	
			// Object on target node, and accessor. May not contain reserved
			// characters. Accessor may contain any character except closing bracket.
			var objectRe = /(?:\.(WC+)(?:\[(.+)\])?)?/.source.replace( 'WC', wordChar );
	
			// Property and accessor. May not contain reserved characters. Accessor may
			// contain any non-bracket characters.
			var propertyRe = /\.(WC+)(?:\[(.+)\])?/.source.replace( 'WC', wordChar );
	
			var trackRe = new RegExp( ''
				+ '^'
				+ directoryRe
				+ nodeRe
				+ objectRe
				+ propertyRe
				+ '$'
			);
	
			var supportedObjectNames = [ 'material', 'materials', 'bones' ];
	
			return function parseTrackName( trackName ) {
	
				var matches = trackRe.exec( trackName );
	
				if ( ! matches ) {
	
					throw new Error( 'PropertyBinding: Cannot parse trackName: ' + trackName );
	
				}
	
				var results = {
					// directoryName: matches[ 1 ], // (tschw) currently unused
					nodeName: matches[ 2 ],
					objectName: matches[ 3 ],
					objectIndex: matches[ 4 ],
					propertyName: matches[ 5 ], // required
					propertyIndex: matches[ 6 ]
				};
	
				var lastDot = results.nodeName && results.nodeName.lastIndexOf( '.' );
	
				if ( lastDot !== undefined && lastDot !== - 1 ) {
	
					var objectName = results.nodeName.substring( lastDot + 1 );
	
					// Object names must be checked against a whitelist. Otherwise, there
					// is no way to parse 'foo.bar.baz': 'baz' must be a property, but
					// 'bar' could be the objectName, or part of a nodeName (which can
					// include '.' characters).
					if ( supportedObjectNames.indexOf( objectName ) !== - 1 ) {
	
						results.nodeName = results.nodeName.substring( 0, lastDot );
						results.objectName = objectName;
	
					}
	
				}
	
				if ( results.propertyName === null || results.propertyName.length === 0 ) {
	
					throw new Error( 'PropertyBinding: can not parse propertyName from trackName: ' + trackName );
	
				}
	
				return results;
	
			};
	
		}(),
	
		findNode: function ( root, nodeName ) {
	
			if ( ! nodeName || nodeName === "" || nodeName === "root" || nodeName === "." || nodeName === - 1 || nodeName === root.name || nodeName === root.uuid ) {
	
				return root;
	
			}
	
			// search into skeleton bones.
			if ( root.skeleton ) {
	
				var bone = root.skeleton.getBoneByName( nodeName );
	
				if ( bone !== undefined ) {
	
					return bone;
	
				}
	
			}
	
			// search into node subtree.
			if ( root.children ) {
	
				var searchNodeSubtree = function ( children ) {
	
					for ( var i = 0; i < children.length; i ++ ) {
	
						var childNode = children[ i ];
	
						if ( childNode.name === nodeName || childNode.uuid === nodeName ) {
	
							return childNode;
	
						}
	
						var result = searchNodeSubtree( childNode.children );
	
						if ( result ) return result;
	
					}
	
					return null;
	
				};
	
				var subTreeNode = searchNodeSubtree( root.children );
	
				if ( subTreeNode ) {
	
					return subTreeNode;
	
				}
	
			}
	
			return null;
	
		}
	
	} );
	
	Object.assign( PropertyBinding.prototype, { // prototype, continued
	
		// these are used to "bind" a nonexistent property
		_getValue_unavailable: function () {},
		_setValue_unavailable: function () {},
	
		BindingType: {
			Direct: 0,
			EntireArray: 1,
			ArrayElement: 2,
			HasFromToArray: 3
		},
	
		Versioning: {
			None: 0,
			NeedsUpdate: 1,
			MatrixWorldNeedsUpdate: 2
		},
	
		GetterByBindingType: [
	
			function getValue_direct( buffer, offset ) {
	
				buffer[ offset ] = this.node[ this.propertyName ];
	
			},
	
			function getValue_array( buffer, offset ) {
	
				var source = this.resolvedProperty;
	
				for ( var i = 0, n = source.length; i !== n; ++ i ) {
	
					buffer[ offset ++ ] = source[ i ];
	
				}
	
			},
	
			function getValue_arrayElement( buffer, offset ) {
	
				buffer[ offset ] = this.resolvedProperty[ this.propertyIndex ];
	
			},
	
			function getValue_toArray( buffer, offset ) {
	
				this.resolvedProperty.toArray( buffer, offset );
	
			}
	
		],
	
		SetterByBindingTypeAndVersioning: [
	
			[
				// Direct
	
				function setValue_direct( buffer, offset ) {
	
					this.targetObject[ this.propertyName ] = buffer[ offset ];
	
				},
	
				function setValue_direct_setNeedsUpdate( buffer, offset ) {
	
					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_direct_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.targetObject[ this.propertyName ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// EntireArray
	
				function setValue_array( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
				},
	
				function setValue_array_setNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_array_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					var dest = this.resolvedProperty;
	
					for ( var i = 0, n = dest.length; i !== n; ++ i ) {
	
						dest[ i ] = buffer[ offset ++ ];
	
					}
	
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// ArrayElement
	
				function setValue_arrayElement( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
	
				},
	
				function setValue_arrayElement_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_arrayElement_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty[ this.propertyIndex ] = buffer[ offset ];
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			], [
	
				// HasToFromArray
	
				function setValue_fromArray( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
	
				},
	
				function setValue_fromArray_setNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.needsUpdate = true;
	
				},
	
				function setValue_fromArray_setMatrixWorldNeedsUpdate( buffer, offset ) {
	
					this.resolvedProperty.fromArray( buffer, offset );
					this.targetObject.matrixWorldNeedsUpdate = true;
	
				}
	
			]
	
		],
	
		getValue: function getValue_unbound( targetArray, offset ) {
	
			this.bind();
			this.getValue( targetArray, offset );
	
			// Note: This class uses a State pattern on a per-method basis:
			// 'bind' sets 'this.getValue' / 'setValue' and shadows the
			// prototype version of these methods with one that represents
			// the bound state. When the property is not found, the methods
			// become no-ops.
	
		},
	
		setValue: function getValue_unbound( sourceArray, offset ) {
	
			this.bind();
			this.setValue( sourceArray, offset );
	
		},
	
		// create getter / setter pair for a property in the scene graph
		bind: function () {
	
			var targetObject = this.node,
				parsedPath = this.parsedPath,
	
				objectName = parsedPath.objectName,
				propertyName = parsedPath.propertyName,
				propertyIndex = parsedPath.propertyIndex;
	
			if ( ! targetObject ) {
	
				targetObject = PropertyBinding.findNode( this.rootNode, parsedPath.nodeName ) || this.rootNode;
	
				this.node = targetObject;
	
			}
	
			// set fail state so we can just 'return' on error
			this.getValue = this._getValue_unavailable;
			this.setValue = this._setValue_unavailable;
	
			// ensure there is a value node
			if ( ! targetObject ) {
	
				console.error( 'THREE.PropertyBinding: Trying to update node for track: ' + this.path + ' but it wasn\'t found.' );
				return;
	
			}
	
			if ( objectName ) {
	
				var objectIndex = parsedPath.objectIndex;
	
				// special cases were we need to reach deeper into the hierarchy to get the face materials....
				switch ( objectName ) {
	
					case 'materials':
	
						if ( ! targetObject.material ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to material as node does not have a material.', this );
							return;
	
						}
	
						if ( ! targetObject.material.materials ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to material.materials as node.material does not have a materials array.', this );
							return;
	
						}
	
						targetObject = targetObject.material.materials;
	
						break;
	
					case 'bones':
	
						if ( ! targetObject.skeleton ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to bones as node does not have a skeleton.', this );
							return;
	
						}
	
						// potential future optimization: skip this if propertyIndex is already an integer
						// and convert the integer string to a true integer.
	
						targetObject = targetObject.skeleton.bones;
	
						// support resolving morphTarget names into indices.
						for ( var i = 0; i < targetObject.length; i ++ ) {
	
							if ( targetObject[ i ].name === objectIndex ) {
	
								objectIndex = i;
								break;
	
							}
	
						}
	
						break;
	
					default:
	
						if ( targetObject[ objectName ] === undefined ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to objectName of node undefined.', this );
							return;
	
						}
	
						targetObject = targetObject[ objectName ];
	
				}
	
	
				if ( objectIndex !== undefined ) {
	
					if ( targetObject[ objectIndex ] === undefined ) {
	
						console.error( 'THREE.PropertyBinding: Trying to bind to objectIndex of objectName, but is undefined.', this, targetObject );
						return;
	
					}
	
					targetObject = targetObject[ objectIndex ];
	
				}
	
			}
	
			// resolve property
			var nodeProperty = targetObject[ propertyName ];
	
			if ( nodeProperty === undefined ) {
	
				var nodeName = parsedPath.nodeName;
	
				console.error( 'THREE.PropertyBinding: Trying to update property for track: ' + nodeName +
					'.' + propertyName + ' but it wasn\'t found.', targetObject );
				return;
	
			}
	
			// determine versioning scheme
			var versioning = this.Versioning.None;
	
			this.targetObject = targetObject;
	
			if ( targetObject.needsUpdate !== undefined ) { // material
	
				versioning = this.Versioning.NeedsUpdate;
	
			} else if ( targetObject.matrixWorldNeedsUpdate !== undefined ) { // node transform
	
				versioning = this.Versioning.MatrixWorldNeedsUpdate;
	
			}
	
			// determine how the property gets bound
			var bindingType = this.BindingType.Direct;
	
			if ( propertyIndex !== undefined ) {
	
				// access a sub element of the property array (only primitives are supported right now)
	
				if ( propertyName === "morphTargetInfluences" ) {
	
					// potential optimization, skip this if propertyIndex is already an integer, and convert the integer string to a true integer.
	
					// support resolving morphTarget names into indices.
					if ( ! targetObject.geometry ) {
	
						console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.', this );
						return;
	
					}
	
					if ( targetObject.geometry.isBufferGeometry ) {
	
						if ( ! targetObject.geometry.morphAttributes ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphAttributes.', this );
							return;
	
						}
	
						for ( var i = 0; i < this.node.geometry.morphAttributes.position.length; i ++ ) {
	
							if ( targetObject.geometry.morphAttributes.position[ i ].name === propertyIndex ) {
	
								propertyIndex = i;
								break;
	
							}
	
						}
	
	
					} else {
	
						if ( ! targetObject.geometry.morphTargets ) {
	
							console.error( 'THREE.PropertyBinding: Can not bind to morphTargetInfluences because node does not have a geometry.morphTargets.', this );
							return;
	
						}
	
						for ( var i = 0; i < this.node.geometry.morphTargets.length; i ++ ) {
	
							if ( targetObject.geometry.morphTargets[ i ].name === propertyIndex ) {
	
								propertyIndex = i;
								break;
	
							}
	
						}
	
					}
	
				}
	
				bindingType = this.BindingType.ArrayElement;
	
				this.resolvedProperty = nodeProperty;
				this.propertyIndex = propertyIndex;
	
			} else if ( nodeProperty.fromArray !== undefined && nodeProperty.toArray !== undefined ) {
	
				// must use copy for Object3D.Euler/Quaternion
	
				bindingType = this.BindingType.HasFromToArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else if ( Array.isArray( nodeProperty ) ) {
	
				bindingType = this.BindingType.EntireArray;
	
				this.resolvedProperty = nodeProperty;
	
			} else {
	
				this.propertyName = propertyName;
	
			}
	
			// select getter / setter
			this.getValue = this.GetterByBindingType[ bindingType ];
			this.setValue = this.SetterByBindingTypeAndVersioning[ bindingType ][ versioning ];
	
		},
	
		unbind: function () {
	
			this.node = null;
	
			// back to the prototype version of getValue / setValue
			// note: avoiding to mutate the shape of 'this' via 'delete'
			this.getValue = this._getValue_unbound;
			this.setValue = this._setValue_unbound;
	
		}
	
	} );
	
	//!\ DECLARE ALIAS AFTER assign prototype !
	Object.assign( PropertyBinding.prototype, {
	
		// initial state of these methods that calls 'bind'
		_getValue_unbound: PropertyBinding.prototype.getValue,
		_setValue_unbound: PropertyBinding.prototype.setValue,
	
	} );
	
	/**
	 *
	 * A group of objects that receives a shared animation state.
	 *
	 * Usage:
	 *
	 *  - Add objects you would otherwise pass as 'root' to the
	 *    constructor or the .clipAction method of AnimationMixer.
	 *
	 *  - Instead pass this object as 'root'.
	 *
	 *  - You can also add and remove objects later when the mixer
	 *    is running.
	 *
	 * Note:
	 *
	 *    Objects of this class appear as one object to the mixer,
	 *    so cache control of the individual objects must be done
	 *    on the group.
	 *
	 * Limitation:
	 *
	 *  - The animated properties must be compatible among the
	 *    all objects in the group.
	 *
	 *  - A single property can either be controlled through a
	 *    target group or directly, but not both.
	 *
	 * @author tschw
	 */
	
	function AnimationObjectGroup() {
	
		this.uuid = _Math.generateUUID();
	
		// cached objects followed by the active ones
		this._objects = Array.prototype.slice.call( arguments );
	
		this.nCachedObjects_ = 0; // threshold
		// note: read by PropertyBinding.Composite
	
		var indices = {};
		this._indicesByUUID = indices; // for bookkeeping
	
		for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
			indices[ arguments[ i ].uuid ] = i;
	
		}
	
		this._paths = []; // inside: string
		this._parsedPaths = []; // inside: { we don't care, here }
		this._bindings = []; // inside: Array< PropertyBinding >
		this._bindingsIndicesByPath = {}; // inside: indices in these arrays
	
		var scope = this;
	
		this.stats = {
	
			objects: {
				get total() {
	
					return scope._objects.length;
	
				},
				get inUse() {
	
					return this.total - scope.nCachedObjects_;
	
				}
			},
			get bindingsPerObject() {
	
				return scope._bindings.length;
	
			}
	
		};
	
	}
	
	Object.assign( AnimationObjectGroup.prototype, {
	
		isAnimationObjectGroup: true,
	
		add: function () {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				paths = this._paths,
				parsedPaths = this._parsedPaths,
				bindings = this._bindings,
				nBindings = bindings.length,
				knownObject = undefined;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index === undefined ) {
	
					// unknown object -> add it to the ACTIVE region
	
					index = nObjects ++;
					indicesByUUID[ uuid ] = index;
					objects.push( object );
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						bindings[ j ].push( new PropertyBinding( object, paths[ j ], parsedPaths[ j ] ) );
	
					}
	
				} else if ( index < nCachedObjects ) {
	
					knownObject = objects[ index ];
	
					// move existing object to the ACTIVE region
	
					var firstActiveIndex = -- nCachedObjects,
						lastCachedObject = objects[ firstActiveIndex ];
	
					indicesByUUID[ lastCachedObject.uuid ] = index;
					objects[ index ] = lastCachedObject;
	
					indicesByUUID[ uuid ] = firstActiveIndex;
					objects[ firstActiveIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							lastCached = bindingsForPath[ firstActiveIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = lastCached;
	
						if ( binding === undefined ) {
	
							// since we do not bother to create new bindings
							// for objects that are cached, the binding may
							// or may not exist
	
							binding = new PropertyBinding( object, paths[ j ], parsedPaths[ j ] );
	
						}
	
						bindingsForPath[ firstActiveIndex ] = binding;
	
					}
	
				} else if ( objects[ index ] !== knownObject ) {
	
					console.error( 'THREE.AnimationObjectGroup: Different objects with the same UUID ' +
						'detected. Clean the caches or recreate your infrastructure when reloading scenes.' );
	
				} // else the object is already where we want it to be
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		remove: function () {
	
			var objects = this._objects,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined && index >= nCachedObjects ) {
	
					// move existing object into the CACHED region
	
					var lastCachedIndex = nCachedObjects ++,
						firstActiveObject = objects[ lastCachedIndex ];
	
					indicesByUUID[ firstActiveObject.uuid ] = index;
					objects[ index ] = firstActiveObject;
	
					indicesByUUID[ uuid ] = lastCachedIndex;
					objects[ lastCachedIndex ] = object;
	
					// accounting is done, now do the same for all bindings
	
					for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
						var bindingsForPath = bindings[ j ],
							firstActive = bindingsForPath[ lastCachedIndex ],
							binding = bindingsForPath[ index ];
	
						bindingsForPath[ index ] = firstActive;
						bindingsForPath[ lastCachedIndex ] = binding;
	
					}
	
				}
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// remove & forget
		uncache: function () {
	
			var objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				indicesByUUID = this._indicesByUUID,
				bindings = this._bindings,
				nBindings = bindings.length;
	
			for ( var i = 0, n = arguments.length; i !== n; ++ i ) {
	
				var object = arguments[ i ],
					uuid = object.uuid,
					index = indicesByUUID[ uuid ];
	
				if ( index !== undefined ) {
	
					delete indicesByUUID[ uuid ];
	
					if ( index < nCachedObjects ) {
	
						// object is cached, shrink the CACHED region
	
						var firstActiveIndex = -- nCachedObjects,
							lastCachedObject = objects[ firstActiveIndex ],
							lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						// last cached object takes this object's place
						indicesByUUID[ lastCachedObject.uuid ] = index;
						objects[ index ] = lastCachedObject;
	
						// last object goes to the activated slot and pop
						indicesByUUID[ lastObject.uuid ] = firstActiveIndex;
						objects[ firstActiveIndex ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ],
								lastCached = bindingsForPath[ firstActiveIndex ],
								last = bindingsForPath[ lastIndex ];
	
							bindingsForPath[ index ] = lastCached;
							bindingsForPath[ firstActiveIndex ] = last;
							bindingsForPath.pop();
	
						}
	
					} else {
	
						// object is active, just swap with the last and pop
	
						var lastIndex = -- nObjects,
							lastObject = objects[ lastIndex ];
	
						indicesByUUID[ lastObject.uuid ] = index;
						objects[ index ] = lastObject;
						objects.pop();
	
						// accounting is done, now do the same for all bindings
	
						for ( var j = 0, m = nBindings; j !== m; ++ j ) {
	
							var bindingsForPath = bindings[ j ];
	
							bindingsForPath[ index ] = bindingsForPath[ lastIndex ];
							bindingsForPath.pop();
	
						}
	
					} // cached or active
	
				} // if object is known
	
			} // for arguments
	
			this.nCachedObjects_ = nCachedObjects;
	
		},
	
		// Internal interface used by befriended PropertyBinding.Composite:
	
		subscribe_: function ( path, parsedPath ) {
	
			// returns an array of bindings for the given path that is changed
			// according to the contained objects in the group
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ],
				bindings = this._bindings;
	
			if ( index !== undefined ) return bindings[ index ];
	
			var paths = this._paths,
				parsedPaths = this._parsedPaths,
				objects = this._objects,
				nObjects = objects.length,
				nCachedObjects = this.nCachedObjects_,
				bindingsForPath = new Array( nObjects );
	
			index = bindings.length;
	
			indicesByPath[ path ] = index;
	
			paths.push( path );
			parsedPaths.push( parsedPath );
			bindings.push( bindingsForPath );
	
			for ( var i = nCachedObjects, n = objects.length; i !== n; ++ i ) {
	
				var object = objects[ i ];
				bindingsForPath[ i ] = new PropertyBinding( object, path, parsedPath );
	
			}
	
			return bindingsForPath;
	
		},
	
		unsubscribe_: function ( path ) {
	
			// tells the group to forget about a property path and no longer
			// update the array previously obtained with 'subscribe_'
	
			var indicesByPath = this._bindingsIndicesByPath,
				index = indicesByPath[ path ];
	
			if ( index !== undefined ) {
	
				var paths = this._paths,
					parsedPaths = this._parsedPaths,
					bindings = this._bindings,
					lastBindingsIndex = bindings.length - 1,
					lastBindings = bindings[ lastBindingsIndex ],
					lastBindingsPath = path[ lastBindingsIndex ];
	
				indicesByPath[ lastBindingsPath ] = index;
	
				bindings[ index ] = lastBindings;
				bindings.pop();
	
				parsedPaths[ index ] = parsedPaths[ lastBindingsIndex ];
				parsedPaths.pop();
	
				paths[ index ] = paths[ lastBindingsIndex ];
				paths.pop();
	
			}
	
		}
	
	} );
	
	/**
	 *
	 * Action provided by AnimationMixer for scheduling clip playback on specific
	 * objects.
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 *
	 */
	
	function AnimationAction( mixer, clip, localRoot ) {
	
		this._mixer = mixer;
		this._clip = clip;
		this._localRoot = localRoot || null;
	
		var tracks = clip.tracks,
			nTracks = tracks.length,
			interpolants = new Array( nTracks );
	
		var interpolantSettings = {
			endingStart: ZeroCurvatureEnding,
			endingEnd: ZeroCurvatureEnding
		};
	
		for ( var i = 0; i !== nTracks; ++ i ) {
	
			var interpolant = tracks[ i ].createInterpolant( null );
			interpolants[ i ] = interpolant;
			interpolant.settings = interpolantSettings;
	
		}
	
		this._interpolantSettings = interpolantSettings;
	
		this._interpolants = interpolants; // bound by the mixer
	
		// inside: PropertyMixer (managed by the mixer)
		this._propertyBindings = new Array( nTracks );
	
		this._cacheIndex = null; // for the memory manager
		this._byClipCacheIndex = null; // for the memory manager
	
		this._timeScaleInterpolant = null;
		this._weightInterpolant = null;
	
		this.loop = LoopRepeat;
		this._loopCount = - 1;
	
		// global mixer time when the action is to be started
		// it's set back to 'null' upon start of the action
		this._startTime = null;
	
		// scaled local time of the action
		// gets clamped or wrapped to 0..clip.duration according to loop
		this.time = 0;
	
		this.timeScale = 1;
		this._effectiveTimeScale = 1;
	
		this.weight = 1;
		this._effectiveWeight = 1;
	
		this.repetitions = Infinity; // no. of repetitions when looping
	
		this.paused = false; // true -> zero effective time scale
		this.enabled = true; // false -> zero effective weight
	
		this.clampWhenFinished = false;// keep feeding the last frame?
	
		this.zeroSlopeAtStart = true;// for smooth interpolation w/o separate
		this.zeroSlopeAtEnd = true;// clips for start, loop and end
	
	}
	
	Object.assign( AnimationAction.prototype, {
	
		// State & Scheduling
	
		play: function () {
	
			this._mixer._activateAction( this );
	
			return this;
	
		},
	
		stop: function () {
	
			this._mixer._deactivateAction( this );
	
			return this.reset();
	
		},
	
		reset: function () {
	
			this.paused = false;
			this.enabled = true;
	
			this.time = 0; // restart clip
			this._loopCount = - 1;// forget previous loops
			this._startTime = null;// forget scheduling
	
			return this.stopFading().stopWarping();
	
		},
	
		isRunning: function () {
	
			return this.enabled && ! this.paused && this.timeScale !== 0 &&
				this._startTime === null && this._mixer._isActiveAction( this );
	
		},
	
		// return true when play has been called
		isScheduled: function () {
	
			return this._mixer._isActiveAction( this );
	
		},
	
		startAt: function ( time ) {
	
			this._startTime = time;
	
			return this;
	
		},
	
		setLoop: function ( mode, repetitions ) {
	
			this.loop = mode;
			this.repetitions = repetitions;
	
			return this;
	
		},
	
		// Weight
	
		// set the weight stopping any scheduled fading
		// although .enabled = false yields an effective weight of zero, this
		// method does *not* change .enabled, because it would be confusing
		setEffectiveWeight: function ( weight ) {
	
			this.weight = weight;
	
			// note: same logic as when updated at runtime
			this._effectiveWeight = this.enabled ? weight : 0;
	
			return this.stopFading();
	
		},
	
		// return the weight considering fading and .enabled
		getEffectiveWeight: function () {
	
			return this._effectiveWeight;
	
		},
	
		fadeIn: function ( duration ) {
	
			return this._scheduleFading( duration, 0, 1 );
	
		},
	
		fadeOut: function ( duration ) {
	
			return this._scheduleFading( duration, 1, 0 );
	
		},
	
		crossFadeFrom: function ( fadeOutAction, duration, warp ) {
	
			fadeOutAction.fadeOut( duration );
			this.fadeIn( duration );
	
			if ( warp ) {
	
				var fadeInDuration = this._clip.duration,
					fadeOutDuration = fadeOutAction._clip.duration,
	
					startEndRatio = fadeOutDuration / fadeInDuration,
					endStartRatio = fadeInDuration / fadeOutDuration;
	
				fadeOutAction.warp( 1.0, startEndRatio, duration );
				this.warp( endStartRatio, 1.0, duration );
	
			}
	
			return this;
	
		},
	
		crossFadeTo: function ( fadeInAction, duration, warp ) {
	
			return fadeInAction.crossFadeFrom( this, duration, warp );
	
		},
	
		stopFading: function () {
	
			var weightInterpolant = this._weightInterpolant;
	
			if ( weightInterpolant !== null ) {
	
				this._weightInterpolant = null;
				this._mixer._takeBackControlInterpolant( weightInterpolant );
	
			}
	
			return this;
	
		},
	
		// Time Scale Control
	
		// set the time scale stopping any scheduled warping
		// although .paused = true yields an effective time scale of zero, this
		// method does *not* change .paused, because it would be confusing
		setEffectiveTimeScale: function ( timeScale ) {
	
			this.timeScale = timeScale;
			this._effectiveTimeScale = this.paused ? 0 : timeScale;
	
			return this.stopWarping();
	
		},
	
		// return the time scale considering warping and .paused
		getEffectiveTimeScale: function () {
	
			return this._effectiveTimeScale;
	
		},
	
		setDuration: function ( duration ) {
	
			this.timeScale = this._clip.duration / duration;
	
			return this.stopWarping();
	
		},
	
		syncWith: function ( action ) {
	
			this.time = action.time;
			this.timeScale = action.timeScale;
	
			return this.stopWarping();
	
		},
	
		halt: function ( duration ) {
	
			return this.warp( this._effectiveTimeScale, 0, duration );
	
		},
	
		warp: function ( startTimeScale, endTimeScale, duration ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._timeScaleInterpolant,
	
				timeScale = this.timeScale;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant();
				this._timeScaleInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now;
			times[ 1 ] = now + duration;
	
			values[ 0 ] = startTimeScale / timeScale;
			values[ 1 ] = endTimeScale / timeScale;
	
			return this;
	
		},
	
		stopWarping: function () {
	
			var timeScaleInterpolant = this._timeScaleInterpolant;
	
			if ( timeScaleInterpolant !== null ) {
	
				this._timeScaleInterpolant = null;
				this._mixer._takeBackControlInterpolant( timeScaleInterpolant );
	
			}
	
			return this;
	
		},
	
		// Object Accessors
	
		getMixer: function () {
	
			return this._mixer;
	
		},
	
		getClip: function () {
	
			return this._clip;
	
		},
	
		getRoot: function () {
	
			return this._localRoot || this._mixer._root;
	
		},
	
		// Interna
	
		_update: function ( time, deltaTime, timeDirection, accuIndex ) {
	
			// called by the mixer
	
			if ( ! this.enabled ) {
	
				// call ._updateWeight() to update ._effectiveWeight
	
				this._updateWeight( time );
				return;
	
			}
	
			var startTime = this._startTime;
	
			if ( startTime !== null ) {
	
				// check for scheduled start of action
	
				var timeRunning = ( time - startTime ) * timeDirection;
				if ( timeRunning < 0 || timeDirection === 0 ) {
	
					return; // yet to come / don't decide when delta = 0
	
				}
	
				// start
	
				this._startTime = null; // unschedule
				deltaTime = timeDirection * timeRunning;
	
			}
	
			// apply time scale and advance time
	
			deltaTime *= this._updateTimeScale( time );
			var clipTime = this._updateTime( deltaTime );
	
			// note: _updateTime may disable the action resulting in
			// an effective weight of 0
	
			var weight = this._updateWeight( time );
	
			if ( weight > 0 ) {
	
				var interpolants = this._interpolants;
				var propertyMixers = this._propertyBindings;
	
				for ( var j = 0, m = interpolants.length; j !== m; ++ j ) {
	
					interpolants[ j ].evaluate( clipTime );
					propertyMixers[ j ].accumulate( accuIndex, weight );
	
				}
	
			}
	
		},
	
		_updateWeight: function ( time ) {
	
			var weight = 0;
	
			if ( this.enabled ) {
	
				weight = this.weight;
				var interpolant = this._weightInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					weight *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopFading();
	
						if ( interpolantValue === 0 ) {
	
							// faded out, disable
							this.enabled = false;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveWeight = weight;
			return weight;
	
		},
	
		_updateTimeScale: function ( time ) {
	
			var timeScale = 0;
	
			if ( ! this.paused ) {
	
				timeScale = this.timeScale;
	
				var interpolant = this._timeScaleInterpolant;
	
				if ( interpolant !== null ) {
	
					var interpolantValue = interpolant.evaluate( time )[ 0 ];
	
					timeScale *= interpolantValue;
	
					if ( time > interpolant.parameterPositions[ 1 ] ) {
	
						this.stopWarping();
	
						if ( timeScale === 0 ) {
	
							// motion has halted, pause
							this.paused = true;
	
						} else {
	
							// warp done - apply final time scale
							this.timeScale = timeScale;
	
						}
	
					}
	
				}
	
			}
	
			this._effectiveTimeScale = timeScale;
			return timeScale;
	
		},
	
		_updateTime: function ( deltaTime ) {
	
			var time = this.time + deltaTime;
			var duration = this._clip.duration;
			var loop = this.loop;
			var loopCount = this._loopCount;
	
			var pingPong = ( loop === LoopPingPong );
	
			if ( deltaTime === 0 ) {
	
				if ( loopCount === - 1 ) return time;
	
				return ( pingPong && ( loopCount & 1 ) === 1 ) ? duration - time : time;
	
			}
	
			if ( loop === LoopOnce ) {
	
				if ( loopCount === - 1 ) {
	
					// just started
	
					this._loopCount = 0;
					this._setEndings( true, true, false );
	
				}
	
				handle_stop: {
	
					if ( time >= duration ) {
	
						time = duration;
	
					} else if ( time < 0 ) {
	
						time = 0;
	
					} else break handle_stop;
	
					if ( this.clampWhenFinished ) this.paused = true;
					else this.enabled = false;
	
					this._mixer.dispatchEvent( {
						type: 'finished', action: this,
						direction: deltaTime < 0 ? - 1 : 1
					} );
	
				}
	
			} else { // repetitive Repeat or PingPong
	
				if ( loopCount === - 1 ) {
	
					// just started
	
					if ( deltaTime >= 0 ) {
	
						loopCount = 0;
	
						this._setEndings( true, this.repetitions === 0, pingPong );
	
					} else {
	
						// when looping in reverse direction, the initial
						// transition through zero counts as a repetition,
						// so leave loopCount at -1
	
						this._setEndings( this.repetitions === 0, true, pingPong );
	
					}
	
				}
	
				if ( time >= duration || time < 0 ) {
	
					// wrap around
	
					var loopDelta = Math.floor( time / duration ); // signed
					time -= duration * loopDelta;
	
					loopCount += Math.abs( loopDelta );
	
					var pending = this.repetitions - loopCount;
	
					if ( pending <= 0 ) {
	
						// have to stop (switch state, clamp time, fire event)
	
						if ( this.clampWhenFinished ) this.paused = true;
						else this.enabled = false;
	
						time = deltaTime > 0 ? duration : 0;
	
						this._mixer.dispatchEvent( {
							type: 'finished', action: this,
							direction: deltaTime > 0 ? 1 : - 1
						} );
	
					} else {
	
						// keep running
	
						if ( pending === 1 ) {
	
							// entering the last round
	
							var atStart = deltaTime < 0;
							this._setEndings( atStart, ! atStart, pingPong );
	
						} else {
	
							this._setEndings( false, false, pingPong );
	
						}
	
						this._loopCount = loopCount;
	
						this._mixer.dispatchEvent( {
							type: 'loop', action: this, loopDelta: loopDelta
						} );
	
					}
	
				}
	
				if ( pingPong && ( loopCount & 1 ) === 1 ) {
	
					// invert time for the "pong round"
	
					this.time = time;
					return duration - time;
	
				}
	
			}
	
			this.time = time;
			return time;
	
		},
	
		_setEndings: function ( atStart, atEnd, pingPong ) {
	
			var settings = this._interpolantSettings;
	
			if ( pingPong ) {
	
				settings.endingStart = ZeroSlopeEnding;
				settings.endingEnd = ZeroSlopeEnding;
	
			} else {
	
				// assuming for LoopOnce atStart == atEnd == true
	
				if ( atStart ) {
	
					settings.endingStart = this.zeroSlopeAtStart ? ZeroSlopeEnding : ZeroCurvatureEnding;
	
				} else {
	
					settings.endingStart = WrapAroundEnding;
	
				}
	
				if ( atEnd ) {
	
					settings.endingEnd = this.zeroSlopeAtEnd ? ZeroSlopeEnding : ZeroCurvatureEnding;
	
				} else {
	
					settings.endingEnd 	 = WrapAroundEnding;
	
				}
	
			}
	
		},
	
		_scheduleFading: function ( duration, weightNow, weightThen ) {
	
			var mixer = this._mixer, now = mixer.time,
				interpolant = this._weightInterpolant;
	
			if ( interpolant === null ) {
	
				interpolant = mixer._lendControlInterpolant();
				this._weightInterpolant = interpolant;
	
			}
	
			var times = interpolant.parameterPositions,
				values = interpolant.sampleValues;
	
			times[ 0 ] = now;
			values[ 0 ] = weightNow;
			times[ 1 ] = now + duration;
			values[ 1 ] = weightThen;
	
			return this;
	
		}
	
	} );
	
	/**
	 *
	 * Player for AnimationClips.
	 *
	 *
	 * @author Ben Houston / http://clara.io/
	 * @author David Sarno / http://lighthaus.us/
	 * @author tschw
	 */
	
	function AnimationMixer( root ) {
	
		this._root = root;
		this._initMemoryManager();
		this._accuIndex = 0;
	
		this.time = 0;
	
		this.timeScale = 1.0;
	
	}
	
	AnimationMixer.prototype = Object.assign( Object.create( EventDispatcher.prototype ), {
	
		constructor: AnimationMixer,
	
		_bindAction: function ( action, prototypeAction ) {
	
			var root = action._localRoot || this._root,
				tracks = action._clip.tracks,
				nTracks = tracks.length,
				bindings = action._propertyBindings,
				interpolants = action._interpolants,
				rootUuid = root.uuid,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingsByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingsByName === undefined ) {
	
				bindingsByName = {};
				bindingsByRoot[ rootUuid ] = bindingsByName;
	
			}
	
			for ( var i = 0; i !== nTracks; ++ i ) {
	
				var track = tracks[ i ],
					trackName = track.name,
					binding = bindingsByName[ trackName ];
	
				if ( binding !== undefined ) {
	
					bindings[ i ] = binding;
	
				} else {
	
					binding = bindings[ i ];
	
					if ( binding !== undefined ) {
	
						// existing binding, make sure the cache knows
	
						if ( binding._cacheIndex === null ) {
	
							++ binding.referenceCount;
							this._addInactiveBinding( binding, rootUuid, trackName );
	
						}
	
						continue;
	
					}
	
					var path = prototypeAction && prototypeAction.
						_propertyBindings[ i ].binding.parsedPath;
	
					binding = new PropertyMixer(
						PropertyBinding.create( root, trackName, path ),
						track.ValueTypeName, track.getValueSize() );
	
					++ binding.referenceCount;
					this._addInactiveBinding( binding, rootUuid, trackName );
	
					bindings[ i ] = binding;
	
				}
	
				interpolants[ i ].resultBuffer = binding.buffer;
	
			}
	
		},
	
		_activateAction: function ( action ) {
	
			if ( ! this._isActiveAction( action ) ) {
	
				if ( action._cacheIndex === null ) {
	
					// this action has been forgotten by the cache, but the user
					// appears to be still using it -> rebind
	
					var rootUuid = ( action._localRoot || this._root ).uuid,
						clipUuid = action._clip.uuid,
						actionsForClip = this._actionsByClip[ clipUuid ];
	
					this._bindAction( action,
						actionsForClip && actionsForClip.knownActions[ 0 ] );
	
					this._addInactiveAction( action, clipUuid, rootUuid );
	
				}
	
				var bindings = action._propertyBindings;
	
				// increment reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( binding.useCount ++ === 0 ) {
	
						this._lendBinding( binding );
						binding.saveOriginalState();
	
					}
	
				}
	
				this._lendAction( action );
	
			}
	
		},
	
		_deactivateAction: function ( action ) {
	
			if ( this._isActiveAction( action ) ) {
	
				var bindings = action._propertyBindings;
	
				// decrement reference counts / sort out state
				for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
					var binding = bindings[ i ];
	
					if ( -- binding.useCount === 0 ) {
	
						binding.restoreOriginalState();
						this._takeBackBinding( binding );
	
					}
	
				}
	
				this._takeBackAction( action );
	
			}
	
		},
	
		// Memory manager
	
		_initMemoryManager: function () {
	
			this._actions = []; // 'nActiveActions' followed by inactive ones
			this._nActiveActions = 0;
	
			this._actionsByClip = {};
			// inside:
			// {
			// 	knownActions: Array< AnimationAction > - used as prototypes
			// 	actionByRoot: AnimationAction - lookup
			// }
	
	
			this._bindings = []; // 'nActiveBindings' followed by inactive ones
			this._nActiveBindings = 0;
	
			this._bindingsByRootAndName = {}; // inside: Map< name, PropertyMixer >
	
	
			this._controlInterpolants = []; // same game as above
			this._nActiveControlInterpolants = 0;
	
			var scope = this;
	
			this.stats = {
	
				actions: {
					get total() {
	
						return scope._actions.length;
	
					},
					get inUse() {
	
						return scope._nActiveActions;
	
					}
				},
				bindings: {
					get total() {
	
						return scope._bindings.length;
	
					},
					get inUse() {
	
						return scope._nActiveBindings;
	
					}
				},
				controlInterpolants: {
					get total() {
	
						return scope._controlInterpolants.length;
	
					},
					get inUse() {
	
						return scope._nActiveControlInterpolants;
	
					}
				}
	
			};
	
		},
	
		// Memory management for AnimationAction objects
	
		_isActiveAction: function ( action ) {
	
			var index = action._cacheIndex;
			return index !== null && index < this._nActiveActions;
	
		},
	
		_addInactiveAction: function ( action, clipUuid, rootUuid ) {
	
			var actions = this._actions,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];
	
			if ( actionsForClip === undefined ) {
	
				actionsForClip = {
	
					knownActions: [ action ],
					actionByRoot: {}
	
				};
	
				action._byClipCacheIndex = 0;
	
				actionsByClip[ clipUuid ] = actionsForClip;
	
			} else {
	
				var knownActions = actionsForClip.knownActions;
	
				action._byClipCacheIndex = knownActions.length;
				knownActions.push( action );
	
			}
	
			action._cacheIndex = actions.length;
			actions.push( action );
	
			actionsForClip.actionByRoot[ rootUuid ] = action;
	
		},
	
		_removeInactiveAction: function ( action ) {
	
			var actions = this._actions,
				lastInactiveAction = actions[ actions.length - 1 ],
				cacheIndex = action._cacheIndex;
	
			lastInactiveAction._cacheIndex = cacheIndex;
			actions[ cacheIndex ] = lastInactiveAction;
			actions.pop();
	
			action._cacheIndex = null;
	
	
			var clipUuid = action._clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ],
				knownActionsForClip = actionsForClip.knownActions,
	
				lastKnownAction =
					knownActionsForClip[ knownActionsForClip.length - 1 ],
	
				byClipCacheIndex = action._byClipCacheIndex;
	
			lastKnownAction._byClipCacheIndex = byClipCacheIndex;
			knownActionsForClip[ byClipCacheIndex ] = lastKnownAction;
			knownActionsForClip.pop();
	
			action._byClipCacheIndex = null;
	
	
			var actionByRoot = actionsForClip.actionByRoot,
				rootUuid = ( action._localRoot || this._root ).uuid;
	
			delete actionByRoot[ rootUuid ];
	
			if ( knownActionsForClip.length === 0 ) {
	
				delete actionsByClip[ clipUuid ];
	
			}
	
			this._removeInactiveBindingsForAction( action );
	
		},
	
		_removeInactiveBindingsForAction: function ( action ) {
	
			var bindings = action._propertyBindings;
			for ( var i = 0, n = bindings.length; i !== n; ++ i ) {
	
				var binding = bindings[ i ];
	
				if ( -- binding.referenceCount === 0 ) {
	
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		_lendAction: function ( action ) {
	
			// [ active actions |  inactive actions  ]
			// [  active actions >| inactive actions ]
			//                 s        a
			//                  <-swap->
			//                 a        s
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				lastActiveIndex = this._nActiveActions ++,
	
				firstInactiveAction = actions[ lastActiveIndex ];
	
			action._cacheIndex = lastActiveIndex;
			actions[ lastActiveIndex ] = action;
	
			firstInactiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = firstInactiveAction;
	
		},
	
		_takeBackAction: function ( action ) {
	
			// [  active actions  | inactive actions ]
			// [ active actions |< inactive actions  ]
			//        a        s
			//         <-swap->
			//        s        a
	
			var actions = this._actions,
				prevIndex = action._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveActions,
	
				lastActiveAction = actions[ firstInactiveIndex ];
	
			action._cacheIndex = firstInactiveIndex;
			actions[ firstInactiveIndex ] = action;
	
			lastActiveAction._cacheIndex = prevIndex;
			actions[ prevIndex ] = lastActiveAction;
	
		},
	
		// Memory management for PropertyMixer objects
	
		_addInactiveBinding: function ( binding, rootUuid, trackName ) {
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				bindings = this._bindings;
	
			if ( bindingByName === undefined ) {
	
				bindingByName = {};
				bindingsByRoot[ rootUuid ] = bindingByName;
	
			}
	
			bindingByName[ trackName ] = binding;
	
			binding._cacheIndex = bindings.length;
			bindings.push( binding );
	
		},
	
		_removeInactiveBinding: function ( binding ) {
	
			var bindings = this._bindings,
				propBinding = binding.binding,
				rootUuid = propBinding.rootNode.uuid,
				trackName = propBinding.path,
				bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ],
	
				lastInactiveBinding = bindings[ bindings.length - 1 ],
				cacheIndex = binding._cacheIndex;
	
			lastInactiveBinding._cacheIndex = cacheIndex;
			bindings[ cacheIndex ] = lastInactiveBinding;
			bindings.pop();
	
			delete bindingByName[ trackName ];
	
			remove_empty_map: {
	
				for ( var _ in bindingByName ) break remove_empty_map; // eslint-disable-line no-unused-vars
	
				delete bindingsByRoot[ rootUuid ];
	
			}
	
		},
	
		_lendBinding: function ( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				lastActiveIndex = this._nActiveBindings ++,
	
				firstInactiveBinding = bindings[ lastActiveIndex ];
	
			binding._cacheIndex = lastActiveIndex;
			bindings[ lastActiveIndex ] = binding;
	
			firstInactiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = firstInactiveBinding;
	
		},
	
		_takeBackBinding: function ( binding ) {
	
			var bindings = this._bindings,
				prevIndex = binding._cacheIndex,
	
				firstInactiveIndex = -- this._nActiveBindings,
	
				lastActiveBinding = bindings[ firstInactiveIndex ];
	
			binding._cacheIndex = firstInactiveIndex;
			bindings[ firstInactiveIndex ] = binding;
	
			lastActiveBinding._cacheIndex = prevIndex;
			bindings[ prevIndex ] = lastActiveBinding;
	
		},
	
	
		// Memory management of Interpolants for weight and time scale
	
		_lendControlInterpolant: function () {
	
			var interpolants = this._controlInterpolants,
				lastActiveIndex = this._nActiveControlInterpolants ++,
				interpolant = interpolants[ lastActiveIndex ];
	
			if ( interpolant === undefined ) {
	
				interpolant = new LinearInterpolant(
					new Float32Array( 2 ), new Float32Array( 2 ),
					1, this._controlInterpolantsResultBuffer );
	
				interpolant.__cacheIndex = lastActiveIndex;
				interpolants[ lastActiveIndex ] = interpolant;
	
			}
	
			return interpolant;
	
		},
	
		_takeBackControlInterpolant: function ( interpolant ) {
	
			var interpolants = this._controlInterpolants,
				prevIndex = interpolant.__cacheIndex,
	
				firstInactiveIndex = -- this._nActiveControlInterpolants,
	
				lastActiveInterpolant = interpolants[ firstInactiveIndex ];
	
			interpolant.__cacheIndex = firstInactiveIndex;
			interpolants[ firstInactiveIndex ] = interpolant;
	
			lastActiveInterpolant.__cacheIndex = prevIndex;
			interpolants[ prevIndex ] = lastActiveInterpolant;
	
		},
	
		_controlInterpolantsResultBuffer: new Float32Array( 1 ),
	
		// return an action for a clip optionally using a custom root target
		// object (this method allocates a lot of dynamic memory in case a
		// previously unknown clip/root combination is specified)
		clipAction: function ( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
	
				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,
	
				clipUuid = clipObject !== null ? clipObject.uuid : clip,
	
				actionsForClip = this._actionsByClip[ clipUuid ],
				prototypeAction = null;
	
			if ( actionsForClip !== undefined ) {
	
				var existingAction =
						actionsForClip.actionByRoot[ rootUuid ];
	
				if ( existingAction !== undefined ) {
	
					return existingAction;
	
				}
	
				// we know the clip, so we don't have to parse all
				// the bindings again but can just copy
				prototypeAction = actionsForClip.knownActions[ 0 ];
	
				// also, take the clip from the prototype action
				if ( clipObject === null )
					clipObject = prototypeAction._clip;
	
			}
	
			// clip must be known when specified via string
			if ( clipObject === null ) return null;
	
			// allocate all resources required to run it
			var newAction = new AnimationAction( this, clipObject, optionalRoot );
	
			this._bindAction( newAction, prototypeAction );
	
			// and make the action known to the memory manager
			this._addInactiveAction( newAction, clipUuid, rootUuid );
	
			return newAction;
	
		},
	
		// get an existing action
		existingAction: function ( clip, optionalRoot ) {
	
			var root = optionalRoot || this._root,
				rootUuid = root.uuid,
	
				clipObject = typeof clip === 'string' ?
					AnimationClip.findByName( root, clip ) : clip,
	
				clipUuid = clipObject ? clipObject.uuid : clip,
	
				actionsForClip = this._actionsByClip[ clipUuid ];
	
			if ( actionsForClip !== undefined ) {
	
				return actionsForClip.actionByRoot[ rootUuid ] || null;
	
			}
	
			return null;
	
		},
	
		// deactivates all previously scheduled actions
		stopAllAction: function () {
	
			var actions = this._actions,
				nActions = this._nActiveActions,
				bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			this._nActiveActions = 0;
			this._nActiveBindings = 0;
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				actions[ i ].reset();
	
			}
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].useCount = 0;
	
			}
	
			return this;
	
		},
	
		// advance the time and update apply the animation
		update: function ( deltaTime ) {
	
			deltaTime *= this.timeScale;
	
			var actions = this._actions,
				nActions = this._nActiveActions,
	
				time = this.time += deltaTime,
				timeDirection = Math.sign( deltaTime ),
	
				accuIndex = this._accuIndex ^= 1;
	
			// run active actions
	
			for ( var i = 0; i !== nActions; ++ i ) {
	
				var action = actions[ i ];
	
				action._update( time, deltaTime, timeDirection, accuIndex );
	
			}
	
			// update scene graph
	
			var bindings = this._bindings,
				nBindings = this._nActiveBindings;
	
			for ( var i = 0; i !== nBindings; ++ i ) {
	
				bindings[ i ].apply( accuIndex );
	
			}
	
			return this;
	
		},
	
		// return this mixer's root target object
		getRoot: function () {
	
			return this._root;
	
		},
	
		// free all resources specific to a particular clip
		uncacheClip: function ( clip ) {
	
			var actions = this._actions,
				clipUuid = clip.uuid,
				actionsByClip = this._actionsByClip,
				actionsForClip = actionsByClip[ clipUuid ];
	
			if ( actionsForClip !== undefined ) {
	
				// note: just calling _removeInactiveAction would mess up the
				// iteration state and also require updating the state we can
				// just throw away
	
				var actionsToRemove = actionsForClip.knownActions;
	
				for ( var i = 0, n = actionsToRemove.length; i !== n; ++ i ) {
	
					var action = actionsToRemove[ i ];
	
					this._deactivateAction( action );
	
					var cacheIndex = action._cacheIndex,
						lastInactiveAction = actions[ actions.length - 1 ];
	
					action._cacheIndex = null;
					action._byClipCacheIndex = null;
	
					lastInactiveAction._cacheIndex = cacheIndex;
					actions[ cacheIndex ] = lastInactiveAction;
					actions.pop();
	
					this._removeInactiveBindingsForAction( action );
	
				}
	
				delete actionsByClip[ clipUuid ];
	
			}
	
		},
	
		// free all resources specific to a particular root target object
		uncacheRoot: function ( root ) {
	
			var rootUuid = root.uuid,
				actionsByClip = this._actionsByClip;
	
			for ( var clipUuid in actionsByClip ) {
	
				var actionByRoot = actionsByClip[ clipUuid ].actionByRoot,
					action = actionByRoot[ rootUuid ];
	
				if ( action !== undefined ) {
	
					this._deactivateAction( action );
					this._removeInactiveAction( action );
	
				}
	
			}
	
			var bindingsByRoot = this._bindingsByRootAndName,
				bindingByName = bindingsByRoot[ rootUuid ];
	
			if ( bindingByName !== undefined ) {
	
				for ( var trackName in bindingByName ) {
	
					var binding = bindingByName[ trackName ];
					binding.restoreOriginalState();
					this._removeInactiveBinding( binding );
	
				}
	
			}
	
		},
	
		// remove a targeted clip from the cache
		uncacheAction: function ( clip, optionalRoot ) {
	
			var action = this.existingAction( clip, optionalRoot );
	
			if ( action !== null ) {
	
				this._deactivateAction( action );
				this._removeInactiveAction( action );
	
			}
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Uniform( value ) {
	
		if ( typeof value === 'string' ) {
	
			console.warn( 'THREE.Uniform: Type parameter is no longer needed.' );
			value = arguments[ 1 ];
	
		}
	
		this.value = value;
	
	}
	
	Uniform.prototype.clone = function () {
	
		return new Uniform( this.value.clone === undefined ? this.value : this.value.clone() );
	
	};
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	function InstancedBufferGeometry() {
	
		BufferGeometry.call( this );
	
		this.type = 'InstancedBufferGeometry';
		this.maxInstancedCount = undefined;
	
	}
	
	InstancedBufferGeometry.prototype = Object.assign( Object.create( BufferGeometry.prototype ), {
	
		constructor: InstancedBufferGeometry,
	
		isInstancedBufferGeometry: true,
	
		copy: function ( source ) {
	
			BufferGeometry.prototype.copy.call( this, source );
	
			this.maxInstancedCount = source.maxInstancedCount;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		}
	
	} );
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	function InstancedInterleavedBuffer( array, stride, meshPerAttribute ) {
	
		InterleavedBuffer.call( this, array, stride );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	}
	
	InstancedInterleavedBuffer.prototype = Object.assign( Object.create( InterleavedBuffer.prototype ), {
	
		constructor: InstancedInterleavedBuffer,
	
		isInstancedInterleavedBuffer: true,
	
		copy: function ( source ) {
	
			InterleavedBuffer.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author benaadams / https://twitter.com/ben_a_adams
	 */
	
	function InstancedBufferAttribute( array, itemSize, normalized, meshPerAttribute ) {
	
		if ( typeof ( normalized ) === 'number' ) {
	
			meshPerAttribute = normalized;
	
			normalized = false;
	
			console.error( 'THREE.InstancedBufferAttribute: The constructor now expects normalized as the third argument.' );
	
		}
	
		BufferAttribute.call( this, array, itemSize, normalized );
	
		this.meshPerAttribute = meshPerAttribute || 1;
	
	}
	
	InstancedBufferAttribute.prototype = Object.assign( Object.create( BufferAttribute.prototype ), {
	
		constructor: InstancedBufferAttribute,
	
		isInstancedBufferAttribute: true,
	
		copy: function ( source ) {
	
			BufferAttribute.prototype.copy.call( this, source );
	
			this.meshPerAttribute = source.meshPerAttribute;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author bhouston / http://clara.io/
	 * @author stephomi / http://stephaneginier.com/
	 */
	
	function Raycaster( origin, direction, near, far ) {
	
		this.ray = new Ray( origin, direction );
		// direction is assumed to be normalized (for accurate distance calculations)
	
		this.near = near || 0;
		this.far = far || Infinity;
	
		this.params = {
			Mesh: {},
			Line: {},
			LOD: {},
			Points: { threshold: 1 },
			Sprite: {}
		};
	
		Object.defineProperties( this.params, {
			PointCloud: {
				get: function () {
	
					console.warn( 'THREE.Raycaster: params.PointCloud has been renamed to params.Points.' );
					return this.Points;
	
				}
			}
		} );
	
	}
	
	function ascSort( a, b ) {
	
		return a.distance - b.distance;
	
	}
	
	function intersectObject( object, raycaster, intersects, recursive ) {
	
		if ( object.visible === false ) return;
	
		object.raycast( raycaster, intersects );
	
		if ( recursive === true ) {
	
			var children = object.children;
	
			for ( var i = 0, l = children.length; i < l; i ++ ) {
	
				intersectObject( children[ i ], raycaster, intersects, true );
	
			}
	
		}
	
	}
	
	Object.assign( Raycaster.prototype, {
	
		linePrecision: 1,
	
		set: function ( origin, direction ) {
	
			// direction is assumed to be normalized (for accurate distance calculations)
	
			this.ray.set( origin, direction );
	
		},
	
		setFromCamera: function ( coords, camera ) {
	
			if ( ( camera && camera.isPerspectiveCamera ) ) {
	
				this.ray.origin.setFromMatrixPosition( camera.matrixWorld );
				this.ray.direction.set( coords.x, coords.y, 0.5 ).unproject( camera ).sub( this.ray.origin ).normalize();
	
			} else if ( ( camera && camera.isOrthographicCamera ) ) {
	
				this.ray.origin.set( coords.x, coords.y, ( camera.near + camera.far ) / ( camera.near - camera.far ) ).unproject( camera ); // set origin in plane of camera
				this.ray.direction.set( 0, 0, - 1 ).transformDirection( camera.matrixWorld );
	
			} else {
	
				console.error( 'THREE.Raycaster: Unsupported camera type.' );
	
			}
	
		},
	
		intersectObject: function ( object, recursive, optionalTarget ) {
	
			var intersects = optionalTarget || [];
	
			intersectObject( object, this, intersects, recursive );
	
			intersects.sort( ascSort );
	
			return intersects;
	
		},
	
		intersectObjects: function ( objects, recursive, optionalTarget ) {
	
			var intersects = optionalTarget || [];
	
			if ( Array.isArray( objects ) === false ) {
	
				console.warn( 'THREE.Raycaster.intersectObjects: objects is not an Array.' );
				return intersects;
	
			}
	
			for ( var i = 0, l = objects.length; i < l; i ++ ) {
	
				intersectObject( objects[ i ], this, intersects, recursive );
	
			}
	
			intersects.sort( ascSort );
	
			return intersects;
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 * Ref: https://en.wikipedia.org/wiki/Spherical_coordinate_system
	 *
	 * The polar angle (phi) is measured from the positive y-axis. The positive y-axis is up.
	 * The azimuthal angle (theta) is measured from the positive z-axiz.
	 */
	
	function Spherical( radius, phi, theta ) {
	
		this.radius = ( radius !== undefined ) ? radius : 1.0;
		this.phi = ( phi !== undefined ) ? phi : 0; // polar angle
		this.theta = ( theta !== undefined ) ? theta : 0; // azimuthal angle
	
		return this;
	
	}
	
	Object.assign( Spherical.prototype, {
	
		set: function ( radius, phi, theta ) {
	
			this.radius = radius;
			this.phi = phi;
			this.theta = theta;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( other ) {
	
			this.radius = other.radius;
			this.phi = other.phi;
			this.theta = other.theta;
	
			return this;
	
		},
	
		// restrict phi to be betwee EPS and PI-EPS
		makeSafe: function () {
	
			var EPS = 0.000001;
			this.phi = Math.max( EPS, Math.min( Math.PI - EPS, this.phi ) );
	
			return this;
	
		},
	
		setFromVector3: function ( v ) {
	
			return this.setFromCartesianCoords( v.x, v.y, v.z );
	
		},
	
		setFromCartesianCoords: function ( x, y, z ) {
	
			this.radius = Math.sqrt( x * x + y * y + z * z );
	
			if ( this.radius === 0 ) {
	
				this.theta = 0;
				this.phi = 0;
	
			} else {
	
				this.theta = Math.atan2( x, z );
				this.phi = Math.acos( _Math.clamp( y / this.radius, - 1, 1 ) );
	
			}
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 * Ref: https://en.wikipedia.org/wiki/Cylindrical_coordinate_system
	 *
	 */
	
	function Cylindrical( radius, theta, y ) {
	
		this.radius = ( radius !== undefined ) ? radius : 1.0; // distance from the origin to a point in the x-z plane
		this.theta = ( theta !== undefined ) ? theta : 0; // counterclockwise angle in the x-z plane measured in radians from the positive z-axis
		this.y = ( y !== undefined ) ? y : 0; // height above the x-z plane
	
		return this;
	
	}
	
	Object.assign( Cylindrical.prototype, {
	
		set: function ( radius, theta, y ) {
	
			this.radius = radius;
			this.theta = theta;
			this.y = y;
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( other ) {
	
			this.radius = other.radius;
			this.theta = other.theta;
			this.y = other.y;
	
			return this;
	
		},
	
		setFromVector3: function ( v ) {
	
			return this.setFromCartesianCoords( v.x, v.y, v.z );
	
		},
	
		setFromCartesianCoords: function ( x, y, z ) {
	
			this.radius = Math.sqrt( x * x + z * z );
			this.theta = Math.atan2( x, z );
			this.y = y;
	
			return this;
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	function Box2( min, max ) {
	
		this.min = ( min !== undefined ) ? min : new Vector2( + Infinity, + Infinity );
		this.max = ( max !== undefined ) ? max : new Vector2( - Infinity, - Infinity );
	
	}
	
	Object.assign( Box2.prototype, {
	
		set: function ( min, max ) {
	
			this.min.copy( min );
			this.max.copy( max );
	
			return this;
	
		},
	
		setFromPoints: function ( points ) {
	
			this.makeEmpty();
	
			for ( var i = 0, il = points.length; i < il; i ++ ) {
	
				this.expandByPoint( points[ i ] );
	
			}
	
			return this;
	
		},
	
		setFromCenterAndSize: function () {
	
			var v1 = new Vector2();
	
			return function setFromCenterAndSize( center, size ) {
	
				var halfSize = v1.copy( size ).multiplyScalar( 0.5 );
				this.min.copy( center ).sub( halfSize );
				this.max.copy( center ).add( halfSize );
	
				return this;
	
			};
	
		}(),
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( box ) {
	
			this.min.copy( box.min );
			this.max.copy( box.max );
	
			return this;
	
		},
	
		makeEmpty: function () {
	
			this.min.x = this.min.y = + Infinity;
			this.max.x = this.max.y = - Infinity;
	
			return this;
	
		},
	
		isEmpty: function () {
	
			// this is a more robust check for empty than ( volume <= 0 ) because volume can get positive with two negative axes
	
			return ( this.max.x < this.min.x ) || ( this.max.y < this.min.y );
	
		},
	
		getCenter: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box2: .getCenter() target is now required' );
				target = new Vector2();
	
			}
	
			return this.isEmpty() ? target.set( 0, 0 ) : target.addVectors( this.min, this.max ).multiplyScalar( 0.5 );
	
		},
	
		getSize: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box2: .getSize() target is now required' );
				target = new Vector2();
	
			}
	
			return this.isEmpty() ? target.set( 0, 0 ) : target.subVectors( this.max, this.min );
	
		},
	
		expandByPoint: function ( point ) {
	
			this.min.min( point );
			this.max.max( point );
	
			return this;
	
		},
	
		expandByVector: function ( vector ) {
	
			this.min.sub( vector );
			this.max.add( vector );
	
			return this;
	
		},
	
		expandByScalar: function ( scalar ) {
	
			this.min.addScalar( - scalar );
			this.max.addScalar( scalar );
	
			return this;
	
		},
	
		containsPoint: function ( point ) {
	
			return point.x < this.min.x || point.x > this.max.x ||
				point.y < this.min.y || point.y > this.max.y ? false : true;
	
		},
	
		containsBox: function ( box ) {
	
			return this.min.x <= box.min.x && box.max.x <= this.max.x &&
				this.min.y <= box.min.y && box.max.y <= this.max.y;
	
		},
	
		getParameter: function ( point, target ) {
	
			// This can potentially have a divide by zero if the box
			// has a size dimension of 0.
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box2: .getParameter() target is now required' );
				target = new Vector2();
	
			}
	
			return target.set(
				( point.x - this.min.x ) / ( this.max.x - this.min.x ),
				( point.y - this.min.y ) / ( this.max.y - this.min.y )
			);
	
		},
	
		intersectsBox: function ( box ) {
	
			// using 4 splitting planes to rule out intersections
	
			return box.max.x < this.min.x || box.min.x > this.max.x ||
				box.max.y < this.min.y || box.min.y > this.max.y ? false : true;
	
		},
	
		clampPoint: function ( point, target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Box2: .clampPoint() target is now required' );
				target = new Vector2();
	
			}
	
			return target.copy( point ).clamp( this.min, this.max );
	
		},
	
		distanceToPoint: function () {
	
			var v1 = new Vector2();
	
			return function distanceToPoint( point ) {
	
				var clampedPoint = v1.copy( point ).clamp( this.min, this.max );
				return clampedPoint.sub( point ).length();
	
			};
	
		}(),
	
		intersect: function ( box ) {
	
			this.min.max( box.min );
			this.max.min( box.max );
	
			return this;
	
		},
	
		union: function ( box ) {
	
			this.min.min( box.min );
			this.max.max( box.max );
	
			return this;
	
		},
	
		translate: function ( offset ) {
	
			this.min.add( offset );
			this.max.add( offset );
	
			return this;
	
		},
	
		equals: function ( box ) {
	
			return box.min.equals( this.min ) && box.max.equals( this.max );
	
		}
	
	} );
	
	/**
	 * @author bhouston / http://clara.io
	 */
	
	function Line3( start, end ) {
	
		this.start = ( start !== undefined ) ? start : new Vector3();
		this.end = ( end !== undefined ) ? end : new Vector3();
	
	}
	
	Object.assign( Line3.prototype, {
	
		set: function ( start, end ) {
	
			this.start.copy( start );
			this.end.copy( end );
	
			return this;
	
		},
	
		clone: function () {
	
			return new this.constructor().copy( this );
	
		},
	
		copy: function ( line ) {
	
			this.start.copy( line.start );
			this.end.copy( line.end );
	
			return this;
	
		},
	
		getCenter: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Line3: .getCenter() target is now required' );
				target = new Vector3();
	
			}
	
			return target.addVectors( this.start, this.end ).multiplyScalar( 0.5 );
	
		},
	
		delta: function ( target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Line3: .delta() target is now required' );
				target = new Vector3();
	
			}
	
			return target.subVectors( this.end, this.start );
	
		},
	
		distanceSq: function () {
	
			return this.start.distanceToSquared( this.end );
	
		},
	
		distance: function () {
	
			return this.start.distanceTo( this.end );
	
		},
	
		at: function ( t, target ) {
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Line3: .at() target is now required' );
				target = new Vector3();
	
			}
	
			return this.delta( target ).multiplyScalar( t ).add( this.start );
	
		},
	
		closestPointToPointParameter: function () {
	
			var startP = new Vector3();
			var startEnd = new Vector3();
	
			return function closestPointToPointParameter( point, clampToLine ) {
	
				startP.subVectors( point, this.start );
				startEnd.subVectors( this.end, this.start );
	
				var startEnd2 = startEnd.dot( startEnd );
				var startEnd_startP = startEnd.dot( startP );
	
				var t = startEnd_startP / startEnd2;
	
				if ( clampToLine ) {
	
					t = _Math.clamp( t, 0, 1 );
	
				}
	
				return t;
	
			};
	
		}(),
	
		closestPointToPoint: function ( point, clampToLine, target ) {
	
			var t = this.closestPointToPointParameter( point, clampToLine );
	
			if ( target === undefined ) {
	
				console.warn( 'THREE.Line3: .closestPointToPoint() target is now required' );
				target = new Vector3();
	
			}
	
			return this.delta( target ).multiplyScalar( t ).add( this.start );
	
		},
	
		applyMatrix4: function ( matrix ) {
	
			this.start.applyMatrix4( matrix );
			this.end.applyMatrix4( matrix );
	
			return this;
	
		},
	
		equals: function ( line ) {
	
			return line.start.equals( this.start ) && line.end.equals( this.end );
	
		}
	
	} );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 */
	
	function ImmediateRenderObject( material ) {
	
		Object3D.call( this );
	
		this.material = material;
		this.render = function ( /* renderCallback */ ) {};
	
	}
	
	ImmediateRenderObject.prototype = Object.create( Object3D.prototype );
	ImmediateRenderObject.prototype.constructor = ImmediateRenderObject;
	
	ImmediateRenderObject.prototype.isImmediateRenderObject = true;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function VertexNormalsHelper( object, size, hex, linewidth ) {
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xff0000;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry && objGeometry.isGeometry ) {
	
			nNormals = objGeometry.faces.length * 3;
	
		} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
			nNormals = objGeometry.attributes.normal.count;
	
		}
	
		//
	
		var geometry = new BufferGeometry();
	
		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	}
	
	VertexNormalsHelper.prototype = Object.create( LineSegments.prototype );
	VertexNormalsHelper.prototype.constructor = VertexNormalsHelper;
	
	VertexNormalsHelper.prototype.update = ( function () {
	
		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();
	
		return function update() {
	
			var keys = [ 'a', 'b', 'c' ];
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			if ( objGeometry && objGeometry.isGeometry ) {
	
				var vertices = objGeometry.vertices;
	
				var faces = objGeometry.faces;
	
				var idx = 0;
	
				for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
					var face = faces[ i ];
	
					for ( var j = 0, jl = face.vertexNormals.length; j < jl; j ++ ) {
	
						var vertex = vertices[ face[ keys[ j ] ] ];
	
						var normal = face.vertexNormals[ j ];
	
						v1.copy( vertex ).applyMatrix4( matrixWorld );
	
						v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
						position.setXYZ( idx, v1.x, v1.y, v1.z );
	
						idx = idx + 1;
	
						position.setXYZ( idx, v2.x, v2.y, v2.z );
	
						idx = idx + 1;
	
					}
	
				}
	
			} else if ( objGeometry && objGeometry.isBufferGeometry ) {
	
				var objPos = objGeometry.attributes.position;
	
				var objNorm = objGeometry.attributes.normal;
	
				var idx = 0;
	
				// for simplicity, ignore index and drawcalls, and render every normal
	
				for ( var j = 0, jl = objPos.count; j < jl; j ++ ) {
	
					v1.set( objPos.getX( j ), objPos.getY( j ), objPos.getZ( j ) ).applyMatrix4( matrixWorld );
	
					v2.set( objNorm.getX( j ), objNorm.getY( j ), objNorm.getZ( j ) );
	
					v2.applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
					position.setXYZ( idx, v1.x, v1.y, v1.z );
	
					idx = idx + 1;
	
					position.setXYZ( idx, v2.x, v2.y, v2.z );
	
					idx = idx + 1;
	
				}
	
			}
	
			position.needsUpdate = true;
	
		};
	
	}() );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function SpotLightHelper( light, color ) {
	
		Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.color = color;
	
		var geometry = new BufferGeometry();
	
		var positions = [
			0, 0, 0, 	0, 0, 1,
			0, 0, 0, 	1, 0, 1,
			0, 0, 0,	- 1, 0, 1,
			0, 0, 0, 	0, 1, 1,
			0, 0, 0, 	0, - 1, 1
		];
	
		for ( var i = 0, j = 1, l = 32; i < l; i ++, j ++ ) {
	
			var p1 = ( i / l ) * Math.PI * 2;
			var p2 = ( j / l ) * Math.PI * 2;
	
			positions.push(
				Math.cos( p1 ), Math.sin( p1 ), 1,
				Math.cos( p2 ), Math.sin( p2 ), 1
			);
	
		}
	
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	
		var material = new LineBasicMaterial( { fog: false } );
	
		this.cone = new LineSegments( geometry, material );
		this.add( this.cone );
	
		this.update();
	
	}
	
	SpotLightHelper.prototype = Object.create( Object3D.prototype );
	SpotLightHelper.prototype.constructor = SpotLightHelper;
	
	SpotLightHelper.prototype.dispose = function () {
	
		this.cone.geometry.dispose();
		this.cone.material.dispose();
	
	};
	
	SpotLightHelper.prototype.update = function () {
	
		var vector = new Vector3();
	
		return function update() {
	
			this.light.updateMatrixWorld();
	
			var coneLength = this.light.distance ? this.light.distance : 1000;
			var coneWidth = coneLength * Math.tan( this.light.angle );
	
			this.cone.scale.set( coneWidth, coneWidth, coneLength );
	
			vector.setFromMatrixPosition( this.light.target.matrixWorld );
	
			this.cone.lookAt( vector );
	
			if ( this.color !== undefined ) {
	
				this.cone.material.color.set( this.color );
	
			} else {
	
				this.cone.material.color.copy( this.light.color );
	
			}
	
		};
	
	}();
	
	/**
	 * @author Sean Griffin / http://twitter.com/sgrif
	 * @author Michael Guerrero / http://realitymeltdown.com
	 * @author mrdoob / http://mrdoob.com/
	 * @author ikerr / http://verold.com
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	function getBoneList( object ) {
	
		var boneList = [];
	
		if ( object && object.isBone ) {
	
			boneList.push( object );
	
		}
	
		for ( var i = 0; i < object.children.length; i ++ ) {
	
			boneList.push.apply( boneList, getBoneList( object.children[ i ] ) );
	
		}
	
		return boneList;
	
	}
	
	function SkeletonHelper( object ) {
	
		var bones = getBoneList( object );
	
		var geometry = new BufferGeometry();
	
		var vertices = [];
		var colors = [];
	
		var color1 = new Color( 0, 0, 1 );
		var color2 = new Color( 0, 1, 0 );
	
		for ( var i = 0; i < bones.length; i ++ ) {
	
			var bone = bones[ i ];
	
			if ( bone.parent && bone.parent.isBone ) {
	
				vertices.push( 0, 0, 0 );
				vertices.push( 0, 0, 0 );
				colors.push( color1.r, color1.g, color1.b );
				colors.push( color2.r, color2.g, color2.b );
	
			}
	
		}
	
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
		var material = new LineBasicMaterial( { vertexColors: VertexColors, depthTest: false, depthWrite: false, transparent: true } );
	
		LineSegments.call( this, geometry, material );
	
		this.root = object;
		this.bones = bones;
	
		this.matrix = object.matrixWorld;
		this.matrixAutoUpdate = false;
	
	}
	
	SkeletonHelper.prototype = Object.create( LineSegments.prototype );
	SkeletonHelper.prototype.constructor = SkeletonHelper;
	
	SkeletonHelper.prototype.updateMatrixWorld = function () {
	
		var vector = new Vector3();
	
		var boneMatrix = new Matrix4();
		var matrixWorldInv = new Matrix4();
	
		return function updateMatrixWorld( force ) {
	
			var bones = this.bones;
	
			var geometry = this.geometry;
			var position = geometry.getAttribute( 'position' );
	
			matrixWorldInv.getInverse( this.root.matrixWorld );
	
			for ( var i = 0, j = 0; i < bones.length; i ++ ) {
	
				var bone = bones[ i ];
	
				if ( bone.parent && bone.parent.isBone ) {
	
					boneMatrix.multiplyMatrices( matrixWorldInv, bone.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j, vector.x, vector.y, vector.z );
	
					boneMatrix.multiplyMatrices( matrixWorldInv, bone.parent.matrixWorld );
					vector.setFromMatrixPosition( boneMatrix );
					position.setXYZ( j + 1, vector.x, vector.y, vector.z );
	
					j += 2;
	
				}
	
			}
	
			geometry.getAttribute( 'position' ).needsUpdate = true;
	
			Object3D.prototype.updateMatrixWorld.call( this, force );
	
		};
	
	}();
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function PointLightHelper( light, sphereSize, color ) {
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.color = color;
	
		var geometry = new SphereBufferGeometry( sphereSize, 4, 2 );
		var material = new MeshBasicMaterial( { wireframe: true, fog: false } );
	
		Mesh.call( this, geometry, material );
	
		this.matrix = this.light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.update();
	
	
		/*
		var distanceGeometry = new THREE.IcosahedronBufferGeometry( 1, 2 );
		var distanceMaterial = new THREE.MeshBasicMaterial( { color: hexColor, fog: false, wireframe: true, opacity: 0.1, transparent: true } );
	
		this.lightSphere = new THREE.Mesh( bulbGeometry, bulbMaterial );
		this.lightDistance = new THREE.Mesh( distanceGeometry, distanceMaterial );
	
		var d = light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.scale.set( d, d, d );
	
		}
	
		this.add( this.lightDistance );
		*/
	
	}
	
	PointLightHelper.prototype = Object.create( Mesh.prototype );
	PointLightHelper.prototype.constructor = PointLightHelper;
	
	PointLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
	
	};
	
	PointLightHelper.prototype.update = function () {
	
		if ( this.color !== undefined ) {
	
			this.material.color.set( this.color );
	
		} else {
	
			this.material.color.copy( this.light.color );
	
		}
	
		/*
		var d = this.light.distance;
	
		if ( d === 0.0 ) {
	
			this.lightDistance.visible = false;
	
		} else {
	
			this.lightDistance.visible = true;
			this.lightDistance.scale.set( d, d, d );
	
		}
		*/
	
	};
	
	/**
	 * @author abelnation / http://github.com/abelnation
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author WestLangley / http://github.com/WestLangley
	 *
	 *  This helper must be added as a child of the light
	 */
	
	function RectAreaLightHelper( light, color ) {
	
		this.type = 'RectAreaLightHelper';
	
		this.light = light;
	
		this.color = color; // optional hardwired color for the helper
	
		var positions = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, - 1, 0, 1, 1, 0 ];
	
		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();
	
		var material = new LineBasicMaterial( { fog: false } );
	
		Line.call( this, geometry, material );
	
		//
	
		var positions2 = [ 1, 1, 0, - 1, 1, 0, - 1, - 1, 0, 1, 1, 0, - 1, - 1, 0, 1, - 1, 0 ];
	
		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();
	
		this.add( new Mesh( geometry2, new MeshBasicMaterial( { side: BackSide, fog: false } ) ) );
	
		this.update();
	
	}
	
	RectAreaLightHelper.prototype = Object.create( Line.prototype );
	RectAreaLightHelper.prototype.constructor = RectAreaLightHelper;
	
	RectAreaLightHelper.prototype.update = function () {
	
		this.scale.set( 0.5 * this.light.width, 0.5 * this.light.height, 1 );
	
		if ( this.color !== undefined ) {
	
			this.material.color.set( this.color );
			this.children[ 0 ].material.color.set( this.color );
	
		} else {
	
			this.material.color.copy( this.light.color ).multiplyScalar( this.light.intensity );
	
			// prevent hue shift
			var c = this.material.color;
			var max = Math.max( c.r, c.g, c.b );
			if ( max > 1 ) c.multiplyScalar( 1 / max );
	
			this.children[ 0 ].material.color.copy( this.material.color );
	
		}
	
	};
	
	RectAreaLightHelper.prototype.dispose = function () {
	
		this.geometry.dispose();
		this.material.dispose();
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();
	
	};
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 */
	
	function HemisphereLightHelper( light, size, color ) {
	
		Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.color = color;
	
		var geometry = new OctahedronBufferGeometry( size );
		geometry.rotateY( Math.PI * 0.5 );
	
		this.material = new MeshBasicMaterial( { wireframe: true, fog: false } );
		if ( this.color === undefined ) this.material.vertexColors = VertexColors;
	
		var position = geometry.getAttribute( 'position' );
		var colors = new Float32Array( position.count * 3 );
	
		geometry.addAttribute( 'color', new BufferAttribute( colors, 3 ) );
	
		this.add( new Mesh( geometry, this.material ) );
	
		this.update();
	
	}
	
	HemisphereLightHelper.prototype = Object.create( Object3D.prototype );
	HemisphereLightHelper.prototype.constructor = HemisphereLightHelper;
	
	HemisphereLightHelper.prototype.dispose = function () {
	
		this.children[ 0 ].geometry.dispose();
		this.children[ 0 ].material.dispose();
	
	};
	
	HemisphereLightHelper.prototype.update = function () {
	
		var vector = new Vector3();
	
		var color1 = new Color();
		var color2 = new Color();
	
		return function update() {
	
			var mesh = this.children[ 0 ];
	
			if ( this.color !== undefined ) {
	
				this.material.color.set( this.color );
	
			} else {
	
				var colors = mesh.geometry.getAttribute( 'color' );
	
				color1.copy( this.light.color );
				color2.copy( this.light.groundColor );
	
				for ( var i = 0, l = colors.count; i < l; i ++ ) {
	
					var color = ( i < ( l / 2 ) ) ? color1 : color2;
	
					colors.setXYZ( i, color.r, color.g, color.b );
	
				}
	
				colors.needsUpdate = true;
	
			}
	
			mesh.lookAt( vector.setFromMatrixPosition( this.light.matrixWorld ).negate() );
	
		};
	
	}();
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function GridHelper( size, divisions, color1, color2 ) {
	
		size = size || 10;
		divisions = divisions || 10;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
		var center = divisions / 2;
		var step = size / divisions;
		var halfSize = size / 2;
	
		var vertices = [], colors = [];
	
		for ( var i = 0, j = 0, k = - halfSize; i <= divisions; i ++, k += step ) {
	
			vertices.push( - halfSize, 0, k, halfSize, 0, k );
			vertices.push( k, 0, - halfSize, k, 0, halfSize );
	
			var color = i === center ? color1 : color2;
	
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
			color.toArray( colors, j ); j += 3;
	
		}
	
		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
		var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
		LineSegments.call( this, geometry, material );
	
	}
	
	GridHelper.prototype = Object.create( LineSegments.prototype );
	GridHelper.prototype.constructor = GridHelper;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 * @author Hectate / http://www.github.com/Hectate
	 */
	
	function PolarGridHelper( radius, radials, circles, divisions, color1, color2 ) {
	
		radius = radius || 10;
		radials = radials || 16;
		circles = circles || 8;
		divisions = divisions || 64;
		color1 = new Color( color1 !== undefined ? color1 : 0x444444 );
		color2 = new Color( color2 !== undefined ? color2 : 0x888888 );
	
		var vertices = [];
		var colors = [];
	
		var x, z;
		var v, i, j, r, color;
	
		// create the radials
	
		for ( i = 0; i <= radials; i ++ ) {
	
			v = ( i / radials ) * ( Math.PI * 2 );
	
			x = Math.sin( v ) * radius;
			z = Math.cos( v ) * radius;
	
			vertices.push( 0, 0, 0 );
			vertices.push( x, 0, z );
	
			color = ( i & 1 ) ? color1 : color2;
	
			colors.push( color.r, color.g, color.b );
			colors.push( color.r, color.g, color.b );
	
		}
	
		// create the circles
	
		for ( i = 0; i <= circles; i ++ ) {
	
			color = ( i & 1 ) ? color1 : color2;
	
			r = radius - ( radius / circles * i );
	
			for ( j = 0; j < divisions; j ++ ) {
	
				// first vertex
	
				v = ( j / divisions ) * ( Math.PI * 2 );
	
				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;
	
				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );
	
				// second vertex
	
				v = ( ( j + 1 ) / divisions ) * ( Math.PI * 2 );
	
				x = Math.sin( v ) * r;
				z = Math.cos( v ) * r;
	
				vertices.push( x, 0, z );
				colors.push( color.r, color.g, color.b );
	
			}
	
		}
	
		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
		var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
		LineSegments.call( this, geometry, material );
	
	}
	
	PolarGridHelper.prototype = Object.create( LineSegments.prototype );
	PolarGridHelper.prototype.constructor = PolarGridHelper;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function FaceNormalsHelper( object, size, hex, linewidth ) {
	
		// FaceNormalsHelper only supports THREE.Geometry
	
		this.object = object;
	
		this.size = ( size !== undefined ) ? size : 1;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var width = ( linewidth !== undefined ) ? linewidth : 1;
	
		//
	
		var nNormals = 0;
	
		var objGeometry = this.object.geometry;
	
		if ( objGeometry && objGeometry.isGeometry ) {
	
			nNormals = objGeometry.faces.length;
	
		} else {
	
			console.warn( 'THREE.FaceNormalsHelper: only THREE.Geometry is supported. Use THREE.VertexNormalsHelper, instead.' );
	
		}
	
		//
	
		var geometry = new BufferGeometry();
	
		var positions = new Float32BufferAttribute( nNormals * 2 * 3, 3 );
	
		geometry.addAttribute( 'position', positions );
	
		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color, linewidth: width } ) );
	
		//
	
		this.matrixAutoUpdate = false;
		this.update();
	
	}
	
	FaceNormalsHelper.prototype = Object.create( LineSegments.prototype );
	FaceNormalsHelper.prototype.constructor = FaceNormalsHelper;
	
	FaceNormalsHelper.prototype.update = ( function () {
	
		var v1 = new Vector3();
		var v2 = new Vector3();
		var normalMatrix = new Matrix3();
	
		return function update() {
	
			this.object.updateMatrixWorld( true );
	
			normalMatrix.getNormalMatrix( this.object.matrixWorld );
	
			var matrixWorld = this.object.matrixWorld;
	
			var position = this.geometry.attributes.position;
	
			//
	
			var objGeometry = this.object.geometry;
	
			var vertices = objGeometry.vertices;
	
			var faces = objGeometry.faces;
	
			var idx = 0;
	
			for ( var i = 0, l = faces.length; i < l; i ++ ) {
	
				var face = faces[ i ];
	
				var normal = face.normal;
	
				v1.copy( vertices[ face.a ] )
					.add( vertices[ face.b ] )
					.add( vertices[ face.c ] )
					.divideScalar( 3 )
					.applyMatrix4( matrixWorld );
	
				v2.copy( normal ).applyMatrix3( normalMatrix ).normalize().multiplyScalar( this.size ).add( v1 );
	
				position.setXYZ( idx, v1.x, v1.y, v1.z );
	
				idx = idx + 1;
	
				position.setXYZ( idx, v2.x, v2.y, v2.z );
	
				idx = idx + 1;
	
			}
	
			position.needsUpdate = true;
	
		};
	
	}() );
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author mrdoob / http://mrdoob.com/
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function DirectionalLightHelper( light, size, color ) {
	
		Object3D.call( this );
	
		this.light = light;
		this.light.updateMatrixWorld();
	
		this.matrix = light.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.color = color;
	
		if ( size === undefined ) size = 1;
	
		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [
			- size, size, 0,
			size, size, 0,
			size, - size, 0,
			- size, - size, 0,
			- size, size, 0
		], 3 ) );
	
		var material = new LineBasicMaterial( { fog: false } );
	
		this.lightPlane = new Line( geometry, material );
		this.add( this.lightPlane );
	
		geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 0, 1 ], 3 ) );
	
		this.targetLine = new Line( geometry, material );
		this.add( this.targetLine );
	
		this.update();
	
	}
	
	DirectionalLightHelper.prototype = Object.create( Object3D.prototype );
	DirectionalLightHelper.prototype.constructor = DirectionalLightHelper;
	
	DirectionalLightHelper.prototype.dispose = function () {
	
		this.lightPlane.geometry.dispose();
		this.lightPlane.material.dispose();
		this.targetLine.geometry.dispose();
		this.targetLine.material.dispose();
	
	};
	
	DirectionalLightHelper.prototype.update = function () {
	
		var v1 = new Vector3();
		var v2 = new Vector3();
		var v3 = new Vector3();
	
		return function update() {
	
			v1.setFromMatrixPosition( this.light.matrixWorld );
			v2.setFromMatrixPosition( this.light.target.matrixWorld );
			v3.subVectors( v2, v1 );
	
			this.lightPlane.lookAt( v2 );
	
			if ( this.color !== undefined ) {
	
				this.lightPlane.material.color.set( this.color );
				this.targetLine.material.color.set( this.color );
	
			} else {
	
				this.lightPlane.material.color.copy( this.light.color );
				this.targetLine.material.color.copy( this.light.color );
	
			}
	
			this.targetLine.lookAt( v2 );
			this.targetLine.scale.z = v3.length();
	
		};
	
	}();
	
	/**
	 * @author alteredq / http://alteredqualia.com/
	 * @author Mugen87 / https://github.com/Mugen87
	 *
	 *	- shows frustum, line of sight and up of the camera
	 *	- suitable for fast updates
	 * 	- based on frustum visualization in lightgl.js shadowmap example
	 *		http://evanw.github.com/lightgl.js/tests/shadowmap.html
	 */
	
	function CameraHelper( camera ) {
	
		var geometry = new BufferGeometry();
		var material = new LineBasicMaterial( { color: 0xffffff, vertexColors: FaceColors } );
	
		var vertices = [];
		var colors = [];
	
		var pointMap = {};
	
		// colors
	
		var colorFrustum = new Color( 0xffaa00 );
		var colorCone = new Color( 0xff0000 );
		var colorUp = new Color( 0x00aaff );
		var colorTarget = new Color( 0xffffff );
		var colorCross = new Color( 0x333333 );
	
		// near
	
		addLine( 'n1', 'n2', colorFrustum );
		addLine( 'n2', 'n4', colorFrustum );
		addLine( 'n4', 'n3', colorFrustum );
		addLine( 'n3', 'n1', colorFrustum );
	
		// far
	
		addLine( 'f1', 'f2', colorFrustum );
		addLine( 'f2', 'f4', colorFrustum );
		addLine( 'f4', 'f3', colorFrustum );
		addLine( 'f3', 'f1', colorFrustum );
	
		// sides
	
		addLine( 'n1', 'f1', colorFrustum );
		addLine( 'n2', 'f2', colorFrustum );
		addLine( 'n3', 'f3', colorFrustum );
		addLine( 'n4', 'f4', colorFrustum );
	
		// cone
	
		addLine( 'p', 'n1', colorCone );
		addLine( 'p', 'n2', colorCone );
		addLine( 'p', 'n3', colorCone );
		addLine( 'p', 'n4', colorCone );
	
		// up
	
		addLine( 'u1', 'u2', colorUp );
		addLine( 'u2', 'u3', colorUp );
		addLine( 'u3', 'u1', colorUp );
	
		// target
	
		addLine( 'c', 't', colorTarget );
		addLine( 'p', 'c', colorCross );
	
		// cross
	
		addLine( 'cn1', 'cn2', colorCross );
		addLine( 'cn3', 'cn4', colorCross );
	
		addLine( 'cf1', 'cf2', colorCross );
		addLine( 'cf3', 'cf4', colorCross );
	
		function addLine( a, b, color ) {
	
			addPoint( a, color );
			addPoint( b, color );
	
		}
	
		function addPoint( id, color ) {
	
			vertices.push( 0, 0, 0 );
			colors.push( color.r, color.g, color.b );
	
			if ( pointMap[ id ] === undefined ) {
	
				pointMap[ id ] = [];
	
			}
	
			pointMap[ id ].push( ( vertices.length / 3 ) - 1 );
	
		}
	
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
		LineSegments.call( this, geometry, material );
	
		this.camera = camera;
		if ( this.camera.updateProjectionMatrix ) this.camera.updateProjectionMatrix();
	
		this.matrix = camera.matrixWorld;
		this.matrixAutoUpdate = false;
	
		this.pointMap = pointMap;
	
		this.update();
	
	}
	
	CameraHelper.prototype = Object.create( LineSegments.prototype );
	CameraHelper.prototype.constructor = CameraHelper;
	
	CameraHelper.prototype.update = function () {
	
		var geometry, pointMap;
	
		var vector = new Vector3();
		var camera = new Camera();
	
		function setPoint( point, x, y, z ) {
	
			vector.set( x, y, z ).unproject( camera );
	
			var points = pointMap[ point ];
	
			if ( points !== undefined ) {
	
				var position = geometry.getAttribute( 'position' );
	
				for ( var i = 0, l = points.length; i < l; i ++ ) {
	
					position.setXYZ( points[ i ], vector.x, vector.y, vector.z );
	
				}
	
			}
	
		}
	
		return function update() {
	
			geometry = this.geometry;
			pointMap = this.pointMap;
	
			var w = 1, h = 1;
	
			// we need just camera projection matrix
			// world matrix must be identity
	
			camera.projectionMatrix.copy( this.camera.projectionMatrix );
	
			// center / target
	
			setPoint( 'c', 0, 0, - 1 );
			setPoint( 't', 0, 0, 1 );
	
			// near
	
			setPoint( 'n1', - w, - h, - 1 );
			setPoint( 'n2', w, - h, - 1 );
			setPoint( 'n3', - w, h, - 1 );
			setPoint( 'n4', w, h, - 1 );
	
			// far
	
			setPoint( 'f1', - w, - h, 1 );
			setPoint( 'f2', w, - h, 1 );
			setPoint( 'f3', - w, h, 1 );
			setPoint( 'f4', w, h, 1 );
	
			// up
	
			setPoint( 'u1', w * 0.7, h * 1.1, - 1 );
			setPoint( 'u2', - w * 0.7, h * 1.1, - 1 );
			setPoint( 'u3', 0, h * 2, - 1 );
	
			// cross
	
			setPoint( 'cf1', - w, 0, 1 );
			setPoint( 'cf2', w, 0, 1 );
			setPoint( 'cf3', 0, - h, 1 );
			setPoint( 'cf4', 0, h, 1 );
	
			setPoint( 'cn1', - w, 0, - 1 );
			setPoint( 'cn2', w, 0, - 1 );
			setPoint( 'cn3', 0, - h, - 1 );
			setPoint( 'cn4', 0, h, - 1 );
	
			geometry.getAttribute( 'position' ).needsUpdate = true;
	
		};
	
	}();
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 * @author Mugen87 / http://github.com/Mugen87
	 */
	
	function BoxHelper( object, color ) {
	
		this.object = object;
	
		if ( color === undefined ) color = 0xffff00;
	
		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
		var positions = new Float32Array( 8 * 3 );
	
		var geometry = new BufferGeometry();
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
		geometry.addAttribute( 'position', new BufferAttribute( positions, 3 ) );
	
		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
		this.matrixAutoUpdate = false;
	
		this.update();
	
	}
	
	BoxHelper.prototype = Object.create( LineSegments.prototype );
	BoxHelper.prototype.constructor = BoxHelper;
	
	BoxHelper.prototype.update = ( function () {
	
		var box = new Box3();
	
		return function update( object ) {
	
			if ( object !== undefined ) {
	
				console.warn( 'THREE.BoxHelper: .update() has no longer arguments.' );
	
			}
	
			if ( this.object !== undefined ) {
	
				box.setFromObject( this.object );
	
			}
	
			if ( box.isEmpty() ) return;
	
			var min = box.min;
			var max = box.max;
	
			/*
				5____4
			1/___0/|
			| 6__|_7
			2/___3/
	
			0: max.x, max.y, max.z
			1: min.x, max.y, max.z
			2: min.x, min.y, max.z
			3: max.x, min.y, max.z
			4: max.x, max.y, min.z
			5: min.x, max.y, min.z
			6: min.x, min.y, min.z
			7: max.x, min.y, min.z
			*/
	
			var position = this.geometry.attributes.position;
			var array = position.array;
	
			array[ 0 ] = max.x; array[ 1 ] = max.y; array[ 2 ] = max.z;
			array[ 3 ] = min.x; array[ 4 ] = max.y; array[ 5 ] = max.z;
			array[ 6 ] = min.x; array[ 7 ] = min.y; array[ 8 ] = max.z;
			array[ 9 ] = max.x; array[ 10 ] = min.y; array[ 11 ] = max.z;
			array[ 12 ] = max.x; array[ 13 ] = max.y; array[ 14 ] = min.z;
			array[ 15 ] = min.x; array[ 16 ] = max.y; array[ 17 ] = min.z;
			array[ 18 ] = min.x; array[ 19 ] = min.y; array[ 20 ] = min.z;
			array[ 21 ] = max.x; array[ 22 ] = min.y; array[ 23 ] = min.z;
	
			position.needsUpdate = true;
	
			this.geometry.computeBoundingSphere();
	
		};
	
	} )();
	
	BoxHelper.prototype.setFromObject = function ( object ) {
	
		this.object = object;
		this.update();
	
		return this;
	
	};
	
	BoxHelper.prototype.copy = function ( source ) {
	
		LineSegments.prototype.copy.call( this, source );
	
		this.object = source.object;
	
		return this;
	
	};
	
	BoxHelper.prototype.clone = function () {
	
		return new this.constructor().copy( this );
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function Box3Helper( box, hex ) {
	
		this.type = 'Box3Helper';
	
		this.box = box;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var indices = new Uint16Array( [ 0, 1, 1, 2, 2, 3, 3, 0, 4, 5, 5, 6, 6, 7, 7, 4, 0, 4, 1, 5, 2, 6, 3, 7 ] );
	
		var positions = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, - 1, - 1, 1, - 1, - 1, - 1, - 1, 1, - 1, - 1 ];
	
		var geometry = new BufferGeometry();
	
		geometry.setIndex( new BufferAttribute( indices, 1 ) );
	
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
	
		LineSegments.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
		this.geometry.computeBoundingSphere();
	
	}
	
	Box3Helper.prototype = Object.create( LineSegments.prototype );
	Box3Helper.prototype.constructor = Box3Helper;
	
	Box3Helper.prototype.updateMatrixWorld = function ( force ) {
	
		var box = this.box;
	
		if ( box.isEmpty() ) return;
	
		box.getCenter( this.position );
	
		box.getSize( this.scale );
	
		this.scale.multiplyScalar( 0.5 );
	
		Object3D.prototype.updateMatrixWorld.call( this, force );
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 */
	
	function PlaneHelper( plane, size, hex ) {
	
		this.type = 'PlaneHelper';
	
		this.plane = plane;
	
		this.size = ( size === undefined ) ? 1 : size;
	
		var color = ( hex !== undefined ) ? hex : 0xffff00;
	
		var positions = [ 1, - 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, - 1, 1, 1, 1, 1, 0, 0, 1, 0, 0, 0 ];
	
		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( positions, 3 ) );
		geometry.computeBoundingSphere();
	
		Line.call( this, geometry, new LineBasicMaterial( { color: color } ) );
	
		//
	
		var positions2 = [ 1, 1, 1, - 1, 1, 1, - 1, - 1, 1, 1, 1, 1, - 1, - 1, 1, 1, - 1, 1 ];
	
		var geometry2 = new BufferGeometry();
		geometry2.addAttribute( 'position', new Float32BufferAttribute( positions2, 3 ) );
		geometry2.computeBoundingSphere();
	
		this.add( new Mesh( geometry2, new MeshBasicMaterial( { color: color, opacity: 0.2, transparent: true, depthWrite: false } ) ) );
	
	}
	
	PlaneHelper.prototype = Object.create( Line.prototype );
	PlaneHelper.prototype.constructor = PlaneHelper;
	
	PlaneHelper.prototype.updateMatrixWorld = function ( force ) {
	
		var scale = - this.plane.constant;
	
		if ( Math.abs( scale ) < 1e-8 ) scale = 1e-8; // sign does not matter
	
		this.scale.set( 0.5 * this.size, 0.5 * this.size, scale );
	
		this.children[ 0 ].material.side = ( scale < 0 ) ? BackSide : FrontSide; // renderer flips side when determinant < 0; flipping not wanted here
	
		this.lookAt( this.plane.normal );
	
		Object3D.prototype.updateMatrixWorld.call( this, force );
	
	};
	
	/**
	 * @author WestLangley / http://github.com/WestLangley
	 * @author zz85 / http://github.com/zz85
	 * @author bhouston / http://clara.io
	 *
	 * Creates an arrow for visualizing directions
	 *
	 * Parameters:
	 *  dir - Vector3
	 *  origin - Vector3
	 *  length - Number
	 *  color - color in hex value
	 *  headLength - Number
	 *  headWidth - Number
	 */
	
	var lineGeometry, coneGeometry;
	
	function ArrowHelper( dir, origin, length, color, headLength, headWidth ) {
	
		// dir is assumed to be normalized
	
		Object3D.call( this );
	
		if ( dir === undefined ) dir = new Vector3( 0, 0, 1 );
		if ( origin === undefined ) origin = new Vector3( 0, 0, 0 );
		if ( length === undefined ) length = 1;
		if ( color === undefined ) color = 0xffff00;
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		if ( lineGeometry === undefined ) {
	
			lineGeometry = new BufferGeometry();
			lineGeometry.addAttribute( 'position', new Float32BufferAttribute( [ 0, 0, 0, 0, 1, 0 ], 3 ) );
	
			coneGeometry = new CylinderBufferGeometry( 0, 0.5, 1, 5, 1 );
			coneGeometry.translate( 0, - 0.5, 0 );
	
		}
	
		this.position.copy( origin );
	
		this.line = new Line( lineGeometry, new LineBasicMaterial( { color: color } ) );
		this.line.matrixAutoUpdate = false;
		this.add( this.line );
	
		this.cone = new Mesh( coneGeometry, new MeshBasicMaterial( { color: color } ) );
		this.cone.matrixAutoUpdate = false;
		this.add( this.cone );
	
		this.setDirection( dir );
		this.setLength( length, headLength, headWidth );
	
	}
	
	ArrowHelper.prototype = Object.create( Object3D.prototype );
	ArrowHelper.prototype.constructor = ArrowHelper;
	
	ArrowHelper.prototype.setDirection = ( function () {
	
		var axis = new Vector3();
		var radians;
	
		return function setDirection( dir ) {
	
			// dir is assumed to be normalized
	
			if ( dir.y > 0.99999 ) {
	
				this.quaternion.set( 0, 0, 0, 1 );
	
			} else if ( dir.y < - 0.99999 ) {
	
				this.quaternion.set( 1, 0, 0, 0 );
	
			} else {
	
				axis.set( dir.z, 0, - dir.x ).normalize();
	
				radians = Math.acos( dir.y );
	
				this.quaternion.setFromAxisAngle( axis, radians );
	
			}
	
		};
	
	}() );
	
	ArrowHelper.prototype.setLength = function ( length, headLength, headWidth ) {
	
		if ( headLength === undefined ) headLength = 0.2 * length;
		if ( headWidth === undefined ) headWidth = 0.2 * headLength;
	
		this.line.scale.set( 1, Math.max( 0, length - headLength ), 1 );
		this.line.updateMatrix();
	
		this.cone.scale.set( headWidth, headLength, headWidth );
		this.cone.position.y = length;
		this.cone.updateMatrix();
	
	};
	
	ArrowHelper.prototype.setColor = function ( color ) {
	
		this.line.material.color.copy( color );
		this.cone.material.color.copy( color );
	
	};
	
	ArrowHelper.prototype.copy = function ( source ) {
	
		Object3D.prototype.copy.call( this, source, false );
	
		this.line.copy( source.line );
		this.cone.copy( source.cone );
	
		return this;
	
	};
	
	ArrowHelper.prototype.clone = function () {
	
		return new this.constructor().copy( this );
	
	};
	
	/**
	 * @author sroucheray / http://sroucheray.org/
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function AxesHelper( size ) {
	
		size = size || 1;
	
		var vertices = [
			0, 0, 0,	size, 0, 0,
			0, 0, 0,	0, size, 0,
			0, 0, 0,	0, 0, size
		];
	
		var colors = [
			1, 0, 0,	1, 0.6, 0,
			0, 1, 0,	0.6, 1, 0,
			0, 0, 1,	0, 0.6, 1
		];
	
		var geometry = new BufferGeometry();
		geometry.addAttribute( 'position', new Float32BufferAttribute( vertices, 3 ) );
		geometry.addAttribute( 'color', new Float32BufferAttribute( colors, 3 ) );
	
		var material = new LineBasicMaterial( { vertexColors: VertexColors } );
	
		LineSegments.call( this, geometry, material );
	
	}
	
	AxesHelper.prototype = Object.create( LineSegments.prototype );
	AxesHelper.prototype.constructor = AxesHelper;
	
	/**
	 * @author mrdoob / http://mrdoob.com/
	 */
	
	function Face4( a, b, c, d, normal, color, materialIndex ) {
	
		console.warn( 'THREE.Face4 has been removed. A THREE.Face3 will be created instead.' );
		return new Face3( a, b, c, normal, color, materialIndex );
	
	}
	
	var LineStrip = 0;
	
	var LinePieces = 1;
	
	function MeshFaceMaterial( materials ) {
	
		console.warn( 'THREE.MeshFaceMaterial has been removed. Use an Array instead.' );
		return materials;
	
	}
	
	function MultiMaterial( materials ) {
	
		if ( materials === undefined ) materials = [];
	
		console.warn( 'THREE.MultiMaterial has been removed. Use an Array instead.' );
		materials.isMultiMaterial = true;
		materials.materials = materials;
		materials.clone = function () {
	
			return materials.slice();
	
		};
		return materials;
	
	}
	
	function PointCloud( geometry, material ) {
	
		console.warn( 'THREE.PointCloud has been renamed to THREE.Points.' );
		return new Points( geometry, material );
	
	}
	
	function Particle( material ) {
	
		console.warn( 'THREE.Particle has been renamed to THREE.Sprite.' );
		return new Sprite( material );
	
	}
	
	function ParticleSystem( geometry, material ) {
	
		console.warn( 'THREE.ParticleSystem has been renamed to THREE.Points.' );
		return new Points( geometry, material );
	
	}
	
	function PointCloudMaterial( parameters ) {
	
		console.warn( 'THREE.PointCloudMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );
	
	}
	
	function ParticleBasicMaterial( parameters ) {
	
		console.warn( 'THREE.ParticleBasicMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );
	
	}
	
	function ParticleSystemMaterial( parameters ) {
	
		console.warn( 'THREE.ParticleSystemMaterial has been renamed to THREE.PointsMaterial.' );
		return new PointsMaterial( parameters );
	
	}
	
	function Vertex( x, y, z ) {
	
		console.warn( 'THREE.Vertex has been removed. Use THREE.Vector3 instead.' );
		return new Vector3( x, y, z );
	
	}
	
	//
	
	function DynamicBufferAttribute( array, itemSize ) {
	
		console.warn( 'THREE.DynamicBufferAttribute has been removed. Use new THREE.BufferAttribute().setDynamic( true ) instead.' );
		return new BufferAttribute( array, itemSize ).setDynamic( true );
	
	}
	
	function Int8Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Int8Attribute has been removed. Use new THREE.Int8BufferAttribute() instead.' );
		return new Int8BufferAttribute( array, itemSize );
	
	}
	
	function Uint8Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Uint8Attribute has been removed. Use new THREE.Uint8BufferAttribute() instead.' );
		return new Uint8BufferAttribute( array, itemSize );
	
	}
	
	function Uint8ClampedAttribute( array, itemSize ) {
	
		console.warn( 'THREE.Uint8ClampedAttribute has been removed. Use new THREE.Uint8ClampedBufferAttribute() instead.' );
		return new Uint8ClampedBufferAttribute( array, itemSize );
	
	}
	
	function Int16Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Int16Attribute has been removed. Use new THREE.Int16BufferAttribute() instead.' );
		return new Int16BufferAttribute( array, itemSize );
	
	}
	
	function Uint16Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Uint16Attribute has been removed. Use new THREE.Uint16BufferAttribute() instead.' );
		return new Uint16BufferAttribute( array, itemSize );
	
	}
	
	function Int32Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Int32Attribute has been removed. Use new THREE.Int32BufferAttribute() instead.' );
		return new Int32BufferAttribute( array, itemSize );
	
	}
	
	function Uint32Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Uint32Attribute has been removed. Use new THREE.Uint32BufferAttribute() instead.' );
		return new Uint32BufferAttribute( array, itemSize );
	
	}
	
	function Float32Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Float32Attribute has been removed. Use new THREE.Float32BufferAttribute() instead.' );
		return new Float32BufferAttribute( array, itemSize );
	
	}
	
	function Float64Attribute( array, itemSize ) {
	
		console.warn( 'THREE.Float64Attribute has been removed. Use new THREE.Float64BufferAttribute() instead.' );
		return new Float64BufferAttribute( array, itemSize );
	
	}
	
	//
	
	Curve.create = function ( construct, getPoint ) {
	
		console.log( 'THREE.Curve.create() has been deprecated' );
	
		construct.prototype = Object.create( Curve.prototype );
		construct.prototype.constructor = construct;
		construct.prototype.getPoint = getPoint;
	
		return construct;
	
	};
	
	//
	
	Object.assign( CurvePath.prototype, {
	
		createPointsGeometry: function ( divisions ) {
	
			console.warn( 'THREE.CurvePath: .createPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
	
			// generate geometry from path points (for Line or Points objects)
	
			var pts = this.getPoints( divisions );
			return this.createGeometry( pts );
	
		},
	
		createSpacedPointsGeometry: function ( divisions ) {
	
			console.warn( 'THREE.CurvePath: .createSpacedPointsGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
	
			// generate geometry from equidistant sampling along the path
	
			var pts = this.getSpacedPoints( divisions );
			return this.createGeometry( pts );
	
		},
	
		createGeometry: function ( points ) {
	
			console.warn( 'THREE.CurvePath: .createGeometry() has been removed. Use new THREE.Geometry().setFromPoints( points ) instead.' );
	
			var geometry = new Geometry();
	
			for ( var i = 0, l = points.length; i < l; i ++ ) {
	
				var point = points[ i ];
				geometry.vertices.push( new Vector3( point.x, point.y, point.z || 0 ) );
	
			}
	
			return geometry;
	
		}
	
	} );
	
	//
	
	Object.assign( Path.prototype, {
	
		fromPoints: function ( points ) {
	
			console.warn( 'THREE.Path: .fromPoints() has been renamed to .setFromPoints().' );
			this.setFromPoints( points );
	
		}
	
	} );
	
	//
	
	function ClosedSplineCurve3( points ) {
	
		console.warn( 'THREE.ClosedSplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
		this.closed = true;
	
	}
	
	ClosedSplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
	//
	
	function SplineCurve3( points ) {
	
		console.warn( 'THREE.SplineCurve3 has been deprecated. Use THREE.CatmullRomCurve3 instead.' );
	
		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
	
	}
	
	SplineCurve3.prototype = Object.create( CatmullRomCurve3.prototype );
	
	//
	
	function Spline( points ) {
	
		console.warn( 'THREE.Spline has been removed. Use THREE.CatmullRomCurve3 instead.' );
	
		CatmullRomCurve3.call( this, points );
		this.type = 'catmullrom';
	
	}
	
	Spline.prototype = Object.create( CatmullRomCurve3.prototype );
	
	Object.assign( Spline.prototype, {
	
		initFromArray: function ( /* a */ ) {
	
			console.error( 'THREE.Spline: .initFromArray() has been removed.' );
	
		},
		getControlPointsArray: function ( /* optionalTarget */ ) {
	
			console.error( 'THREE.Spline: .getControlPointsArray() has been removed.' );
	
		},
		reparametrizeByArcLength: function ( /* samplingCoef */ ) {
	
			console.error( 'THREE.Spline: .reparametrizeByArcLength() has been removed.' );
	
		}
	
	} );
	
	//
	
	function AxisHelper( size ) {
	
		console.warn( 'THREE.AxisHelper has been renamed to THREE.AxesHelper.' );
		return new AxesHelper( size );
	
	}
	
	function BoundingBoxHelper( object, color ) {
	
		console.warn( 'THREE.BoundingBoxHelper has been deprecated. Creating a THREE.BoxHelper instead.' );
		return new BoxHelper( object, color );
	
	}
	
	function EdgesHelper( object, hex ) {
	
		console.warn( 'THREE.EdgesHelper has been removed. Use THREE.EdgesGeometry instead.' );
		return new LineSegments( new EdgesGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
	}
	
	GridHelper.prototype.setColors = function () {
	
		console.error( 'THREE.GridHelper: setColors() has been deprecated, pass them in the constructor instead.' );
	
	};
	
	SkeletonHelper.prototype.update = function () {
	
		console.error( 'THREE.SkeletonHelper: update() no longer needs to be called.' );
	
	};
	
	function WireframeHelper( object, hex ) {
	
		console.warn( 'THREE.WireframeHelper has been removed. Use THREE.WireframeGeometry instead.' );
		return new LineSegments( new WireframeGeometry( object.geometry ), new LineBasicMaterial( { color: hex !== undefined ? hex : 0xffffff } ) );
	
	}
	
	//
	
	Object.assign( Loader.prototype, {
	
		extractUrlBase: function ( url ) {
	
			console.warn( 'THREE.Loader: .extractUrlBase() has been deprecated. Use THREE.LoaderUtils.extractUrlBase() instead.' );
			return LoaderUtils.extractUrlBase( url );
	
		}
	
	} );
	
	function XHRLoader( manager ) {
	
		console.warn( 'THREE.XHRLoader has been renamed to THREE.FileLoader.' );
		return new FileLoader( manager );
	
	}
	
	function BinaryTextureLoader( manager ) {
	
		console.warn( 'THREE.BinaryTextureLoader has been renamed to THREE.DataTextureLoader.' );
		return new DataTextureLoader( manager );
	
	}
	
	Object.assign( ObjectLoader.prototype, {
	
		setTexturePath: function ( value ) {
	
			console.warn( 'THREE.ObjectLoader: .setTexturePath() has been renamed to .setResourcePath().' );
			return this.setResourcePath( value );
	
		}
	
	} );
	
	//
	
	Object.assign( Box2.prototype, {
	
		center: function ( optionalTarget ) {
	
			console.warn( 'THREE.Box2: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
	
		},
		empty: function () {
	
			console.warn( 'THREE.Box2: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
	
		},
		isIntersectionBox: function ( box ) {
	
			console.warn( 'THREE.Box2: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
	
		},
		size: function ( optionalTarget ) {
	
			console.warn( 'THREE.Box2: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );
	
		}
	} );
	
	Object.assign( Box3.prototype, {
	
		center: function ( optionalTarget ) {
	
			console.warn( 'THREE.Box3: .center() has been renamed to .getCenter().' );
			return this.getCenter( optionalTarget );
	
		},
		empty: function () {
	
			console.warn( 'THREE.Box3: .empty() has been renamed to .isEmpty().' );
			return this.isEmpty();
	
		},
		isIntersectionBox: function ( box ) {
	
			console.warn( 'THREE.Box3: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
	
		},
		isIntersectionSphere: function ( sphere ) {
	
			console.warn( 'THREE.Box3: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
	
		},
		size: function ( optionalTarget ) {
	
			console.warn( 'THREE.Box3: .size() has been renamed to .getSize().' );
			return this.getSize( optionalTarget );
	
		}
	} );
	
	Line3.prototype.center = function ( optionalTarget ) {
	
		console.warn( 'THREE.Line3: .center() has been renamed to .getCenter().' );
		return this.getCenter( optionalTarget );
	
	};
	
	Object.assign( _Math, {
	
		random16: function () {
	
			console.warn( 'THREE.Math: .random16() has been deprecated. Use Math.random() instead.' );
			return Math.random();
	
		},
	
		nearestPowerOfTwo: function ( value ) {
	
			console.warn( 'THREE.Math: .nearestPowerOfTwo() has been renamed to .floorPowerOfTwo().' );
			return _Math.floorPowerOfTwo( value );
	
		},
	
		nextPowerOfTwo: function ( value ) {
	
			console.warn( 'THREE.Math: .nextPowerOfTwo() has been renamed to .ceilPowerOfTwo().' );
			return _Math.ceilPowerOfTwo( value );
	
		}
	
	} );
	
	Object.assign( Matrix3.prototype, {
	
		flattenToArrayOffset: function ( array, offset ) {
	
			console.warn( "THREE.Matrix3: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );
	
		},
		multiplyVector3: function ( vector ) {
	
			console.warn( 'THREE.Matrix3: .multiplyVector3() has been removed. Use vector.applyMatrix3( matrix ) instead.' );
			return vector.applyMatrix3( this );
	
		},
		multiplyVector3Array: function ( /* a */ ) {
	
			console.error( 'THREE.Matrix3: .multiplyVector3Array() has been removed.' );
	
		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {
	
			console.warn( 'THREE.Matrix3: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );
	
		},
		applyToVector3Array: function ( /* array, offset, length */ ) {
	
			console.error( 'THREE.Matrix3: .applyToVector3Array() has been removed.' );
	
		}
	
	} );
	
	Object.assign( Matrix4.prototype, {
	
		extractPosition: function ( m ) {
	
			console.warn( 'THREE.Matrix4: .extractPosition() has been renamed to .copyPosition().' );
			return this.copyPosition( m );
	
		},
		flattenToArrayOffset: function ( array, offset ) {
	
			console.warn( "THREE.Matrix4: .flattenToArrayOffset() has been deprecated. Use .toArray() instead." );
			return this.toArray( array, offset );
	
		},
		getPosition: function () {
	
			var v1;
	
			return function getPosition() {
	
				if ( v1 === undefined ) v1 = new Vector3();
				console.warn( 'THREE.Matrix4: .getPosition() has been removed. Use Vector3.setFromMatrixPosition( matrix ) instead.' );
				return v1.setFromMatrixColumn( this, 3 );
	
			};
	
		}(),
		setRotationFromQuaternion: function ( q ) {
	
			console.warn( 'THREE.Matrix4: .setRotationFromQuaternion() has been renamed to .makeRotationFromQuaternion().' );
			return this.makeRotationFromQuaternion( q );
	
		},
		multiplyToArray: function () {
	
			console.warn( 'THREE.Matrix4: .multiplyToArray() has been removed.' );
	
		},
		multiplyVector3: function ( vector ) {
	
			console.warn( 'THREE.Matrix4: .multiplyVector3() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
		multiplyVector4: function ( vector ) {
	
			console.warn( 'THREE.Matrix4: .multiplyVector4() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
		multiplyVector3Array: function ( /* a */ ) {
	
			console.error( 'THREE.Matrix4: .multiplyVector3Array() has been removed.' );
	
		},
		rotateAxis: function ( v ) {
	
			console.warn( 'THREE.Matrix4: .rotateAxis() has been removed. Use Vector3.transformDirection( matrix ) instead.' );
			v.transformDirection( this );
	
		},
		crossVector: function ( vector ) {
	
			console.warn( 'THREE.Matrix4: .crossVector() has been removed. Use vector.applyMatrix4( matrix ) instead.' );
			return vector.applyMatrix4( this );
	
		},
		translate: function () {
	
			console.error( 'THREE.Matrix4: .translate() has been removed.' );
	
		},
		rotateX: function () {
	
			console.error( 'THREE.Matrix4: .rotateX() has been removed.' );
	
		},
		rotateY: function () {
	
			console.error( 'THREE.Matrix4: .rotateY() has been removed.' );
	
		},
		rotateZ: function () {
	
			console.error( 'THREE.Matrix4: .rotateZ() has been removed.' );
	
		},
		rotateByAxis: function () {
	
			console.error( 'THREE.Matrix4: .rotateByAxis() has been removed.' );
	
		},
		applyToBuffer: function ( buffer /*, offset, length */ ) {
	
			console.warn( 'THREE.Matrix4: .applyToBuffer() has been removed. Use matrix.applyToBufferAttribute( attribute ) instead.' );
			return this.applyToBufferAttribute( buffer );
	
		},
		applyToVector3Array: function ( /* array, offset, length */ ) {
	
			console.error( 'THREE.Matrix4: .applyToVector3Array() has been removed.' );
	
		},
		makeFrustum: function ( left, right, bottom, top, near, far ) {
	
			console.warn( 'THREE.Matrix4: .makeFrustum() has been removed. Use .makePerspective( left, right, top, bottom, near, far ) instead.' );
			return this.makePerspective( left, right, top, bottom, near, far );
	
		}
	
	} );
	
	Plane.prototype.isIntersectionLine = function ( line ) {
	
		console.warn( 'THREE.Plane: .isIntersectionLine() has been renamed to .intersectsLine().' );
		return this.intersectsLine( line );
	
	};
	
	Quaternion.prototype.multiplyVector3 = function ( vector ) {
	
		console.warn( 'THREE.Quaternion: .multiplyVector3() has been removed. Use is now vector.applyQuaternion( quaternion ) instead.' );
		return vector.applyQuaternion( this );
	
	};
	
	Object.assign( Ray.prototype, {
	
		isIntersectionBox: function ( box ) {
	
			console.warn( 'THREE.Ray: .isIntersectionBox() has been renamed to .intersectsBox().' );
			return this.intersectsBox( box );
	
		},
		isIntersectionPlane: function ( plane ) {
	
			console.warn( 'THREE.Ray: .isIntersectionPlane() has been renamed to .intersectsPlane().' );
			return this.intersectsPlane( plane );
	
		},
		isIntersectionSphere: function ( sphere ) {
	
			console.warn( 'THREE.Ray: .isIntersectionSphere() has been renamed to .intersectsSphere().' );
			return this.intersectsSphere( sphere );
	
		}
	
	} );
	
	Object.assign( Triangle.prototype, {
	
		area: function () {
	
			console.warn( 'THREE.Triangle: .area() has been renamed to .getArea().' );
			return this.getArea();
	
		},
		barycoordFromPoint: function ( point, target ) {
	
			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return this.getBarycoord( point, target );
	
		},
		midpoint: function ( target ) {
	
			console.warn( 'THREE.Triangle: .midpoint() has been renamed to .getMidpoint().' );
			return this.getMidpoint( target );
	
		},
		normal: function ( target ) {
	
			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return this.getNormal( target );
	
		},
		plane: function ( target ) {
	
			console.warn( 'THREE.Triangle: .plane() has been renamed to .getPlane().' );
			return this.getPlane( target );
	
		}
	
	} );
	
	Object.assign( Triangle, {
	
		barycoordFromPoint: function ( point, a, b, c, target ) {
	
			console.warn( 'THREE.Triangle: .barycoordFromPoint() has been renamed to .getBarycoord().' );
			return Triangle.getBarycoord( point, a, b, c, target );
	
		},
		normal: function ( a, b, c, target ) {
	
			console.warn( 'THREE.Triangle: .normal() has been renamed to .getNormal().' );
			return Triangle.getNormal( a, b, c, target );
	
		}
	
	} );
	
	Object.assign( Shape.prototype, {
	
		extractAllPoints: function ( divisions ) {
	
			console.warn( 'THREE.Shape: .extractAllPoints() has been removed. Use .extractPoints() instead.' );
			return this.extractPoints( divisions );
	
		},
		extrude: function ( options ) {
	
			console.warn( 'THREE.Shape: .extrude() has been removed. Use ExtrudeGeometry() instead.' );
			return new ExtrudeGeometry( this, options );
	
		},
		makeGeometry: function ( options ) {
	
			console.warn( 'THREE.Shape: .makeGeometry() has been removed. Use ShapeGeometry() instead.' );
			return new ShapeGeometry( this, options );
	
		}
	
	} );
	
	Object.assign( Vector2.prototype, {
	
		fromAttribute: function ( attribute, index, offset ) {
	
			console.warn( 'THREE.Vector2: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );
	
		},
		distanceToManhattan: function ( v ) {
	
			console.warn( 'THREE.Vector2: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );
	
		},
		lengthManhattan: function () {
	
			console.warn( 'THREE.Vector2: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();
	
		}
	
	} );
	
	Object.assign( Vector3.prototype, {
	
		setEulerFromRotationMatrix: function () {
	
			console.error( 'THREE.Vector3: .setEulerFromRotationMatrix() has been removed. Use Euler.setFromRotationMatrix() instead.' );
	
		},
		setEulerFromQuaternion: function () {
	
			console.error( 'THREE.Vector3: .setEulerFromQuaternion() has been removed. Use Euler.setFromQuaternion() instead.' );
	
		},
		getPositionFromMatrix: function ( m ) {
	
			console.warn( 'THREE.Vector3: .getPositionFromMatrix() has been renamed to .setFromMatrixPosition().' );
			return this.setFromMatrixPosition( m );
	
		},
		getScaleFromMatrix: function ( m ) {
	
			console.warn( 'THREE.Vector3: .getScaleFromMatrix() has been renamed to .setFromMatrixScale().' );
			return this.setFromMatrixScale( m );
	
		},
		getColumnFromMatrix: function ( index, matrix ) {
	
			console.warn( 'THREE.Vector3: .getColumnFromMatrix() has been renamed to .setFromMatrixColumn().' );
			return this.setFromMatrixColumn( matrix, index );
	
		},
		applyProjection: function ( m ) {
	
			console.warn( 'THREE.Vector3: .applyProjection() has been removed. Use .applyMatrix4( m ) instead.' );
			return this.applyMatrix4( m );
	
		},
		fromAttribute: function ( attribute, index, offset ) {
	
			console.warn( 'THREE.Vector3: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );
	
		},
		distanceToManhattan: function ( v ) {
	
			console.warn( 'THREE.Vector3: .distanceToManhattan() has been renamed to .manhattanDistanceTo().' );
			return this.manhattanDistanceTo( v );
	
		},
		lengthManhattan: function () {
	
			console.warn( 'THREE.Vector3: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();
	
		}
	
	} );
	
	Object.assign( Vector4.prototype, {
	
		fromAttribute: function ( attribute, index, offset ) {
	
			console.warn( 'THREE.Vector4: .fromAttribute() has been renamed to .fromBufferAttribute().' );
			return this.fromBufferAttribute( attribute, index, offset );
	
		},
		lengthManhattan: function () {
	
			console.warn( 'THREE.Vector4: .lengthManhattan() has been renamed to .manhattanLength().' );
			return this.manhattanLength();
	
		}
	
	} );
	
	//
	
	Object.assign( Geometry.prototype, {
	
		computeTangents: function () {
	
			console.error( 'THREE.Geometry: .computeTangents() has been removed.' );
	
		},
		computeLineDistances: function () {
	
			console.error( 'THREE.Geometry: .computeLineDistances() has been removed. Use THREE.Line.computeLineDistances() instead.' );
	
		}
	
	} );
	
	Object.assign( Object3D.prototype, {
	
		getChildByName: function ( name ) {
	
			console.warn( 'THREE.Object3D: .getChildByName() has been renamed to .getObjectByName().' );
			return this.getObjectByName( name );
	
		},
		renderDepth: function () {
	
			console.warn( 'THREE.Object3D: .renderDepth has been removed. Use .renderOrder, instead.' );
	
		},
		translate: function ( distance, axis ) {
	
			console.warn( 'THREE.Object3D: .translate() has been removed. Use .translateOnAxis( axis, distance ) instead.' );
			return this.translateOnAxis( axis, distance );
	
		},
		getWorldRotation: function () {
	
			console.error( 'THREE.Object3D: .getWorldRotation() has been removed. Use THREE.Object3D.getWorldQuaternion( target ) instead.' );
	
		}
	
	} );
	
	Object.defineProperties( Object3D.prototype, {
	
		eulerOrder: {
			get: function () {
	
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				return this.rotation.order;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.Object3D: .eulerOrder is now .rotation.order.' );
				this.rotation.order = value;
	
			}
		},
		useQuaternion: {
			get: function () {
	
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
			},
			set: function () {
	
				console.warn( 'THREE.Object3D: .useQuaternion has been removed. The library now uses quaternions by default.' );
	
			}
		}
	
	} );
	
	Object.defineProperties( LOD.prototype, {
	
		objects: {
			get: function () {
	
				console.warn( 'THREE.LOD: .objects has been renamed to .levels.' );
				return this.levels;
	
			}
		}
	
	} );
	
	Object.defineProperty( Skeleton.prototype, 'useVertexTexture', {
	
		get: function () {
	
			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
	
		},
		set: function () {
	
			console.warn( 'THREE.Skeleton: useVertexTexture has been removed.' );
	
		}
	
	} );
	
	SkinnedMesh.prototype.initBones = function () {
	
		console.error( 'THREE.SkinnedMesh: initBones() has been removed.' );
	
	};
	
	Object.defineProperty( Curve.prototype, '__arcLengthDivisions', {
	
		get: function () {
	
			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			return this.arcLengthDivisions;
	
		},
		set: function ( value ) {
	
			console.warn( 'THREE.Curve: .__arcLengthDivisions is now .arcLengthDivisions.' );
			this.arcLengthDivisions = value;
	
		}
	
	} );
	
	//
	
	PerspectiveCamera.prototype.setLens = function ( focalLength, filmGauge ) {
	
		console.warn( "THREE.PerspectiveCamera.setLens is deprecated. " +
				"Use .setFocalLength and .filmGauge for a photographic setup." );
	
		if ( filmGauge !== undefined ) this.filmGauge = filmGauge;
		this.setFocalLength( focalLength );
	
	};
	
	//
	
	Object.defineProperties( Light.prototype, {
		onlyShadow: {
			set: function () {
	
				console.warn( 'THREE.Light: .onlyShadow has been removed.' );
	
			}
		},
		shadowCameraFov: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraFov is now .shadow.camera.fov.' );
				this.shadow.camera.fov = value;
	
			}
		},
		shadowCameraLeft: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraLeft is now .shadow.camera.left.' );
				this.shadow.camera.left = value;
	
			}
		},
		shadowCameraRight: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraRight is now .shadow.camera.right.' );
				this.shadow.camera.right = value;
	
			}
		},
		shadowCameraTop: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraTop is now .shadow.camera.top.' );
				this.shadow.camera.top = value;
	
			}
		},
		shadowCameraBottom: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraBottom is now .shadow.camera.bottom.' );
				this.shadow.camera.bottom = value;
	
			}
		},
		shadowCameraNear: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraNear is now .shadow.camera.near.' );
				this.shadow.camera.near = value;
	
			}
		},
		shadowCameraFar: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowCameraFar is now .shadow.camera.far.' );
				this.shadow.camera.far = value;
	
			}
		},
		shadowCameraVisible: {
			set: function () {
	
				console.warn( 'THREE.Light: .shadowCameraVisible has been removed. Use new THREE.CameraHelper( light.shadow.camera ) instead.' );
	
			}
		},
		shadowBias: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowBias is now .shadow.bias.' );
				this.shadow.bias = value;
	
			}
		},
		shadowDarkness: {
			set: function () {
	
				console.warn( 'THREE.Light: .shadowDarkness has been removed.' );
	
			}
		},
		shadowMapWidth: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowMapWidth is now .shadow.mapSize.width.' );
				this.shadow.mapSize.width = value;
	
			}
		},
		shadowMapHeight: {
			set: function ( value ) {
	
				console.warn( 'THREE.Light: .shadowMapHeight is now .shadow.mapSize.height.' );
				this.shadow.mapSize.height = value;
	
			}
		}
	} );
	
	//
	
	Object.defineProperties( BufferAttribute.prototype, {
	
		length: {
			get: function () {
	
				console.warn( 'THREE.BufferAttribute: .length has been deprecated. Use .count instead.' );
				return this.array.length;
	
			}
		},
		copyIndicesArray: function ( /* indices */ ) {
	
			console.error( 'THREE.BufferAttribute: .copyIndicesArray() has been removed.' );
	
		}
	
	} );
	
	Object.assign( BufferGeometry.prototype, {
	
		addIndex: function ( index ) {
	
			console.warn( 'THREE.BufferGeometry: .addIndex() has been renamed to .setIndex().' );
			this.setIndex( index );
	
		},
		addDrawCall: function ( start, count, indexOffset ) {
	
			if ( indexOffset !== undefined ) {
	
				console.warn( 'THREE.BufferGeometry: .addDrawCall() no longer supports indexOffset.' );
	
			}
			console.warn( 'THREE.BufferGeometry: .addDrawCall() is now .addGroup().' );
			this.addGroup( start, count );
	
		},
		clearDrawCalls: function () {
	
			console.warn( 'THREE.BufferGeometry: .clearDrawCalls() is now .clearGroups().' );
			this.clearGroups();
	
		},
		computeTangents: function () {
	
			console.warn( 'THREE.BufferGeometry: .computeTangents() has been removed.' );
	
		},
		computeOffsets: function () {
	
			console.warn( 'THREE.BufferGeometry: .computeOffsets() has been removed.' );
	
		}
	
	} );
	
	Object.defineProperties( BufferGeometry.prototype, {
	
		drawcalls: {
			get: function () {
	
				console.error( 'THREE.BufferGeometry: .drawcalls has been renamed to .groups.' );
				return this.groups;
	
			}
		},
		offsets: {
			get: function () {
	
				console.warn( 'THREE.BufferGeometry: .offsets has been renamed to .groups.' );
				return this.groups;
	
			}
		}
	
	} );
	
	//
	
	Object.assign( ExtrudeBufferGeometry.prototype, {
	
		getArrays: function () {
	
			console.error( 'THREE.ExtrudeBufferGeometry: .getArrays() has been removed.' );
	
		},
	
		addShapeList: function () {
	
			console.error( 'THREE.ExtrudeBufferGeometry: .addShapeList() has been removed.' );
	
		},
	
		addShape: function () {
	
			console.error( 'THREE.ExtrudeBufferGeometry: .addShape() has been removed.' );
	
		}
	
	} );
	
	//
	
	Object.defineProperties( Uniform.prototype, {
	
		dynamic: {
			set: function () {
	
				console.warn( 'THREE.Uniform: .dynamic has been removed. Use object.onBeforeRender() instead.' );
	
			}
		},
		onUpdate: {
			value: function () {
	
				console.warn( 'THREE.Uniform: .onUpdate() has been removed. Use object.onBeforeRender() instead.' );
				return this;
	
			}
		}
	
	} );
	
	//
	
	Object.defineProperties( Material.prototype, {
	
		wrapAround: {
			get: function () {
	
				console.warn( 'THREE.Material: .wrapAround has been removed.' );
	
			},
			set: function () {
	
				console.warn( 'THREE.Material: .wrapAround has been removed.' );
	
			}
		},
	
		overdraw: {
			get: function () {
	
				console.warn( 'THREE.Material: .overdraw has been removed.' );
	
			},
			set: function () {
	
				console.warn( 'THREE.Material: .overdraw has been removed.' );
	
			}
		},
	
		wrapRGB: {
			get: function () {
	
				console.warn( 'THREE.Material: .wrapRGB has been removed.' );
				return new Color();
	
			}
		},
	
		shading: {
			get: function () {
	
				console.error( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.' + this.type + ': .shading has been removed. Use the boolean .flatShading instead.' );
				this.flatShading = ( value === FlatShading );
	
			}
		}
	
	} );
	
	Object.defineProperties( MeshPhongMaterial.prototype, {
	
		metal: {
			get: function () {
	
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead.' );
				return false;
	
			},
			set: function () {
	
				console.warn( 'THREE.MeshPhongMaterial: .metal has been removed. Use THREE.MeshStandardMaterial instead' );
	
			}
		}
	
	} );
	
	Object.defineProperties( ShaderMaterial.prototype, {
	
		derivatives: {
			get: function () {
	
				console.warn( 'THREE.ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				return this.extensions.derivatives;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE. ShaderMaterial: .derivatives has been moved to .extensions.derivatives.' );
				this.extensions.derivatives = value;
	
			}
		}
	
	} );
	
	//
	
	Object.assign( WebGLRenderer.prototype, {
	
		clearTarget: function ( renderTarget, color, depth, stencil ) {
	
			console.warn( 'THREE.WebGLRenderer: .clearTarget() has been deprecated. Use .setRenderTarget() and .clear() instead.' );
			this.setRenderTarget( renderTarget );
			this.clear( color, depth, stencil );
	
		},
	
		animate: function ( callback ) {
	
			console.warn( 'THREE.WebGLRenderer: .animate() is now .setAnimationLoop().' );
			this.setAnimationLoop( callback );
	
		},
	
		getCurrentRenderTarget: function () {
	
			console.warn( 'THREE.WebGLRenderer: .getCurrentRenderTarget() is now .getRenderTarget().' );
			return this.getRenderTarget();
	
		},
	
		getMaxAnisotropy: function () {
	
			console.warn( 'THREE.WebGLRenderer: .getMaxAnisotropy() is now .capabilities.getMaxAnisotropy().' );
			return this.capabilities.getMaxAnisotropy();
	
		},
	
		getPrecision: function () {
	
			console.warn( 'THREE.WebGLRenderer: .getPrecision() is now .capabilities.precision.' );
			return this.capabilities.precision;
	
		},
	
		resetGLState: function () {
	
			console.warn( 'THREE.WebGLRenderer: .resetGLState() is now .state.reset().' );
			return this.state.reset();
	
		},
	
		supportsFloatTextures: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsFloatTextures() is now .extensions.get( \'OES_texture_float\' ).' );
			return this.extensions.get( 'OES_texture_float' );
	
		},
		supportsHalfFloatTextures: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsHalfFloatTextures() is now .extensions.get( \'OES_texture_half_float\' ).' );
			return this.extensions.get( 'OES_texture_half_float' );
	
		},
		supportsStandardDerivatives: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsStandardDerivatives() is now .extensions.get( \'OES_standard_derivatives\' ).' );
			return this.extensions.get( 'OES_standard_derivatives' );
	
		},
		supportsCompressedTextureS3TC: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTextureS3TC() is now .extensions.get( \'WEBGL_compressed_texture_s3tc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_s3tc' );
	
		},
		supportsCompressedTexturePVRTC: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsCompressedTexturePVRTC() is now .extensions.get( \'WEBGL_compressed_texture_pvrtc\' ).' );
			return this.extensions.get( 'WEBGL_compressed_texture_pvrtc' );
	
		},
		supportsBlendMinMax: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsBlendMinMax() is now .extensions.get( \'EXT_blend_minmax\' ).' );
			return this.extensions.get( 'EXT_blend_minmax' );
	
		},
		supportsVertexTextures: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsVertexTextures() is now .capabilities.vertexTextures.' );
			return this.capabilities.vertexTextures;
	
		},
		supportsInstancedArrays: function () {
	
			console.warn( 'THREE.WebGLRenderer: .supportsInstancedArrays() is now .extensions.get( \'ANGLE_instanced_arrays\' ).' );
			return this.extensions.get( 'ANGLE_instanced_arrays' );
	
		},
		enableScissorTest: function ( boolean ) {
	
			console.warn( 'THREE.WebGLRenderer: .enableScissorTest() is now .setScissorTest().' );
			this.setScissorTest( boolean );
	
		},
		initMaterial: function () {
	
			console.warn( 'THREE.WebGLRenderer: .initMaterial() has been removed.' );
	
		},
		addPrePlugin: function () {
	
			console.warn( 'THREE.WebGLRenderer: .addPrePlugin() has been removed.' );
	
		},
		addPostPlugin: function () {
	
			console.warn( 'THREE.WebGLRenderer: .addPostPlugin() has been removed.' );
	
		},
		updateShadowMap: function () {
	
			console.warn( 'THREE.WebGLRenderer: .updateShadowMap() has been removed.' );
	
		},
		setFaceCulling: function () {
	
			console.warn( 'THREE.WebGLRenderer: .setFaceCulling() has been removed.' );
	
		}
	
	} );
	
	Object.defineProperties( WebGLRenderer.prototype, {
	
		shadowMapEnabled: {
			get: function () {
	
				return this.shadowMap.enabled;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMapEnabled is now .shadowMap.enabled.' );
				this.shadowMap.enabled = value;
	
			}
		},
		shadowMapType: {
			get: function () {
	
				return this.shadowMap.type;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMapType is now .shadowMap.type.' );
				this.shadowMap.type = value;
	
			}
		},
		shadowMapCullFace: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;
	
			},
			set: function ( /* value */ ) {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMapCullFace has been removed. Set Material.shadowSide instead.' );
	
			}
		}
	} );
	
	Object.defineProperties( WebGLShadowMap.prototype, {
	
		cullFace: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
				return undefined;
	
			},
			set: function ( /* cullFace */ ) {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMap.cullFace has been removed. Set Material.shadowSide instead.' );
	
			}
		},
		renderReverseSided: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
				return undefined;
	
			},
			set: function () {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderReverseSided has been removed. Set Material.shadowSide instead.' );
	
			}
		},
		renderSingleSided: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
				return undefined;
	
			},
			set: function () {
	
				console.warn( 'THREE.WebGLRenderer: .shadowMap.renderSingleSided has been removed. Set Material.shadowSide instead.' );
	
			}
		}
	
	} );
	
	//
	
	Object.defineProperties( WebGLRenderTarget.prototype, {
	
		wrapS: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				return this.texture.wrapS;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .wrapS is now .texture.wrapS.' );
				this.texture.wrapS = value;
	
			}
		},
		wrapT: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				return this.texture.wrapT;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .wrapT is now .texture.wrapT.' );
				this.texture.wrapT = value;
	
			}
		},
		magFilter: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				return this.texture.magFilter;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .magFilter is now .texture.magFilter.' );
				this.texture.magFilter = value;
	
			}
		},
		minFilter: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				return this.texture.minFilter;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .minFilter is now .texture.minFilter.' );
				this.texture.minFilter = value;
	
			}
		},
		anisotropy: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				return this.texture.anisotropy;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .anisotropy is now .texture.anisotropy.' );
				this.texture.anisotropy = value;
	
			}
		},
		offset: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				return this.texture.offset;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .offset is now .texture.offset.' );
				this.texture.offset = value;
	
			}
		},
		repeat: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				return this.texture.repeat;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .repeat is now .texture.repeat.' );
				this.texture.repeat = value;
	
			}
		},
		format: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				return this.texture.format;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .format is now .texture.format.' );
				this.texture.format = value;
	
			}
		},
		type: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				return this.texture.type;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .type is now .texture.type.' );
				this.texture.type = value;
	
			}
		},
		generateMipmaps: {
			get: function () {
	
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				return this.texture.generateMipmaps;
	
			},
			set: function ( value ) {
	
				console.warn( 'THREE.WebGLRenderTarget: .generateMipmaps is now .texture.generateMipmaps.' );
				this.texture.generateMipmaps = value;
	
			}
		}
	
	} );
	
	//
	
	Object.defineProperties( WebVRManager.prototype, {
	
		standing: {
			set: function ( /* value */ ) {
	
				console.warn( 'THREE.WebVRManager: .standing has been removed.' );
	
			}
		},
		userHeight: {
			set: function ( /* value */ ) {
	
				console.warn( 'THREE.WebVRManager: .userHeight has been removed.' );
	
			}
		}
	
	} );
	
	//
	
	Audio.prototype.load = function ( file ) {
	
		console.warn( 'THREE.Audio: .load has been deprecated. Use THREE.AudioLoader instead.' );
		var scope = this;
		var audioLoader = new AudioLoader();
		audioLoader.load( file, function ( buffer ) {
	
			scope.setBuffer( buffer );
	
		} );
		return this;
	
	};
	
	AudioAnalyser.prototype.getData = function () {
	
		console.warn( 'THREE.AudioAnalyser: .getData() is now .getFrequencyData().' );
		return this.getFrequencyData();
	
	};
	
	//
	
	CubeCamera.prototype.updateCubeMap = function ( renderer, scene ) {
	
		console.warn( 'THREE.CubeCamera: .updateCubeMap() is now .update().' );
		return this.update( renderer, scene );
	
	};
	
	//
	
	var GeometryUtils = {
	
		merge: function ( geometry1, geometry2, materialIndexOffset ) {
	
			console.warn( 'THREE.GeometryUtils: .merge() has been moved to Geometry. Use geometry.merge( geometry2, matrix, materialIndexOffset ) instead.' );
			var matrix;
	
			if ( geometry2.isMesh ) {
	
				geometry2.matrixAutoUpdate && geometry2.updateMatrix();
	
				matrix = geometry2.matrix;
				geometry2 = geometry2.geometry;
	
			}
	
			geometry1.merge( geometry2, matrix, materialIndexOffset );
	
		},
	
		center: function ( geometry ) {
	
			console.warn( 'THREE.GeometryUtils: .center() has been moved to Geometry. Use geometry.center() instead.' );
			return geometry.center();
	
		}
	
	};
	
	ImageUtils.crossOrigin = undefined;
	
	ImageUtils.loadTexture = function ( url, mapping, onLoad, onError ) {
	
		console.warn( 'THREE.ImageUtils.loadTexture has been deprecated. Use THREE.TextureLoader() instead.' );
	
		var loader = new TextureLoader();
		loader.setCrossOrigin( this.crossOrigin );
	
		var texture = loader.load( url, onLoad, undefined, onError );
	
		if ( mapping ) texture.mapping = mapping;
	
		return texture;
	
	};
	
	ImageUtils.loadTextureCube = function ( urls, mapping, onLoad, onError ) {
	
		console.warn( 'THREE.ImageUtils.loadTextureCube has been deprecated. Use THREE.CubeTextureLoader() instead.' );
	
		var loader = new CubeTextureLoader();
		loader.setCrossOrigin( this.crossOrigin );
	
		var texture = loader.load( urls, onLoad, undefined, onError );
	
		if ( mapping ) texture.mapping = mapping;
	
		return texture;
	
	};
	
	ImageUtils.loadCompressedTexture = function () {
	
		console.error( 'THREE.ImageUtils.loadCompressedTexture has been removed. Use THREE.DDSLoader instead.' );
	
	};
	
	ImageUtils.loadCompressedTextureCube = function () {
	
		console.error( 'THREE.ImageUtils.loadCompressedTextureCube has been removed. Use THREE.DDSLoader instead.' );
	
	};
	
	//
	
	function Projector() {
	
		console.error( 'THREE.Projector has been moved to /examples/js/renderers/Projector.js.' );
	
		this.projectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .projectVector() is now vector.project().' );
			vector.project( camera );
	
		};
	
		this.unprojectVector = function ( vector, camera ) {
	
			console.warn( 'THREE.Projector: .unprojectVector() is now vector.unproject().' );
			vector.unproject( camera );
	
		};
	
		this.pickingRay = function () {
	
			console.error( 'THREE.Projector: .pickingRay() is now raycaster.setFromCamera().' );
	
		};
	
	}
	
	//
	
	function CanvasRenderer() {
	
		console.error( 'THREE.CanvasRenderer has been removed' );
	
	}
	
	//
	
	function JSONLoader() {
	
		console.error( 'THREE.JSONLoader has been removed.' );
	
	}
	
	//
	
	var SceneUtils = {
	
		createMultiMaterialObject: function ( /* geometry, materials */ ) {
	
			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );
	
		},
	
		detach: function ( /* child, parent, scene */ ) {
	
			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );
	
		},
	
		attach: function ( /* child, scene, parent */ ) {
	
			console.error( 'THREE.SceneUtils has been moved to /examples/js/utils/SceneUtils.js' );
	
		}
	
	};
	
	//
	
	function LensFlare() {
	
		console.error( 'THREE.LensFlare has been moved to /examples/js/objects/Lensflare.js' );
	
	}
	
	
	
	
	/***/ }),
	/* 2 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Binder, Model, Primitive,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Model = __webpack_require__(23);
	
	Primitive = (function() {
		Primitive.Node = Model.Node;
	
		Primitive.Group = Model.Group;
	
		Primitive.model = Primitive.Node;
	
		Primitive.defaults = null;
	
		Primitive.traits = null;
	
		Primitive.props = null;
	
		Primitive.finals = null;
	
		Primitive.freeform = false;
	
		function Primitive(node1, _context, helpers) {
			this.node = node1;
			this._context = _context;
			this._renderables = this._context.renderables;
			this._attributes = this._context.attributes;
			this._shaders = this._context.shaders;
			this._overlays = this._context.overlays;
			this._animator = this._context.animator;
			this._types = this._attributes.types;
			this.node.controller = this;
			this.node.on('added', (function(_this) {
				return function(event) {
					return _this._added();
				};
			})(this));
			this.node.on('removed', (function(_this) {
				return function(event) {
					return _this._removed();
				};
			})(this));
			this.node.on('change', (function(_this) {
				return function(event) {
					if (_this._root) {
						return _this.change(event.changed, event.touched);
					}
				};
			})(this));
			this.reconfigure();
			this._get = this.node.get.bind(this.node);
			this._helpers = helpers(this, this.node.traits);
			this._handlers = {
				inherit: {},
				listen: [],
				watch: [],
				compute: []
			};
			this._root = this._parent = null;
			this.init();
		}
	
		Primitive.prototype.is = function(trait) {
			return this.traits.hash[trait];
		};
	
		Primitive.prototype.init = function() {};
	
		Primitive.prototype.make = function() {};
	
		Primitive.prototype.made = function() {};
	
		Primitive.prototype.unmake = function(rebuild) {};
	
		Primitive.prototype.unmade = function() {};
	
		Primitive.prototype.change = function(changed, touched, init) {};
	
		Primitive.prototype.refresh = function() {
			return this.change({}, {}, true);
		};
	
		Primitive.prototype.rebuild = function() {
			if (this._root) {
				this._removed(true);
				return this._added();
			}
		};
	
		Primitive.prototype.reconfigure = function(config) {
			if (config != null) {
				this.node.configure(config, this._attributes);
			}
			this.traits = this.node.traits;
			return this.props = this.node.props;
		};
	
		Primitive.prototype._added = function() {
			var e, ref, ref1, ref2;
			this._parent = (ref = this.node.parent) != null ? ref.controller : void 0;
			this._root = (ref1 = this.node.root) != null ? ref1.controller : void 0;
			this.node.clock = (ref2 = this._inherit('clock')) != null ? ref2 : this._root;
			try {
				try {
					this.make();
					this.refresh();
					return this.made();
				} catch (error) {
					e = error;
					this.node.print('warn');
					console.error(e);
					throw e;
				}
			} catch (error) {
				e = error;
				try {
					return this._removed();
				} catch (error) {}
			}
		};
	
		Primitive.prototype._removed = function(rebuild) {
			if (rebuild == null) {
				rebuild = false;
			}
			this.unmake(rebuild);
			this._unlisten();
			this._unattach();
			this._uncompute();
			this._root = null;
			this._parent = null;
			return this.unmade(rebuild);
		};
	
		Primitive.prototype._listen = function(object, type, method, self) {
			var i, len, o;
			if (self == null) {
				self = this;
			}
			if (object instanceof Array) {
				for (i = 0, len = object.length; i < len; i++) {
					o = object[i];
					return this.__listen(o, type, method, self);
				}
			}
			return this.__listen(object, type, method, self);
		};
	
		Primitive.prototype.__listen = function(object, type, method, self) {
			var handler;
			if (self == null) {
				self = this;
			}
			if (typeof object === 'string') {
				object = this._inherit(object);
			}
			if (object != null) {
				handler = method.bind(self);
				handler.node = this.node;
				object.on(type, handler);
				this._handlers.listen.push([object, type, handler]);
			}
			return object;
		};
	
		Primitive.prototype._unlisten = function() {
			var handler, i, len, object, ref, ref1, type;
			if (!this._handlers.listen.length) {
				return;
			}
			ref = this._handlers.listen;
			for (i = 0, len = ref.length; i < len; i++) {
				ref1 = ref[i], object = ref1[0], type = ref1[1], handler = ref1[2];
				object.off(type, handler);
			}
			return this._handlers.listen = [];
		};
	
		Primitive.prototype._inherit = function(trait) {
			var cached, ref;
			cached = this._handlers.inherit[trait];
			if (cached !== void 0) {
				return cached;
			}
			return this._handlers.inherit[trait] = (ref = this._parent) != null ? ref._find(trait != null ? trait : null) : void 0;
		};
	
		Primitive.prototype._find = function(trait) {
			var ref;
			if (this.is(trait)) {
				return this;
			}
			return (ref = this._parent) != null ? ref._find(trait) : void 0;
		};
	
		Primitive.prototype._uninherit = function() {
			return this._handlers.inherit = {};
		};
	
		Primitive.prototype._attach = function(selector, trait, method, self, start, optional, multiple) {
			var filter, flatten, map, nodes, resolve;
			if (self == null) {
				self = this;
			}
			if (start == null) {
				start = this;
			}
			if (optional == null) {
				optional = false;
			}
			if (multiple == null) {
				multiple = false;
			}
			filter = function(node) {
				if ((node != null) && indexOf.call(node.traits, trait) >= 0) {
					return node;
				}
			};
			map = function(node) {
				return node != null ? node.controller : void 0;
			};
			flatten = function(list) {
				var i, len, out, sub;
				if (list == null) {
					return list;
				}
				out = [];
				for (i = 0, len = list.length; i < len; i++) {
					sub = list[i];
					if (sub instanceof Array) {
						out = out.concat(sub);
					} else {
						out.push(sub);
					}
				}
				return out;
			};
			resolve = (function(_this) {
				return function(selector) {
					var discard, match, node, nodes, parent, previous, selection, watcher;
					if (typeof selector === 'object') {
						node = selector;
						if (node != null ? node._up : void 0) {
							selector = multiple ? node._targets : [node[0]];
							return selector;
						}
						if (node instanceof Array) {
							selector = multiple ? flatten(node.map(resolve)) : resolve(node[0]);
							return selector;
						}
						if (node instanceof Model.Node) {
							return [node];
						}
					} else if (typeof selector === 'string' && selector[0] === '<') {
						discard = 0;
						if (match = selector.match(/^<([0-9])+$/)) {
							discard = +match[1] - 1;
						}
						if (selector.match(/^<+$/)) {
							discard = +selector.length - 1;
						}
						nodes = [];
						previous = start.node;
						while (previous) {
							parent = previous.parent;
							if (!parent) {
								break;
							}
							previous = parent.children[previous.index - 1];
							if (!(previous || nodes.length)) {
								previous = parent;
							}
							node = null;
							if (filter(previous)) {
								node = previous;
							}
							if ((node != null) && discard-- <= 0) {
								nodes.push(node);
							}
							if (!multiple && nodes.length) {
								return nodes;
							}
						}
						if (multiple && nodes.length) {
							return nodes;
						}
					} else if (typeof selector === 'string') {
						watcher = method.bind(self);
						_this._handlers.watch.push(watcher);
						selection = _this._root.watch(selector, watcher);
						if (!multiple) {
							if (filter(selection[0])) {
								node = selection[0];
							}
							if (node != null) {
								return [node];
							}
						} else {
							nodes = selection.filter(filter);
							if (nodes.length) {
								return nodes;
							}
						}
					}
					if (!optional) {
						console.warn(_this.node.toMarkup());
						throw new Error((_this.node.toString()) + " - Could not find " + trait + " `" + selector + "`");
					}
					if (multiple) {
						return [];
					} else {
						return null;
					}
				};
			})(this);
			nodes = flatten(resolve(selector));
			if (multiple) {
				if (nodes != null) {
					return nodes.map(map);
				} else {
					return null;
				}
			} else {
				if (nodes != null) {
					return map(nodes[0]);
				} else {
					return null;
				}
			}
		};
	
		Primitive.prototype._unattach = function() {
			var i, len, ref, watcher;
			if (!this._handlers.watch.length) {
				return;
			}
			ref = this._handlers.watch;
			for (i = 0, len = ref.length; i < len; i++) {
				watcher = ref[i];
				if (watcher != null) {
					watcher.unwatch();
				}
			}
			return this._handlers.watch = [];
		};
	
		Primitive.prototype._compute = function(key, expr) {
			this._handlers.compute.push(key);
			return this.node.bind(key, expr, true);
		};
	
		Primitive.prototype._uncompute = function() {
			var i, key, len, ref;
			if (!this._handlers.compute.length) {
				return;
			}
			ref = this._handlers.compute;
			for (i = 0, len = ref.length; i < len; i++) {
				key = ref[i];
				this.node.unbind(key, true);
			}
			return this._handlers.compute = [];
		};
	
		return Primitive;
	
	})();
	
	Binder = __webpack_require__(41);
	
	Binder.apply(Primitive.prototype);
	
	module.exports = Primitive;
	
	
	/***/ }),
	/* 3 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Source,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Source = __webpack_require__(20);
	
	Operator = (function(superClass) {
		extend(Operator, superClass);
	
		function Operator() {
			return Operator.__super__.constructor.apply(this, arguments);
		}
	
		Operator.traits = ['node', 'bind', 'operator', 'source', 'index'];
	
		Operator.prototype.indexShader = function(shader) {
			var ref;
			return (ref = this.bind.source) != null ? typeof ref.indexShader === "function" ? ref.indexShader(shader) : void 0 : void 0;
		};
	
		Operator.prototype.sourceShader = function(shader) {
			var ref;
			return (ref = this.bind.source) != null ? typeof ref.sourceShader === "function" ? ref.sourceShader(shader) : void 0 : void 0;
		};
	
		Operator.prototype.getDimensions = function() {
			return this.bind.source.getDimensions();
		};
	
		Operator.prototype.getFutureDimensions = function() {
			return this.bind.source.getFutureDimensions();
		};
	
		Operator.prototype.getActiveDimensions = function() {
			return this.bind.source.getActiveDimensions();
		};
	
		Operator.prototype.getIndexDimensions = function() {
			return this.bind.source.getIndexDimensions();
		};
	
		Operator.prototype.init = function() {
			return this.sourceSpec = [
				{
					to: 'operator.source',
					trait: 'source',
					optional: true
				}
			];
		};
	
		Operator.prototype.make = function() {
			Operator.__super__.make.apply(this, arguments);
			return this._helpers.bind.make(this.sourceSpec);
		};
	
		Operator.prototype.made = function() {
			this.resize();
			return Operator.__super__.made.apply(this, arguments);
		};
	
		Operator.prototype.unmake = function() {
			return this._helpers.bind.unmake();
		};
	
		Operator.prototype.resize = function(rebuild) {
			return this.trigger({
				type: 'source.resize'
			});
		};
	
		return Operator;
	
	})(Source);
	
	module.exports = Operator;
	
	
	/***/ }),
	/* 4 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Primitive,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Parent = (function(superClass) {
		extend(Parent, superClass);
	
		function Parent() {
			return Parent.__super__.constructor.apply(this, arguments);
		}
	
		Parent.model = Primitive.Group;
	
		Parent.traits = ['node'];
	
		return Parent;
	
	})(Primitive);
	
	module.exports = Parent;
	
	
	/***/ }),
	/* 5 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Renderable, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Renderable = __webpack_require__(10);
	
	Util = __webpack_require__(0);
	
	Base = (function(superClass) {
		extend(Base, superClass);
	
		function Base(renderer, shaders, options) {
			var ref;
			Base.__super__.constructor.call(this, renderer, shaders, options);
			this.zUnits = (ref = options.zUnits) != null ? ref : 0;
		}
	
		Base.prototype.raw = function() {
			var i, len, object, ref;
			ref = this.renders;
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				this._raw(object);
			}
			return null;
		};
	
		Base.prototype.depth = function(write, test) {
			var i, len, object, ref;
			ref = this.renders;
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				this._depth(object, write, test);
			}
			return null;
		};
	
		Base.prototype.polygonOffset = function(factor, units) {
			var i, len, object, ref;
			ref = this.renders;
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				this._polygonOffset(object, factor, units);
			}
			return null;
		};
	
		Base.prototype.show = function(transparent, blending, order) {
			var i, len, object, ref, results;
			ref = this.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this._show(object, transparent, blending, order));
			}
			return results;
		};
	
		Base.prototype.hide = function() {
			var i, len, object, ref;
			ref = this.renders;
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				this._hide(object);
			}
			return null;
		};
	
		Base.prototype._injectPreamble = function(preamble, code) {
			var program;
			program = preamble + "\n" + code;
			if (code.match(/#extension/)) {
				return this._hoist(program);
			} else {
				return program;
			}
		};
	
		Base.prototype._hoist = function(code) {
			var i, len, line, lines, out;
			lines = code.split("\n");
			out = [];
			for (i = 0, len = lines.length; i < len; i++) {
				line = lines[i];
				if (line.match(/^\s*#extension/)) {
					out.unshift(line);
				} else {
					out.push(line);
				}
			}
			return out.join("\n");
		};
	
		Base.prototype._material = function(options) {
			var fragmentPrefix, i, key, len, material, precision, ref, shaderOptions, vertexPrefix;
			precision = this.renderer.capabilities.precision;
			vertexPrefix = "    precision " + precision + " float;\n    precision " + precision + " int;\nuniform mat4 modelMatrix;\nuniform mat4 modelViewMatrix;\nuniform mat4 projectionMatrix;\nuniform mat4 viewMatrix;\nuniform mat3 normalMatrix;\nuniform vec3 cameraPosition;";
			fragmentPrefix = "    precision " + precision + " float;\n    precision " + precision + " int;\nuniform mat4 viewMatrix;\nuniform vec3 cameraPosition;";
			shaderOptions = {};
			Object.assign(shaderOptions, options);
			delete shaderOptions.attributes;
			delete shaderOptions.varyings;
			delete shaderOptions.inspect;
			delete shaderOptions.vertexGraph;
			delete shaderOptions.fragmentGraph;
			material = new THREE.RawShaderMaterial(shaderOptions);
			ref = ['vertexGraph', 'fragmentGraph', 'inspect'];
			for (i = 0, len = ref.length; i < len; i++) {
				key = ref[i];
				material[key] = options[key];
			}
			material.vertexShader = this._injectPreamble(vertexPrefix, material.vertexShader);
			material.fragmentShader = this._injectPreamble(fragmentPrefix, material.fragmentShader);
			return material;
		};
	
		Base.prototype._raw = function(object) {
			object.rotationAutoUpdate = false;
			object.frustumCulled = false;
			object.matrixAutoUpdate = false;
			return object.material.defaultAttributeValues = void 0;
		};
	
		Base.prototype._depth = function(object, write, test) {
			var m;
			m = object.material;
			m.depthWrite = write;
			return m.depthTest = test;
		};
	
		Base.prototype._polygonOffset = function(object, factor, units) {
			var enabled, m;
			units -= this.zUnits;
			enabled = units !== 0;
			m = object.material;
			m.polygonOffset = enabled;
			if (enabled) {
				m.polygonOffsetFactor = factor;
				return m.polygonOffsetUnits = units;
			}
		};
	
		Base.prototype._show = function(object, transparent, blending, order) {
			var m;
			transparent = true;
			m = object.material;
			object.renderOrder = -order;
			object.visible = true;
			m.transparent = transparent;
			m.blending = blending;
			return null;
		};
	
		Base.prototype._hide = function(object) {
			return object.visible = false;
		};
	
		Base.prototype._vertexColor = function(color, mask) {
			var v;
			if (!(color || mask)) {
				return;
			}
			v = this.shaders.shader();
			if (color) {
				v.require(color);
				v.pipe('mesh.vertex.color', this.uniforms);
			}
			if (mask) {
				v.require(mask);
				v.pipe('mesh.vertex.mask', this.uniforms);
			}
			return v;
		};
	
		Base.prototype._vertexPosition = function(position, material, map, channels, stpq) {
			var defs, v;
			v = this.shaders.shader();
			if (map || (material && material !== true)) {
				defs = {};
				if (channels > 0 || stpq) {
					defs.POSITION_MAP = '';
				}
				if (channels > 0) {
					defs[['POSITION_U', 'POSITION_UV', 'POSITION_UVW', 'POSITION_UVWO'][channels - 1]] = '';
				}
				if (stpq) {
					defs.POSITION_STPQ = '';
				}
			}
			v.require(position);
			return v.pipe('mesh.vertex.position', this.uniforms, defs);
		};
	
		Base.prototype._fragmentColor = function(hasStyle, material, color, mask, map, channels, stpq, combine, linear) {
			var defs, f, gamma, join;
			f = this.shaders.shader();
			join = false;
			gamma = false;
			defs = {};
			if (channels > 0) {
				defs[['POSITION_U', 'POSITION_UV', 'POSITION_UVW', 'POSITION_UVWO'][channels - 1]] = '';
			}
			if (stpq) {
				defs.POSITION_STPQ = '';
			}
			if (hasStyle) {
				f.pipe('style.color', this.uniforms);
				join = true;
				if (color || map || material) {
					if (!linear || color) {
						f.pipe('mesh.gamma.in');
					}
					gamma = true;
				}
			}
			if (color) {
				f.isolate();
				f.pipe('mesh.fragment.color', this.uniforms);
				if (!linear || join) {
					f.pipe('mesh.gamma.in');
				}
				f.end();
				if (join) {
					f.pipe(Util.GLSL.binaryOperator('vec4', '*'));
				}
				if (linear && join) {
					f.pipe('mesh.gamma.out');
				}
				join = true;
				gamma = true;
			}
			if (map) {
				if (!join && combine) {
					f.pipe(Util.GLSL.constant('vec4', 'vec4(1.0)'));
				}
				f.isolate();
				f.require(map);
				f.pipe('mesh.fragment.map', this.uniforms, defs);
				if (!linear) {
					f.pipe('mesh.gamma.in');
				}
				f.end();
				if (combine) {
					f.pipe(combine);
				} else {
					if (join) {
						f.pipe(Util.GLSL.binaryOperator('vec4', '*'));
					}
				}
				join = true;
				gamma = true;
			}
			if (material) {
				if (!join) {
					f.pipe(Util.GLSL.constant('vec4', 'vec4(1.0)'));
				}
				if (material === true) {
					f.pipe('mesh.fragment.shaded', this.uniforms);
				} else {
					f.require(material);
					f.pipe('mesh.fragment.material', this.uniforms, defs);
				}
				gamma = true;
			}
			if (gamma && !linear) {
				f.pipe('mesh.gamma.out');
			}
			if (mask) {
				f.pipe('mesh.fragment.mask', this.uniforms);
				if (join) {
					f.pipe(Util.GLSL.binaryOperator('vec4', '*'));
				}
			}
			return f;
		};
	
		return Base;
	
	})(Renderable);
	
	module.exports = Base;
	
	
	/***/ }),
	/* 6 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Graph = __webpack_require__(33);
	
	exports.Node = __webpack_require__(205);
	
	exports.Outlet = __webpack_require__(61);
	
	exports.IN = exports.Graph.IN;
	
	exports.OUT = exports.Graph.OUT;
	
	
	/***/ }),
	/* 7 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Transform, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transform = __webpack_require__(13);
	
	View = (function(superClass) {
		extend(View, superClass);
	
		function View() {
			return View.__super__.constructor.apply(this, arguments);
		}
	
		View.traits = ['node', 'object', 'visible', 'view', 'vertex'];
	
		View.prototype.make = function() {
			return this._helpers.visible.make();
		};
	
		View.prototype.unmake = function() {
			return this._helpers.visible.unmake();
		};
	
		View.prototype.axis = function(dimension) {
			return this.props.range[dimension - 1];
		};
	
		return View;
	
	})(Transform);
	
	module.exports = View;
	
	
	/***/ }),
	/* 8 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Geometry = __webpack_require__(54);
	
	exports.ArrowGeometry = __webpack_require__(181);
	
	exports.FaceGeometry = __webpack_require__(182);
	
	exports.LineGeometry = __webpack_require__(183);
	
	exports.ScreenGeometry = __webpack_require__(184);
	
	exports.SpriteGeometry = __webpack_require__(185);
	
	exports.StripGeometry = __webpack_require__(186);
	
	exports.SurfaceGeometry = __webpack_require__(55);
	
	
	/***/ }),
	/* 9 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a duplex stream is just a stream that is both readable and writable.
	// Since JS doesn't have multiple prototypal inheritance, this class
	// prototypally inherits from Readable, and then parasitically from
	// Writable.
	
	
	
	/*<replacement>*/
	
	var pna = __webpack_require__(18);
	/*</replacement>*/
	
	/*<replacement>*/
	var objectKeys = Object.keys || function (obj) {
		var keys = [];
		for (var key in obj) {
			keys.push(key);
		}return keys;
	};
	/*</replacement>*/
	
	module.exports = Duplex;
	
	/*<replacement>*/
	var util = __webpack_require__(16);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	var Readable = __webpack_require__(42);
	var Writable = __webpack_require__(28);
	
	util.inherits(Duplex, Readable);
	
	{
		// avoid scope creep, the keys array can then be collected
		var keys = objectKeys(Writable.prototype);
		for (var v = 0; v < keys.length; v++) {
			var method = keys[v];
			if (!Duplex.prototype[method]) Duplex.prototype[method] = Writable.prototype[method];
		}
	}
	
	function Duplex(options) {
		if (!(this instanceof Duplex)) return new Duplex(options);
	
		Readable.call(this, options);
		Writable.call(this, options);
	
		if (options && options.readable === false) this.readable = false;
	
		if (options && options.writable === false) this.writable = false;
	
		this.allowHalfOpen = true;
		if (options && options.allowHalfOpen === false) this.allowHalfOpen = false;
	
		this.once('end', onend);
	}
	
	Object.defineProperty(Duplex.prototype, 'writableHighWaterMark', {
		// making it explicit this property is not enumerable
		// because otherwise some prototype manipulation in
		// userland will fail
		enumerable: false,
		get: function () {
			return this._writableState.highWaterMark;
		}
	});
	
	// the no-half-open enforcer
	function onend() {
		// if we allow half-open state, or if the writable side ended,
		// then we're ok.
		if (this.allowHalfOpen || this._writableState.ended) return;
	
		// no more data can be written.
		// But allow more writes to happen in this tick.
		pna.nextTick(onEndNT, this);
	}
	
	function onEndNT(self) {
		self.end();
	}
	
	Object.defineProperty(Duplex.prototype, 'destroyed', {
		get: function () {
			if (this._readableState === undefined || this._writableState === undefined) {
				return false;
			}
			return this._readableState.destroyed && this._writableState.destroyed;
		},
		set: function (value) {
			// we ignore the value if the stream
			// has not been initialized yet
			if (this._readableState === undefined || this._writableState === undefined) {
				return;
			}
	
			// backward compatibility, the user is explicitly
			// managing destroyed
			this._readableState.destroyed = value;
			this._writableState.destroyed = value;
		}
	});
	
	Duplex.prototype._destroy = function (err, cb) {
		this.push(null);
		this.end();
	
		pna.nextTick(cb, err);
	};
	
	/***/ }),
	/* 10 */
	/***/ (function(module, exports) {
	
	var Renderable;
	
	Renderable = (function() {
		function Renderable(renderer, shaders) {
			this.renderer = renderer;
			this.shaders = shaders;
			this.gl = this.renderer.context;
			if (this.uniforms == null) {
				this.uniforms = {};
			}
		}
	
		Renderable.prototype.dispose = function() {
			return this.uniforms = null;
		};
	
		Renderable.prototype._adopt = function(uniforms) {
			var key, value;
			for (key in uniforms) {
				value = uniforms[key];
				this.uniforms[key] = value;
			}
		};
	
		Renderable.prototype._set = function(uniforms) {
			var key, value;
			for (key in uniforms) {
				value = uniforms[key];
				if (this.uniforms[key] != null) {
					this.uniforms[key].value = value;
				}
			}
		};
	
		return Renderable;
	
	})();
	
	module.exports = Renderable;
	
	
	/***/ }),
	/* 11 */
	/***/ (function(module, exports) {
	
	if (typeof Object.create === 'function') {
		// implementation from standard node.js 'util' module
		module.exports = function inherits(ctor, superCtor) {
			if (superCtor) {
				ctor.super_ = superCtor
				ctor.prototype = Object.create(superCtor.prototype, {
					constructor: {
						value: ctor,
						enumerable: false,
						writable: true,
						configurable: true
					}
				})
			}
		};
	} else {
		// old school shim for old browsers
		module.exports = function inherits(ctor, superCtor) {
			if (superCtor) {
				ctor.super_ = superCtor
				var TempCtor = function () {}
				TempCtor.prototype = superCtor.prototype
				ctor.prototype = new TempCtor()
				ctor.prototype.constructor = ctor
			}
		}
	}
	
	
	/***/ }),
	/* 12 */
	/***/ (function(module, exports) {
	
	var g;
	
	// This works in non-strict mode
	g = (function() {
		return this;
	})();
	
	try {
		// This works if eval is allowed (see CSP)
		g = g || new Function("return this")();
	} catch (e) {
		// This works if the window reference is available
		if (typeof window === "object") g = window;
	}
	
	// g can still be undefined, but nothing to do about it...
	// We return undefined, instead of nothing here, so it's
	// easier to handle this case. if(!global) { ...}
	
	module.exports = g;
	
	
	/***/ }),
	/* 13 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Transform,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Transform = (function(superClass) {
		extend(Transform, superClass);
	
		function Transform() {
			return Transform.__super__.constructor.apply(this, arguments);
		}
	
		Transform.traits = ['node', 'vertex', 'fragment'];
	
		Transform.prototype.vertex = function(shader, pass) {
			var ref, ref1;
			return (ref = (ref1 = this._inherit('vertex')) != null ? ref1.vertex(shader, pass) : void 0) != null ? ref : shader;
		};
	
		Transform.prototype.fragment = function(shader, pass) {
			var ref, ref1;
			return (ref = (ref1 = this._inherit('fragment')) != null ? ref1.fragment(shader, pass) : void 0) != null ? ref : shader;
		};
	
		return Transform;
	
	})(Parent);
	
	module.exports = Transform;
	
	
	/***/ }),
	/* 14 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ClipGeometry, Geometry, THREE, debug, tick,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Geometry = __webpack_require__(54);
	
	debug = false;
	
	tick = function() {
		var now;
		now = +(new Date);
		return function(label) {
			var delta;
			delta = +new Date() - now;
			console.log(label, delta + " ms");
			return delta;
		};
	};
	
	ClipGeometry = (function(superClass) {
		extend(ClipGeometry, superClass);
	
		function ClipGeometry() {
			return ClipGeometry.__super__.constructor.apply(this, arguments);
		}
	
		ClipGeometry.prototype._clipUniforms = function() {
			this.geometryClip = new THREE.Vector4(1e10, 1e10, 1e10, 1e10);
			this.geometryResolution = new THREE.Vector4;
			this.mapSize = new THREE.Vector4;
			if (this.uniforms == null) {
				this.uniforms = {};
			}
			this.uniforms.geometryClip = {
				type: 'v4',
				value: this.geometryClip
			};
			this.uniforms.geometryResolution = {
				type: 'v4',
				value: this.geometryResolution
			};
			return this.uniforms.mapSize = {
				type: 'v4',
				value: this.mapSize
			};
		};
	
		ClipGeometry.prototype._clipGeometry = function(width, height, depth, items) {
			var c, r;
			c = function(x) {
				return Math.max(0, x - 1);
			};
			r = function(x) {
				return 1 / Math.max(1, x - 1);
			};
			this.geometryClip.set(c(width), c(height), c(depth), c(items));
			return this.geometryResolution.set(r(width), r(height), r(depth), r(items));
		};
	
		ClipGeometry.prototype._clipMap = function(mapWidth, mapHeight, mapDepth, mapItems) {
			return this.mapSize.set(mapWidth, mapHeight, mapDepth, mapItems);
		};
	
		ClipGeometry.prototype._clipOffsets = function(factor, width, height, depth, items, _width, _height, _depth, _items) {
			var dims, elements, maxs;
			dims = [depth, height, width, items];
			maxs = [_depth, _height, _width, _items];
			elements = this._reduce(dims, maxs);
			return this._offsets([
				{
					start: 0,
					count: elements * factor
				}
			]);
		};
	
		return ClipGeometry;
	
	})(Geometry);
	
	module.exports = ClipGeometry;
	
	
	/***/ }),
	/* 15 */
	/***/ (function(module, exports) {
	
	// shim for using process in browser
	var process = module.exports = {};
	
	// cached from whatever global is present so that test runners that stub it
	// don't break things.  But we need to wrap it in a try catch in case it is
	// wrapped in strict mode code which doesn't define any globals.  It's inside a
	// function because try/catches deoptimize in certain engines.
	
	var cachedSetTimeout;
	var cachedClearTimeout;
	
	function defaultSetTimout() {
			throw new Error('setTimeout has not been defined');
	}
	function defaultClearTimeout () {
			throw new Error('clearTimeout has not been defined');
	}
	(function () {
			try {
					if (typeof setTimeout === 'function') {
							cachedSetTimeout = setTimeout;
					} else {
							cachedSetTimeout = defaultSetTimout;
					}
			} catch (e) {
					cachedSetTimeout = defaultSetTimout;
			}
			try {
					if (typeof clearTimeout === 'function') {
							cachedClearTimeout = clearTimeout;
					} else {
							cachedClearTimeout = defaultClearTimeout;
					}
			} catch (e) {
					cachedClearTimeout = defaultClearTimeout;
			}
	} ())
	function runTimeout(fun) {
			if (cachedSetTimeout === setTimeout) {
					//normal enviroments in sane situations
					return setTimeout(fun, 0);
			}
			// if setTimeout wasn't available but was latter defined
			if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
					cachedSetTimeout = setTimeout;
					return setTimeout(fun, 0);
			}
			try {
					// when when somebody has screwed with setTimeout but no I.E. maddness
					return cachedSetTimeout(fun, 0);
			} catch(e){
					try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
							return cachedSetTimeout.call(null, fun, 0);
					} catch(e){
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
							return cachedSetTimeout.call(this, fun, 0);
					}
			}
	
	
	}
	function runClearTimeout(marker) {
			if (cachedClearTimeout === clearTimeout) {
					//normal enviroments in sane situations
					return clearTimeout(marker);
			}
			// if clearTimeout wasn't available but was latter defined
			if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
					cachedClearTimeout = clearTimeout;
					return clearTimeout(marker);
			}
			try {
					// when when somebody has screwed with setTimeout but no I.E. maddness
					return cachedClearTimeout(marker);
			} catch (e){
					try {
							// When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
							return cachedClearTimeout.call(null, marker);
					} catch (e){
							// same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
							// Some versions of I.E. have different rules for clearTimeout vs setTimeout
							return cachedClearTimeout.call(this, marker);
					}
			}
	
	
	
	}
	var queue = [];
	var draining = false;
	var currentQueue;
	var queueIndex = -1;
	
	function cleanUpNextTick() {
			if (!draining || !currentQueue) {
					return;
			}
			draining = false;
			if (currentQueue.length) {
					queue = currentQueue.concat(queue);
			} else {
					queueIndex = -1;
			}
			if (queue.length) {
					drainQueue();
			}
	}
	
	function drainQueue() {
			if (draining) {
					return;
			}
			var timeout = runTimeout(cleanUpNextTick);
			draining = true;
	
			var len = queue.length;
			while(len) {
					currentQueue = queue;
					queue = [];
					while (++queueIndex < len) {
							if (currentQueue) {
									currentQueue[queueIndex].run();
							}
					}
					queueIndex = -1;
					len = queue.length;
			}
			currentQueue = null;
			draining = false;
			runClearTimeout(timeout);
	}
	
	process.nextTick = function (fun) {
			var args = new Array(arguments.length - 1);
			if (arguments.length > 1) {
					for (var i = 1; i < arguments.length; i++) {
							args[i - 1] = arguments[i];
					}
			}
			queue.push(new Item(fun, args));
			if (queue.length === 1 && !draining) {
					runTimeout(drainQueue);
			}
	};
	
	// v8 likes predictible objects
	function Item(fun, array) {
			this.fun = fun;
			this.array = array;
	}
	Item.prototype.run = function () {
			this.fun.apply(null, this.array);
	};
	process.title = 'browser';
	process.browser = true;
	process.env = {};
	process.argv = [];
	process.version = ''; // empty string to avoid regexp issues
	process.versions = {};
	
	function noop() {}
	
	process.on = noop;
	process.addListener = noop;
	process.once = noop;
	process.off = noop;
	process.removeListener = noop;
	process.removeAllListeners = noop;
	process.emit = noop;
	process.prependListener = noop;
	process.prependOnceListener = noop;
	
	process.listeners = function (name) { return [] }
	
	process.binding = function (name) {
			throw new Error('process.binding is not supported');
	};
	
	process.cwd = function () { return '/' };
	process.chdir = function (dir) {
			throw new Error('process.chdir is not supported');
	};
	process.umask = function() { return 0; };
	
	
	/***/ }),
	/* 16 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(Buffer) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// NOTE: These type checking functions intentionally don't use `instanceof`
	// because it is fragile and can be easily faked with `Object.create()`.
	
	function isArray(arg) {
		if (Array.isArray) {
			return Array.isArray(arg);
		}
		return objectToString(arg) === '[object Array]';
	}
	exports.isArray = isArray;
	
	function isBoolean(arg) {
		return typeof arg === 'boolean';
	}
	exports.isBoolean = isBoolean;
	
	function isNull(arg) {
		return arg === null;
	}
	exports.isNull = isNull;
	
	function isNullOrUndefined(arg) {
		return arg == null;
	}
	exports.isNullOrUndefined = isNullOrUndefined;
	
	function isNumber(arg) {
		return typeof arg === 'number';
	}
	exports.isNumber = isNumber;
	
	function isString(arg) {
		return typeof arg === 'string';
	}
	exports.isString = isString;
	
	function isSymbol(arg) {
		return typeof arg === 'symbol';
	}
	exports.isSymbol = isSymbol;
	
	function isUndefined(arg) {
		return arg === void 0;
	}
	exports.isUndefined = isUndefined;
	
	function isRegExp(re) {
		return objectToString(re) === '[object RegExp]';
	}
	exports.isRegExp = isRegExp;
	
	function isObject(arg) {
		return typeof arg === 'object' && arg !== null;
	}
	exports.isObject = isObject;
	
	function isDate(d) {
		return objectToString(d) === '[object Date]';
	}
	exports.isDate = isDate;
	
	function isError(e) {
		return (objectToString(e) === '[object Error]' || e instanceof Error);
	}
	exports.isError = isError;
	
	function isFunction(arg) {
		return typeof arg === 'function';
	}
	exports.isFunction = isFunction;
	
	function isPrimitive(arg) {
		return arg === null ||
					 typeof arg === 'boolean' ||
					 typeof arg === 'number' ||
					 typeof arg === 'string' ||
					 typeof arg === 'symbol' ||  // ES6 symbol
					 typeof arg === 'undefined';
	}
	exports.isPrimitive = isPrimitive;
	
	exports.isBuffer = Buffer.isBuffer;
	
	function objectToString(o) {
		return Object.prototype.toString.call(o);
	}
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(27).Buffer))
	
	/***/ }),
	/* 17 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Graph, Layout, OutletError, Program, debug;
	
	Graph = __webpack_require__(6);
	
	Program = __webpack_require__(34).Program;
	
	Layout = __webpack_require__(34).Layout;
	
	debug = false;
	
	Block = (function() {
		Block.previous = function(outlet) {
			var ref;
			return (ref = outlet.input) != null ? ref.node.owner : void 0;
		};
	
		function Block() {
			var ref;
			if (this.namespace == null) {
				this.namespace = Program.entry();
			}
			this.node = new Graph.Node(this, (ref = typeof this.makeOutlets === "function" ? this.makeOutlets() : void 0) != null ? ref : {});
		}
	
		Block.prototype.refresh = function() {
			var ref;
			return this.node.setOutlets((ref = typeof this.makeOutlets === "function" ? this.makeOutlets() : void 0) != null ? ref : {});
		};
	
		Block.prototype.clone = function() {
			return new Block;
		};
	
		Block.prototype.compile = function(language, namespace) {
			var program;
			program = new Program(language, namespace != null ? namespace : Program.entry(), this.node.graph);
			this.call(program, 0);
			return program.assemble();
		};
	
		Block.prototype.link = function(language, namespace) {
			var layout, module;
			module = this.compile(language, namespace);
			layout = new Layout(language, this.node.graph);
			this._include(module, layout, 0);
			this["export"](layout, 0);
			return layout.link(module);
		};
	
		Block.prototype.call = function(program, depth) {};
	
		Block.prototype.callback = function(layout, depth, name, external, outlet) {};
	
		Block.prototype["export"] = function(layout, depth) {};
	
		Block.prototype._info = function(suffix) {
			var ref, ref1, string;
			string = (ref = (ref1 = this.node.owner.snippet) != null ? ref1._name : void 0) != null ? ref : this.node.owner.namespace;
			if (suffix != null) {
				return string += '.' + suffix;
			}
		};
	
		Block.prototype._outlet = function(def, props) {
			var outlet;
			outlet = Graph.Outlet.make(def, props);
			outlet.meta.def = def;
			return outlet;
		};
	
		Block.prototype._call = function(module, program, depth) {
			return program.call(this.node, module, depth);
		};
	
		Block.prototype._require = function(module, program) {
			return program.require(this.node, module);
		};
	
		Block.prototype._inputs = function(module, program, depth) {
			var arg, i, len, outlet, ref, ref1, results;
			ref = module.main.signature;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				arg = ref[i];
				outlet = this.node.get(arg.name);
				results.push((ref1 = Block.previous(outlet)) != null ? ref1.call(program, depth + 1) : void 0);
			}
			return results;
		};
	
		Block.prototype._callback = function(module, layout, depth, name, external, outlet) {
			return layout.callback(this.node, module, depth, name, external, outlet);
		};
	
		Block.prototype._include = function(module, layout, depth) {
			return layout.include(this.node, module, depth);
		};
	
		Block.prototype._link = function(module, layout, depth) {
			var block, ext, i, key, len, orig, outlet, parent, ref, ref1, ref2, results;
			debug && console.log('block::_link', this.toString(), module.namespace);
			ref = module.symbols;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				key = ref[i];
				ext = module.externals[key];
				outlet = this.node.get(ext.name);
				if (!outlet) {
					throw new OutletError("External not found on " + (this._info(ext.name)));
				}
				if (outlet.meta.child != null) {
					continue;
				}
				ref1 = [outlet, outlet, null], orig = ref1[0], parent = ref1[1], block = ref1[2];
				while (!block && parent) {
					ref2 = [outlet.meta.parent, parent], parent = ref2[0], outlet = ref2[1];
				}
				block = Block.previous(outlet);
				if (!block) {
					throw new OutletError("Missing connection on " + (this._info(ext.name)));
				}
				debug && console.log('callback -> ', this.toString(), ext.name, outlet);
				block.callback(layout, depth + 1, key, ext, outlet.input);
				results.push(block != null ? block["export"](layout, depth + 1) : void 0);
			}
			return results;
		};
	
		Block.prototype._trace = function(module, layout, depth) {
			var arg, i, len, outlet, ref, ref1, results;
			debug && console.log('block::_trace', this.toString(), module.namespace);
			ref = module.main.signature;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				arg = ref[i];
				outlet = this.node.get(arg.name);
				results.push((ref1 = Block.previous(outlet)) != null ? ref1["export"](layout, depth + 1) : void 0);
			}
			return results;
		};
	
		return Block;
	
	})();
	
	OutletError = function(message) {
		var e;
		e = new Error(message);
		e.name = 'OutletError';
		return e;
	};
	
	OutletError.prototype = new Error;
	
	module.exports = Block;
	
	
	/***/ }),
	/* 18 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	/* WEBPACK VAR INJECTION */(function(process) {
	
	if (typeof process === 'undefined' ||
			!process.version ||
			process.version.indexOf('v0.') === 0 ||
			process.version.indexOf('v1.') === 0 && process.version.indexOf('v1.8.') !== 0) {
		module.exports = { nextTick: nextTick };
	} else {
		module.exports = process
	}
	
	function nextTick(fn, arg1, arg2, arg3) {
		if (typeof fn !== 'function') {
			throw new TypeError('"callback" argument must be a function');
		}
		var len = arguments.length;
		var args, i;
		switch (len) {
		case 0:
		case 1:
			return process.nextTick(fn);
		case 2:
			return process.nextTick(function afterTickOne() {
				fn.call(null, arg1);
			});
		case 3:
			return process.nextTick(function afterTickTwo() {
				fn.call(null, arg1, arg2);
			});
		case 4:
			return process.nextTick(function afterTickThree() {
				fn.call(null, arg1, arg2, arg3);
			});
		default:
			args = new Array(len - 1);
			i = 0;
			while (i < args.length) {
				args[i++] = arguments[i];
			}
			return process.nextTick(function afterTick() {
				fn.apply(null, args);
			});
		}
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))
	
	/***/ }),
	/* 19 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, Data, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Data = __webpack_require__(132);
	
	Util = __webpack_require__(0);
	
	Buffer = (function(superClass) {
		extend(Buffer, superClass);
	
		function Buffer() {
			return Buffer.__super__.constructor.apply(this, arguments);
		}
	
		Buffer.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'texture'];
	
		Buffer.prototype.init = function() {
			this.bufferSlack = 0;
			this.bufferFrames = 0;
			this.bufferTime = 0;
			this.bufferDelta = 0;
			this.bufferClock = 0;
			this.bufferStep = 0;
			return Buffer.__super__.init.apply(this, arguments);
		};
	
		Buffer.prototype.make = function() {
			Buffer.__super__.make.apply(this, arguments);
			this.clockParent = this._inherit('clock');
			return this.latchParent = this._inherit('latch');
		};
	
		Buffer.prototype.unmake = function() {
			return Buffer.__super__.unmake.apply(this, arguments);
		};
	
		Buffer.prototype.rawBuffer = function() {
			return this.buffer;
		};
	
		Buffer.prototype.emitter = function() {
			var channels, items, ref;
			ref = this.props, channels = ref.channels, items = ref.items;
			return Buffer.__super__.emitter.call(this, channels, items);
		};
	
		Buffer.prototype.change = function(changed, touched, init) {
			var fps;
			if (changed['buffer.fps'] || init) {
				fps = this.props.fps;
				return this.bufferSlack = fps ? .5 / fps : 0;
			}
		};
	
		Buffer.prototype.syncBuffer = function(callback) {
			var abort, delta, filled, fps, frame, frames, hurry, i, j, limit, live, observe, realtime, ref, ref1, results, slack, speed, step, stop, time;
			if (!this.buffer) {
				return;
			}
			ref = this.props, live = ref.live, fps = ref.fps, hurry = ref.hurry, limit = ref.limit, realtime = ref.realtime, observe = ref.observe;
			filled = this.buffer.getFilled();
			if (filled && !live) {
				return;
			}
			if (this.latchParent && !this.latchParent.isDirty) {
				return;
			}
			time = this.clockParent.getTime();
			if (fps != null) {
				slack = this.bufferSlack;
				speed = time.step / time.delta;
				delta = realtime ? time.delta : time.step;
				frame = 1 / fps;
				step = realtime && observe ? speed * frame : frame;
				if (Math.abs(time.time - this.bufferTime) > time.step * limit) {
					this.bufferTime = time.time;
					this.bufferClock = time.clock;
				}
				this.bufferSlack = Math.min(limit / fps, slack + delta);
				this.bufferDelta = delta;
				this.bufferStep = step;
				frames = Math.min(hurry, Math.floor(slack * fps));
				if (!filled) {
					frames = Math.max(1, frames);
				}
				stop = false;
				abort = function() {
					return stop = true;
				};
				results = [];
				for (i = j = 0, ref1 = frames; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
					this.bufferTime += delta;
					this.bufferClock += step;
					if (stop) {
						break;
					}
					callback(abort, this.bufferFrames++, i, frames);
					results.push(this.bufferSlack -= frame);
				}
				return results;
			} else {
				this.bufferTime = time.time;
				this.bufferDelta = time.delta;
				this.bufferClock = time.clock;
				this.bufferStep = time.step;
				return callback((function() {}), this.bufferFrames++, 0, 1);
			}
		};
	
		Buffer.prototype.alignShader = function(dims, shader) {
			var aligned, magFilter, minFilter, mixed, nearest, ref;
			ref = this.props, minFilter = ref.minFilter, magFilter = ref.magFilter, aligned = ref.aligned;
			mixed = (dims.items > 1 && dims.width > 1) || (dims.height > 1 && dims.depth > 1);
			if (aligned || !mixed) {
				return;
			}
			nearest = minFilter === this.node.attributes['texture.minFilter']["enum"].nearest && magFilter === this.node.attributes['texture.magFilter']["enum"].nearest;
			if (!nearest) {
				console.warn((this.node.toString()) + " - Cannot use linear min/magFilter with 3D/4D sampling");
			}
			return shader.pipe('map.xyzw.align');
		};
	
		return Buffer;
	
	})(Data);
	
	module.exports = Buffer;
	
	
	/***/ }),
	/* 20 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Source, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Source = (function(superClass) {
		extend(Source, superClass);
	
		function Source() {
			return Source.__super__.constructor.apply(this, arguments);
		}
	
		Source.traits = ['node', 'source', 'index'];
	
		Source.prototype.made = function() {
			return this.trigger({
				type: 'source.rebuild'
			});
		};
	
		Source.prototype.indexShader = function(shader) {
			return shader.pipe(Util.GLSL.identity('vec4'));
		};
	
		Source.prototype.sourceShader = function(shader) {
			return shader.pipe(Util.GLSL.identity('vec4'));
		};
	
		Source.prototype.getDimensions = function() {
			return {
				items: 1,
				width: 1,
				height: 1,
				depth: 1
			};
		};
	
		Source.prototype.getActiveDimensions = function() {
			return this.getDimensions();
		};
	
		Source.prototype.getIndexDimensions = function() {
			return this.getActiveDimensions();
		};
	
		Source.prototype.getFutureDimensions = function() {
			return this.getActiveDimensions();
		};
	
		return Source;
	
	})(Primitive);
	
	module.exports = Source;
	
	
	/***/ }),
	/* 21 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, Util, Voxel,
		bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Buffer = __webpack_require__(19);
	
	Util = __webpack_require__(0);
	
	Voxel = (function(superClass) {
		extend(Voxel, superClass);
	
		function Voxel() {
			this.update = bind(this.update, this);
			return Voxel.__super__.constructor.apply(this, arguments);
		}
	
		Voxel.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'texture', 'voxel', 'raw'];
	
		Voxel.prototype.init = function() {
			this.buffer = this.spec = null;
			this.space = {
				width: 0,
				height: 0,
				depth: 0
			};
			this.used = {
				width: 0,
				height: 0,
				depth: 0
			};
			this.storage = 'voxelBuffer';
			this.passthrough = function(emit, x, y, z) {
				return emit(x, y, z, 0);
			};
			return Voxel.__super__.init.apply(this, arguments);
		};
	
		Voxel.prototype.sourceShader = function(shader) {
			var dims;
			dims = this.getDimensions();
			this.alignShader(dims, shader);
			return this.buffer.shader(shader);
		};
	
		Voxel.prototype.getDimensions = function() {
			return {
				items: this.items,
				width: this.space.width,
				height: this.space.height,
				depth: this.space.depth
			};
		};
	
		Voxel.prototype.getActiveDimensions = function() {
			return {
				items: this.items,
				width: this.used.width,
				height: this.used.height,
				depth: this.used.depth * this.buffer.getFilled()
			};
		};
	
		Voxel.prototype.getRawDimensions = function() {
			return this.getDimensions();
		};
	
		Voxel.prototype.make = function() {
			var channels, data, depth, dims, height, items, magFilter, minFilter, ref, ref1, ref2, reserveX, reserveY, reserveZ, space, type, width;
			Voxel.__super__.make.apply(this, arguments);
			minFilter = (ref = this.minFilter) != null ? ref : this.props.minFilter;
			magFilter = (ref1 = this.magFilter) != null ? ref1 : this.props.magFilter;
			type = (ref2 = this.type) != null ? ref2 : this.props.type;
			width = this.props.width;
			height = this.props.height;
			depth = this.props.depth;
			reserveX = this.props.bufferWidth;
			reserveY = this.props.bufferHeight;
			reserveZ = this.props.bufferDepth;
			channels = this.props.channels;
			items = this.props.items;
			dims = this.spec = {
				channels: channels,
				items: items,
				width: width,
				height: height,
				depth: depth
			};
			this.items = dims.items;
			this.channels = dims.channels;
			data = this.props.data;
			dims = Util.Data.getDimensions(data, dims);
			space = this.space;
			space.width = Math.max(reserveX, dims.width || 1);
			space.height = Math.max(reserveY, dims.height || 1);
			space.depth = Math.max(reserveZ, dims.depth || 1);
			return this.buffer = this._renderables.make(this.storage, {
				width: space.width,
				height: space.height,
				depth: space.depth,
				channels: channels,
				items: items,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
		};
	
		Voxel.prototype.unmake = function() {
			Voxel.__super__.unmake.apply(this, arguments);
			if (this.buffer) {
				this.buffer.dispose();
				return this.buffer = this.spec = null;
			}
		};
	
		Voxel.prototype.change = function(changed, touched, init) {
			var depth, height, width;
			if (touched['texture'] || changed['buffer.channels'] || changed['buffer.items'] || changed['voxel.bufferWidth'] || changed['voxel.bufferHeight'] || changed['voxel.bufferDepth']) {
				return this.rebuild();
			}
			if (!this.buffer) {
				return;
			}
			if (changed['voxel.width']) {
				this.spec.width = width = this.props.width;
				if (width > this.space.width) {
					return this.rebuild();
				}
			}
			if (changed['voxel.height']) {
				this.spec.height = height = this.props.height;
				if (height > this.space.height) {
					return this.rebuild();
				}
			}
			if (changed['voxel.depth']) {
				this.spec.depth = depth = this.props.depth;
				if (depth > this.space.depth) {
					return this.rebuild();
				}
			}
			if (changed['data.map'] || changed['data.data'] || changed['data.resolve'] || changed['data.expr'] || init) {
				return this.buffer.setCallback(this.emitter());
			}
		};
	
		Voxel.prototype.callback = function(callback) {
			if (callback.length <= 4) {
				return callback;
			} else {
				return (function(_this) {
					return function(emit, i, j, k) {
						return callback(emit, i, j, k, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		Voxel.prototype.update = function() {
			var d, data, depth, filled, h, height, ref, ref1, space, used, w, width;
			if (!this.buffer) {
				return;
			}
			ref = this.props, data = ref.data, width = ref.width, height = ref.height, depth = ref.depth;
			ref1 = this, space = ref1.space, used = ref1.used;
			w = used.width;
			h = used.height;
			d = used.depth;
			filled = this.buffer.getFilled();
			this.syncBuffer((function(_this) {
				return function(abort) {
					var _h, _w, base, dims, length;
					if (data != null) {
						dims = Util.Data.getDimensions(data, _this.spec);
						if (dims.width > space.width || dims.height > space.height || dims.depth > space.depth) {
							abort();
							return _this.rebuild();
						}
						used.width = dims.width;
						used.height = dims.height;
						used.depth = dims.depth;
						_this.buffer.setActive(used.width, used.height, used.depth);
						if (typeof (base = _this.buffer.callback).rebind === "function") {
							base.rebind(data);
						}
						return _this.buffer.update();
					} else {
						width = _this.spec.width || 1;
						height = _this.spec.height || 1;
						depth = _this.spec.depth || 1;
						_this.buffer.setActive(width, height, depth);
						length = _this.buffer.update();
						used.width = _w = width;
						used.height = _h = height;
						used.depth = Math.min(depth, Math.ceil(length / _w / _h));
						if (used.depth === 1) {
							used.height = Math.min(height, Math.ceil(length / _w));
							if (used.height === 1) {
								return used.width = Math.min(width, length);
							}
						}
					}
				};
			})(this));
			if (used.width !== w || used.height !== h || used.depth !== d || filled !== this.buffer.getFilled()) {
				return this.trigger({
					type: 'source.resize'
				});
			}
		};
	
		return Voxel;
	
	})(Buffer);
	
	module.exports = Voxel;
	
	
	/***/ }),
	/* 22 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, DataBuffer, DataTexture, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Buffer = __webpack_require__(30);
	
	DataTexture = __webpack_require__(31);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * Data buffer on the GPU
	 * - Stores samples (1-n) x items (1-n) x channels (1-4)
	 * - Provides generic sampler shader
	 * - Provides generic copy/write handler
	 * => specialized into Array/Matrix/VoxelBuffer
	 */
	
	DataBuffer = (function(superClass) {
		extend(DataBuffer, superClass);
	
		function DataBuffer(renderer, shaders, options) {
			this.width = options.width || 1;
			this.height = options.height || 1;
			this.depth = options.depth || 1;
			if (this.samples == null) {
				this.samples = this.width * this.height * this.depth;
			}
			DataBuffer.__super__.constructor.call(this, renderer, shaders, options);
			this.build(options);
		}
	
		DataBuffer.prototype.shader = function(shader, indices) {
			if (indices == null) {
				indices = 4;
			}
			if (this.items > 1 || this.depth > 1) {
				if (indices !== 4) {
					shader.pipe(Util.GLSL.extendVec(indices, 4));
				}
				shader.pipe('map.xyzw.texture', this.uniforms);
			} else {
				if (indices !== 2) {
					shader.pipe(Util.GLSL.truncateVec(indices, 2));
				}
			}
			shader.pipe("map.2d.data", this.uniforms);
			shader.pipe("sample.2d", this.uniforms);
			if (this.channels < 4) {
				shader.pipe(Util.GLSL.swizzleVec4(['0000', 'x000', 'xw00', 'xyz0'][this.channels]));
			}
			return shader;
		};
	
		DataBuffer.prototype.build = function(options) {
			this.data = new Float32Array(this.samples * this.channels * this.items);
			this.texture = new DataTexture(this.renderer, this.items * this.width, this.height * this.depth, this.channels, options);
			this.filled = 0;
			this.used = 0;
			this._adopt(this.texture.uniforms);
			this._adopt({
				dataPointer: {
					type: 'v2',
					value: new THREE.Vector2()
				},
				textureItems: {
					type: 'f',
					value: this.items
				},
				textureHeight: {
					type: 'f',
					value: this.height
				}
			});
			this.dataPointer = this.uniforms.dataPointer.value;
			return this.streamer = this.generate(this.data);
		};
	
		DataBuffer.prototype.dispose = function() {
			this.data = null;
			this.texture.dispose();
			return DataBuffer.__super__.dispose.apply(this, arguments);
		};
	
		DataBuffer.prototype.getFilled = function() {
			return this.filled;
		};
	
		DataBuffer.prototype.setCallback = function(callback1) {
			this.callback = callback1;
			return this.filled = 0;
		};
	
		DataBuffer.prototype.copy = function(data) {
			var d, i, j, n, ref;
			n = Math.min(data.length, this.samples * this.channels * this.items);
			d = this.data;
			for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
				d[i] = data[i];
			}
			return this.write(Math.ceil(n / this.channels / this.items));
		};
	
		DataBuffer.prototype.write = function(n) {
			var height, width;
			if (n == null) {
				n = this.samples;
			}
			height = n / this.width;
			n *= this.items;
			width = height < 1 ? n : this.items * this.width;
			height = Math.ceil(height);
			this.texture.write(this.data, 0, 0, width, height);
			this.dataPointer.set(.5, .5);
			this.filled = 1;
			return this.used = n;
		};
	
		DataBuffer.prototype.through = function(callback, target) {
			var consume, done, dst, emit, i, pipe, ref, src;
			ref = src = this.streamer, consume = ref.consume, done = ref.done;
			emit = (dst = target.streamer).emit;
			i = 0;
			pipe = function() {
				return consume(function(x, y, z, w) {
					return callback(emit, x, y, z, w, i);
				});
			};
			pipe = Util.Data.repeatCall(pipe, this.items);
			return (function(_this) {
				return function() {
					var limit;
					src.reset();
					dst.reset();
					limit = _this.used;
					i = 0;
					while (!done() && i < limit) {
						pipe();
						i++;
					}
					return src.count();
				};
			})(this);
		};
	
		return DataBuffer;
	
	})(Buffer);
	
	module.exports = DataBuffer;
	
	
	/***/ }),
	/* 23 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Attributes = __webpack_require__(70);
	
	exports.Group = __webpack_require__(71);
	
	exports.Guard = __webpack_require__(81);
	
	exports.Model = __webpack_require__(82);
	
	exports.Node = __webpack_require__(40);
	
	
	/***/ }),
	/* 24 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	
	var R = typeof Reflect === 'object' ? Reflect : null
	var ReflectApply = R && typeof R.apply === 'function'
		? R.apply
		: function ReflectApply(target, receiver, args) {
			return Function.prototype.apply.call(target, receiver, args);
		}
	
	var ReflectOwnKeys
	if (R && typeof R.ownKeys === 'function') {
		ReflectOwnKeys = R.ownKeys
	} else if (Object.getOwnPropertySymbols) {
		ReflectOwnKeys = function ReflectOwnKeys(target) {
			return Object.getOwnPropertyNames(target)
				.concat(Object.getOwnPropertySymbols(target));
		};
	} else {
		ReflectOwnKeys = function ReflectOwnKeys(target) {
			return Object.getOwnPropertyNames(target);
		};
	}
	
	function ProcessEmitWarning(warning) {
		if (console && console.warn) console.warn(warning);
	}
	
	var NumberIsNaN = Number.isNaN || function NumberIsNaN(value) {
		return value !== value;
	}
	
	function EventEmitter() {
		EventEmitter.init.call(this);
	}
	module.exports = EventEmitter;
	module.exports.once = once;
	
	// Backwards-compat with node 0.10.x
	EventEmitter.EventEmitter = EventEmitter;
	
	EventEmitter.prototype._events = undefined;
	EventEmitter.prototype._eventsCount = 0;
	EventEmitter.prototype._maxListeners = undefined;
	
	// By default EventEmitters will print a warning if more than 10 listeners are
	// added to it. This is a useful default which helps finding memory leaks.
	var defaultMaxListeners = 10;
	
	function checkListener(listener) {
		if (typeof listener !== 'function') {
			throw new TypeError('The "listener" argument must be of type Function. Received type ' + typeof listener);
		}
	}
	
	Object.defineProperty(EventEmitter, 'defaultMaxListeners', {
		enumerable: true,
		get: function() {
			return defaultMaxListeners;
		},
		set: function(arg) {
			if (typeof arg !== 'number' || arg < 0 || NumberIsNaN(arg)) {
				throw new RangeError('The value of "defaultMaxListeners" is out of range. It must be a non-negative number. Received ' + arg + '.');
			}
			defaultMaxListeners = arg;
		}
	});
	
	EventEmitter.init = function() {
	
		if (this._events === undefined ||
				this._events === Object.getPrototypeOf(this)._events) {
			this._events = Object.create(null);
			this._eventsCount = 0;
		}
	
		this._maxListeners = this._maxListeners || undefined;
	};
	
	// Obviously not all Emitters should be limited to 10. This function allows
	// that to be increased. Set to zero for unlimited.
	EventEmitter.prototype.setMaxListeners = function setMaxListeners(n) {
		if (typeof n !== 'number' || n < 0 || NumberIsNaN(n)) {
			throw new RangeError('The value of "n" is out of range. It must be a non-negative number. Received ' + n + '.');
		}
		this._maxListeners = n;
		return this;
	};
	
	function _getMaxListeners(that) {
		if (that._maxListeners === undefined)
			return EventEmitter.defaultMaxListeners;
		return that._maxListeners;
	}
	
	EventEmitter.prototype.getMaxListeners = function getMaxListeners() {
		return _getMaxListeners(this);
	};
	
	EventEmitter.prototype.emit = function emit(type) {
		var args = [];
		for (var i = 1; i < arguments.length; i++) args.push(arguments[i]);
		var doError = (type === 'error');
	
		var events = this._events;
		if (events !== undefined)
			doError = (doError && events.error === undefined);
		else if (!doError)
			return false;
	
		// If there is no 'error' event listener then throw.
		if (doError) {
			var er;
			if (args.length > 0)
				er = args[0];
			if (er instanceof Error) {
				// Note: The comments on the `throw` lines are intentional, they show
				// up in Node's output if this results in an unhandled exception.
				throw er; // Unhandled 'error' event
			}
			// At least give some kind of context to the user
			var err = new Error('Unhandled error.' + (er ? ' (' + er.message + ')' : ''));
			err.context = er;
			throw err; // Unhandled 'error' event
		}
	
		var handler = events[type];
	
		if (handler === undefined)
			return false;
	
		if (typeof handler === 'function') {
			ReflectApply(handler, this, args);
		} else {
			var len = handler.length;
			var listeners = arrayClone(handler, len);
			for (var i = 0; i < len; ++i)
				ReflectApply(listeners[i], this, args);
		}
	
		return true;
	};
	
	function _addListener(target, type, listener, prepend) {
		var m;
		var events;
		var existing;
	
		checkListener(listener);
	
		events = target._events;
		if (events === undefined) {
			events = target._events = Object.create(null);
			target._eventsCount = 0;
		} else {
			// To avoid recursion in the case that type === "newListener"! Before
			// adding it to the listeners, first emit "newListener".
			if (events.newListener !== undefined) {
				target.emit('newListener', type,
										listener.listener ? listener.listener : listener);
	
				// Re-assign `events` because a newListener handler could have caused the
				// this._events to be assigned to a new object
				events = target._events;
			}
			existing = events[type];
		}
	
		if (existing === undefined) {
			// Optimize the case of one listener. Don't need the extra array object.
			existing = events[type] = listener;
			++target._eventsCount;
		} else {
			if (typeof existing === 'function') {
				// Adding the second element, need to change to array.
				existing = events[type] =
					prepend ? [listener, existing] : [existing, listener];
				// If we've already got an array, just append.
			} else if (prepend) {
				existing.unshift(listener);
			} else {
				existing.push(listener);
			}
	
			// Check for listener leak
			m = _getMaxListeners(target);
			if (m > 0 && existing.length > m && !existing.warned) {
				existing.warned = true;
				// No error code for this since it is a Warning
				// eslint-disable-next-line no-restricted-syntax
				var w = new Error('Possible EventEmitter memory leak detected. ' +
														existing.length + ' ' + String(type) + ' listeners ' +
														'added. Use emitter.setMaxListeners() to ' +
														'increase limit');
				w.name = 'MaxListenersExceededWarning';
				w.emitter = target;
				w.type = type;
				w.count = existing.length;
				ProcessEmitWarning(w);
			}
		}
	
		return target;
	}
	
	EventEmitter.prototype.addListener = function addListener(type, listener) {
		return _addListener(this, type, listener, false);
	};
	
	EventEmitter.prototype.on = EventEmitter.prototype.addListener;
	
	EventEmitter.prototype.prependListener =
			function prependListener(type, listener) {
				return _addListener(this, type, listener, true);
			};
	
	function onceWrapper() {
		if (!this.fired) {
			this.target.removeListener(this.type, this.wrapFn);
			this.fired = true;
			if (arguments.length === 0)
				return this.listener.call(this.target);
			return this.listener.apply(this.target, arguments);
		}
	}
	
	function _onceWrap(target, type, listener) {
		var state = { fired: false, wrapFn: undefined, target: target, type: type, listener: listener };
		var wrapped = onceWrapper.bind(state);
		wrapped.listener = listener;
		state.wrapFn = wrapped;
		return wrapped;
	}
	
	EventEmitter.prototype.once = function once(type, listener) {
		checkListener(listener);
		this.on(type, _onceWrap(this, type, listener));
		return this;
	};
	
	EventEmitter.prototype.prependOnceListener =
			function prependOnceListener(type, listener) {
				checkListener(listener);
				this.prependListener(type, _onceWrap(this, type, listener));
				return this;
			};
	
	// Emits a 'removeListener' event if and only if the listener was removed.
	EventEmitter.prototype.removeListener =
			function removeListener(type, listener) {
				var list, events, position, i, originalListener;
	
				checkListener(listener);
	
				events = this._events;
				if (events === undefined)
					return this;
	
				list = events[type];
				if (list === undefined)
					return this;
	
				if (list === listener || list.listener === listener) {
					if (--this._eventsCount === 0)
						this._events = Object.create(null);
					else {
						delete events[type];
						if (events.removeListener)
							this.emit('removeListener', type, list.listener || listener);
					}
				} else if (typeof list !== 'function') {
					position = -1;
	
					for (i = list.length - 1; i >= 0; i--) {
						if (list[i] === listener || list[i].listener === listener) {
							originalListener = list[i].listener;
							position = i;
							break;
						}
					}
	
					if (position < 0)
						return this;
	
					if (position === 0)
						list.shift();
					else {
						spliceOne(list, position);
					}
	
					if (list.length === 1)
						events[type] = list[0];
	
					if (events.removeListener !== undefined)
						this.emit('removeListener', type, originalListener || listener);
				}
	
				return this;
			};
	
	EventEmitter.prototype.off = EventEmitter.prototype.removeListener;
	
	EventEmitter.prototype.removeAllListeners =
			function removeAllListeners(type) {
				var listeners, events, i;
	
				events = this._events;
				if (events === undefined)
					return this;
	
				// not listening for removeListener, no need to emit
				if (events.removeListener === undefined) {
					if (arguments.length === 0) {
						this._events = Object.create(null);
						this._eventsCount = 0;
					} else if (events[type] !== undefined) {
						if (--this._eventsCount === 0)
							this._events = Object.create(null);
						else
							delete events[type];
					}
					return this;
				}
	
				// emit removeListener for all listeners on all events
				if (arguments.length === 0) {
					var keys = Object.keys(events);
					var key;
					for (i = 0; i < keys.length; ++i) {
						key = keys[i];
						if (key === 'removeListener') continue;
						this.removeAllListeners(key);
					}
					this.removeAllListeners('removeListener');
					this._events = Object.create(null);
					this._eventsCount = 0;
					return this;
				}
	
				listeners = events[type];
	
				if (typeof listeners === 'function') {
					this.removeListener(type, listeners);
				} else if (listeners !== undefined) {
					// LIFO order
					for (i = listeners.length - 1; i >= 0; i--) {
						this.removeListener(type, listeners[i]);
					}
				}
	
				return this;
			};
	
	function _listeners(target, type, unwrap) {
		var events = target._events;
	
		if (events === undefined)
			return [];
	
		var evlistener = events[type];
		if (evlistener === undefined)
			return [];
	
		if (typeof evlistener === 'function')
			return unwrap ? [evlistener.listener || evlistener] : [evlistener];
	
		return unwrap ?
			unwrapListeners(evlistener) : arrayClone(evlistener, evlistener.length);
	}
	
	EventEmitter.prototype.listeners = function listeners(type) {
		return _listeners(this, type, true);
	};
	
	EventEmitter.prototype.rawListeners = function rawListeners(type) {
		return _listeners(this, type, false);
	};
	
	EventEmitter.listenerCount = function(emitter, type) {
		if (typeof emitter.listenerCount === 'function') {
			return emitter.listenerCount(type);
		} else {
			return listenerCount.call(emitter, type);
		}
	};
	
	EventEmitter.prototype.listenerCount = listenerCount;
	function listenerCount(type) {
		var events = this._events;
	
		if (events !== undefined) {
			var evlistener = events[type];
	
			if (typeof evlistener === 'function') {
				return 1;
			} else if (evlistener !== undefined) {
				return evlistener.length;
			}
		}
	
		return 0;
	}
	
	EventEmitter.prototype.eventNames = function eventNames() {
		return this._eventsCount > 0 ? ReflectOwnKeys(this._events) : [];
	};
	
	function arrayClone(arr, n) {
		var copy = new Array(n);
		for (var i = 0; i < n; ++i)
			copy[i] = arr[i];
		return copy;
	}
	
	function spliceOne(list, index) {
		for (; index + 1 < list.length; index++)
			list[index] = list[index + 1];
		list.pop();
	}
	
	function unwrapListeners(arr) {
		var ret = new Array(arr.length);
		for (var i = 0; i < ret.length; ++i) {
			ret[i] = arr[i].listener || arr[i];
		}
		return ret;
	}
	
	function once(emitter, name) {
		return new Promise(function (resolve, reject) {
			function errorListener(err) {
				emitter.removeListener(name, resolver);
				reject(err);
			}
	
			function resolver() {
				if (typeof emitter.removeListener === 'function') {
					emitter.removeListener('error', errorListener);
				}
				resolve([].slice.call(arguments));
			};
	
			eventTargetAgnosticAddListener(emitter, name, resolver, { once: true });
			if (name !== 'error') {
				addErrorHandlerIfEventEmitter(emitter, errorListener, { once: true });
			}
		});
	}
	
	function addErrorHandlerIfEventEmitter(emitter, handler, flags) {
		if (typeof emitter.on === 'function') {
			eventTargetAgnosticAddListener(emitter, 'error', handler, flags);
		}
	}
	
	function eventTargetAgnosticAddListener(emitter, name, listener, flags) {
		if (typeof emitter.on === 'function') {
			if (flags.once) {
				emitter.once(name, listener);
			} else {
				emitter.on(name, listener);
			}
		} else if (typeof emitter.addEventListener === 'function') {
			// EventTarget does not have `error` event semantics like Node
			// EventEmitters, we do not listen for `error` events here.
			emitter.addEventListener(name, function wrapListener(arg) {
				// IE does not have builtin `{ once: true }` support so we
				// have to do it manually.
				if (flags.once) {
					emitter.removeEventListener(name, wrapListener);
				}
				listener(arg);
			});
		} else {
			throw new TypeError('The "emitter" argument must be of type EventEmitter. Received type ' + typeof emitter);
		}
	}
	
	
	/***/ }),
	/* 25 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports = module.exports = __webpack_require__(42);
	exports.Stream = exports;
	exports.Readable = exports;
	exports.Writable = __webpack_require__(28);
	exports.Duplex = __webpack_require__(9);
	exports.Transform = __webpack_require__(46);
	exports.PassThrough = __webpack_require__(98);
	
	
	/***/ }),
	/* 26 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* eslint-disable node/no-deprecated-api */
	var buffer = __webpack_require__(27)
	var Buffer = buffer.Buffer
	
	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
		for (var key in src) {
			dst[key] = src[key]
		}
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		module.exports = buffer
	} else {
		// Copy properties from require('buffer')
		copyProps(buffer, exports)
		exports.Buffer = SafeBuffer
	}
	
	function SafeBuffer (arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length)
	}
	
	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer)
	
	SafeBuffer.from = function (arg, encodingOrOffset, length) {
		if (typeof arg === 'number') {
			throw new TypeError('Argument must not be a number')
		}
		return Buffer(arg, encodingOrOffset, length)
	}
	
	SafeBuffer.alloc = function (size, fill, encoding) {
		if (typeof size !== 'number') {
			throw new TypeError('Argument must be a number')
		}
		var buf = Buffer(size)
		if (fill !== undefined) {
			if (typeof encoding === 'string') {
				buf.fill(fill, encoding)
			} else {
				buf.fill(fill)
			}
		} else {
			buf.fill(0)
		}
		return buf
	}
	
	SafeBuffer.allocUnsafe = function (size) {
		if (typeof size !== 'number') {
			throw new TypeError('Argument must be a number')
		}
		return Buffer(size)
	}
	
	SafeBuffer.allocUnsafeSlow = function (size) {
		if (typeof size !== 'number') {
			throw new TypeError('Argument must be a number')
		}
		return buffer.SlowBuffer(size)
	}
	
	
	/***/ }),
	/* 27 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	/* WEBPACK VAR INJECTION */(function(global) {/*!
	 * The buffer module from node.js, for the browser.
	 *
	 * @author   Feross Aboukhadijeh <http://feross.org>
	 * @license  MIT
	 */
	/* eslint-disable no-proto */
	
	
	
	var base64 = __webpack_require__(88)
	var ieee754 = __webpack_require__(89)
	var isArray = __webpack_require__(90)
	
	exports.Buffer = Buffer
	exports.SlowBuffer = SlowBuffer
	exports.INSPECT_MAX_BYTES = 50
	
	/**
	 * If `Buffer.TYPED_ARRAY_SUPPORT`:
	 *   === true    Use Uint8Array implementation (fastest)
	 *   === false   Use Object implementation (most compatible, even IE6)
	 *
	 * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,
	 * Opera 11.6+, iOS 4.2+.
	 *
	 * Due to various browser bugs, sometimes the Object implementation will be used even
	 * when the browser supports typed arrays.
	 *
	 * Note:
	 *
	 *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,
	 *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.
	 *
	 *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.
	 *
	 *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of
	 *     incorrect length in some situations.
	
	 * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they
	 * get the Object implementation, which is slower but behaves correctly.
	 */
	Buffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined
		? global.TYPED_ARRAY_SUPPORT
		: typedArraySupport()
	
	/*
	 * Export kMaxLength after typed array support is determined.
	 */
	exports.kMaxLength = kMaxLength()
	
	function typedArraySupport () {
		try {
			var arr = new Uint8Array(1)
			arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}
			return arr.foo() === 42 && // typed array instances can be augmented
					typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`
					arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`
		} catch (e) {
			return false
		}
	}
	
	function kMaxLength () {
		return Buffer.TYPED_ARRAY_SUPPORT
			? 0x7fffffff
			: 0x3fffffff
	}
	
	function createBuffer (that, length) {
		if (kMaxLength() < length) {
			throw new RangeError('Invalid typed array length')
		}
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			// Return an augmented `Uint8Array` instance, for best performance
			that = new Uint8Array(length)
			that.__proto__ = Buffer.prototype
		} else {
			// Fallback: Return an object instance of the Buffer class
			if (that === null) {
				that = new Buffer(length)
			}
			that.length = length
		}
	
		return that
	}
	
	/**
	 * The Buffer constructor returns instances of `Uint8Array` that have their
	 * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of
	 * `Uint8Array`, so the returned instances will have all the node `Buffer` methods
	 * and the `Uint8Array` methods. Square bracket notation works as expected -- it
	 * returns a single octet.
	 *
	 * The `Uint8Array` prototype remains unmodified.
	 */
	
	function Buffer (arg, encodingOrOffset, length) {
		if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {
			return new Buffer(arg, encodingOrOffset, length)
		}
	
		// Common case.
		if (typeof arg === 'number') {
			if (typeof encodingOrOffset === 'string') {
				throw new Error(
					'If encoding is specified then the first argument must be a string'
				)
			}
			return allocUnsafe(this, arg)
		}
		return from(this, arg, encodingOrOffset, length)
	}
	
	Buffer.poolSize = 8192 // not used by this implementation
	
	// TODO: Legacy, not needed anymore. Remove in next major version.
	Buffer._augment = function (arr) {
		arr.__proto__ = Buffer.prototype
		return arr
	}
	
	function from (that, value, encodingOrOffset, length) {
		if (typeof value === 'number') {
			throw new TypeError('"value" argument must not be a number')
		}
	
		if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {
			return fromArrayBuffer(that, value, encodingOrOffset, length)
		}
	
		if (typeof value === 'string') {
			return fromString(that, value, encodingOrOffset)
		}
	
		return fromObject(that, value)
	}
	
	/**
	 * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError
	 * if value is a number.
	 * Buffer.from(str[, encoding])
	 * Buffer.from(array)
	 * Buffer.from(buffer)
	 * Buffer.from(arrayBuffer[, byteOffset[, length]])
	 **/
	Buffer.from = function (value, encodingOrOffset, length) {
		return from(null, value, encodingOrOffset, length)
	}
	
	if (Buffer.TYPED_ARRAY_SUPPORT) {
		Buffer.prototype.__proto__ = Uint8Array.prototype
		Buffer.__proto__ = Uint8Array
		if (typeof Symbol !== 'undefined' && Symbol.species &&
				Buffer[Symbol.species] === Buffer) {
			// Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97
			Object.defineProperty(Buffer, Symbol.species, {
				value: null,
				configurable: true
			})
		}
	}
	
	function assertSize (size) {
		if (typeof size !== 'number') {
			throw new TypeError('"size" argument must be a number')
		} else if (size < 0) {
			throw new RangeError('"size" argument must not be negative')
		}
	}
	
	function alloc (that, size, fill, encoding) {
		assertSize(size)
		if (size <= 0) {
			return createBuffer(that, size)
		}
		if (fill !== undefined) {
			// Only pay attention to encoding if it's a string. This
			// prevents accidentally sending in a number that would
			// be interpretted as a start offset.
			return typeof encoding === 'string'
				? createBuffer(that, size).fill(fill, encoding)
				: createBuffer(that, size).fill(fill)
		}
		return createBuffer(that, size)
	}
	
	/**
	 * Creates a new filled Buffer instance.
	 * alloc(size[, fill[, encoding]])
	 **/
	Buffer.alloc = function (size, fill, encoding) {
		return alloc(null, size, fill, encoding)
	}
	
	function allocUnsafe (that, size) {
		assertSize(size)
		that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)
		if (!Buffer.TYPED_ARRAY_SUPPORT) {
			for (var i = 0; i < size; ++i) {
				that[i] = 0
			}
		}
		return that
	}
	
	/**
	 * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.
	 * */
	Buffer.allocUnsafe = function (size) {
		return allocUnsafe(null, size)
	}
	/**
	 * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.
	 */
	Buffer.allocUnsafeSlow = function (size) {
		return allocUnsafe(null, size)
	}
	
	function fromString (that, string, encoding) {
		if (typeof encoding !== 'string' || encoding === '') {
			encoding = 'utf8'
		}
	
		if (!Buffer.isEncoding(encoding)) {
			throw new TypeError('"encoding" must be a valid string encoding')
		}
	
		var length = byteLength(string, encoding) | 0
		that = createBuffer(that, length)
	
		var actual = that.write(string, encoding)
	
		if (actual !== length) {
			// Writing a hex string, for example, that contains invalid characters will
			// cause everything after the first invalid character to be ignored. (e.g.
			// 'abxxcd' will be treated as 'ab')
			that = that.slice(0, actual)
		}
	
		return that
	}
	
	function fromArrayLike (that, array) {
		var length = array.length < 0 ? 0 : checked(array.length) | 0
		that = createBuffer(that, length)
		for (var i = 0; i < length; i += 1) {
			that[i] = array[i] & 255
		}
		return that
	}
	
	function fromArrayBuffer (that, array, byteOffset, length) {
		array.byteLength // this throws if `array` is not a valid ArrayBuffer
	
		if (byteOffset < 0 || array.byteLength < byteOffset) {
			throw new RangeError('\'offset\' is out of bounds')
		}
	
		if (array.byteLength < byteOffset + (length || 0)) {
			throw new RangeError('\'length\' is out of bounds')
		}
	
		if (byteOffset === undefined && length === undefined) {
			array = new Uint8Array(array)
		} else if (length === undefined) {
			array = new Uint8Array(array, byteOffset)
		} else {
			array = new Uint8Array(array, byteOffset, length)
		}
	
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			// Return an augmented `Uint8Array` instance, for best performance
			that = array
			that.__proto__ = Buffer.prototype
		} else {
			// Fallback: Return an object instance of the Buffer class
			that = fromArrayLike(that, array)
		}
		return that
	}
	
	function fromObject (that, obj) {
		if (Buffer.isBuffer(obj)) {
			var len = checked(obj.length) | 0
			that = createBuffer(that, len)
	
			if (that.length === 0) {
				return that
			}
	
			obj.copy(that, 0, 0, len)
			return that
		}
	
		if (obj) {
			if ((typeof ArrayBuffer !== 'undefined' &&
					obj.buffer instanceof ArrayBuffer) || 'length' in obj) {
				if (typeof obj.length !== 'number' || isnan(obj.length)) {
					return createBuffer(that, 0)
				}
				return fromArrayLike(that, obj)
			}
	
			if (obj.type === 'Buffer' && isArray(obj.data)) {
				return fromArrayLike(that, obj.data)
			}
		}
	
		throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')
	}
	
	function checked (length) {
		// Note: cannot use `length < kMaxLength()` here because that fails when
		// length is NaN (which is otherwise coerced to zero.)
		if (length >= kMaxLength()) {
			throw new RangeError('Attempt to allocate Buffer larger than maximum ' +
													 'size: 0x' + kMaxLength().toString(16) + ' bytes')
		}
		return length | 0
	}
	
	function SlowBuffer (length) {
		if (+length != length) { // eslint-disable-line eqeqeq
			length = 0
		}
		return Buffer.alloc(+length)
	}
	
	Buffer.isBuffer = function isBuffer (b) {
		return !!(b != null && b._isBuffer)
	}
	
	Buffer.compare = function compare (a, b) {
		if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {
			throw new TypeError('Arguments must be Buffers')
		}
	
		if (a === b) return 0
	
		var x = a.length
		var y = b.length
	
		for (var i = 0, len = Math.min(x, y); i < len; ++i) {
			if (a[i] !== b[i]) {
				x = a[i]
				y = b[i]
				break
			}
		}
	
		if (x < y) return -1
		if (y < x) return 1
		return 0
	}
	
	Buffer.isEncoding = function isEncoding (encoding) {
		switch (String(encoding).toLowerCase()) {
			case 'hex':
			case 'utf8':
			case 'utf-8':
			case 'ascii':
			case 'latin1':
			case 'binary':
			case 'base64':
			case 'ucs2':
			case 'ucs-2':
			case 'utf16le':
			case 'utf-16le':
				return true
			default:
				return false
		}
	}
	
	Buffer.concat = function concat (list, length) {
		if (!isArray(list)) {
			throw new TypeError('"list" argument must be an Array of Buffers')
		}
	
		if (list.length === 0) {
			return Buffer.alloc(0)
		}
	
		var i
		if (length === undefined) {
			length = 0
			for (i = 0; i < list.length; ++i) {
				length += list[i].length
			}
		}
	
		var buffer = Buffer.allocUnsafe(length)
		var pos = 0
		for (i = 0; i < list.length; ++i) {
			var buf = list[i]
			if (!Buffer.isBuffer(buf)) {
				throw new TypeError('"list" argument must be an Array of Buffers')
			}
			buf.copy(buffer, pos)
			pos += buf.length
		}
		return buffer
	}
	
	function byteLength (string, encoding) {
		if (Buffer.isBuffer(string)) {
			return string.length
		}
		if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&
				(ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {
			return string.byteLength
		}
		if (typeof string !== 'string') {
			string = '' + string
		}
	
		var len = string.length
		if (len === 0) return 0
	
		// Use a for loop to avoid recursion
		var loweredCase = false
		for (;;) {
			switch (encoding) {
				case 'ascii':
				case 'latin1':
				case 'binary':
					return len
				case 'utf8':
				case 'utf-8':
				case undefined:
					return utf8ToBytes(string).length
				case 'ucs2':
				case 'ucs-2':
				case 'utf16le':
				case 'utf-16le':
					return len * 2
				case 'hex':
					return len >>> 1
				case 'base64':
					return base64ToBytes(string).length
				default:
					if (loweredCase) return utf8ToBytes(string).length // assume utf8
					encoding = ('' + encoding).toLowerCase()
					loweredCase = true
			}
		}
	}
	Buffer.byteLength = byteLength
	
	function slowToString (encoding, start, end) {
		var loweredCase = false
	
		// No need to verify that "this.length <= MAX_UINT32" since it's a read-only
		// property of a typed array.
	
		// This behaves neither like String nor Uint8Array in that we set start/end
		// to their upper/lower bounds if the value passed is out of range.
		// undefined is handled specially as per ECMA-262 6th Edition,
		// Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.
		if (start === undefined || start < 0) {
			start = 0
		}
		// Return early if start > this.length. Done here to prevent potential uint32
		// coercion fail below.
		if (start > this.length) {
			return ''
		}
	
		if (end === undefined || end > this.length) {
			end = this.length
		}
	
		if (end <= 0) {
			return ''
		}
	
		// Force coersion to uint32. This will also coerce falsey/NaN values to 0.
		end >>>= 0
		start >>>= 0
	
		if (end <= start) {
			return ''
		}
	
		if (!encoding) encoding = 'utf8'
	
		while (true) {
			switch (encoding) {
				case 'hex':
					return hexSlice(this, start, end)
	
				case 'utf8':
				case 'utf-8':
					return utf8Slice(this, start, end)
	
				case 'ascii':
					return asciiSlice(this, start, end)
	
				case 'latin1':
				case 'binary':
					return latin1Slice(this, start, end)
	
				case 'base64':
					return base64Slice(this, start, end)
	
				case 'ucs2':
				case 'ucs-2':
				case 'utf16le':
				case 'utf-16le':
					return utf16leSlice(this, start, end)
	
				default:
					if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
					encoding = (encoding + '').toLowerCase()
					loweredCase = true
			}
		}
	}
	
	// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect
	// Buffer instances.
	Buffer.prototype._isBuffer = true
	
	function swap (b, n, m) {
		var i = b[n]
		b[n] = b[m]
		b[m] = i
	}
	
	Buffer.prototype.swap16 = function swap16 () {
		var len = this.length
		if (len % 2 !== 0) {
			throw new RangeError('Buffer size must be a multiple of 16-bits')
		}
		for (var i = 0; i < len; i += 2) {
			swap(this, i, i + 1)
		}
		return this
	}
	
	Buffer.prototype.swap32 = function swap32 () {
		var len = this.length
		if (len % 4 !== 0) {
			throw new RangeError('Buffer size must be a multiple of 32-bits')
		}
		for (var i = 0; i < len; i += 4) {
			swap(this, i, i + 3)
			swap(this, i + 1, i + 2)
		}
		return this
	}
	
	Buffer.prototype.swap64 = function swap64 () {
		var len = this.length
		if (len % 8 !== 0) {
			throw new RangeError('Buffer size must be a multiple of 64-bits')
		}
		for (var i = 0; i < len; i += 8) {
			swap(this, i, i + 7)
			swap(this, i + 1, i + 6)
			swap(this, i + 2, i + 5)
			swap(this, i + 3, i + 4)
		}
		return this
	}
	
	Buffer.prototype.toString = function toString () {
		var length = this.length | 0
		if (length === 0) return ''
		if (arguments.length === 0) return utf8Slice(this, 0, length)
		return slowToString.apply(this, arguments)
	}
	
	Buffer.prototype.equals = function equals (b) {
		if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')
		if (this === b) return true
		return Buffer.compare(this, b) === 0
	}
	
	Buffer.prototype.inspect = function inspect () {
		var str = ''
		var max = exports.INSPECT_MAX_BYTES
		if (this.length > 0) {
			str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')
			if (this.length > max) str += ' ... '
		}
		return '<Buffer ' + str + '>'
	}
	
	Buffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {
		if (!Buffer.isBuffer(target)) {
			throw new TypeError('Argument must be a Buffer')
		}
	
		if (start === undefined) {
			start = 0
		}
		if (end === undefined) {
			end = target ? target.length : 0
		}
		if (thisStart === undefined) {
			thisStart = 0
		}
		if (thisEnd === undefined) {
			thisEnd = this.length
		}
	
		if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {
			throw new RangeError('out of range index')
		}
	
		if (thisStart >= thisEnd && start >= end) {
			return 0
		}
		if (thisStart >= thisEnd) {
			return -1
		}
		if (start >= end) {
			return 1
		}
	
		start >>>= 0
		end >>>= 0
		thisStart >>>= 0
		thisEnd >>>= 0
	
		if (this === target) return 0
	
		var x = thisEnd - thisStart
		var y = end - start
		var len = Math.min(x, y)
	
		var thisCopy = this.slice(thisStart, thisEnd)
		var targetCopy = target.slice(start, end)
	
		for (var i = 0; i < len; ++i) {
			if (thisCopy[i] !== targetCopy[i]) {
				x = thisCopy[i]
				y = targetCopy[i]
				break
			}
		}
	
		if (x < y) return -1
		if (y < x) return 1
		return 0
	}
	
	// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,
	// OR the last index of `val` in `buffer` at offset <= `byteOffset`.
	//
	// Arguments:
	// - buffer - a Buffer to search
	// - val - a string, Buffer, or number
	// - byteOffset - an index into `buffer`; will be clamped to an int32
	// - encoding - an optional encoding, relevant is val is a string
	// - dir - true for indexOf, false for lastIndexOf
	function bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {
		// Empty buffer means no match
		if (buffer.length === 0) return -1
	
		// Normalize byteOffset
		if (typeof byteOffset === 'string') {
			encoding = byteOffset
			byteOffset = 0
		} else if (byteOffset > 0x7fffffff) {
			byteOffset = 0x7fffffff
		} else if (byteOffset < -0x80000000) {
			byteOffset = -0x80000000
		}
		byteOffset = +byteOffset  // Coerce to Number.
		if (isNaN(byteOffset)) {
			// byteOffset: it it's undefined, null, NaN, "foo", etc, search whole buffer
			byteOffset = dir ? 0 : (buffer.length - 1)
		}
	
		// Normalize byteOffset: negative offsets start from the end of the buffer
		if (byteOffset < 0) byteOffset = buffer.length + byteOffset
		if (byteOffset >= buffer.length) {
			if (dir) return -1
			else byteOffset = buffer.length - 1
		} else if (byteOffset < 0) {
			if (dir) byteOffset = 0
			else return -1
		}
	
		// Normalize val
		if (typeof val === 'string') {
			val = Buffer.from(val, encoding)
		}
	
		// Finally, search either indexOf (if dir is true) or lastIndexOf
		if (Buffer.isBuffer(val)) {
			// Special case: looking for empty string/buffer always fails
			if (val.length === 0) {
				return -1
			}
			return arrayIndexOf(buffer, val, byteOffset, encoding, dir)
		} else if (typeof val === 'number') {
			val = val & 0xFF // Search for a byte value [0-255]
			if (Buffer.TYPED_ARRAY_SUPPORT &&
					typeof Uint8Array.prototype.indexOf === 'function') {
				if (dir) {
					return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)
				} else {
					return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)
				}
			}
			return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)
		}
	
		throw new TypeError('val must be string, number or Buffer')
	}
	
	function arrayIndexOf (arr, val, byteOffset, encoding, dir) {
		var indexSize = 1
		var arrLength = arr.length
		var valLength = val.length
	
		if (encoding !== undefined) {
			encoding = String(encoding).toLowerCase()
			if (encoding === 'ucs2' || encoding === 'ucs-2' ||
					encoding === 'utf16le' || encoding === 'utf-16le') {
				if (arr.length < 2 || val.length < 2) {
					return -1
				}
				indexSize = 2
				arrLength /= 2
				valLength /= 2
				byteOffset /= 2
			}
		}
	
		function read (buf, i) {
			if (indexSize === 1) {
				return buf[i]
			} else {
				return buf.readUInt16BE(i * indexSize)
			}
		}
	
		var i
		if (dir) {
			var foundIndex = -1
			for (i = byteOffset; i < arrLength; i++) {
				if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {
					if (foundIndex === -1) foundIndex = i
					if (i - foundIndex + 1 === valLength) return foundIndex * indexSize
				} else {
					if (foundIndex !== -1) i -= i - foundIndex
					foundIndex = -1
				}
			}
		} else {
			if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength
			for (i = byteOffset; i >= 0; i--) {
				var found = true
				for (var j = 0; j < valLength; j++) {
					if (read(arr, i + j) !== read(val, j)) {
						found = false
						break
					}
				}
				if (found) return i
			}
		}
	
		return -1
	}
	
	Buffer.prototype.includes = function includes (val, byteOffset, encoding) {
		return this.indexOf(val, byteOffset, encoding) !== -1
	}
	
	Buffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {
		return bidirectionalIndexOf(this, val, byteOffset, encoding, true)
	}
	
	Buffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {
		return bidirectionalIndexOf(this, val, byteOffset, encoding, false)
	}
	
	function hexWrite (buf, string, offset, length) {
		offset = Number(offset) || 0
		var remaining = buf.length - offset
		if (!length) {
			length = remaining
		} else {
			length = Number(length)
			if (length > remaining) {
				length = remaining
			}
		}
	
		// must be an even number of digits
		var strLen = string.length
		if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')
	
		if (length > strLen / 2) {
			length = strLen / 2
		}
		for (var i = 0; i < length; ++i) {
			var parsed = parseInt(string.substr(i * 2, 2), 16)
			if (isNaN(parsed)) return i
			buf[offset + i] = parsed
		}
		return i
	}
	
	function utf8Write (buf, string, offset, length) {
		return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	function asciiWrite (buf, string, offset, length) {
		return blitBuffer(asciiToBytes(string), buf, offset, length)
	}
	
	function latin1Write (buf, string, offset, length) {
		return asciiWrite(buf, string, offset, length)
	}
	
	function base64Write (buf, string, offset, length) {
		return blitBuffer(base64ToBytes(string), buf, offset, length)
	}
	
	function ucs2Write (buf, string, offset, length) {
		return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)
	}
	
	Buffer.prototype.write = function write (string, offset, length, encoding) {
		// Buffer#write(string)
		if (offset === undefined) {
			encoding = 'utf8'
			length = this.length
			offset = 0
		// Buffer#write(string, encoding)
		} else if (length === undefined && typeof offset === 'string') {
			encoding = offset
			length = this.length
			offset = 0
		// Buffer#write(string, offset[, length][, encoding])
		} else if (isFinite(offset)) {
			offset = offset | 0
			if (isFinite(length)) {
				length = length | 0
				if (encoding === undefined) encoding = 'utf8'
			} else {
				encoding = length
				length = undefined
			}
		// legacy write(string, encoding, offset, length) - remove in v0.13
		} else {
			throw new Error(
				'Buffer.write(string, encoding, offset[, length]) is no longer supported'
			)
		}
	
		var remaining = this.length - offset
		if (length === undefined || length > remaining) length = remaining
	
		if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {
			throw new RangeError('Attempt to write outside buffer bounds')
		}
	
		if (!encoding) encoding = 'utf8'
	
		var loweredCase = false
		for (;;) {
			switch (encoding) {
				case 'hex':
					return hexWrite(this, string, offset, length)
	
				case 'utf8':
				case 'utf-8':
					return utf8Write(this, string, offset, length)
	
				case 'ascii':
					return asciiWrite(this, string, offset, length)
	
				case 'latin1':
				case 'binary':
					return latin1Write(this, string, offset, length)
	
				case 'base64':
					// Warning: maxLength not taken into account in base64Write
					return base64Write(this, string, offset, length)
	
				case 'ucs2':
				case 'ucs-2':
				case 'utf16le':
				case 'utf-16le':
					return ucs2Write(this, string, offset, length)
	
				default:
					if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)
					encoding = ('' + encoding).toLowerCase()
					loweredCase = true
			}
		}
	}
	
	Buffer.prototype.toJSON = function toJSON () {
		return {
			type: 'Buffer',
			data: Array.prototype.slice.call(this._arr || this, 0)
		}
	}
	
	function base64Slice (buf, start, end) {
		if (start === 0 && end === buf.length) {
			return base64.fromByteArray(buf)
		} else {
			return base64.fromByteArray(buf.slice(start, end))
		}
	}
	
	function utf8Slice (buf, start, end) {
		end = Math.min(buf.length, end)
		var res = []
	
		var i = start
		while (i < end) {
			var firstByte = buf[i]
			var codePoint = null
			var bytesPerSequence = (firstByte > 0xEF) ? 4
				: (firstByte > 0xDF) ? 3
				: (firstByte > 0xBF) ? 2
				: 1
	
			if (i + bytesPerSequence <= end) {
				var secondByte, thirdByte, fourthByte, tempCodePoint
	
				switch (bytesPerSequence) {
					case 1:
						if (firstByte < 0x80) {
							codePoint = firstByte
						}
						break
					case 2:
						secondByte = buf[i + 1]
						if ((secondByte & 0xC0) === 0x80) {
							tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)
							if (tempCodePoint > 0x7F) {
								codePoint = tempCodePoint
							}
						}
						break
					case 3:
						secondByte = buf[i + 1]
						thirdByte = buf[i + 2]
						if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {
							tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)
							if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {
								codePoint = tempCodePoint
							}
						}
						break
					case 4:
						secondByte = buf[i + 1]
						thirdByte = buf[i + 2]
						fourthByte = buf[i + 3]
						if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {
							tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)
							if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {
								codePoint = tempCodePoint
							}
						}
				}
			}
	
			if (codePoint === null) {
				// we did not generate a valid codePoint so insert a
				// replacement char (U+FFFD) and advance only 1 byte
				codePoint = 0xFFFD
				bytesPerSequence = 1
			} else if (codePoint > 0xFFFF) {
				// encode to utf16 (surrogate pair dance)
				codePoint -= 0x10000
				res.push(codePoint >>> 10 & 0x3FF | 0xD800)
				codePoint = 0xDC00 | codePoint & 0x3FF
			}
	
			res.push(codePoint)
			i += bytesPerSequence
		}
	
		return decodeCodePointsArray(res)
	}
	
	// Based on http://stackoverflow.com/a/22747272/680742, the browser with
	// the lowest limit is Chrome, with 0x10000 args.
	// We go 1 magnitude less, for safety
	var MAX_ARGUMENTS_LENGTH = 0x1000
	
	function decodeCodePointsArray (codePoints) {
		var len = codePoints.length
		if (len <= MAX_ARGUMENTS_LENGTH) {
			return String.fromCharCode.apply(String, codePoints) // avoid extra slice()
		}
	
		// Decode in chunks to avoid "call stack size exceeded".
		var res = ''
		var i = 0
		while (i < len) {
			res += String.fromCharCode.apply(
				String,
				codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)
			)
		}
		return res
	}
	
	function asciiSlice (buf, start, end) {
		var ret = ''
		end = Math.min(buf.length, end)
	
		for (var i = start; i < end; ++i) {
			ret += String.fromCharCode(buf[i] & 0x7F)
		}
		return ret
	}
	
	function latin1Slice (buf, start, end) {
		var ret = ''
		end = Math.min(buf.length, end)
	
		for (var i = start; i < end; ++i) {
			ret += String.fromCharCode(buf[i])
		}
		return ret
	}
	
	function hexSlice (buf, start, end) {
		var len = buf.length
	
		if (!start || start < 0) start = 0
		if (!end || end < 0 || end > len) end = len
	
		var out = ''
		for (var i = start; i < end; ++i) {
			out += toHex(buf[i])
		}
		return out
	}
	
	function utf16leSlice (buf, start, end) {
		var bytes = buf.slice(start, end)
		var res = ''
		for (var i = 0; i < bytes.length; i += 2) {
			res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)
		}
		return res
	}
	
	Buffer.prototype.slice = function slice (start, end) {
		var len = this.length
		start = ~~start
		end = end === undefined ? len : ~~end
	
		if (start < 0) {
			start += len
			if (start < 0) start = 0
		} else if (start > len) {
			start = len
		}
	
		if (end < 0) {
			end += len
			if (end < 0) end = 0
		} else if (end > len) {
			end = len
		}
	
		if (end < start) end = start
	
		var newBuf
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			newBuf = this.subarray(start, end)
			newBuf.__proto__ = Buffer.prototype
		} else {
			var sliceLen = end - start
			newBuf = new Buffer(sliceLen, undefined)
			for (var i = 0; i < sliceLen; ++i) {
				newBuf[i] = this[i + start]
			}
		}
	
		return newBuf
	}
	
	/*
	 * Need to make sure that buffer isn't trying to write out of bounds.
	 */
	function checkOffset (offset, ext, length) {
		if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')
		if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')
	}
	
	Buffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {
		offset = offset | 0
		byteLength = byteLength | 0
		if (!noAssert) checkOffset(offset, byteLength, this.length)
	
		var val = this[offset]
		var mul = 1
		var i = 0
		while (++i < byteLength && (mul *= 0x100)) {
			val += this[offset + i] * mul
		}
	
		return val
	}
	
	Buffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {
		offset = offset | 0
		byteLength = byteLength | 0
		if (!noAssert) {
			checkOffset(offset, byteLength, this.length)
		}
	
		var val = this[offset + --byteLength]
		var mul = 1
		while (byteLength > 0 && (mul *= 0x100)) {
			val += this[offset + --byteLength] * mul
		}
	
		return val
	}
	
	Buffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 1, this.length)
		return this[offset]
	}
	
	Buffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 2, this.length)
		return this[offset] | (this[offset + 1] << 8)
	}
	
	Buffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 2, this.length)
		return (this[offset] << 8) | this[offset + 1]
	}
	
	Buffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 4, this.length)
	
		return ((this[offset]) |
				(this[offset + 1] << 8) |
				(this[offset + 2] << 16)) +
				(this[offset + 3] * 0x1000000)
	}
	
	Buffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 4, this.length)
	
		return (this[offset] * 0x1000000) +
			((this[offset + 1] << 16) |
			(this[offset + 2] << 8) |
			this[offset + 3])
	}
	
	Buffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {
		offset = offset | 0
		byteLength = byteLength | 0
		if (!noAssert) checkOffset(offset, byteLength, this.length)
	
		var val = this[offset]
		var mul = 1
		var i = 0
		while (++i < byteLength && (mul *= 0x100)) {
			val += this[offset + i] * mul
		}
		mul *= 0x80
	
		if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
		return val
	}
	
	Buffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {
		offset = offset | 0
		byteLength = byteLength | 0
		if (!noAssert) checkOffset(offset, byteLength, this.length)
	
		var i = byteLength
		var mul = 1
		var val = this[offset + --i]
		while (i > 0 && (mul *= 0x100)) {
			val += this[offset + --i] * mul
		}
		mul *= 0x80
	
		if (val >= mul) val -= Math.pow(2, 8 * byteLength)
	
		return val
	}
	
	Buffer.prototype.readInt8 = function readInt8 (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 1, this.length)
		if (!(this[offset] & 0x80)) return (this[offset])
		return ((0xff - this[offset] + 1) * -1)
	}
	
	Buffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 2, this.length)
		var val = this[offset] | (this[offset + 1] << 8)
		return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 2, this.length)
		var val = this[offset + 1] | (this[offset] << 8)
		return (val & 0x8000) ? val | 0xFFFF0000 : val
	}
	
	Buffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 4, this.length)
	
		return (this[offset]) |
			(this[offset + 1] << 8) |
			(this[offset + 2] << 16) |
			(this[offset + 3] << 24)
	}
	
	Buffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 4, this.length)
	
		return (this[offset] << 24) |
			(this[offset + 1] << 16) |
			(this[offset + 2] << 8) |
			(this[offset + 3])
	}
	
	Buffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 4, this.length)
		return ieee754.read(this, offset, true, 23, 4)
	}
	
	Buffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 4, this.length)
		return ieee754.read(this, offset, false, 23, 4)
	}
	
	Buffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 8, this.length)
		return ieee754.read(this, offset, true, 52, 8)
	}
	
	Buffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {
		if (!noAssert) checkOffset(offset, 8, this.length)
		return ieee754.read(this, offset, false, 52, 8)
	}
	
	function checkInt (buf, value, offset, ext, max, min) {
		if (!Buffer.isBuffer(buf)) throw new TypeError('"buffer" argument must be a Buffer instance')
		if (value > max || value < min) throw new RangeError('"value" argument is out of bounds')
		if (offset + ext > buf.length) throw new RangeError('Index out of range')
	}
	
	Buffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {
		value = +value
		offset = offset | 0
		byteLength = byteLength | 0
		if (!noAssert) {
			var maxBytes = Math.pow(2, 8 * byteLength) - 1
			checkInt(this, value, offset, byteLength, maxBytes, 0)
		}
	
		var mul = 1
		var i = 0
		this[offset] = value & 0xFF
		while (++i < byteLength && (mul *= 0x100)) {
			this[offset + i] = (value / mul) & 0xFF
		}
	
		return offset + byteLength
	}
	
	Buffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {
		value = +value
		offset = offset | 0
		byteLength = byteLength | 0
		if (!noAssert) {
			var maxBytes = Math.pow(2, 8 * byteLength) - 1
			checkInt(this, value, offset, byteLength, maxBytes, 0)
		}
	
		var i = byteLength - 1
		var mul = 1
		this[offset + i] = value & 0xFF
		while (--i >= 0 && (mul *= 0x100)) {
			this[offset + i] = (value / mul) & 0xFF
		}
	
		return offset + byteLength
	}
	
	Buffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)
		if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		this[offset] = (value & 0xff)
		return offset + 1
	}
	
	function objectWriteUInt16 (buf, value, offset, littleEndian) {
		if (value < 0) value = 0xffff + value + 1
		for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {
			buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>
				(littleEndian ? i : 1 - i) * 8
		}
	}
	
	Buffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value & 0xff)
			this[offset + 1] = (value >>> 8)
		} else {
			objectWriteUInt16(this, value, offset, true)
		}
		return offset + 2
	}
	
	Buffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value >>> 8)
			this[offset + 1] = (value & 0xff)
		} else {
			objectWriteUInt16(this, value, offset, false)
		}
		return offset + 2
	}
	
	function objectWriteUInt32 (buf, value, offset, littleEndian) {
		if (value < 0) value = 0xffffffff + value + 1
		for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {
			buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff
		}
	}
	
	Buffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset + 3] = (value >>> 24)
			this[offset + 2] = (value >>> 16)
			this[offset + 1] = (value >>> 8)
			this[offset] = (value & 0xff)
		} else {
			objectWriteUInt32(this, value, offset, true)
		}
		return offset + 4
	}
	
	Buffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value >>> 24)
			this[offset + 1] = (value >>> 16)
			this[offset + 2] = (value >>> 8)
			this[offset + 3] = (value & 0xff)
		} else {
			objectWriteUInt32(this, value, offset, false)
		}
		return offset + 4
	}
	
	Buffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) {
			var limit = Math.pow(2, 8 * byteLength - 1)
	
			checkInt(this, value, offset, byteLength, limit - 1, -limit)
		}
	
		var i = 0
		var mul = 1
		var sub = 0
		this[offset] = value & 0xFF
		while (++i < byteLength && (mul *= 0x100)) {
			if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {
				sub = 1
			}
			this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		}
	
		return offset + byteLength
	}
	
	Buffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) {
			var limit = Math.pow(2, 8 * byteLength - 1)
	
			checkInt(this, value, offset, byteLength, limit - 1, -limit)
		}
	
		var i = byteLength - 1
		var mul = 1
		var sub = 0
		this[offset + i] = value & 0xFF
		while (--i >= 0 && (mul *= 0x100)) {
			if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {
				sub = 1
			}
			this[offset + i] = ((value / mul) >> 0) - sub & 0xFF
		}
	
		return offset + byteLength
	}
	
	Buffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)
		if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)
		if (value < 0) value = 0xff + value + 1
		this[offset] = (value & 0xff)
		return offset + 1
	}
	
	Buffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value & 0xff)
			this[offset + 1] = (value >>> 8)
		} else {
			objectWriteUInt16(this, value, offset, true)
		}
		return offset + 2
	}
	
	Buffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value >>> 8)
			this[offset + 1] = (value & 0xff)
		} else {
			objectWriteUInt16(this, value, offset, false)
		}
		return offset + 2
	}
	
	Buffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value & 0xff)
			this[offset + 1] = (value >>> 8)
			this[offset + 2] = (value >>> 16)
			this[offset + 3] = (value >>> 24)
		} else {
			objectWriteUInt32(this, value, offset, true)
		}
		return offset + 4
	}
	
	Buffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {
		value = +value
		offset = offset | 0
		if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)
		if (value < 0) value = 0xffffffff + value + 1
		if (Buffer.TYPED_ARRAY_SUPPORT) {
			this[offset] = (value >>> 24)
			this[offset + 1] = (value >>> 16)
			this[offset + 2] = (value >>> 8)
			this[offset + 3] = (value & 0xff)
		} else {
			objectWriteUInt32(this, value, offset, false)
		}
		return offset + 4
	}
	
	function checkIEEE754 (buf, value, offset, ext, max, min) {
		if (offset + ext > buf.length) throw new RangeError('Index out of range')
		if (offset < 0) throw new RangeError('Index out of range')
	}
	
	function writeFloat (buf, value, offset, littleEndian, noAssert) {
		if (!noAssert) {
			checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)
		}
		ieee754.write(buf, value, offset, littleEndian, 23, 4)
		return offset + 4
	}
	
	Buffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {
		return writeFloat(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {
		return writeFloat(this, value, offset, false, noAssert)
	}
	
	function writeDouble (buf, value, offset, littleEndian, noAssert) {
		if (!noAssert) {
			checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)
		}
		ieee754.write(buf, value, offset, littleEndian, 52, 8)
		return offset + 8
	}
	
	Buffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {
		return writeDouble(this, value, offset, true, noAssert)
	}
	
	Buffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {
		return writeDouble(this, value, offset, false, noAssert)
	}
	
	// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)
	Buffer.prototype.copy = function copy (target, targetStart, start, end) {
		if (!start) start = 0
		if (!end && end !== 0) end = this.length
		if (targetStart >= target.length) targetStart = target.length
		if (!targetStart) targetStart = 0
		if (end > 0 && end < start) end = start
	
		// Copy 0 bytes; we're done
		if (end === start) return 0
		if (target.length === 0 || this.length === 0) return 0
	
		// Fatal error conditions
		if (targetStart < 0) {
			throw new RangeError('targetStart out of bounds')
		}
		if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')
		if (end < 0) throw new RangeError('sourceEnd out of bounds')
	
		// Are we oob?
		if (end > this.length) end = this.length
		if (target.length - targetStart < end - start) {
			end = target.length - targetStart + start
		}
	
		var len = end - start
		var i
	
		if (this === target && start < targetStart && targetStart < end) {
			// descending copy from end
			for (i = len - 1; i >= 0; --i) {
				target[i + targetStart] = this[i + start]
			}
		} else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {
			// ascending copy from start
			for (i = 0; i < len; ++i) {
				target[i + targetStart] = this[i + start]
			}
		} else {
			Uint8Array.prototype.set.call(
				target,
				this.subarray(start, start + len),
				targetStart
			)
		}
	
		return len
	}
	
	// Usage:
	//    buffer.fill(number[, offset[, end]])
	//    buffer.fill(buffer[, offset[, end]])
	//    buffer.fill(string[, offset[, end]][, encoding])
	Buffer.prototype.fill = function fill (val, start, end, encoding) {
		// Handle string cases:
		if (typeof val === 'string') {
			if (typeof start === 'string') {
				encoding = start
				start = 0
				end = this.length
			} else if (typeof end === 'string') {
				encoding = end
				end = this.length
			}
			if (val.length === 1) {
				var code = val.charCodeAt(0)
				if (code < 256) {
					val = code
				}
			}
			if (encoding !== undefined && typeof encoding !== 'string') {
				throw new TypeError('encoding must be a string')
			}
			if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {
				throw new TypeError('Unknown encoding: ' + encoding)
			}
		} else if (typeof val === 'number') {
			val = val & 255
		}
	
		// Invalid ranges are not set to a default, so can range check early.
		if (start < 0 || this.length < start || this.length < end) {
			throw new RangeError('Out of range index')
		}
	
		if (end <= start) {
			return this
		}
	
		start = start >>> 0
		end = end === undefined ? this.length : end >>> 0
	
		if (!val) val = 0
	
		var i
		if (typeof val === 'number') {
			for (i = start; i < end; ++i) {
				this[i] = val
			}
		} else {
			var bytes = Buffer.isBuffer(val)
				? val
				: utf8ToBytes(new Buffer(val, encoding).toString())
			var len = bytes.length
			for (i = 0; i < end - start; ++i) {
				this[i + start] = bytes[i % len]
			}
		}
	
		return this
	}
	
	// HELPER FUNCTIONS
	// ================
	
	var INVALID_BASE64_RE = /[^+\/0-9A-Za-z-_]/g
	
	function base64clean (str) {
		// Node strips out invalid characters like \n and \t from the string, base64-js does not
		str = stringtrim(str).replace(INVALID_BASE64_RE, '')
		// Node converts strings with length < 2 to ''
		if (str.length < 2) return ''
		// Node allows for non-padded base64 strings (missing trailing ===), base64-js does not
		while (str.length % 4 !== 0) {
			str = str + '='
		}
		return str
	}
	
	function stringtrim (str) {
		if (str.trim) return str.trim()
		return str.replace(/^\s+|\s+$/g, '')
	}
	
	function toHex (n) {
		if (n < 16) return '0' + n.toString(16)
		return n.toString(16)
	}
	
	function utf8ToBytes (string, units) {
		units = units || Infinity
		var codePoint
		var length = string.length
		var leadSurrogate = null
		var bytes = []
	
		for (var i = 0; i < length; ++i) {
			codePoint = string.charCodeAt(i)
	
			// is surrogate component
			if (codePoint > 0xD7FF && codePoint < 0xE000) {
				// last char was a lead
				if (!leadSurrogate) {
					// no lead yet
					if (codePoint > 0xDBFF) {
						// unexpected trail
						if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
						continue
					} else if (i + 1 === length) {
						// unpaired lead
						if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
						continue
					}
	
					// valid lead
					leadSurrogate = codePoint
	
					continue
				}
	
				// 2 leads in a row
				if (codePoint < 0xDC00) {
					if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
					leadSurrogate = codePoint
					continue
				}
	
				// valid surrogate pair
				codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000
			} else if (leadSurrogate) {
				// valid bmp char, but last char was a lead
				if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)
			}
	
			leadSurrogate = null
	
			// encode utf8
			if (codePoint < 0x80) {
				if ((units -= 1) < 0) break
				bytes.push(codePoint)
			} else if (codePoint < 0x800) {
				if ((units -= 2) < 0) break
				bytes.push(
					codePoint >> 0x6 | 0xC0,
					codePoint & 0x3F | 0x80
				)
			} else if (codePoint < 0x10000) {
				if ((units -= 3) < 0) break
				bytes.push(
					codePoint >> 0xC | 0xE0,
					codePoint >> 0x6 & 0x3F | 0x80,
					codePoint & 0x3F | 0x80
				)
			} else if (codePoint < 0x110000) {
				if ((units -= 4) < 0) break
				bytes.push(
					codePoint >> 0x12 | 0xF0,
					codePoint >> 0xC & 0x3F | 0x80,
					codePoint >> 0x6 & 0x3F | 0x80,
					codePoint & 0x3F | 0x80
				)
			} else {
				throw new Error('Invalid code point')
			}
		}
	
		return bytes
	}
	
	function asciiToBytes (str) {
		var byteArray = []
		for (var i = 0; i < str.length; ++i) {
			// Node's code seems to be doing this and not & 0x7F..
			byteArray.push(str.charCodeAt(i) & 0xFF)
		}
		return byteArray
	}
	
	function utf16leToBytes (str, units) {
		var c, hi, lo
		var byteArray = []
		for (var i = 0; i < str.length; ++i) {
			if ((units -= 2) < 0) break
	
			c = str.charCodeAt(i)
			hi = c >> 8
			lo = c % 256
			byteArray.push(lo)
			byteArray.push(hi)
		}
	
		return byteArray
	}
	
	function base64ToBytes (str) {
		return base64.toByteArray(base64clean(str))
	}
	
	function blitBuffer (src, dst, offset, length) {
		for (var i = 0; i < length; ++i) {
			if ((i + offset >= dst.length) || (i >= src.length)) break
			dst[i + offset] = src[i]
		}
		return i
	}
	
	function isnan (val) {
		return val !== val // eslint-disable-line no-self-compare
	}
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))
	
	/***/ }),
	/* 28 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	/* WEBPACK VAR INJECTION */(function(process, setImmediate, global) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// A bit simpler than readable streams.
	// Implement an async ._write(chunk, encoding, cb), and it'll handle all
	// the drain event emission and buffering.
	
	
	
	/*<replacement>*/
	
	var pna = __webpack_require__(18);
	/*</replacement>*/
	
	module.exports = Writable;
	
	/* <replacement> */
	function WriteReq(chunk, encoding, cb) {
		this.chunk = chunk;
		this.encoding = encoding;
		this.callback = cb;
		this.next = null;
	}
	
	// It seems a linked list but it is not
	// there will be only 2 of these for each stream
	function CorkedRequest(state) {
		var _this = this;
	
		this.next = null;
		this.entry = null;
		this.finish = function () {
			onCorkedFinish(_this, state);
		};
	}
	/* </replacement> */
	
	/*<replacement>*/
	var asyncWrite = !process.browser && ['v0.10', 'v0.9.'].indexOf(process.version.slice(0, 5)) > -1 ? setImmediate : pna.nextTick;
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Writable.WritableState = WritableState;
	
	/*<replacement>*/
	var util = __webpack_require__(16);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	/*<replacement>*/
	var internalUtil = {
		deprecate: __webpack_require__(96)
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream = __webpack_require__(43);
	/*</replacement>*/
	
	/*<replacement>*/
	
	var Buffer = __webpack_require__(26).Buffer;
	var OurUint8Array = global.Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
		return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
		return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	
	/*</replacement>*/
	
	var destroyImpl = __webpack_require__(44);
	
	util.inherits(Writable, Stream);
	
	function nop() {}
	
	function WritableState(options, stream) {
		Duplex = Duplex || __webpack_require__(9);
	
		options = options || {};
	
		// Duplex streams are both readable and writable, but share
		// the same options object.
		// However, some cases require setting options to different
		// values for the readable and the writable sides of the duplex stream.
		// These options can be provided separately as readableXXX and writableXXX.
		var isDuplex = stream instanceof Duplex;
	
		// object stream flag to indicate whether or not this stream
		// contains buffers or objects.
		this.objectMode = !!options.objectMode;
	
		if (isDuplex) this.objectMode = this.objectMode || !!options.writableObjectMode;
	
		// the point at which write() starts returning false
		// Note: 0 is a valid value, means that we always return false if
		// the entire buffer is not flushed immediately on write()
		var hwm = options.highWaterMark;
		var writableHwm = options.writableHighWaterMark;
		var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	
		if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (writableHwm || writableHwm === 0)) this.highWaterMark = writableHwm;else this.highWaterMark = defaultHwm;
	
		// cast to ints.
		this.highWaterMark = Math.floor(this.highWaterMark);
	
		// if _final has been called
		this.finalCalled = false;
	
		// drain event flag.
		this.needDrain = false;
		// at the start of calling end()
		this.ending = false;
		// when end() has been called, and returned
		this.ended = false;
		// when 'finish' is emitted
		this.finished = false;
	
		// has it been destroyed
		this.destroyed = false;
	
		// should we decode strings into buffers before passing to _write?
		// this is here so that some node-core streams can optimize string
		// handling at a lower level.
		var noDecode = options.decodeStrings === false;
		this.decodeStrings = !noDecode;
	
		// Crypto is kind of old and crusty.  Historically, its default string
		// encoding is 'binary' so we have to make this configurable.
		// Everything else in the universe uses 'utf8', though.
		this.defaultEncoding = options.defaultEncoding || 'utf8';
	
		// not an actual buffer we keep track of, but a measurement
		// of how much we're waiting to get pushed to some underlying
		// socket or file.
		this.length = 0;
	
		// a flag to see when we're in the middle of a write.
		this.writing = false;
	
		// when true all writes will be buffered until .uncork() call
		this.corked = 0;
	
		// a flag to be able to tell if the onwrite cb is called immediately,
		// or on a later tick.  We set this to true at first, because any
		// actions that shouldn't happen until "later" should generally also
		// not happen before the first write call.
		this.sync = true;
	
		// a flag to know if we're processing previously buffered items, which
		// may call the _write() callback in the same tick, so that we don't
		// end up in an overlapped onwrite situation.
		this.bufferProcessing = false;
	
		// the callback that's passed to _write(chunk,cb)
		this.onwrite = function (er) {
			onwrite(stream, er);
		};
	
		// the callback that the user supplies to write(chunk,encoding,cb)
		this.writecb = null;
	
		// the amount that is being written when _write is called.
		this.writelen = 0;
	
		this.bufferedRequest = null;
		this.lastBufferedRequest = null;
	
		// number of pending user-supplied write callbacks
		// this must be 0 before 'finish' can be emitted
		this.pendingcb = 0;
	
		// emit prefinish if the only thing we're waiting for is _write cbs
		// This is relevant for synchronous Transform streams
		this.prefinished = false;
	
		// True if the error was already emitted and should not be thrown again
		this.errorEmitted = false;
	
		// count buffered requests
		this.bufferedRequestCount = 0;
	
		// allocate the first CorkedRequest, there is always
		// one allocated and free to use, and we maintain at most two
		this.corkedRequestsFree = new CorkedRequest(this);
	}
	
	WritableState.prototype.getBuffer = function getBuffer() {
		var current = this.bufferedRequest;
		var out = [];
		while (current) {
			out.push(current);
			current = current.next;
		}
		return out;
	};
	
	(function () {
		try {
			Object.defineProperty(WritableState.prototype, 'buffer', {
				get: internalUtil.deprecate(function () {
					return this.getBuffer();
				}, '_writableState.buffer is deprecated. Use _writableState.getBuffer ' + 'instead.', 'DEP0003')
			});
		} catch (_) {}
	})();
	
	// Test _writableState for inheritance to account for Duplex streams,
	// whose prototype chain only points to Readable.
	var realHasInstance;
	if (typeof Symbol === 'function' && Symbol.hasInstance && typeof Function.prototype[Symbol.hasInstance] === 'function') {
		realHasInstance = Function.prototype[Symbol.hasInstance];
		Object.defineProperty(Writable, Symbol.hasInstance, {
			value: function (object) {
				if (realHasInstance.call(this, object)) return true;
				if (this !== Writable) return false;
	
				return object && object._writableState instanceof WritableState;
			}
		});
	} else {
		realHasInstance = function (object) {
			return object instanceof this;
		};
	}
	
	function Writable(options) {
		Duplex = Duplex || __webpack_require__(9);
	
		// Writable ctor is applied to Duplexes, too.
		// `realHasInstance` is necessary because using plain `instanceof`
		// would return false, as no `_writableState` property is attached.
	
		// Trying to use the custom `instanceof` for Writable here will also break the
		// Node.js LazyTransform implementation, which has a non-trivial getter for
		// `_writableState` that would lead to infinite recursion.
		if (!realHasInstance.call(Writable, this) && !(this instanceof Duplex)) {
			return new Writable(options);
		}
	
		this._writableState = new WritableState(options, this);
	
		// legacy.
		this.writable = true;
	
		if (options) {
			if (typeof options.write === 'function') this._write = options.write;
	
			if (typeof options.writev === 'function') this._writev = options.writev;
	
			if (typeof options.destroy === 'function') this._destroy = options.destroy;
	
			if (typeof options.final === 'function') this._final = options.final;
		}
	
		Stream.call(this);
	}
	
	// Otherwise people can pipe Writable streams, which is just wrong.
	Writable.prototype.pipe = function () {
		this.emit('error', new Error('Cannot pipe, not readable'));
	};
	
	function writeAfterEnd(stream, cb) {
		var er = new Error('write after end');
		// TODO: defer error events consistently everywhere, not just the cb
		stream.emit('error', er);
		pna.nextTick(cb, er);
	}
	
	// Checks that a user-supplied chunk is valid, especially for the particular
	// mode the stream is in. Currently this means that `null` is never accepted
	// and undefined/non-string values are only allowed in object mode.
	function validChunk(stream, state, chunk, cb) {
		var valid = true;
		var er = false;
	
		if (chunk === null) {
			er = new TypeError('May not write null values to stream');
		} else if (typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
			er = new TypeError('Invalid non-string/buffer chunk');
		}
		if (er) {
			stream.emit('error', er);
			pna.nextTick(cb, er);
			valid = false;
		}
		return valid;
	}
	
	Writable.prototype.write = function (chunk, encoding, cb) {
		var state = this._writableState;
		var ret = false;
		var isBuf = !state.objectMode && _isUint8Array(chunk);
	
		if (isBuf && !Buffer.isBuffer(chunk)) {
			chunk = _uint8ArrayToBuffer(chunk);
		}
	
		if (typeof encoding === 'function') {
			cb = encoding;
			encoding = null;
		}
	
		if (isBuf) encoding = 'buffer';else if (!encoding) encoding = state.defaultEncoding;
	
		if (typeof cb !== 'function') cb = nop;
	
		if (state.ended) writeAfterEnd(this, cb);else if (isBuf || validChunk(this, state, chunk, cb)) {
			state.pendingcb++;
			ret = writeOrBuffer(this, state, isBuf, chunk, encoding, cb);
		}
	
		return ret;
	};
	
	Writable.prototype.cork = function () {
		var state = this._writableState;
	
		state.corked++;
	};
	
	Writable.prototype.uncork = function () {
		var state = this._writableState;
	
		if (state.corked) {
			state.corked--;
	
			if (!state.writing && !state.corked && !state.finished && !state.bufferProcessing && state.bufferedRequest) clearBuffer(this, state);
		}
	};
	
	Writable.prototype.setDefaultEncoding = function setDefaultEncoding(encoding) {
		// node::ParseEncoding() requires lower case.
		if (typeof encoding === 'string') encoding = encoding.toLowerCase();
		if (!(['hex', 'utf8', 'utf-8', 'ascii', 'binary', 'base64', 'ucs2', 'ucs-2', 'utf16le', 'utf-16le', 'raw'].indexOf((encoding + '').toLowerCase()) > -1)) throw new TypeError('Unknown encoding: ' + encoding);
		this._writableState.defaultEncoding = encoding;
		return this;
	};
	
	function decodeChunk(state, chunk, encoding) {
		if (!state.objectMode && state.decodeStrings !== false && typeof chunk === 'string') {
			chunk = Buffer.from(chunk, encoding);
		}
		return chunk;
	}
	
	Object.defineProperty(Writable.prototype, 'writableHighWaterMark', {
		// making it explicit this property is not enumerable
		// because otherwise some prototype manipulation in
		// userland will fail
		enumerable: false,
		get: function () {
			return this._writableState.highWaterMark;
		}
	});
	
	// if we're already writing something, then just put this
	// in the queue, and wait our turn.  Otherwise, call _write
	// If we return false, then we need a drain event, so set that flag.
	function writeOrBuffer(stream, state, isBuf, chunk, encoding, cb) {
		if (!isBuf) {
			var newChunk = decodeChunk(state, chunk, encoding);
			if (chunk !== newChunk) {
				isBuf = true;
				encoding = 'buffer';
				chunk = newChunk;
			}
		}
		var len = state.objectMode ? 1 : chunk.length;
	
		state.length += len;
	
		var ret = state.length < state.highWaterMark;
		// we must ensure that previous needDrain will not be reset to false.
		if (!ret) state.needDrain = true;
	
		if (state.writing || state.corked) {
			var last = state.lastBufferedRequest;
			state.lastBufferedRequest = {
				chunk: chunk,
				encoding: encoding,
				isBuf: isBuf,
				callback: cb,
				next: null
			};
			if (last) {
				last.next = state.lastBufferedRequest;
			} else {
				state.bufferedRequest = state.lastBufferedRequest;
			}
			state.bufferedRequestCount += 1;
		} else {
			doWrite(stream, state, false, len, chunk, encoding, cb);
		}
	
		return ret;
	}
	
	function doWrite(stream, state, writev, len, chunk, encoding, cb) {
		state.writelen = len;
		state.writecb = cb;
		state.writing = true;
		state.sync = true;
		if (writev) stream._writev(chunk, state.onwrite);else stream._write(chunk, encoding, state.onwrite);
		state.sync = false;
	}
	
	function onwriteError(stream, state, sync, er, cb) {
		--state.pendingcb;
	
		if (sync) {
			// defer the callback if we are being called synchronously
			// to avoid piling up things on the stack
			pna.nextTick(cb, er);
			// this can emit finish, and it will always happen
			// after error
			pna.nextTick(finishMaybe, stream, state);
			stream._writableState.errorEmitted = true;
			stream.emit('error', er);
		} else {
			// the caller expect this to happen before if
			// it is async
			cb(er);
			stream._writableState.errorEmitted = true;
			stream.emit('error', er);
			// this can emit finish, but finish must
			// always follow error
			finishMaybe(stream, state);
		}
	}
	
	function onwriteStateUpdate(state) {
		state.writing = false;
		state.writecb = null;
		state.length -= state.writelen;
		state.writelen = 0;
	}
	
	function onwrite(stream, er) {
		var state = stream._writableState;
		var sync = state.sync;
		var cb = state.writecb;
	
		onwriteStateUpdate(state);
	
		if (er) onwriteError(stream, state, sync, er, cb);else {
			// Check if we're actually ready to finish, but don't emit yet
			var finished = needFinish(state);
	
			if (!finished && !state.corked && !state.bufferProcessing && state.bufferedRequest) {
				clearBuffer(stream, state);
			}
	
			if (sync) {
				/*<replacement>*/
				asyncWrite(afterWrite, stream, state, finished, cb);
				/*</replacement>*/
			} else {
				afterWrite(stream, state, finished, cb);
			}
		}
	}
	
	function afterWrite(stream, state, finished, cb) {
		if (!finished) onwriteDrain(stream, state);
		state.pendingcb--;
		cb();
		finishMaybe(stream, state);
	}
	
	// Must force callback to be called on nextTick, so that we don't
	// emit 'drain' before the write() consumer gets the 'false' return
	// value, and has a chance to attach a 'drain' listener.
	function onwriteDrain(stream, state) {
		if (state.length === 0 && state.needDrain) {
			state.needDrain = false;
			stream.emit('drain');
		}
	}
	
	// if there's something in the buffer waiting, then process it
	function clearBuffer(stream, state) {
		state.bufferProcessing = true;
		var entry = state.bufferedRequest;
	
		if (stream._writev && entry && entry.next) {
			// Fast case, write everything using _writev()
			var l = state.bufferedRequestCount;
			var buffer = new Array(l);
			var holder = state.corkedRequestsFree;
			holder.entry = entry;
	
			var count = 0;
			var allBuffers = true;
			while (entry) {
				buffer[count] = entry;
				if (!entry.isBuf) allBuffers = false;
				entry = entry.next;
				count += 1;
			}
			buffer.allBuffers = allBuffers;
	
			doWrite(stream, state, true, state.length, buffer, '', holder.finish);
	
			// doWrite is almost always async, defer these to save a bit of time
			// as the hot path ends with doWrite
			state.pendingcb++;
			state.lastBufferedRequest = null;
			if (holder.next) {
				state.corkedRequestsFree = holder.next;
				holder.next = null;
			} else {
				state.corkedRequestsFree = new CorkedRequest(state);
			}
			state.bufferedRequestCount = 0;
		} else {
			// Slow case, write chunks one-by-one
			while (entry) {
				var chunk = entry.chunk;
				var encoding = entry.encoding;
				var cb = entry.callback;
				var len = state.objectMode ? 1 : chunk.length;
	
				doWrite(stream, state, false, len, chunk, encoding, cb);
				entry = entry.next;
				state.bufferedRequestCount--;
				// if we didn't call the onwrite immediately, then
				// it means that we need to wait until it does.
				// also, that means that the chunk and cb are currently
				// being processed, so move the buffer counter past them.
				if (state.writing) {
					break;
				}
			}
	
			if (entry === null) state.lastBufferedRequest = null;
		}
	
		state.bufferedRequest = entry;
		state.bufferProcessing = false;
	}
	
	Writable.prototype._write = function (chunk, encoding, cb) {
		cb(new Error('_write() is not implemented'));
	};
	
	Writable.prototype._writev = null;
	
	Writable.prototype.end = function (chunk, encoding, cb) {
		var state = this._writableState;
	
		if (typeof chunk === 'function') {
			cb = chunk;
			chunk = null;
			encoding = null;
		} else if (typeof encoding === 'function') {
			cb = encoding;
			encoding = null;
		}
	
		if (chunk !== null && chunk !== undefined) this.write(chunk, encoding);
	
		// .end() fully uncorks
		if (state.corked) {
			state.corked = 1;
			this.uncork();
		}
	
		// ignore unnecessary end() calls.
		if (!state.ending && !state.finished) endWritable(this, state, cb);
	};
	
	function needFinish(state) {
		return state.ending && state.length === 0 && state.bufferedRequest === null && !state.finished && !state.writing;
	}
	function callFinal(stream, state) {
		stream._final(function (err) {
			state.pendingcb--;
			if (err) {
				stream.emit('error', err);
			}
			state.prefinished = true;
			stream.emit('prefinish');
			finishMaybe(stream, state);
		});
	}
	function prefinish(stream, state) {
		if (!state.prefinished && !state.finalCalled) {
			if (typeof stream._final === 'function') {
				state.pendingcb++;
				state.finalCalled = true;
				pna.nextTick(callFinal, stream, state);
			} else {
				state.prefinished = true;
				stream.emit('prefinish');
			}
		}
	}
	
	function finishMaybe(stream, state) {
		var need = needFinish(state);
		if (need) {
			prefinish(stream, state);
			if (state.pendingcb === 0) {
				state.finished = true;
				stream.emit('finish');
			}
		}
		return need;
	}
	
	function endWritable(stream, state, cb) {
		state.ending = true;
		finishMaybe(stream, state);
		if (cb) {
			if (state.finished) pna.nextTick(cb);else stream.once('finish', cb);
		}
		state.ended = true;
		stream.writable = false;
	}
	
	function onCorkedFinish(corkReq, state, err) {
		var entry = corkReq.entry;
		corkReq.entry = null;
		while (entry) {
			var cb = entry.callback;
			state.pendingcb--;
			cb(err);
			entry = entry.next;
		}
		if (state.corkedRequestsFree) {
			state.corkedRequestsFree.next = corkReq;
		} else {
			state.corkedRequestsFree = corkReq;
		}
	}
	
	Object.defineProperty(Writable.prototype, 'destroyed', {
		get: function () {
			if (this._writableState === undefined) {
				return false;
			}
			return this._writableState.destroyed;
		},
		set: function (value) {
			// we ignore the value if the stream
			// has not been initialized yet
			if (!this._writableState) {
				return;
			}
	
			// backward compatibility, the user is explicitly
			// managing destroyed
			this._writableState.destroyed = value;
		}
	});
	
	Writable.prototype.destroy = destroyImpl.destroy;
	Writable.prototype._undestroy = destroyImpl.undestroy;
	Writable.prototype._destroy = function (err, cb) {
		this.end();
		cb(err);
	};
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15), __webpack_require__(94).setImmediate, __webpack_require__(12)))
	
	/***/ }),
	/* 29 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var MathBox, Renderable, Scene, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	THREE = __webpack_require__(1);
	
	Renderable = __webpack_require__(10);
	
	
	/*
	 All MathBox renderables sit inside this root, to keep things tidy.
	 */
	
	MathBox = (function(superClass) {
		extend(MathBox, superClass);
	
		function MathBox() {
			MathBox.__super__.constructor.apply(this, arguments);
			this.rotationAutoUpdate = false;
			this.frustumCulled = false;
			this.matrixAutoUpdate = false;
		}
	
		return MathBox;
	
	})(THREE.Object3D);
	
	
	/*
	 Holds the root and binds to a THREE.Scene
	
	 Will hold objects and inject them a few at a time
	 to avoid long UI blocks.
	
	 Will render injected objects to a 1x1 scratch buffer to ensure availability
	 */
	
	Scene = (function(superClass) {
		extend(Scene, superClass);
	
		function Scene(renderer, shaders, options) {
			Scene.__super__.constructor.call(this, renderer, shaders, options);
			this.root = new MathBox;
			if ((options != null ? options.scene : void 0) != null) {
				this.scene = options.scene;
			}
			if (this.scene == null) {
				this.scene = new THREE.Scene;
			}
			this.pending = [];
			this.async = 0;
			this.scratch = new THREE.WebGLRenderTarget(1, 1);
			this.camera = new THREE.PerspectiveCamera;
		}
	
		Scene.prototype.inject = function(scene) {
			if (scene != null) {
				this.scene = scene;
			}
			return this.scene.add(this.root);
		};
	
		Scene.prototype.unject = function() {
			var ref;
			return (ref = this.scene) != null ? ref.remove(this.root) : void 0;
		};
	
		Scene.prototype.add = function(object) {
			if (this.async) {
				return this.pending.push(object);
			} else {
				return this._add(object);
			}
		};
	
		Scene.prototype.remove = function(object) {
			this.pending = this.pending.filter(function(o) {
				return o !== object;
			});
			if (object.parent != null) {
				return this._remove(object);
			}
		};
	
		Scene.prototype._add = function(object) {
			return this.root.add(object);
		};
	
		Scene.prototype._remove = function(object) {
			return this.root.remove(object);
		};
	
		Scene.prototype.dispose = function() {
			if (this.root.parent != null) {
				return this.unject();
			}
		};
	
		Scene.prototype.warmup = function(n) {
			return this.async = +n || 0;
		};
	
		Scene.prototype.render = function() {
			var added, children, i, j, pending, ref, visible;
			if (!this.pending.length) {
				return;
			}
			children = this.root.children;
			added = [];
			for (i = j = 0, ref = this.async; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
				pending = this.pending.shift();
				if (!pending) {
					break;
				}
				this._add(pending);
				added.push(added);
			}
			visible = children.map(function(o) {
				var v;
				return v = o.visible;
			});
			children.map(function(o) {
				return o.visible = indexOf.call(added, o) < 0;
			});
			this.renderer.render(this.scene, this.camera, this.scratch);
			return children.map(function(o, i) {
				return o.visible = visible[i];
			});
		};
	
		Scene.prototype.toJSON = function() {
			return this.root.toJSON();
		};
	
		return Scene;
	
	})(Renderable);
	
	module.exports = Scene;
	
	
	/***/ }),
	/* 30 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, Renderable, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Renderable = __webpack_require__(10);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * Base class for sample buffers
	 */
	
	Buffer = (function(superClass) {
		extend(Buffer, superClass);
	
		function Buffer(renderer, shaders, options) {
			if (this.items == null) {
				this.items = options.items || 1;
			}
			if (this.samples == null) {
				this.samples = options.samples || 1;
			}
			if (this.channels == null) {
				this.channels = options.channels || 4;
			}
			if (this.callback == null) {
				this.callback = options.callback || function() {};
			}
			Buffer.__super__.constructor.call(this, renderer, shaders);
		}
	
		Buffer.prototype.dispose = function() {
			return Buffer.__super__.dispose.apply(this, arguments);
		};
	
		Buffer.prototype.update = function() {
			var n;
			n = this.fill();
			this.write(n);
			return n;
		};
	
		Buffer.prototype.setActive = function(i, j, k, l) {};
	
		Buffer.prototype.setCallback = function(callback) {
			this.callback = callback;
		};
	
		Buffer.prototype.write = function() {};
	
		Buffer.prototype.fill = function() {};
	
		Buffer.prototype.generate = function(data) {
			return Util.Data.getStreamer(data, this.samples, this.channels, this.items);
		};
	
		return Buffer;
	
	})(Renderable);
	
	module.exports = Buffer;
	
	
	/***/ }),
	/* 31 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var DataTexture, THREE, Util;
	
	THREE = __webpack_require__(1);
	
	Util = __webpack_require__(0);
	
	
	/*
	Manually allocated GL texture for data streaming.
	
	Allows partial updates via subImage.
	 */
	
	DataTexture = (function() {
		function DataTexture(renderer, width, height, channels, options) {
			var gl, magFilter, minFilter, ref, ref1, ref2, type;
			this.renderer = renderer;
			this.width = width;
			this.height = height;
			this.channels = channels;
			this.n = this.width * this.height * this.channels;
			gl = this.gl = this.renderer.context;
			minFilter = (ref = options.minFilter) != null ? ref : THREE.NearestFilter;
			magFilter = (ref1 = options.magFilter) != null ? ref1 : THREE.NearestFilter;
			type = (ref2 = options.type) != null ? ref2 : THREE.FloatType;
			this.minFilter = Util.Three.paramToGL(gl, minFilter);
			this.magFilter = Util.Three.paramToGL(gl, magFilter);
			this.type = Util.Three.paramToGL(gl, type);
			this.ctor = Util.Three.paramToArrayStorage(type);
			this.build(options);
		}
	
		DataTexture.prototype.build = function(options) {
			var gl, state;
			gl = this.gl;
			state = this.renderer.state;
			this.texture = gl.createTexture();
			this.format = [null, gl.LUMINANCE, gl.LUMINANCE_ALPHA, gl.RGB, gl.RGBA][this.channels];
			this.format3 = [null, THREE.LuminanceFormat, THREE.LuminanceAlphaFormat, THREE.RGBFormat, THREE.RGBAFormat][this.channels];
			state.bindTexture(gl.TEXTURE_2D, this.texture);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, this.minFilter);
			gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, this.magFilter);
			this.data = new this.ctor(this.n);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, this.format, this.width, this.height, 0, this.format, this.type, this.data);
			this.textureObject = new THREE.Texture(new Image(), THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, options.minFilter, options.magFilter);
			this.textureProperties = this.renderer.properties.get(this.textureObject);
			this.textureProperties.__webglInit = true;
			this.textureProperties.__webglTexture = this.texture;
			this.textureObject.format = this.format3;
			this.textureObject.type = THREE.FloatType;
			this.textureObject.unpackAlignment = 1;
			this.textureObject.flipY = false;
			this.textureObject.generateMipmaps = false;
			return this.uniforms = {
				dataResolution: {
					type: 'v2',
					value: new THREE.Vector2(1 / this.width, 1 / this.height)
				},
				dataTexture: {
					type: 't',
					value: this.textureObject
				}
			};
		};
	
		DataTexture.prototype.write = function(data, x, y, w, h) {
			var gl, state;
			gl = this.gl;
			state = this.renderer.state;
			state.bindTexture(gl.TEXTURE_2D, this.texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, false);
			gl.pixelStorei(gl.UNPACK_PREMULTIPLY_ALPHA_WEBGL, false);
			return gl.texSubImage2D(gl.TEXTURE_2D, 0, x, y, w, h, this.format, this.type, data);
		};
	
		DataTexture.prototype.dispose = function() {
			this.gl.deleteTexture(this.texture);
			this.textureProperties.__webglInit = false;
			this.textureProperties.__webglTexture = null;
			this.textureProperties = null;
			return this.textureObject = this.texture = null;
		};
	
		return DataTexture;
	
	})();
	
	module.exports = DataTexture;
	
	
	/***/ }),
	/* 32 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Block = __webpack_require__(17);
	
	exports.Call = __webpack_require__(208);
	
	exports.Callback = __webpack_require__(209);
	
	exports.Isolate = __webpack_require__(210);
	
	exports.Join = __webpack_require__(211);
	
	
	/***/ }),
	/* 33 */
	/***/ (function(module, exports) {
	
	
	/*
		Graph of nodes with outlets
	 */
	var Graph;
	
	Graph = (function() {
		Graph.index = 0;
	
		Graph.id = function(name) {
			return ++Graph.index;
		};
	
		Graph.IN = 0;
	
		Graph.OUT = 1;
	
		function Graph(nodes, parent) {
			this.parent = parent != null ? parent : null;
			this.id = Graph.id();
			this.nodes = [];
			nodes && this.add(nodes);
		}
	
		Graph.prototype.inputs = function() {
			var i, inputs, j, len, len1, node, outlet, ref, ref1;
			inputs = [];
			ref = this.nodes;
			for (i = 0, len = ref.length; i < len; i++) {
				node = ref[i];
				ref1 = node.inputs;
				for (j = 0, len1 = ref1.length; j < len1; j++) {
					outlet = ref1[j];
					if (outlet.input === null) {
						inputs.push(outlet);
					}
				}
			}
			return inputs;
		};
	
		Graph.prototype.outputs = function() {
			var i, j, len, len1, node, outlet, outputs, ref, ref1;
			outputs = [];
			ref = this.nodes;
			for (i = 0, len = ref.length; i < len; i++) {
				node = ref[i];
				ref1 = node.outputs;
				for (j = 0, len1 = ref1.length; j < len1; j++) {
					outlet = ref1[j];
					if (outlet.output.length === 0) {
						outputs.push(outlet);
					}
				}
			}
			return outputs;
		};
	
		Graph.prototype.getIn = function(name) {
			var outlet;
			return ((function() {
				var i, len, ref, results;
				ref = this.inputs();
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					outlet = ref[i];
					if (outlet.name === name) {
						results.push(outlet);
					}
				}
				return results;
			}).call(this))[0];
		};
	
		Graph.prototype.getOut = function(name) {
			var outlet;
			return ((function() {
				var i, len, ref, results;
				ref = this.outputs();
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					outlet = ref[i];
					if (outlet.name === name) {
						results.push(outlet);
					}
				}
				return results;
			}).call(this))[0];
		};
	
		Graph.prototype.add = function(node, ignore) {
			var _node, i, len;
			if (node.length) {
				for (i = 0, len = node.length; i < len; i++) {
					_node = node[i];
					this.add(_node);
				}
				return;
			}
			if (node.graph && !ignore) {
				throw new Error("Adding node to two graphs at once");
			}
			node.graph = this;
			return this.nodes.push(node);
		};
	
		Graph.prototype.remove = function(node, ignore) {
			var _node, i, len;
			if (node.length) {
				for (i = 0, len = node.length; i < len; i++) {
					_node = node[i];
					this.remove(_node);
				}
				return;
			}
			if (node.graph !== this) {
				throw new Error("Removing node from wrong graph.");
			}
			ignore || node.disconnect();
			this.nodes.splice(this.nodes.indexOf(node), 1);
			return node.graph = null;
		};
	
		Graph.prototype.adopt = function(node) {
			var _node, i, len;
			if (node.length) {
				for (i = 0, len = node.length; i < len; i++) {
					_node = node[i];
					this.adopt(_node);
				}
				return;
			}
			node.graph.remove(node, true);
			return this.add(node, true);
		};
	
		return Graph;
	
	})();
	
	module.exports = Graph;
	
	
	/***/ }),
	/* 34 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Snippet = __webpack_require__(35);
	
	exports.Program = __webpack_require__(206);
	
	exports.Layout = __webpack_require__(207);
	
	exports.assemble = __webpack_require__(62);
	
	exports.link = __webpack_require__(63);
	
	exports.priority = __webpack_require__(36);
	
	exports.load = exports.Snippet.load;
	
	
	/***/ }),
	/* 35 */
	/***/ (function(module, exports) {
	
	var Snippet;
	
	Snippet = (function() {
		Snippet.index = 0;
	
		Snippet.namespace = function() {
			return "_sn_" + (++Snippet.index) + "_";
		};
	
		Snippet.load = function(language, name, code) {
			var compiler, program, ref, sigs;
			program = language.parse(name, code);
			ref = language.compile(program), sigs = ref[0], compiler = ref[1];
			return new Snippet(language, sigs, compiler, name, code);
		};
	
		function Snippet(language1, _signatures, _compiler, _name, _original) {
			var ref;
			this.language = language1;
			this._signatures = _signatures;
			this._compiler = _compiler;
			this._name = _name;
			this._original = _original;
			this.namespace = null;
			this.code = null;
			this.main = null;
			this.entry = null;
			this.uniforms = null;
			this.externals = null;
			this.symbols = null;
			this.attributes = null;
			this.varyings = null;
			if (!this.language) {
				delete this.language;
			}
			if (!this._signatures) {
				delete this._signatures;
			}
			if (!this._compiler) {
				delete this._compiler;
			}
			if (!this._original) {
				delete this._original;
			}
			if (!this._name) {
				this._name = (ref = this._signatures) != null ? ref.main.name : void 0;
			}
		}
	
		Snippet.prototype.clone = function() {
			return new Snippet(this.language, this._signatures, this._compiler, this._name, this._original);
		};
	
		Snippet.prototype.bind = function(config, uniforms, namespace, defines) {
			var _a, _e, _u, _v, a, def, defs, e, exceptions, exist, global, i, j, k, key, l, len, len1, len2, len3, len4, len5, local, m, n, name, o, redef, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, u, v, x;
			if (uniforms === '' + uniforms) {
				ref = [uniforms, namespace != null ? namespace : {}, defines != null ? defines : {}], namespace = ref[0], uniforms = ref[1], defines = ref[2];
			} else if (namespace !== '' + namespace) {
				ref1 = [namespace != null ? namespace : {}, void 0], defines = ref1[0], namespace = ref1[1];
			}
			this.main = this._signatures.main;
			this.namespace = (ref2 = namespace != null ? namespace : this.namespace) != null ? ref2 : Snippet.namespace();
			this.entry = this.namespace + this.main.name;
			this.uniforms = {};
			this.varyings = {};
			this.attributes = {};
			this.externals = {};
			this.symbols = [];
			exist = {};
			exceptions = {};
			global = function(name) {
				exceptions[name] = true;
				return name;
			};
			local = (function(_this) {
				return function(name) {
					return _this.namespace + name;
				};
			})(this);
			if (config.globals) {
				ref3 = config.globals;
				for (i = 0, len = ref3.length; i < len; i++) {
					key = ref3[i];
					global(key);
				}
			}
			_u = config.globalUniforms ? global : local;
			_v = config.globalVaryings ? global : local;
			_a = config.globalAttributes ? global : local;
			_e = local;
			x = (function(_this) {
				return function(def) {
					return exist[def.name] = true;
				};
			})(this);
			u = (function(_this) {
				return function(def, name) {
					return _this.uniforms[_u(name != null ? name : def.name)] = def;
				};
			})(this);
			v = (function(_this) {
				return function(def) {
					return _this.varyings[_v(def.name)] = def;
				};
			})(this);
			a = (function(_this) {
				return function(def) {
					return _this.attributes[_a(def.name)] = def;
				};
			})(this);
			e = (function(_this) {
				return function(def) {
					var name;
					name = _e(def.name);
					_this.externals[name] = def;
					return _this.symbols.push(name);
				};
			})(this);
			redef = function(def) {
				return {
					type: def.type,
					name: def.name,
					value: def.value
				};
			};
			ref4 = this._signatures.uniform;
			for (j = 0, len1 = ref4.length; j < len1; j++) {
				def = ref4[j];
				x(def);
			}
			ref5 = this._signatures.uniform;
			for (l = 0, len2 = ref5.length; l < len2; l++) {
				def = ref5[l];
				u(redef(def));
			}
			ref6 = this._signatures.varying;
			for (m = 0, len3 = ref6.length; m < len3; m++) {
				def = ref6[m];
				v(redef(def));
			}
			ref7 = this._signatures.external;
			for (n = 0, len4 = ref7.length; n < len4; n++) {
				def = ref7[n];
				e(def);
			}
			ref8 = this._signatures.attribute;
			for (o = 0, len5 = ref8.length; o < len5; o++) {
				def = ref8[o];
				a(redef(def));
			}
			for (name in uniforms) {
				def = uniforms[name];
				if (exist[name]) {
					u(def, name);
				}
			}
			this.body = this.code = this._compiler(this.namespace, exceptions, defines);
			if (defines) {
				defs = ((function() {
					var results;
					results = [];
					for (k in defines) {
						v = defines[k];
						results.push("#define " + k + " " + v);
					}
					return results;
				})()).join('\n');
				if (defs.length) {
					this._original = [defs, "//----------------------------------------", this._original].join("\n");
				}
			}
			return null;
		};
	
		return Snippet;
	
	})();
	
	module.exports = Snippet;
	
	
	/***/ }),
	/* 36 */
	/***/ (function(module, exports) {
	
	exports.make = function(x) {
		var ref;
		if (x == null) {
			x = [];
		}
		if (!(x instanceof Array)) {
			x = [(ref = +x) != null ? ref : 0];
		}
		return x;
	};
	
	exports.nest = function(a, b) {
		return a.concat(b);
	};
	
	exports.compare = function(a, b) {
		var i, j, n, p, q, ref;
		n = Math.min(a.length, b.length);
		for (i = j = 0, ref = n; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
			p = a[i];
			q = b[i];
			if (p > q) {
				return -1;
			}
			if (p < q) {
				return 1;
			}
		}
		a = a.length;
		b = b.length;
		if (a > b) {
			return -1;
		} else if (a < b) {
			return 1;
		} else {
			return 0;
		}
	};
	
	exports.max = function(a, b) {
		if (exports.compare(a, b) > 0) {
			return b;
		} else {
			return a;
		}
	};
	
	
	/***/ }),
	/* 37 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Graph, markup, merge, resolve, serialize, visualize;
	
	Graph = __webpack_require__(6).Graph;
	
	exports.serialize = serialize = __webpack_require__(214);
	
	exports.markup = markup = __webpack_require__(215);
	
	visualize = function(graph) {
		var data;
		if (!graph) {
			return;
		}
		if (!graph.nodes) {
			return graph;
		}
		data = serialize(graph);
		return markup.process(data);
	};
	
	resolve = function(arg) {
		if (arg == null) {
			return arg;
		}
		if (arg instanceof Array) {
			return arg.map(resolve);
		}
		if ((arg.vertex != null) && (arg.fragment != null)) {
			return [resolve(arg.vertex, resolve(arg.fragment))];
		}
		if (arg._graph != null) {
			return arg._graph;
		}
		if (arg.graph != null) {
			return arg.graph;
		}
		return arg;
	};
	
	merge = function(args) {
		var arg, i, len, out;
		out = [];
		for (i = 0, len = args.length; i < len; i++) {
			arg = args[i];
			if (arg instanceof Array) {
				out = out.concat(merge(arg));
			} else if (arg != null) {
				out.push(arg);
			}
		}
		return out;
	};
	
	exports.visualize = function() {
		var graph, list;
		list = merge(resolve([].slice.call(arguments)));
		return markup.merge((function() {
			var i, len, results;
			results = [];
			for (i = 0, len = list.length; i < len; i++) {
				graph = list[i];
				if (graph) {
					results.push(visualize(graph));
				}
			}
			return results;
		})());
	};
	
	exports.inspect = function() {
		var contents, el, element, i, len, ref;
		contents = exports.visualize.apply(null, arguments);
		element = markup.overlay(contents);
		ref = document.querySelectorAll('.shadergraph-overlay');
		for (i = 0, len = ref.length; i < len; i++) {
			el = ref[i];
			el.remove();
		}
		document.body.appendChild(element);
		contents.update();
		return element;
	};
	
	
	/***/ }),
	/* 38 */
	/***/ (function(module, exports) {
	
	var c1, c2, c3, c4, c5, hash, imul, test;
	
	c1 = 0xcc9e2d51;
	
	c2 = 0x1b873593;
	
	c3 = 0xe6546b64;
	
	c4 = 0x85ebca6b;
	
	c5 = 0xc2b2ae35;
	
	imul = function(a, b) {
		var ah, al, bh, bl;
		ah = (a >>> 16) & 0xffff;
		al = a & 0xffff;
		bh = (b >>> 16) & 0xffff;
		bl = b & 0xffff;
		return (al * bl) + (((ah * bl + al * bh) << 16) >>> 0) | 0;
	};
	
	if (Math.imul != null) {
		test = Math.imul(0xffffffff, 5);
		if (test === -5) {
			imul = Math.imul;
		}
	}
	
	hash = function(string) {
		var h, iterate, j, m, n, next;
		n = string.length;
		m = Math.floor(n / 2);
		j = h = 0;
		next = function() {
			return string.charCodeAt(j++);
		};
		iterate = function(a, b) {
			var k;
			k = a | (b << 16);
			k ^= k << 9;
			k = imul(k, c1);
			k = (k << 15) | (k >>> 17);
			k = imul(k, c2);
			h ^= k;
			h = (h << 13) | (h >>> 19);
			h = imul(h, 5);
			return h = (h + c3) | 0;
		};
		while (m--) {
			iterate(next(), next());
		}
		if (n & 1) {
			iterate(next(), 0);
		}
		h ^= n;
		h ^= h >>> 16;
		h = imul(h, c4);
		h ^= h >>> 13;
		h = imul(h, c5);
		return h ^= h >>> 16;
	};
	
	module.exports = hash;
	
	
	/***/ }),
	/* 39 */
	/***/ (function(module, exports) {
	
	module.exports = {
		SHADOW_ARG: '_i_o',
		RETURN_ARG: 'return'
	};
	
	
	/***/ }),
	/* 40 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Binder, Node, Util, nodeIndex;
	
	Util = __webpack_require__(0);
	
	nodeIndex = 0;
	
	Node = (function() {
		function Node(type, defaults, options, binds, config, attributes) {
			this.type = type;
			this._id = (++nodeIndex).toString();
			this.configure(config, attributes);
			this.parent = this.root = this.path = this.index = null;
			this.set(defaults, true, true);
			this.set(options, false, true);
			this.bind(binds, false);
		}
	
		Node.prototype.configure = function(config, attributes) {
			var finals, freeform, props, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, traits;
			traits = config.traits, props = config.props, finals = config.finals, freeform = config.freeform;
			if (traits == null) {
				traits = (ref = (ref1 = this._config) != null ? ref1.traits : void 0) != null ? ref : [];
			}
			if (props == null) {
				props = (ref2 = (ref3 = this._config) != null ? ref3.props : void 0) != null ? ref2 : {};
			}
			if (finals == null) {
				finals = (ref4 = (ref5 = this._config) != null ? ref5.finals : void 0) != null ? ref4 : {};
			}
			if (freeform == null) {
				freeform = (ref6 = (ref7 = this._config) != null ? ref7.freeform : void 0) != null ? ref6 : false;
			}
			this._config = {
				traits: traits,
				props: props,
				finals: finals,
				freeform: freeform
			};
			return this.attributes = attributes.apply(this, this._config);
		};
	
		Node.prototype.dispose = function() {
			this.attributes.dispose();
			return this.attributes = null;
		};
	
		Node.prototype._added = function(parent) {
			var event;
			this.parent = parent;
			this.root = parent.root;
			event = {
				type: 'add',
				node: this,
				parent: this.parent
			};
			if (this.root) {
				this.root.trigger(event);
			}
			event.type = 'added';
			return this.trigger(event);
		};
	
		Node.prototype._removed = function() {
			var event;
			event = {
				type: 'remove',
				node: this
			};
			if (this.root) {
				this.root.trigger(event);
			}
			event.type = 'removed';
			this.trigger(event);
			return this.root = this.parent = null;
		};
	
		Node.prototype._index = function(index, parent) {
			var path, ref;
			if (parent == null) {
				parent = this.parent;
			}
			this.index = index;
			this.path = path = index != null ? ((ref = parent != null ? parent.path : void 0) != null ? ref : []).concat([index]) : null;
			this.order = path != null ? this._encode(path) : 2e308;
			if (this.root != null) {
				return this.trigger({
					type: 'reindex'
				});
			}
		};
	
		Node.prototype._encode = function(path) {
			var a, b, f, g, i, index, k, len, lerp, map, ref;
			k = 3;
			map = function(x) {
				return k / (x + k);
			};
			lerp = function(t) {
				return b + (a - b) * t;
			};
			a = 1 + 1 / k;
			b = 0;
			for (i = 0, len = path.length; i < len; i++) {
				index = path[i];
				f = map(index + 1);
				g = map(index + 2);
				ref = [lerp(f), lerp(g)], a = ref[0], b = ref[1];
			}
			return a;
		};
	
		Node.prototype.toString = function() {
			var _id, count, id, ref, ref1, ref2, tag;
			_id = (ref = this.id) != null ? ref : this._id;
			tag = (ref1 = this.type) != null ? ref1 : 'node';
			id = tag;
			id += "#" + _id;
			if ((ref2 = this.classes) != null ? ref2.length : void 0) {
				id += "." + (this.classes.join('.'));
			}
			if (this.children != null) {
				if (count = this.children.length) {
					return "<" + id + ">(" + count + ")</" + tag + ">";
				} else {
					return "<" + id + "></" + tag + ">";
				}
			} else {
				return "<" + id + " />";
			}
		};
	
		Node.prototype.toMarkup = function(selector, indent) {
			var attr, child, children, close, expr, k, open, orig, props, recurse, ref, ref1, ref2, ref3, tag, v;
			if (selector == null) {
				selector = null;
			}
			if (indent == null) {
				indent = '';
			}
			if (selector && typeof selector !== 'function') {
				selector = (ref = (ref1 = this.root) != null ? ref1.model._matcher(selector) : void 0) != null ? ref : function() {
					return true;
				};
			}
			tag = (ref2 = this.type) != null ? ref2 : 'node';
			expr = this.expr;
			orig = {
				id: this._id
			};
			ref3 = typeof this.orig === "function" ? this.orig() : void 0;
			for (k in ref3) {
				v = ref3[k];
				orig[k] = v;
			}
			props = (function() {
				var results;
				results = [];
				for (k in orig) {
					v = orig[k];
					if (!this.expr[k]) {
						results.push(Util.Pretty.JSX.prop(k, v));
					}
				}
				return results;
			}).call(this);
			expr = (function() {
				var results;
				results = [];
				for (k in expr) {
					v = expr[k];
					results.push(Util.Pretty.JSX.bind(k, v));
				}
				return results;
			})();
			attr = [''];
			if (props.length) {
				attr = attr.concat(props);
			}
			if (expr.length) {
				attr = attr.concat(expr);
			}
			attr = attr.join(' ');
			child = indent;
			recurse = (function(_this) {
				return function() {
					var children, ref4;
					if (!((ref4 = _this.children) != null ? ref4.length : void 0)) {
						return '';
					}
					return children = _this.children.map(function(x) {
						return x.toMarkup(selector, child);
					}).filter(function(x) {
						return (x != null) && x.length;
					}).join("\n");
				};
			})(this);
			if (selector && !selector(this)) {
				return recurse();
			}
			if (this.children != null) {
				open = "<" + tag + attr + ">";
				close = "</" + tag + ">";
				child = indent + '  ';
				children = recurse();
				if (children.length) {
					children = "\n" + children + "\n" + indent;
				}
				if (children == null) {
					children = '';
				}
				return indent + open + children + close;
			} else {
				return indent + "<" + tag + attr + " />";
			}
		};
	
		Node.prototype.print = function(selector, level) {
			return Util.Pretty.print(this.toMarkup(selector), level);
		};
	
		return Node;
	
	})();
	
	Binder = __webpack_require__(41);
	
	Binder.apply(Node.prototype);
	
	module.exports = Node;
	
	
	/***/ }),
	/* 41 */
	/***/ (function(module, exports, __webpack_require__) {
	
	const THREE = __webpack_require__(1)
	// Recycled from threestrap
	
	module.exports = self = {
		bind: function (context, globals) {
			return function (key, object) {
	
				// Prepare object
				if (!object.__binds) {
					object.__binds = [];
				}
	
				// Set base target
				var fallback = context;
				if (_.isArray(key)) {
					fallback = key[0];
					key = key[1];
				}
	
				// Match key
				var match = /^([^.:]*(?:\.[^.:]+)*)?(?:\:(.*))?$/.exec(key);
				var path = match[1].split(/\./g);
	
				var name = path.pop();
				var dest = match[2] || name;
	
				// Whitelisted objects
				var selector = path.shift();
				var target = {
					'this': object,
				}[selector] || globals[selector] || context[selector] || fallback;
	
				// Look up keys
				while (target && (key = path.shift())) { target = target[key] };
	
				// Attach event handler at last level
				if (target && (target.on || target.addEventListener)) {
					var callback = function (event) {
						object[dest] && object[dest](event, context);
					};
	
					// Polyfill for both styles of event listener adders
					self._polyfill(target, [ 'addEventListener', 'on' ], function (method) {
						target[method](name, callback);
					});
	
					// Store bind for removal later
					var bind = { target: target, name: name, callback: callback };
					object.__binds.push(bind);
	
					// Return callback
					return callback;
				}
				else {
					throw "Cannot bind '" + key + "' in " + this.__name;
				}
			};
		},
	
		unbind: function () {
			return function (object) {
				// Remove all binds belonging to object
				if (object.__binds) {
	
					object.__binds.forEach(function (bind) {
	
						// Polyfill for both styles of event listener removers
						self._polyfill(bind.target, [ 'removeEventListener', 'off' ], function (method) {
							bind.target[method](bind.name, bind.callback);
						});
					}.bind(this));
	
					object.__binds = [];
				}
			}
		},
	
		apply: function ( object ) {
	
			Object.assign( object, THREE.EventDispatcher.prototype );
	
			object.trigger     = self._trigger;
			object.triggerOnce = self._triggerOnce;
	
			object.on = object.addEventListener;
			object.off = object.removeEventListener;
			object.dispatchEvent = object.trigger;
	
		},
	
		////
	
		_triggerOnce: function (event) {
			this.trigger(event);
			if (this._listeners) {
				delete this._listeners[event.type]
			}
		},
	
		_trigger: function (event) {
	
			if (this._listeners === undefined) return;
	
			var type = event.type;
			var listeners = this._listeners[type];
			if (listeners !== undefined) {
	
				listeners = listeners.slice()
				var length = listeners.length;
	
				event.target = this;
				for (var i = 0; i < length; i++) {
					// add original target as parameter for convenience
					listeners[i].call(this, event, this);
				}
			}
		},
	
		_polyfill: function (object, methods, callback) {
			methods.map(function (method) { return object.method });
			if (methods.length) callback(methods[0]);
		},
	
	};
	
	
	/***/ }),
	/* 42 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	/* WEBPACK VAR INJECTION */(function(global, process) {// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	
	/*<replacement>*/
	
	var pna = __webpack_require__(18);
	/*</replacement>*/
	
	module.exports = Readable;
	
	/*<replacement>*/
	var isArray = __webpack_require__(87);
	/*</replacement>*/
	
	/*<replacement>*/
	var Duplex;
	/*</replacement>*/
	
	Readable.ReadableState = ReadableState;
	
	/*<replacement>*/
	var EE = __webpack_require__(24).EventEmitter;
	
	var EElistenerCount = function (emitter, type) {
		return emitter.listeners(type).length;
	};
	/*</replacement>*/
	
	/*<replacement>*/
	var Stream = __webpack_require__(43);
	/*</replacement>*/
	
	/*<replacement>*/
	
	var Buffer = __webpack_require__(26).Buffer;
	var OurUint8Array = global.Uint8Array || function () {};
	function _uint8ArrayToBuffer(chunk) {
		return Buffer.from(chunk);
	}
	function _isUint8Array(obj) {
		return Buffer.isBuffer(obj) || obj instanceof OurUint8Array;
	}
	
	/*</replacement>*/
	
	/*<replacement>*/
	var util = __webpack_require__(16);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	/*<replacement>*/
	var debugUtil = __webpack_require__(91);
	var debug = void 0;
	if (debugUtil && debugUtil.debuglog) {
		debug = debugUtil.debuglog('stream');
	} else {
		debug = function () {};
	}
	/*</replacement>*/
	
	var BufferList = __webpack_require__(92);
	var destroyImpl = __webpack_require__(44);
	var StringDecoder;
	
	util.inherits(Readable, Stream);
	
	var kProxyEvents = ['error', 'close', 'destroy', 'pause', 'resume'];
	
	function prependListener(emitter, event, fn) {
		// Sadly this is not cacheable as some libraries bundle their own
		// event emitter implementation with them.
		if (typeof emitter.prependListener === 'function') return emitter.prependListener(event, fn);
	
		// This is a hack to make sure that our error handler is attached before any
		// userland ones.  NEVER DO THIS. This is here only because this code needs
		// to continue to work with older versions of Node.js that do not include
		// the prependListener() method. The goal is to eventually remove this hack.
		if (!emitter._events || !emitter._events[event]) emitter.on(event, fn);else if (isArray(emitter._events[event])) emitter._events[event].unshift(fn);else emitter._events[event] = [fn, emitter._events[event]];
	}
	
	function ReadableState(options, stream) {
		Duplex = Duplex || __webpack_require__(9);
	
		options = options || {};
	
		// Duplex streams are both readable and writable, but share
		// the same options object.
		// However, some cases require setting options to different
		// values for the readable and the writable sides of the duplex stream.
		// These options can be provided separately as readableXXX and writableXXX.
		var isDuplex = stream instanceof Duplex;
	
		// object stream flag. Used to make read(n) ignore n and to
		// make all the buffer merging and length checks go away
		this.objectMode = !!options.objectMode;
	
		if (isDuplex) this.objectMode = this.objectMode || !!options.readableObjectMode;
	
		// the point at which it stops calling _read() to fill the buffer
		// Note: 0 is a valid value, means "don't call _read preemptively ever"
		var hwm = options.highWaterMark;
		var readableHwm = options.readableHighWaterMark;
		var defaultHwm = this.objectMode ? 16 : 16 * 1024;
	
		if (hwm || hwm === 0) this.highWaterMark = hwm;else if (isDuplex && (readableHwm || readableHwm === 0)) this.highWaterMark = readableHwm;else this.highWaterMark = defaultHwm;
	
		// cast to ints.
		this.highWaterMark = Math.floor(this.highWaterMark);
	
		// A linked list is used to store data chunks instead of an array because the
		// linked list can remove elements from the beginning faster than
		// array.shift()
		this.buffer = new BufferList();
		this.length = 0;
		this.pipes = null;
		this.pipesCount = 0;
		this.flowing = null;
		this.ended = false;
		this.endEmitted = false;
		this.reading = false;
	
		// a flag to be able to tell if the event 'readable'/'data' is emitted
		// immediately, or on a later tick.  We set this to true at first, because
		// any actions that shouldn't happen until "later" should generally also
		// not happen before the first read call.
		this.sync = true;
	
		// whenever we return null, then we set a flag to say
		// that we're awaiting a 'readable' event emission.
		this.needReadable = false;
		this.emittedReadable = false;
		this.readableListening = false;
		this.resumeScheduled = false;
	
		// has it been destroyed
		this.destroyed = false;
	
		// Crypto is kind of old and crusty.  Historically, its default string
		// encoding is 'binary' so we have to make this configurable.
		// Everything else in the universe uses 'utf8', though.
		this.defaultEncoding = options.defaultEncoding || 'utf8';
	
		// the number of writers that are awaiting a drain event in .pipe()s
		this.awaitDrain = 0;
	
		// if true, a maybeReadMore has been scheduled
		this.readingMore = false;
	
		this.decoder = null;
		this.encoding = null;
		if (options.encoding) {
			if (!StringDecoder) StringDecoder = __webpack_require__(45).StringDecoder;
			this.decoder = new StringDecoder(options.encoding);
			this.encoding = options.encoding;
		}
	}
	
	function Readable(options) {
		Duplex = Duplex || __webpack_require__(9);
	
		if (!(this instanceof Readable)) return new Readable(options);
	
		this._readableState = new ReadableState(options, this);
	
		// legacy
		this.readable = true;
	
		if (options) {
			if (typeof options.read === 'function') this._read = options.read;
	
			if (typeof options.destroy === 'function') this._destroy = options.destroy;
		}
	
		Stream.call(this);
	}
	
	Object.defineProperty(Readable.prototype, 'destroyed', {
		get: function () {
			if (this._readableState === undefined) {
				return false;
			}
			return this._readableState.destroyed;
		},
		set: function (value) {
			// we ignore the value if the stream
			// has not been initialized yet
			if (!this._readableState) {
				return;
			}
	
			// backward compatibility, the user is explicitly
			// managing destroyed
			this._readableState.destroyed = value;
		}
	});
	
	Readable.prototype.destroy = destroyImpl.destroy;
	Readable.prototype._undestroy = destroyImpl.undestroy;
	Readable.prototype._destroy = function (err, cb) {
		this.push(null);
		cb(err);
	};
	
	// Manually shove something into the read() buffer.
	// This returns true if the highWaterMark has not been hit yet,
	// similar to how Writable.write() returns true if you should
	// write() some more.
	Readable.prototype.push = function (chunk, encoding) {
		var state = this._readableState;
		var skipChunkCheck;
	
		if (!state.objectMode) {
			if (typeof chunk === 'string') {
				encoding = encoding || state.defaultEncoding;
				if (encoding !== state.encoding) {
					chunk = Buffer.from(chunk, encoding);
					encoding = '';
				}
				skipChunkCheck = true;
			}
		} else {
			skipChunkCheck = true;
		}
	
		return readableAddChunk(this, chunk, encoding, false, skipChunkCheck);
	};
	
	// Unshift should *always* be something directly out of read()
	Readable.prototype.unshift = function (chunk) {
		return readableAddChunk(this, chunk, null, true, false);
	};
	
	function readableAddChunk(stream, chunk, encoding, addToFront, skipChunkCheck) {
		var state = stream._readableState;
		if (chunk === null) {
			state.reading = false;
			onEofChunk(stream, state);
		} else {
			var er;
			if (!skipChunkCheck) er = chunkInvalid(state, chunk);
			if (er) {
				stream.emit('error', er);
			} else if (state.objectMode || chunk && chunk.length > 0) {
				if (typeof chunk !== 'string' && !state.objectMode && Object.getPrototypeOf(chunk) !== Buffer.prototype) {
					chunk = _uint8ArrayToBuffer(chunk);
				}
	
				if (addToFront) {
					if (state.endEmitted) stream.emit('error', new Error('stream.unshift() after end event'));else addChunk(stream, state, chunk, true);
				} else if (state.ended) {
					stream.emit('error', new Error('stream.push() after EOF'));
				} else {
					state.reading = false;
					if (state.decoder && !encoding) {
						chunk = state.decoder.write(chunk);
						if (state.objectMode || chunk.length !== 0) addChunk(stream, state, chunk, false);else maybeReadMore(stream, state);
					} else {
						addChunk(stream, state, chunk, false);
					}
				}
			} else if (!addToFront) {
				state.reading = false;
			}
		}
	
		return needMoreData(state);
	}
	
	function addChunk(stream, state, chunk, addToFront) {
		if (state.flowing && state.length === 0 && !state.sync) {
			stream.emit('data', chunk);
			stream.read(0);
		} else {
			// update the buffer info.
			state.length += state.objectMode ? 1 : chunk.length;
			if (addToFront) state.buffer.unshift(chunk);else state.buffer.push(chunk);
	
			if (state.needReadable) emitReadable(stream);
		}
		maybeReadMore(stream, state);
	}
	
	function chunkInvalid(state, chunk) {
		var er;
		if (!_isUint8Array(chunk) && typeof chunk !== 'string' && chunk !== undefined && !state.objectMode) {
			er = new TypeError('Invalid non-string/buffer chunk');
		}
		return er;
	}
	
	// if it's past the high water mark, we can push in some more.
	// Also, if we have no data yet, we can stand some
	// more bytes.  This is to work around cases where hwm=0,
	// such as the repl.  Also, if the push() triggered a
	// readable event, and the user called read(largeNumber) such that
	// needReadable was set, then we ought to push more, so that another
	// 'readable' event will be triggered.
	function needMoreData(state) {
		return !state.ended && (state.needReadable || state.length < state.highWaterMark || state.length === 0);
	}
	
	Readable.prototype.isPaused = function () {
		return this._readableState.flowing === false;
	};
	
	// backwards compatibility.
	Readable.prototype.setEncoding = function (enc) {
		if (!StringDecoder) StringDecoder = __webpack_require__(45).StringDecoder;
		this._readableState.decoder = new StringDecoder(enc);
		this._readableState.encoding = enc;
		return this;
	};
	
	// Don't raise the hwm > 8MB
	var MAX_HWM = 0x800000;
	function computeNewHighWaterMark(n) {
		if (n >= MAX_HWM) {
			n = MAX_HWM;
		} else {
			// Get the next highest power of 2 to prevent increasing hwm excessively in
			// tiny amounts
			n--;
			n |= n >>> 1;
			n |= n >>> 2;
			n |= n >>> 4;
			n |= n >>> 8;
			n |= n >>> 16;
			n++;
		}
		return n;
	}
	
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function howMuchToRead(n, state) {
		if (n <= 0 || state.length === 0 && state.ended) return 0;
		if (state.objectMode) return 1;
		if (n !== n) {
			// Only flow one buffer at a time
			if (state.flowing && state.length) return state.buffer.head.data.length;else return state.length;
		}
		// If we're asking for more than the current hwm, then raise the hwm.
		if (n > state.highWaterMark) state.highWaterMark = computeNewHighWaterMark(n);
		if (n <= state.length) return n;
		// Don't have enough
		if (!state.ended) {
			state.needReadable = true;
			return 0;
		}
		return state.length;
	}
	
	// you can override either this method, or the async _read(n) below.
	Readable.prototype.read = function (n) {
		debug('read', n);
		n = parseInt(n, 10);
		var state = this._readableState;
		var nOrig = n;
	
		if (n !== 0) state.emittedReadable = false;
	
		// if we're doing read(0) to trigger a readable event, but we
		// already have a bunch of data in the buffer, then just trigger
		// the 'readable' event and move on.
		if (n === 0 && state.needReadable && (state.length >= state.highWaterMark || state.ended)) {
			debug('read: emitReadable', state.length, state.ended);
			if (state.length === 0 && state.ended) endReadable(this);else emitReadable(this);
			return null;
		}
	
		n = howMuchToRead(n, state);
	
		// if we've ended, and we're now clear, then finish it up.
		if (n === 0 && state.ended) {
			if (state.length === 0) endReadable(this);
			return null;
		}
	
		// All the actual chunk generation logic needs to be
		// *below* the call to _read.  The reason is that in certain
		// synthetic stream cases, such as passthrough streams, _read
		// may be a completely synchronous operation which may change
		// the state of the read buffer, providing enough data when
		// before there was *not* enough.
		//
		// So, the steps are:
		// 1. Figure out what the state of things will be after we do
		// a read from the buffer.
		//
		// 2. If that resulting state will trigger a _read, then call _read.
		// Note that this may be asynchronous, or synchronous.  Yes, it is
		// deeply ugly to write APIs this way, but that still doesn't mean
		// that the Readable class should behave improperly, as streams are
		// designed to be sync/async agnostic.
		// Take note if the _read call is sync or async (ie, if the read call
		// has returned yet), so that we know whether or not it's safe to emit
		// 'readable' etc.
		//
		// 3. Actually pull the requested chunks out of the buffer and return.
	
		// if we need a readable event, then we need to do some reading.
		var doRead = state.needReadable;
		debug('need readable', doRead);
	
		// if we currently have less than the highWaterMark, then also read some
		if (state.length === 0 || state.length - n < state.highWaterMark) {
			doRead = true;
			debug('length less than watermark', doRead);
		}
	
		// however, if we've ended, then there's no point, and if we're already
		// reading, then it's unnecessary.
		if (state.ended || state.reading) {
			doRead = false;
			debug('reading or ended', doRead);
		} else if (doRead) {
			debug('do read');
			state.reading = true;
			state.sync = true;
			// if the length is currently zero, then we *need* a readable event.
			if (state.length === 0) state.needReadable = true;
			// call internal read method
			this._read(state.highWaterMark);
			state.sync = false;
			// If _read pushed data synchronously, then `reading` will be false,
			// and we need to re-evaluate how much data we can return to the user.
			if (!state.reading) n = howMuchToRead(nOrig, state);
		}
	
		var ret;
		if (n > 0) ret = fromList(n, state);else ret = null;
	
		if (ret === null) {
			state.needReadable = true;
			n = 0;
		} else {
			state.length -= n;
		}
	
		if (state.length === 0) {
			// If we have nothing in the buffer, then we want to know
			// as soon as we *do* get something into the buffer.
			if (!state.ended) state.needReadable = true;
	
			// If we tried to read() past the EOF, then emit end on the next tick.
			if (nOrig !== n && state.ended) endReadable(this);
		}
	
		if (ret !== null) this.emit('data', ret);
	
		return ret;
	};
	
	function onEofChunk(stream, state) {
		if (state.ended) return;
		if (state.decoder) {
			var chunk = state.decoder.end();
			if (chunk && chunk.length) {
				state.buffer.push(chunk);
				state.length += state.objectMode ? 1 : chunk.length;
			}
		}
		state.ended = true;
	
		// emit 'readable' now to make sure it gets picked up.
		emitReadable(stream);
	}
	
	// Don't emit readable right away in sync mode, because this can trigger
	// another read() call => stack overflow.  This way, it might trigger
	// a nextTick recursion warning, but that's not so bad.
	function emitReadable(stream) {
		var state = stream._readableState;
		state.needReadable = false;
		if (!state.emittedReadable) {
			debug('emitReadable', state.flowing);
			state.emittedReadable = true;
			if (state.sync) pna.nextTick(emitReadable_, stream);else emitReadable_(stream);
		}
	}
	
	function emitReadable_(stream) {
		debug('emit readable');
		stream.emit('readable');
		flow(stream);
	}
	
	// at this point, the user has presumably seen the 'readable' event,
	// and called read() to consume some data.  that may have triggered
	// in turn another _read(n) call, in which case reading = true if
	// it's in progress.
	// However, if we're not ended, or reading, and the length < hwm,
	// then go ahead and try to read some more preemptively.
	function maybeReadMore(stream, state) {
		if (!state.readingMore) {
			state.readingMore = true;
			pna.nextTick(maybeReadMore_, stream, state);
		}
	}
	
	function maybeReadMore_(stream, state) {
		var len = state.length;
		while (!state.reading && !state.flowing && !state.ended && state.length < state.highWaterMark) {
			debug('maybeReadMore read 0');
			stream.read(0);
			if (len === state.length)
				// didn't get any data, stop spinning.
				break;else len = state.length;
		}
		state.readingMore = false;
	}
	
	// abstract method.  to be overridden in specific implementation classes.
	// call cb(er, data) where data is <= n in length.
	// for virtual (non-string, non-buffer) streams, "length" is somewhat
	// arbitrary, and perhaps not very meaningful.
	Readable.prototype._read = function (n) {
		this.emit('error', new Error('_read() is not implemented'));
	};
	
	Readable.prototype.pipe = function (dest, pipeOpts) {
		var src = this;
		var state = this._readableState;
	
		switch (state.pipesCount) {
			case 0:
				state.pipes = dest;
				break;
			case 1:
				state.pipes = [state.pipes, dest];
				break;
			default:
				state.pipes.push(dest);
				break;
		}
		state.pipesCount += 1;
		debug('pipe count=%d opts=%j', state.pipesCount, pipeOpts);
	
		var doEnd = (!pipeOpts || pipeOpts.end !== false) && dest !== process.stdout && dest !== process.stderr;
	
		var endFn = doEnd ? onend : unpipe;
		if (state.endEmitted) pna.nextTick(endFn);else src.once('end', endFn);
	
		dest.on('unpipe', onunpipe);
		function onunpipe(readable, unpipeInfo) {
			debug('onunpipe');
			if (readable === src) {
				if (unpipeInfo && unpipeInfo.hasUnpiped === false) {
					unpipeInfo.hasUnpiped = true;
					cleanup();
				}
			}
		}
	
		function onend() {
			debug('onend');
			dest.end();
		}
	
		// when the dest drains, it reduces the awaitDrain counter
		// on the source.  This would be more elegant with a .once()
		// handler in flow(), but adding and removing repeatedly is
		// too slow.
		var ondrain = pipeOnDrain(src);
		dest.on('drain', ondrain);
	
		var cleanedUp = false;
		function cleanup() {
			debug('cleanup');
			// cleanup event handlers once the pipe is broken
			dest.removeListener('close', onclose);
			dest.removeListener('finish', onfinish);
			dest.removeListener('drain', ondrain);
			dest.removeListener('error', onerror);
			dest.removeListener('unpipe', onunpipe);
			src.removeListener('end', onend);
			src.removeListener('end', unpipe);
			src.removeListener('data', ondata);
	
			cleanedUp = true;
	
			// if the reader is waiting for a drain event from this
			// specific writer, then it would cause it to never start
			// flowing again.
			// So, if this is awaiting a drain, then we just call it now.
			// If we don't know, then assume that we are waiting for one.
			if (state.awaitDrain && (!dest._writableState || dest._writableState.needDrain)) ondrain();
		}
	
		// If the user pushes more data while we're writing to dest then we'll end up
		// in ondata again. However, we only want to increase awaitDrain once because
		// dest will only emit one 'drain' event for the multiple writes.
		// => Introduce a guard on increasing awaitDrain.
		var increasedAwaitDrain = false;
		src.on('data', ondata);
		function ondata(chunk) {
			debug('ondata');
			increasedAwaitDrain = false;
			var ret = dest.write(chunk);
			if (false === ret && !increasedAwaitDrain) {
				// If the user unpiped during `dest.write()`, it is possible
				// to get stuck in a permanently paused state if that write
				// also returned false.
				// => Check whether `dest` is still a piping destination.
				if ((state.pipesCount === 1 && state.pipes === dest || state.pipesCount > 1 && indexOf(state.pipes, dest) !== -1) && !cleanedUp) {
					debug('false write response, pause', src._readableState.awaitDrain);
					src._readableState.awaitDrain++;
					increasedAwaitDrain = true;
				}
				src.pause();
			}
		}
	
		// if the dest has an error, then stop piping into it.
		// however, don't suppress the throwing behavior for this.
		function onerror(er) {
			debug('onerror', er);
			unpipe();
			dest.removeListener('error', onerror);
			if (EElistenerCount(dest, 'error') === 0) dest.emit('error', er);
		}
	
		// Make sure our error handler is attached before userland ones.
		prependListener(dest, 'error', onerror);
	
		// Both close and finish should trigger unpipe, but only once.
		function onclose() {
			dest.removeListener('finish', onfinish);
			unpipe();
		}
		dest.once('close', onclose);
		function onfinish() {
			debug('onfinish');
			dest.removeListener('close', onclose);
			unpipe();
		}
		dest.once('finish', onfinish);
	
		function unpipe() {
			debug('unpipe');
			src.unpipe(dest);
		}
	
		// tell the dest that it's being piped to
		dest.emit('pipe', src);
	
		// start the flow if it hasn't been started already.
		if (!state.flowing) {
			debug('pipe resume');
			src.resume();
		}
	
		return dest;
	};
	
	function pipeOnDrain(src) {
		return function () {
			var state = src._readableState;
			debug('pipeOnDrain', state.awaitDrain);
			if (state.awaitDrain) state.awaitDrain--;
			if (state.awaitDrain === 0 && EElistenerCount(src, 'data')) {
				state.flowing = true;
				flow(src);
			}
		};
	}
	
	Readable.prototype.unpipe = function (dest) {
		var state = this._readableState;
		var unpipeInfo = { hasUnpiped: false };
	
		// if we're not piping anywhere, then do nothing.
		if (state.pipesCount === 0) return this;
	
		// just one destination.  most common case.
		if (state.pipesCount === 1) {
			// passed in one, but it's not the right one.
			if (dest && dest !== state.pipes) return this;
	
			if (!dest) dest = state.pipes;
	
			// got a match.
			state.pipes = null;
			state.pipesCount = 0;
			state.flowing = false;
			if (dest) dest.emit('unpipe', this, unpipeInfo);
			return this;
		}
	
		// slow case. multiple pipe destinations.
	
		if (!dest) {
			// remove all.
			var dests = state.pipes;
			var len = state.pipesCount;
			state.pipes = null;
			state.pipesCount = 0;
			state.flowing = false;
	
			for (var i = 0; i < len; i++) {
				dests[i].emit('unpipe', this, unpipeInfo);
			}return this;
		}
	
		// try to find the right one.
		var index = indexOf(state.pipes, dest);
		if (index === -1) return this;
	
		state.pipes.splice(index, 1);
		state.pipesCount -= 1;
		if (state.pipesCount === 1) state.pipes = state.pipes[0];
	
		dest.emit('unpipe', this, unpipeInfo);
	
		return this;
	};
	
	// set up data events if they are asked for
	// Ensure readable listeners eventually get something
	Readable.prototype.on = function (ev, fn) {
		var res = Stream.prototype.on.call(this, ev, fn);
	
		if (ev === 'data') {
			// Start flowing on next tick if stream isn't explicitly paused
			if (this._readableState.flowing !== false) this.resume();
		} else if (ev === 'readable') {
			var state = this._readableState;
			if (!state.endEmitted && !state.readableListening) {
				state.readableListening = state.needReadable = true;
				state.emittedReadable = false;
				if (!state.reading) {
					pna.nextTick(nReadingNextTick, this);
				} else if (state.length) {
					emitReadable(this);
				}
			}
		}
	
		return res;
	};
	Readable.prototype.addListener = Readable.prototype.on;
	
	function nReadingNextTick(self) {
		debug('readable nexttick read 0');
		self.read(0);
	}
	
	// pause() and resume() are remnants of the legacy readable stream API
	// If the user uses them, then switch into old mode.
	Readable.prototype.resume = function () {
		var state = this._readableState;
		if (!state.flowing) {
			debug('resume');
			state.flowing = true;
			resume(this, state);
		}
		return this;
	};
	
	function resume(stream, state) {
		if (!state.resumeScheduled) {
			state.resumeScheduled = true;
			pna.nextTick(resume_, stream, state);
		}
	}
	
	function resume_(stream, state) {
		if (!state.reading) {
			debug('resume read 0');
			stream.read(0);
		}
	
		state.resumeScheduled = false;
		state.awaitDrain = 0;
		stream.emit('resume');
		flow(stream);
		if (state.flowing && !state.reading) stream.read(0);
	}
	
	Readable.prototype.pause = function () {
		debug('call pause flowing=%j', this._readableState.flowing);
		if (false !== this._readableState.flowing) {
			debug('pause');
			this._readableState.flowing = false;
			this.emit('pause');
		}
		return this;
	};
	
	function flow(stream) {
		var state = stream._readableState;
		debug('flow', state.flowing);
		while (state.flowing && stream.read() !== null) {}
	}
	
	// wrap an old-style stream as the async data source.
	// This is *not* part of the readable stream interface.
	// It is an ugly unfortunate mess of history.
	Readable.prototype.wrap = function (stream) {
		var _this = this;
	
		var state = this._readableState;
		var paused = false;
	
		stream.on('end', function () {
			debug('wrapped end');
			if (state.decoder && !state.ended) {
				var chunk = state.decoder.end();
				if (chunk && chunk.length) _this.push(chunk);
			}
	
			_this.push(null);
		});
	
		stream.on('data', function (chunk) {
			debug('wrapped data');
			if (state.decoder) chunk = state.decoder.write(chunk);
	
			// don't skip over falsy values in objectMode
			if (state.objectMode && (chunk === null || chunk === undefined)) return;else if (!state.objectMode && (!chunk || !chunk.length)) return;
	
			var ret = _this.push(chunk);
			if (!ret) {
				paused = true;
				stream.pause();
			}
		});
	
		// proxy all the other methods.
		// important when wrapping filters and duplexes.
		for (var i in stream) {
			if (this[i] === undefined && typeof stream[i] === 'function') {
				this[i] = function (method) {
					return function () {
						return stream[method].apply(stream, arguments);
					};
				}(i);
			}
		}
	
		// proxy certain important events.
		for (var n = 0; n < kProxyEvents.length; n++) {
			stream.on(kProxyEvents[n], this.emit.bind(this, kProxyEvents[n]));
		}
	
		// when we try to consume some more bytes, simply unpause the
		// underlying stream.
		this._read = function (n) {
			debug('wrapped _read', n);
			if (paused) {
				paused = false;
				stream.resume();
			}
		};
	
		return this;
	};
	
	Object.defineProperty(Readable.prototype, 'readableHighWaterMark', {
		// making it explicit this property is not enumerable
		// because otherwise some prototype manipulation in
		// userland will fail
		enumerable: false,
		get: function () {
			return this._readableState.highWaterMark;
		}
	});
	
	// exposed for testing purposes only.
	Readable._fromList = fromList;
	
	// Pluck off n bytes from an array of buffers.
	// Length is the combined lengths of all the buffers in the list.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromList(n, state) {
		// nothing buffered
		if (state.length === 0) return null;
	
		var ret;
		if (state.objectMode) ret = state.buffer.shift();else if (!n || n >= state.length) {
			// read it all, truncate the list
			if (state.decoder) ret = state.buffer.join('');else if (state.buffer.length === 1) ret = state.buffer.head.data;else ret = state.buffer.concat(state.length);
			state.buffer.clear();
		} else {
			// read part of list
			ret = fromListPartial(n, state.buffer, state.decoder);
		}
	
		return ret;
	}
	
	// Extracts only enough buffered data to satisfy the amount requested.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function fromListPartial(n, list, hasStrings) {
		var ret;
		if (n < list.head.data.length) {
			// slice is the same for buffers and strings
			ret = list.head.data.slice(0, n);
			list.head.data = list.head.data.slice(n);
		} else if (n === list.head.data.length) {
			// first chunk is a perfect match
			ret = list.shift();
		} else {
			// result spans more than one buffer
			ret = hasStrings ? copyFromBufferString(n, list) : copyFromBuffer(n, list);
		}
		return ret;
	}
	
	// Copies a specified amount of characters from the list of buffered data
	// chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBufferString(n, list) {
		var p = list.head;
		var c = 1;
		var ret = p.data;
		n -= ret.length;
		while (p = p.next) {
			var str = p.data;
			var nb = n > str.length ? str.length : n;
			if (nb === str.length) ret += str;else ret += str.slice(0, n);
			n -= nb;
			if (n === 0) {
				if (nb === str.length) {
					++c;
					if (p.next) list.head = p.next;else list.head = list.tail = null;
				} else {
					list.head = p;
					p.data = str.slice(nb);
				}
				break;
			}
			++c;
		}
		list.length -= c;
		return ret;
	}
	
	// Copies a specified amount of bytes from the list of buffered data chunks.
	// This function is designed to be inlinable, so please take care when making
	// changes to the function body.
	function copyFromBuffer(n, list) {
		var ret = Buffer.allocUnsafe(n);
		var p = list.head;
		var c = 1;
		p.data.copy(ret);
		n -= p.data.length;
		while (p = p.next) {
			var buf = p.data;
			var nb = n > buf.length ? buf.length : n;
			buf.copy(ret, ret.length - n, 0, nb);
			n -= nb;
			if (n === 0) {
				if (nb === buf.length) {
					++c;
					if (p.next) list.head = p.next;else list.head = list.tail = null;
				} else {
					list.head = p;
					p.data = buf.slice(nb);
				}
				break;
			}
			++c;
		}
		list.length -= c;
		return ret;
	}
	
	function endReadable(stream) {
		var state = stream._readableState;
	
		// If we get here before consuming all the bytes, then that is a
		// bug in node.  Should never happen.
		if (state.length > 0) throw new Error('"endReadable()" called on non-empty stream');
	
		if (!state.endEmitted) {
			state.ended = true;
			pna.nextTick(endReadableNT, state, stream);
		}
	}
	
	function endReadableNT(state, stream) {
		// Check that we didn't get one last unshift.
		if (!state.endEmitted && state.length === 0) {
			state.endEmitted = true;
			stream.readable = false;
			stream.emit('end');
		}
	}
	
	function indexOf(xs, x) {
		for (var i = 0, l = xs.length; i < l; i++) {
			if (xs[i] === x) return i;
		}
		return -1;
	}
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12), __webpack_require__(15)))
	
	/***/ }),
	/* 43 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(24).EventEmitter;
	
	
	/***/ }),
	/* 44 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	
	
	/*<replacement>*/
	
	var pna = __webpack_require__(18);
	/*</replacement>*/
	
	// undocumented cb() API, needed for core, not for public API
	function destroy(err, cb) {
		var _this = this;
	
		var readableDestroyed = this._readableState && this._readableState.destroyed;
		var writableDestroyed = this._writableState && this._writableState.destroyed;
	
		if (readableDestroyed || writableDestroyed) {
			if (cb) {
				cb(err);
			} else if (err && (!this._writableState || !this._writableState.errorEmitted)) {
				pna.nextTick(emitErrorNT, this, err);
			}
			return this;
		}
	
		// we set destroyed to true before firing error callbacks in order
		// to make it re-entrance safe in case destroy() is called within callbacks
	
		if (this._readableState) {
			this._readableState.destroyed = true;
		}
	
		// if this is a duplex stream mark the writable part as destroyed as well
		if (this._writableState) {
			this._writableState.destroyed = true;
		}
	
		this._destroy(err || null, function (err) {
			if (!cb && err) {
				pna.nextTick(emitErrorNT, _this, err);
				if (_this._writableState) {
					_this._writableState.errorEmitted = true;
				}
			} else if (cb) {
				cb(err);
			}
		});
	
		return this;
	}
	
	function undestroy() {
		if (this._readableState) {
			this._readableState.destroyed = false;
			this._readableState.reading = false;
			this._readableState.ended = false;
			this._readableState.endEmitted = false;
		}
	
		if (this._writableState) {
			this._writableState.destroyed = false;
			this._writableState.ended = false;
			this._writableState.ending = false;
			this._writableState.finished = false;
			this._writableState.errorEmitted = false;
		}
	}
	
	function emitErrorNT(self, err) {
		self.emit('error', err);
	}
	
	module.exports = {
		destroy: destroy,
		undestroy: undestroy
	};
	
	/***/ }),
	/* 45 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	
	
	/*<replacement>*/
	
	var Buffer = __webpack_require__(97).Buffer;
	/*</replacement>*/
	
	var isEncoding = Buffer.isEncoding || function (encoding) {
		encoding = '' + encoding;
		switch (encoding && encoding.toLowerCase()) {
			case 'hex':case 'utf8':case 'utf-8':case 'ascii':case 'binary':case 'base64':case 'ucs2':case 'ucs-2':case 'utf16le':case 'utf-16le':case 'raw':
				return true;
			default:
				return false;
		}
	};
	
	function _normalizeEncoding(enc) {
		if (!enc) return 'utf8';
		var retried;
		while (true) {
			switch (enc) {
				case 'utf8':
				case 'utf-8':
					return 'utf8';
				case 'ucs2':
				case 'ucs-2':
				case 'utf16le':
				case 'utf-16le':
					return 'utf16le';
				case 'latin1':
				case 'binary':
					return 'latin1';
				case 'base64':
				case 'ascii':
				case 'hex':
					return enc;
				default:
					if (retried) return; // undefined
					enc = ('' + enc).toLowerCase();
					retried = true;
			}
		}
	};
	
	// Do not cache `Buffer.isEncoding` when checking encoding names as some
	// modules monkey-patch it to support additional encodings
	function normalizeEncoding(enc) {
		var nenc = _normalizeEncoding(enc);
		if (typeof nenc !== 'string' && (Buffer.isEncoding === isEncoding || !isEncoding(enc))) throw new Error('Unknown encoding: ' + enc);
		return nenc || enc;
	}
	
	// StringDecoder provides an interface for efficiently splitting a series of
	// buffers into a series of JS strings without breaking apart multi-byte
	// characters.
	exports.StringDecoder = StringDecoder;
	function StringDecoder(encoding) {
		this.encoding = normalizeEncoding(encoding);
		var nb;
		switch (this.encoding) {
			case 'utf16le':
				this.text = utf16Text;
				this.end = utf16End;
				nb = 4;
				break;
			case 'utf8':
				this.fillLast = utf8FillLast;
				nb = 4;
				break;
			case 'base64':
				this.text = base64Text;
				this.end = base64End;
				nb = 3;
				break;
			default:
				this.write = simpleWrite;
				this.end = simpleEnd;
				return;
		}
		this.lastNeed = 0;
		this.lastTotal = 0;
		this.lastChar = Buffer.allocUnsafe(nb);
	}
	
	StringDecoder.prototype.write = function (buf) {
		if (buf.length === 0) return '';
		var r;
		var i;
		if (this.lastNeed) {
			r = this.fillLast(buf);
			if (r === undefined) return '';
			i = this.lastNeed;
			this.lastNeed = 0;
		} else {
			i = 0;
		}
		if (i < buf.length) return r ? r + this.text(buf, i) : this.text(buf, i);
		return r || '';
	};
	
	StringDecoder.prototype.end = utf8End;
	
	// Returns only complete characters in a Buffer
	StringDecoder.prototype.text = utf8Text;
	
	// Attempts to complete a partial non-UTF-8 character using bytes from a Buffer
	StringDecoder.prototype.fillLast = function (buf) {
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, this.lastTotal - this.lastNeed, 0, buf.length);
		this.lastNeed -= buf.length;
	};
	
	// Checks the type of a UTF-8 byte, whether it's ASCII, a leading byte, or a
	// continuation byte. If an invalid byte is detected, -2 is returned.
	function utf8CheckByte(byte) {
		if (byte <= 0x7F) return 0;else if (byte >> 5 === 0x06) return 2;else if (byte >> 4 === 0x0E) return 3;else if (byte >> 3 === 0x1E) return 4;
		return byte >> 6 === 0x02 ? -1 : -2;
	}
	
	// Checks at most 3 bytes at the end of a Buffer in order to detect an
	// incomplete multi-byte UTF-8 character. The total number of bytes (2, 3, or 4)
	// needed to complete the UTF-8 character (if applicable) are returned.
	function utf8CheckIncomplete(self, buf, i) {
		var j = buf.length - 1;
		if (j < i) return 0;
		var nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) self.lastNeed = nb - 1;
			return nb;
		}
		if (--j < i || nb === -2) return 0;
		nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) self.lastNeed = nb - 2;
			return nb;
		}
		if (--j < i || nb === -2) return 0;
		nb = utf8CheckByte(buf[j]);
		if (nb >= 0) {
			if (nb > 0) {
				if (nb === 2) nb = 0;else self.lastNeed = nb - 3;
			}
			return nb;
		}
		return 0;
	}
	
	// Validates as many continuation bytes for a multi-byte UTF-8 character as
	// needed or are available. If we see a non-continuation byte where we expect
	// one, we "replace" the validated continuation bytes we've seen so far with
	// a single UTF-8 replacement character ('\ufffd'), to match v8's UTF-8 decoding
	// behavior. The continuation byte check is included three times in the case
	// where all of the continuation bytes for a character exist in the same buffer.
	// It is also done this way as a slight performance increase instead of using a
	// loop.
	function utf8CheckExtraBytes(self, buf, p) {
		if ((buf[0] & 0xC0) !== 0x80) {
			self.lastNeed = 0;
			return '\ufffd';
		}
		if (self.lastNeed > 1 && buf.length > 1) {
			if ((buf[1] & 0xC0) !== 0x80) {
				self.lastNeed = 1;
				return '\ufffd';
			}
			if (self.lastNeed > 2 && buf.length > 2) {
				if ((buf[2] & 0xC0) !== 0x80) {
					self.lastNeed = 2;
					return '\ufffd';
				}
			}
		}
	}
	
	// Attempts to complete a multi-byte UTF-8 character using bytes from a Buffer.
	function utf8FillLast(buf) {
		var p = this.lastTotal - this.lastNeed;
		var r = utf8CheckExtraBytes(this, buf, p);
		if (r !== undefined) return r;
		if (this.lastNeed <= buf.length) {
			buf.copy(this.lastChar, p, 0, this.lastNeed);
			return this.lastChar.toString(this.encoding, 0, this.lastTotal);
		}
		buf.copy(this.lastChar, p, 0, buf.length);
		this.lastNeed -= buf.length;
	}
	
	// Returns all complete UTF-8 characters in a Buffer. If the Buffer ended on a
	// partial character, the character's bytes are buffered until the required
	// number of bytes are available.
	function utf8Text(buf, i) {
		var total = utf8CheckIncomplete(this, buf, i);
		if (!this.lastNeed) return buf.toString('utf8', i);
		this.lastTotal = total;
		var end = buf.length - (total - this.lastNeed);
		buf.copy(this.lastChar, 0, end);
		return buf.toString('utf8', i, end);
	}
	
	// For UTF-8, a replacement character is added when ending on a partial
	// character.
	function utf8End(buf) {
		var r = buf && buf.length ? this.write(buf) : '';
		if (this.lastNeed) return r + '\ufffd';
		return r;
	}
	
	// UTF-16LE typically needs two bytes per character, but even if we have an even
	// number of bytes available, we need to check if we end on a leading/high
	// surrogate. In that case, we need to wait for the next two bytes in order to
	// decode the last character properly.
	function utf16Text(buf, i) {
		if ((buf.length - i) % 2 === 0) {
			var r = buf.toString('utf16le', i);
			if (r) {
				var c = r.charCodeAt(r.length - 1);
				if (c >= 0xD800 && c <= 0xDBFF) {
					this.lastNeed = 2;
					this.lastTotal = 4;
					this.lastChar[0] = buf[buf.length - 2];
					this.lastChar[1] = buf[buf.length - 1];
					return r.slice(0, -1);
				}
			}
			return r;
		}
		this.lastNeed = 1;
		this.lastTotal = 2;
		this.lastChar[0] = buf[buf.length - 1];
		return buf.toString('utf16le', i, buf.length - 1);
	}
	
	// For UTF-16LE we do not explicitly append special replacement characters if we
	// end on a partial character, we simply let v8 handle that.
	function utf16End(buf) {
		var r = buf && buf.length ? this.write(buf) : '';
		if (this.lastNeed) {
			var end = this.lastTotal - this.lastNeed;
			return r + this.lastChar.toString('utf16le', 0, end);
		}
		return r;
	}
	
	function base64Text(buf, i) {
		var n = (buf.length - i) % 3;
		if (n === 0) return buf.toString('base64', i);
		this.lastNeed = 3 - n;
		this.lastTotal = 3;
		if (n === 1) {
			this.lastChar[0] = buf[buf.length - 1];
		} else {
			this.lastChar[0] = buf[buf.length - 2];
			this.lastChar[1] = buf[buf.length - 1];
		}
		return buf.toString('base64', i, buf.length - n);
	}
	
	function base64End(buf) {
		var r = buf && buf.length ? this.write(buf) : '';
		if (this.lastNeed) return r + this.lastChar.toString('base64', 0, 3 - this.lastNeed);
		return r;
	}
	
	// Pass bytes on through for single-byte encodings (e.g. ascii, latin1, hex)
	function simpleWrite(buf) {
		return buf.toString(this.encoding);
	}
	
	function simpleEnd(buf) {
		return buf && buf.length ? this.write(buf) : '';
	}
	
	/***/ }),
	/* 46 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a transform stream is a readable/writable stream where you do
	// something with the data.  Sometimes it's called a "filter",
	// but that's not a great name for it, since that implies a thing where
	// some bits pass through, and others are simply ignored.  (That would
	// be a valid example of a transform, of course.)
	//
	// While the output is causally related to the input, it's not a
	// necessarily symmetric or synchronous transformation.  For example,
	// a zlib stream might take multiple plain-text writes(), and then
	// emit a single compressed chunk some time in the future.
	//
	// Here's how this works:
	//
	// The Transform stream has all the aspects of the readable and writable
	// stream classes.  When you write(chunk), that calls _write(chunk,cb)
	// internally, and returns false if there's a lot of pending writes
	// buffered up.  When you call read(), that calls _read(n) until
	// there's enough pending readable data buffered up.
	//
	// In a transform stream, the written data is placed in a buffer.  When
	// _read(n) is called, it transforms the queued up data, calling the
	// buffered _write cb's as it consumes chunks.  If consuming a single
	// written chunk would result in multiple output chunks, then the first
	// outputted bit calls the readcb, and subsequent chunks just go into
	// the read buffer, and will cause it to emit 'readable' if necessary.
	//
	// This way, back-pressure is actually determined by the reading side,
	// since _read has to be called to start processing a new chunk.  However,
	// a pathological inflate type of transform can cause excessive buffering
	// here.  For example, imagine a stream where every byte of input is
	// interpreted as an integer from 0-255, and then results in that many
	// bytes of output.  Writing the 4 bytes {ff,ff,ff,ff} would result in
	// 1kb of data being output.  In this case, you could write a very small
	// amount of input, and end up with a very large amount of output.  In
	// such a pathological inflating mechanism, there'd be no way to tell
	// the system to stop doing the transform.  A single 4MB write could
	// cause the system to run out of memory.
	//
	// However, even in such a pathological case, only a single written chunk
	// would be consumed, and then the rest would wait (un-transformed) until
	// the results of the previous transformed chunk were consumed.
	
	
	
	module.exports = Transform;
	
	var Duplex = __webpack_require__(9);
	
	/*<replacement>*/
	var util = __webpack_require__(16);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	util.inherits(Transform, Duplex);
	
	function afterTransform(er, data) {
		var ts = this._transformState;
		ts.transforming = false;
	
		var cb = ts.writecb;
	
		if (!cb) {
			return this.emit('error', new Error('write callback called multiple times'));
		}
	
		ts.writechunk = null;
		ts.writecb = null;
	
		if (data != null) // single equals check for both `null` and `undefined`
			this.push(data);
	
		cb(er);
	
		var rs = this._readableState;
		rs.reading = false;
		if (rs.needReadable || rs.length < rs.highWaterMark) {
			this._read(rs.highWaterMark);
		}
	}
	
	function Transform(options) {
		if (!(this instanceof Transform)) return new Transform(options);
	
		Duplex.call(this, options);
	
		this._transformState = {
			afterTransform: afterTransform.bind(this),
			needTransform: false,
			transforming: false,
			writecb: null,
			writechunk: null,
			writeencoding: null
		};
	
		// start out asking for a readable event once data is transformed.
		this._readableState.needReadable = true;
	
		// we have implemented the _read method, and done the other things
		// that Readable wants before the first _read call, so unset the
		// sync guard flag.
		this._readableState.sync = false;
	
		if (options) {
			if (typeof options.transform === 'function') this._transform = options.transform;
	
			if (typeof options.flush === 'function') this._flush = options.flush;
		}
	
		// When the writable side finishes, then flush out anything remaining.
		this.on('prefinish', prefinish);
	}
	
	function prefinish() {
		var _this = this;
	
		if (typeof this._flush === 'function') {
			this._flush(function (er, data) {
				done(_this, er, data);
			});
		} else {
			done(this, null, null);
		}
	}
	
	Transform.prototype.push = function (chunk, encoding) {
		this._transformState.needTransform = false;
		return Duplex.prototype.push.call(this, chunk, encoding);
	};
	
	// This is the part where you do stuff!
	// override this function in implementation classes.
	// 'chunk' is an input chunk.
	//
	// Call `push(newChunk)` to pass along transformed output
	// to the readable side.  You may call 'push' zero or more times.
	//
	// Call `cb(err)` when you are done with this chunk.  If you pass
	// an error, then that'll put the hurt on the whole operation.  If you
	// never call cb(), then you'll never get another chunk.
	Transform.prototype._transform = function (chunk, encoding, cb) {
		throw new Error('_transform() is not implemented');
	};
	
	Transform.prototype._write = function (chunk, encoding, cb) {
		var ts = this._transformState;
		ts.writecb = cb;
		ts.writechunk = chunk;
		ts.writeencoding = encoding;
		if (!ts.transforming) {
			var rs = this._readableState;
			if (ts.needTransform || rs.needReadable || rs.length < rs.highWaterMark) this._read(rs.highWaterMark);
		}
	};
	
	// Doesn't matter what the args are here.
	// _transform does all the work.
	// That we got here means that the readable side wants more data.
	Transform.prototype._read = function (n) {
		var ts = this._transformState;
	
		if (ts.writechunk !== null && ts.writecb && !ts.transforming) {
			ts.transforming = true;
			this._transform(ts.writechunk, ts.writeencoding, ts.afterTransform);
		} else {
			// mark that we need a transform, so that any data that comes in
			// will get processed, now that we've asked for it.
			ts.needTransform = true;
		}
	};
	
	Transform.prototype._destroy = function (err, cb) {
		var _this2 = this;
	
		Duplex.prototype._destroy.call(this, err, function (err2) {
			cb(err2);
			_this2.emit('close');
		});
	};
	
	function done(stream, er, data) {
		if (er) return stream.emit('error', er);
	
		if (data != null) // single equals check for both `null` and `undefined`
			stream.push(data);
	
		// if there's nothing in the write buffer, then that means
		// that nothing more will ever be provided
		if (stream._writableState.length) throw new Error('Calling transform done when ws.length != 0');
	
		if (stream._transformState.transforming) throw new Error('Calling transform done when still transforming');
	
		return stream.push(null);
	}
	
	/***/ }),
	/* 47 */
	/***/ (function(module, exports) {
	
	var Overlay;
	
	Overlay = (function() {
		function Overlay(element, options) {
			this.element = element;
			if (typeof this.init === "function") {
				this.init(options);
			}
		}
	
		Overlay.prototype.dispose = function() {};
	
		return Overlay;
	
	})();
	
	module.exports = Overlay;
	
	
	/***/ }),
	/* 48 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Array_, Buffer, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Buffer = __webpack_require__(19);
	
	Util = __webpack_require__(0);
	
	Array_ = (function(superClass) {
		extend(Array_, superClass);
	
		function Array_() {
			return Array_.__super__.constructor.apply(this, arguments);
		}
	
		Array_.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'array', 'texture', 'raw'];
	
		Array_.prototype.init = function() {
			this.buffer = this.spec = null;
			this.space = {
				width: 0,
				history: 0
			};
			this.used = {
				width: 0
			};
			this.storage = 'arrayBuffer';
			this.passthrough = function(emit, x) {
				return emit(x, 0, 0, 0);
			};
			return Array_.__super__.init.apply(this, arguments);
		};
	
		Array_.prototype.sourceShader = function(shader) {
			var dims;
			dims = this.getDimensions();
			this.alignShader(dims, shader);
			return this.buffer.shader(shader);
		};
	
		Array_.prototype.getDimensions = function() {
			return {
				items: this.items,
				width: this.space.width,
				height: this.space.history,
				depth: 1
			};
		};
	
		Array_.prototype.getActiveDimensions = function() {
			return {
				items: this.items,
				width: this.used.width,
				height: this.buffer.getFilled(),
				depth: 1
			};
		};
	
		Array_.prototype.getFutureDimensions = function() {
			return {
				items: this.items,
				width: this.used.width,
				height: this.space.history,
				depth: 1
			};
		};
	
		Array_.prototype.getRawDimensions = function() {
			return {
				items: this.items,
				width: space.width,
				height: 1,
				depth: 1
			};
		};
	
		Array_.prototype.make = function() {
			var channels, data, dims, history, items, magFilter, minFilter, ref, ref1, ref2, reserve, space, type, width;
			Array_.__super__.make.apply(this, arguments);
			minFilter = (ref = this.minFilter) != null ? ref : this.props.minFilter;
			magFilter = (ref1 = this.magFilter) != null ? ref1 : this.props.magFilter;
			type = (ref2 = this.type) != null ? ref2 : this.props.type;
			width = this.props.width;
			history = this.props.history;
			reserve = this.props.bufferWidth;
			channels = this.props.channels;
			items = this.props.items;
			dims = this.spec = {
				channels: channels,
				items: items,
				width: width
			};
			this.items = dims.items;
			this.channels = dims.channels;
			data = this.props.data;
			dims = Util.Data.getDimensions(data, dims);
			space = this.space;
			space.width = Math.max(reserve, dims.width || 1);
			space.history = history;
			return this.buffer = this._renderables.make(this.storage, {
				width: space.width,
				history: space.history,
				channels: channels,
				items: items,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
		};
	
		Array_.prototype.unmake = function() {
			Array_.__super__.unmake.apply(this, arguments);
			if (this.buffer) {
				this.buffer.dispose();
				return this.buffer = this.spec = null;
			}
		};
	
		Array_.prototype.change = function(changed, touched, init) {
			var width;
			if (touched['texture'] || changed['history.history'] || changed['buffer.channels'] || changed['buffer.items'] || changed['array.bufferWidth']) {
				return this.rebuild();
			}
			if (!this.buffer) {
				return;
			}
			if (changed['array.width']) {
				this.spec.width = width = this.props.width;
				if (width > this.space.width) {
					return this.rebuild();
				}
			}
			if (changed['data.map'] || changed['data.data'] || changed['data.resolve'] || changed['data.expr'] || init) {
				return this.buffer.setCallback(this.emitter());
			}
		};
	
		Array_.prototype.callback = function(callback) {
			if (callback.length <= 2) {
				return callback;
			} else {
				return (function(_this) {
					return function(emit, i) {
						return callback(emit, i, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		Array_.prototype.update = function() {
			var data, filled, l, ref, ref1, space, used, width;
			if (!this.buffer) {
				return;
			}
			ref = this.props, data = ref.data, width = ref.width;
			ref1 = this, space = ref1.space, used = ref1.used;
			l = used.width;
			filled = this.buffer.getFilled();
			this.syncBuffer((function(_this) {
				return function(abort) {
					var base, dims;
					if (data != null) {
						dims = Util.Data.getDimensions(data, _this.spec);
						if (dims.width > space.width) {
							abort();
							return _this.rebuild();
						}
						used.width = dims.width;
						_this.buffer.setActive(used.width);
						if (typeof (base = _this.buffer.callback).rebind === "function") {
							base.rebind(data);
						}
						return _this.buffer.update();
					} else {
						width = _this.spec.width || 1;
						_this.buffer.setActive(width);
						width = _this.buffer.update();
						return used.width = width;
					}
				};
			})(this));
			if (used.width !== l || filled !== this.buffer.getFilled()) {
				return this.trigger({
					type: 'source.resize'
				});
			}
		};
	
		return Array_;
	
	})(Buffer);
	
	module.exports = Array_;
	
	
	/***/ }),
	/* 49 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, Matrix, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Buffer = __webpack_require__(19);
	
	Util = __webpack_require__(0);
	
	Matrix = (function(superClass) {
		extend(Matrix, superClass);
	
		function Matrix() {
			return Matrix.__super__.constructor.apply(this, arguments);
		}
	
		Matrix.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'texture', 'matrix', 'raw'];
	
		Matrix.prototype.init = function() {
			this.buffer = this.spec = null;
			this.space = {
				width: 0,
				height: 0,
				history: 0
			};
			this.used = {
				width: 0,
				height: 0
			};
			this.storage = 'matrixBuffer';
			this.passthrough = function(emit, x, y) {
				return emit(x, y, 0, 0);
			};
			return Matrix.__super__.init.apply(this, arguments);
		};
	
		Matrix.prototype.sourceShader = function(shader) {
			var dims;
			dims = this.getDimensions();
			this.alignShader(dims, shader);
			return this.buffer.shader(shader);
		};
	
		Matrix.prototype.getDimensions = function() {
			return {
				items: this.items,
				width: this.space.width,
				height: this.space.height,
				depth: this.space.history
			};
		};
	
		Matrix.prototype.getActiveDimensions = function() {
			return {
				items: this.items,
				width: this.used.width,
				height: this.used.height,
				depth: this.buffer.getFilled()
			};
		};
	
		Matrix.prototype.getFutureDimensions = function() {
			return {
				items: this.items,
				width: this.used.width,
				height: this.used.height,
				depth: this.space.history
			};
		};
	
		Matrix.prototype.getRawDimensions = function() {
			return {
				items: this.items,
				width: this.space.width,
				height: this.space.height,
				depth: 1
			};
		};
	
		Matrix.prototype.make = function() {
			var channels, data, dims, height, history, items, magFilter, minFilter, ref, ref1, ref2, reserveX, reserveY, space, type, width;
			Matrix.__super__.make.apply(this, arguments);
			minFilter = (ref = this.minFilter) != null ? ref : this.props.minFilter;
			magFilter = (ref1 = this.magFilter) != null ? ref1 : this.props.magFilter;
			type = (ref2 = this.type) != null ? ref2 : this.props.type;
			width = this.props.width;
			height = this.props.height;
			history = this.props.history;
			reserveX = this.props.bufferWidth;
			reserveY = this.props.bufferHeight;
			channels = this.props.channels;
			items = this.props.items;
			dims = this.spec = {
				channels: channels,
				items: items,
				width: width,
				height: height
			};
			this.items = dims.items;
			this.channels = dims.channels;
			data = this.props.data;
			dims = Util.Data.getDimensions(data, dims);
			space = this.space;
			space.width = Math.max(reserveX, dims.width || 1);
			space.height = Math.max(reserveY, dims.height || 1);
			space.history = history;
			return this.buffer = this._renderables.make(this.storage, {
				width: space.width,
				height: space.height,
				history: space.history,
				channels: channels,
				items: items,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
		};
	
		Matrix.prototype.unmake = function() {
			Matrix.__super__.unmake.apply(this, arguments);
			if (this.buffer) {
				this.buffer.dispose();
				return this.buffer = this.spec = null;
			}
		};
	
		Matrix.prototype.change = function(changed, touched, init) {
			var height, width;
			if (touched['texture'] || changed['matrix.history'] || changed['buffer.channels'] || changed['buffer.items'] || changed['matrix.bufferWidth'] || changed['matrix.bufferHeight']) {
				return this.rebuild();
			}
			if (!this.buffer) {
				return;
			}
			if (changed['matrix.width']) {
				this.spec.width = width = this.props.width;
				if (width > this.space.width) {
					return this.rebuild();
				}
			}
			if (changed['matrix.height']) {
				this.spec.height = height = this.props.height;
				if (height > this.space.height) {
					return this.rebuild();
				}
			}
			if (changed['data.map'] || changed['data.data'] || changed['data.resolve'] || changed['data.expr'] || init) {
				return this.buffer.setCallback(this.emitter());
			}
		};
	
		Matrix.prototype.callback = function(callback) {
			if (callback.length <= 3) {
				return callback;
			} else {
				return (function(_this) {
					return function(emit, i, j) {
						return callback(emit, i, j, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		Matrix.prototype.update = function() {
			var data, filled, h, height, ref, ref1, space, used, w, width;
			if (!this.buffer) {
				return;
			}
			ref = this.props, data = ref.data, width = ref.width, height = ref.height;
			ref1 = this, space = ref1.space, used = ref1.used;
			w = used.width;
			h = used.height;
			filled = this.buffer.getFilled();
			this.syncBuffer((function(_this) {
				return function(abort) {
					var _w, base, dims, length;
					if (data != null) {
						dims = Util.Data.getDimensions(data, _this.spec);
						if (dims.width > space.width || dims.height > space.height) {
							abort();
							return _this.rebuild();
						}
						used.width = dims.width;
						used.height = dims.height;
						_this.buffer.setActive(used.width, used.height);
						if (typeof (base = _this.buffer.callback).rebind === "function") {
							base.rebind(data);
						}
						return _this.buffer.update();
					} else {
						width = _this.spec.width || 1;
						height = _this.spec.height || 1;
						_this.buffer.setActive(width, height);
						length = _this.buffer.update();
						used.width = _w = width;
						used.height = Math.min(height, Math.ceil(length / _w));
						if (used.height === 1) {
							return used.width = Math.min(width, length);
						}
					}
				};
			})(this));
			if (used.width !== w || used.height !== h || filled !== this.buffer.getFilled()) {
				return this.trigger({
					type: 'source.resize'
				});
			}
		};
	
		return Matrix;
	
	})(Buffer);
	
	module.exports = Matrix;
	
	
	/***/ }),
	/* 50 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Resample, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Resample = (function(superClass) {
		extend(Resample, superClass);
	
		function Resample() {
			return Resample.__super__.constructor.apply(this, arguments);
		}
	
		Resample.traits = ['node', 'bind', 'operator', 'source', 'index', 'resample', 'sampler:x', 'sampler:y', 'sampler:z', 'sampler:w', 'include'];
	
		Resample.prototype.indexShader = function(shader) {
			shader.pipe(this.indexer);
			return Resample.__super__.indexShader.call(this, shader);
		};
	
		Resample.prototype.sourceShader = function(shader) {
			return shader.pipe(this.operator);
		};
	
		Resample.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Resample.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Resample.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Resample.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Resample.prototype._resample = function(dims) {
			var c, p, r;
			r = this.resampled;
			c = this.centered;
			p = this.padding;
			if (this.relativeSize) {
				if (!c.items) {
					dims.items--;
				}
				if (!c.width) {
					dims.width--;
				}
				if (!c.height) {
					dims.height--;
				}
				if (!c.depth) {
					dims.depth--;
				}
				if (r.items != null) {
					dims.items *= r.items;
				}
				if (r.width != null) {
					dims.width *= r.width;
				}
				if (r.height != null) {
					dims.height *= r.height;
				}
				if (r.depth != null) {
					dims.depth *= r.depth;
				}
				if (!c.items) {
					dims.items++;
				}
				if (!c.width) {
					dims.width++;
				}
				if (!c.height) {
					dims.height++;
				}
				if (!c.depth) {
					dims.depth++;
				}
				dims.items -= p.items * 2;
				dims.width -= p.width * 2;
				dims.height -= p.height * 2;
				dims.depth -= p.depth * 2;
			} else {
				if (r.items != null) {
					dims.items = r.items;
				}
				if (r.width != null) {
					dims.width = r.width;
				}
				if (r.height != null) {
					dims.height = r.height;
				}
				if (r.depth != null) {
					dims.depth = r.depth;
				}
			}
			dims.items = Math.max(0, Math.floor(dims.items));
			dims.width = Math.max(0, Math.floor(dims.width));
			dims.height = Math.max(0, Math.floor(dims.height));
			dims.depth = Math.max(0, Math.floor(dims.depth));
			return dims;
		};
	
		Resample.prototype.make = function() {
			var any, centered, channels, depth, height, i, indexer, indices, items, j, key, len, operator, ref, ref1, ref2, relativeSample, relativeSize, resize, sample, shader, size, type, uniforms, vec, width;
			Resample.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			this._helpers.bind.make([
				{
					to: 'include.shader',
					trait: 'shader',
					optional: true
				}
			]);
			ref = this.props, indices = ref.indices, channels = ref.channels;
			shader = this.bind.shader;
			ref1 = this.props, sample = ref1.sample, size = ref1.size, items = ref1.items, width = ref1.width, height = ref1.height, depth = ref1.depth;
			relativeSample = sample === this.node.attributes['resample.sample']["enum"].relative;
			relativeSize = size === this.node.attributes['resample.size']["enum"].relative;
			this.resampled = {};
			if (items != null) {
				this.resampled.items = items;
			}
			if (width != null) {
				this.resampled.width = width;
			}
			if (height != null) {
				this.resampled.height = height;
			}
			if (depth != null) {
				this.resampled.depth = depth;
			}
			this.centered = {};
			this.centered.items = this.props.centeredW;
			this.centered.width = this.props.centeredX;
			this.centered.height = this.props.centeredY;
			this.centered.depth = this.props.centeredZ;
			this.padding = {};
			this.padding.items = this.props.paddingW;
			this.padding.width = this.props.paddingX;
			this.padding.height = this.props.paddingY;
			this.padding.depth = this.props.paddingZ;
			operator = this._shaders.shader();
			indexer = this._shaders.shader();
			type = [null, this._types.number, this._types.vec2, this._types.vec3, this._types.vec4][indices];
			uniforms = {
				dataSize: this._attributes.make(type(0, 0, 0, 0)),
				dataResolution: this._attributes.make(type(0, 0, 0, 0)),
				targetSize: this._attributes.make(type(0, 0, 0, 0)),
				targetResolution: this._attributes.make(type(0, 0, 0, 0)),
				resampleFactor: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
				resampleBias: this._attributes.make(this._types.vec4(0, 0, 0, 0))
			};
			this.dataResolution = uniforms.dataResolution;
			this.dataSize = uniforms.dataSize;
			this.targetResolution = uniforms.targetResolution;
			this.targetSize = uniforms.targetSize;
			this.resampleFactor = uniforms.resampleFactor;
			this.resampleBias = uniforms.resampleBias;
			resize = (items != null) || (width != null) || (height != null) || (depth != null);
			operator.pipe('resample.padding', uniforms);
			vec = [];
			any = false;
			ref2 = ['width', 'height', 'depth', 'items'];
			for (i = j = 0, len = ref2.length; j < len; i = ++j) {
				key = ref2[i];
				centered = this.centered[key];
				any || (any = centered);
				vec[i] = centered ? "0.5" : "0.0";
			}
			if (any) {
				vec = "vec4(" + vec + ")";
				operator.pipe(Util.GLSL.binaryOperator(4, '+', vec4));
				if (resize) {
					indexer.pipe(Util.GLSL.binaryOperator(4, '+', vec4));
				}
			}
			if (relativeSample) {
				if (resize) {
					operator.pipe('resample.relative', uniforms);
					indexer.pipe('resample.relative', uniforms);
				} else {
					indexer.pipe(Util.GLSL.identity('vec4'));
				}
			}
			if (shader != null) {
				if (indices !== 4) {
					operator.pipe(Util.GLSL.truncateVec(4, indices));
				}
				operator.callback();
				if (indices !== 4) {
					operator.pipe(Util.GLSL.extendVec(indices, 4));
				}
				if (any) {
					operator.pipe(Util.GLSL.binaryOperator(4, '-', vec));
				}
				operator.pipe(this.bind.source.sourceShader(this._shaders.shader()));
				if (channels !== 4) {
					operator.pipe(Util.GLSL.truncateVec(4, channels));
				}
				operator.join();
				if (this.bind.shader != null) {
					operator.pipe(this.bind.shader.shaderBind(uniforms));
				}
				if (channels !== 4) {
					operator.pipe(Util.GLSL.extendVec(channels, 4));
				}
			} else {
				if (any) {
					operator.pipe(Util.GLSL.binaryOperator(4, '-', vec));
				}
				operator.pipe(this.bind.source.sourceShader(this._shaders.shader()));
			}
			if (any && resize) {
				indexer.pipe(Util.GLSL.binaryOperator(4, '-', vec));
			}
			this.operator = operator;
			this.indexer = indexer;
			this.indices = indices;
			this.relativeSample = relativeSample;
			return this.relativeSize = relativeSize;
		};
	
		Resample.prototype.unmake = function() {
			Resample.__super__.unmake.apply(this, arguments);
			return this.operator = null;
		};
	
		Resample.prototype.resize = function() {
			var axis, bd, bh, bi, bw, dims, rd, ref, ref1, ref2, ref3, rh, ri, rw, target;
			if (this.bind.source == null) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			target = this.getActiveDimensions();
			axis = (function(_this) {
				return function(key) {
					var centered, pad, res;
					centered = _this.centered[key];
					pad = _this.padding[key];
					target[key] += pad * 2;
					res = centered ? dims[key] / Math.max(1, target[key]) : Math.max(1, dims[key] - 1) / Math.max(1, target[key] - 1);
					return [res, pad];
				};
			})(this);
			ref = axis('width'), rw = ref[0], bw = ref[1];
			ref1 = axis('height'), rh = ref1[0], bh = ref1[1];
			ref2 = axis('depth'), rd = ref2[0], bd = ref2[1];
			ref3 = axis('items'), ri = ref3[0], bi = ref3[1];
			if (this.indices === 1) {
				this.dataResolution.value = 1 / dims.width;
				this.targetResolution.value = 1 / target.width;
				this.dataSize.value = dims.width;
				this.targetSize.value = target.width;
			} else {
				this.dataResolution.value.set(1 / dims.width, 1 / dims.height, 1 / dims.depth, 1 / dims.items);
				this.targetResolution.value.set(1 / target.width, 1 / target.height, 1 / target.depth, 1 / target.items);
				this.dataSize.value.set(dims.width, dims.height, dims.depth, dims.items);
				this.targetSize.value.set(target.width, target.height, target.depth, target.items);
			}
			this.resampleFactor.value.set(rw, rh, rd, ri);
			this.resampleBias.value.set(bw, bh, bd, bi);
			return Resample.__super__.resize.apply(this, arguments);
		};
	
		Resample.prototype.change = function(changed, touched, init) {
			if (touched['operator'] || touched['resample'] || touched['sampler'] || touched['include']) {
				return this.rebuild();
			}
		};
	
		return Resample;
	
	})(Operator);
	
	module.exports = Resample;
	
	
	/***/ }),
	/* 51 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Transition, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Util = __webpack_require__(0);
	
	Transition = (function(superClass) {
		extend(Transition, superClass);
	
		function Transition() {
			return Transition.__super__.constructor.apply(this, arguments);
		}
	
		Transition.traits = ['node', 'transition', 'transform', 'mask', 'visible', 'active'];
	
		Transition.prototype.init = function() {
			this.animate = null;
			this.uniforms = null;
			this.state = {
				isVisible: true,
				isActive: true,
				enter: 1,
				exit: 1
			};
			this.latched = null;
			return this.locked = null;
		};
	
		Transition.prototype.make = function() {
			var activeParent, slideParent, visibleParent;
			this.uniforms = {
				transitionFrom: this._attributes.make(this._types.vec4()),
				transitionTo: this._attributes.make(this._types.vec4()),
				transitionActive: this._attributes.make(this._types.bool()),
				transitionScale: this._attributes.make(this._types.vec4()),
				transitionBias: this._attributes.make(this._types.vec4()),
				transitionEnter: this._attributes.make(this._types.number()),
				transitionExit: this._attributes.make(this._types.number()),
				transitionSkew: this._attributes.make(this._types.number())
			};
			slideParent = this._inherit('slide');
			visibleParent = this._inherit('visible');
			activeParent = this._inherit('active');
			this._listen(slideParent, 'transition.latch', (function(_this) {
				return function(e) {
					return _this.latch(e.step);
				};
			})(this));
			this._listen(slideParent, 'transition.release', (function(_this) {
				return function() {
					return _this.release();
				};
			})(this));
			this._listen(visibleParent, 'visible.change', (function(_this) {
				return function() {
					return _this.update((_this.state.isVisible = visibleParent.isVisible));
				};
			})(this));
			this._listen(activeParent, 'active.change', (function(_this) {
				return function() {
					return _this.update((_this.state.isActive = activeParent.isActive));
				};
			})(this));
			this.animate = this._animator.make(this._types.vec2(1, 1), {
				step: (function(_this) {
					return function(value) {
						_this.state.enter = value.x;
						_this.state.exit = value.y;
						return _this.update();
					};
				})(this),
				complete: (function(_this) {
					return function(done) {
						return _this.complete(done);
					};
				})(this)
			});
			return this.move = (this.props.from != null) || (this.props.to != null);
		};
	
		Transition.prototype.unmake = function() {
			return this.animate.dispose();
		};
	
		Transition.prototype.latch = function(step) {
			var enter, exit, forward, latched, ref, visible;
			this.locked = null;
			this.latched = latched = {
				isVisible: this.state.isVisible,
				isActive: this.state.isActive,
				step: step
			};
			visible = this.isVisible;
			if (!visible) {
				forward = latched.step >= 0;
				ref = forward ? [0, 1] : [1, 0], enter = ref[0], exit = ref[1];
				return this.animate.set(enter, exit);
			}
		};
	
		Transition.prototype.release = function() {
			var delay, delayEnter, delayExit, duration, durationEnter, durationExit, enter, exit, forward, latched, ref, ref1, ref2, state, visible;
			latched = this.latched;
			state = this.state;
			this.latched = null;
			if (latched.isVisible !== state.isVisible) {
				forward = latched.step >= 0;
				visible = state.isVisible;
				ref = visible ? [1, 1] : forward ? [1, 0] : [0, 1], enter = ref[0], exit = ref[1];
				ref1 = this.props, duration = ref1.duration, durationEnter = ref1.durationEnter, durationExit = ref1.durationExit;
				if (durationEnter == null) {
					durationEnter = duration;
				}
				if (durationExit == null) {
					durationExit = duration;
				}
				duration = visible * durationEnter + !visible * durationExit;
				ref2 = this.props, delay = ref2.delay, delayEnter = ref2.delayEnter, delayExit = ref2.delayExit;
				if (delayEnter == null) {
					delayEnter = delay;
				}
				if (delayExit == null) {
					delayExit = delay;
				}
				delay = visible * delayEnter + !visible * delayExit;
				this.animate.immediate({
					x: enter,
					y: exit
				}, {
					duration: duration,
					delay: delay,
					ease: 'linear'
				});
				this.locked = {
					isVisible: true,
					isActive: latched.isActive || state.isActive
				};
			}
			return this.update();
		};
	
		Transition.prototype.complete = function(done) {
			if (!done) {
				return;
			}
			this.locked = null;
			return this.update();
		};
	
		Transition.prototype.update = function() {
			var active, enter, exit, level, partial, ref, ref1, visible;
			if (this.latched != null) {
				return;
			}
			ref = this.props, enter = ref.enter, exit = ref.exit;
			if (enter == null) {
				enter = this.state.enter;
			}
			if (exit == null) {
				exit = this.state.exit;
			}
			level = enter * exit;
			visible = level > 0;
			partial = level < 1;
			this.uniforms.transitionEnter.value = enter;
			this.uniforms.transitionExit.value = exit;
			this.uniforms.transitionActive.value = partial;
			if (visible) {
				visible = !!this.state.isVisible;
			}
			if (this.locked != null) {
				visible = this.locked.isVisible;
			}
			if (this.isVisible !== visible) {
				this.isVisible = visible;
				this.trigger({
					type: 'visible.change'
				});
			}
			active = !!(this.state.isActive || ((ref1 = this.locked) != null ? ref1.isActive : void 0));
			if (this.isActive !== active) {
				this.isActive = active;
				return this.trigger({
					type: 'active.change'
				});
			}
		};
	
		Transition.prototype.change = function(changed, touched, init) {
			var flipW, flipX, flipY, flipZ, stagger, staggerW, staggerX, staggerY, staggerZ;
			if (changed['transition.enter'] || changed['transition.exit'] || init) {
				this.update();
			}
			if (changed['transition.stagger'] || init) {
				stagger = this.props.stagger;
				flipX = stagger.x < 0;
				flipY = stagger.y < 0;
				flipZ = stagger.z < 0;
				flipW = stagger.w < 0;
				staggerX = Math.abs(stagger.x);
				staggerY = Math.abs(stagger.y);
				staggerZ = Math.abs(stagger.z);
				staggerW = Math.abs(stagger.w);
				this.uniforms.transitionSkew.value = staggerX + staggerY + staggerZ + staggerW;
				this.uniforms.transitionScale.value.set((1 - flipX * 2) * staggerX, (1 - flipY * 2) * staggerY, (1 - flipZ * 2) * staggerZ, (1 - flipW * 2) * staggerW);
				return this.uniforms.transitionBias.value.set(flipX * staggerX, flipY * staggerY, flipZ * staggerZ, flipW * staggerW);
			}
		};
	
		return Transition;
	
	})(Parent);
	
	module.exports = Transition;
	
	
	/***/ }),
	/* 52 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Ease, Primitive, Track, deepCopy,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Ease = __webpack_require__(0).Ease;
	
	deepCopy = function(x) {
		var k, out, v;
		out = {};
		for (k in x) {
			v = x[k];
			if (v instanceof Array) {
				out[k] = v.slice();
			} else if ((v != null) && typeof v === 'object') {
				out[k] = deepCopy(v);
			} else {
				out[k] = v;
			}
		}
		return out;
	};
	
	Track = (function(superClass) {
		extend(Track, superClass);
	
		function Track() {
			return Track.__super__.constructor.apply(this, arguments);
		}
	
		Track.traits = ['node', 'track', 'seek', 'bind'];
	
		Track.prototype.init = function() {
			this.handlers = {};
			this.script = null;
			this.values = null;
			this.playhead = 0;
			this.velocity = null;
			this.section = null;
			return this.expr = null;
		};
	
		Track.prototype.make = function() {
			var node, ref, script;
			this._helpers.bind.make([
				{
					to: 'track.target',
					trait: 'node',
					callback: null
				}
			]);
			script = this.props.script;
			node = this.bind.target.node;
			this.targetNode = node;
			return ref = this._process(node, script), this.script = ref[0], this.values = ref[1], this.start = ref[2], this.end = ref[3], ref;
		};
	
		Track.prototype.unmake = function() {
			this.unbindExpr();
			this._helpers.bind.unmake();
			this.script = this.values = this.start = this.end = this.section = this.expr = null;
			return this.playhead = 0;
		};
	
		Track.prototype.bindExpr = function(expr) {
			var clock;
			this.unbindExpr();
			this.expr = expr;
			this.targetNode.bind(expr, true);
			clock = this.targetNode.clock;
			return this._attributes.bind(this.measure = (function() {
				var playhead;
				playhead = null;
				return (function(_this) {
					return function() {
						var step;
						step = clock.getTime().step;
						if (playhead != null) {
							_this.velocity = (_this.playhead - playhead) / step;
						}
						return playhead = _this.playhead;
					};
				})(this);
			})());
		};
	
		Track.prototype.unbindExpr = function() {
			if (this.expr != null) {
				this.targetNode.unbind(this.expr, true);
			}
			if (this.measure != null) {
				this._attributes.unbind(this.measure);
			}
			return this.expr = this.measure = null;
		};
	
		Track.prototype._process = function(object, script) {
			var end, i, j, k, key, l, last, len, len1, message, props, ref, ref1, ref2, result, s, start, step, v, values;
			if (script instanceof Array) {
				s = {};
				for (i = j = 0, len = script.length; j < len; i = ++j) {
					step = script[i];
					s[i] = step;
				}
				script = s;
			}
			s = [];
			for (key in script) {
				step = script[key];
				if (step == null) {
					step = [];
				}
				if (step instanceof Array) {
					step = {
						key: +key,
						props: step[0] != null ? deepCopy(step[0]) : {},
						bind: step[1] != null ? deepCopy(step[1]) : {}
					};
				} else {
					if ((step.key == null) && !step.props && !step.bind) {
						step = {
							props: deepCopy(step)
						};
					} else {
						step = deepCopy(step);
					}
					step.key = step.key != null ? +step.key : +key;
					if (step.props == null) {
						step.props = {};
					}
					if (step.bind == null) {
						step.bind = {};
					}
				}
				s.push(step);
			}
			script = s;
			if (!script.length) {
				return [[], {}, 0, 0];
			}
			script.sort(function(a, b) {
				return a.key - b.key;
			});
			start = script[0].key;
			end = script[script.length - 1].key;
			for (key in script) {
				step = script[key];
				if (typeof last !== "undefined" && last !== null) {
					last.next = step;
				}
				last = step;
			}
			last.next = last;
			script = s;
			props = {};
			values = {};
			for (key in script) {
				step = script[key];
				ref = step.props;
				for (k in ref) {
					v = ref[k];
					props[k] = true;
				}
			}
			for (key in script) {
				step = script[key];
				ref1 = step.bind;
				for (k in ref1) {
					v = ref1[k];
					props[k] = true;
				}
			}
			for (k in props) {
				props[k] = object.get(k);
			}
			try {
				for (k in props) {
					values[k] = [object.attribute(k).T.make(), object.attribute(k).T.make(), object.attribute(k).T.make()];
				}
			} catch (error) {
				console.warn(this.node.toMarkup());
				message = (this.node.toString()) + " - Target " + object + " has no `" + k + "` property";
				throw new Error(message);
			}
			result = [];
			for (l = 0, len1 = script.length; l < len1; l++) {
				step = script[l];
				for (k in props) {
					v = props[k];
					v = object.validate(k, (ref2 = step.props[k]) != null ? ref2 : v);
					props[k] = step.props[k] = v;
					if ((step.bind[k] != null) && typeof step.bind[k] !== 'function') {
						console.warn(this.node.toMarkup());
						message = (this.node.toString()) + " - Bind expression `" + step.bind[k] + "` on property `" + k + "` is not a function";
						throw new Error(message);
					}
				}
				result.push(step);
			}
			return [result, values, start, end];
		};
	
		Track.prototype.update = function() {
			var clock, ease, easeMethod, end, expr, find, from, getLerpFactor, getPlayhead, k, live, node, playhead, ref, ref1, script, section, seek, start, to;
			ref = this, playhead = ref.playhead, script = ref.script;
			ref1 = this.props, ease = ref1.ease, seek = ref1.seek;
			node = this.targetNode;
			if (seek != null) {
				playhead = seek;
			}
			if (script.length) {
				find = function() {
					var i, j, last, len, step;
					last = script[0];
					for (i = j = 0, len = script.length; j < len; i = ++j) {
						step = script[i];
						if (step.key > playhead) {
							break;
						}
						last = step;
					}
					return last;
				};
				section = this.section;
				if (!section || playhead < section.key || playhead > section.next.key) {
					section = find(script, playhead);
				}
				if (section === this.section) {
					return;
				}
				this.section = section;
				from = section;
				to = section.next;
				start = from.key;
				end = to.key;
				easeMethod = (function() {
					switch (ease) {
						case 'linear':
						case 0:
							return Ease.clamp;
						case 'cosine':
						case 1:
							return Ease.cosine;
						case 'binary':
						case 2:
							return Ease.binary;
						case 'hold':
						case 3:
							return Ease.hold;
						default:
							return Ease.cosine;
					}
				})();
				clock = node.clock;
				getPlayhead = (function(_this) {
					return function(time) {
						var now;
						if (_this.velocity == null) {
							return _this.playhead;
						}
						now = clock.getTime();
						return _this.playhead + _this.velocity * (time - now.time);
					};
				})(this);
				getLerpFactor = (function() {
					var scale;
					scale = 1 / Math.max(0.0001, end - start);
					return function(time) {
						return easeMethod((getPlayhead(time) - start) * scale, 0, 1);
					};
				})();
				live = (function(_this) {
					return function(key) {
						var animator, attr, fromE, fromP, invalid, toE, toP, values;
						fromE = from.bind[key];
						toE = to.bind[key];
						fromP = from.props[key];
						toP = to.props[key];
						invalid = function() {
							console.warn(node.toMarkup());
							throw new Error((this.node.toString()) + " - Invalid expression result on track `" + key + "`");
						};
						attr = node.attribute(key);
						values = _this.values[key];
						animator = _this._animator;
						if (fromE && toE) {
							return (function(values, from, to) {
								return function(time, delta) {
									var _from, _to;
									values[0] = _from = attr.T.validate(fromE(time, delta), values[0], invalid);
									values[1] = _to = attr.T.validate(toE(time, delta), values[1], invalid);
									return values[2] = animator.lerp(attr.T, _from, _to, getLerpFactor(time), values[2]);
								};
							})(values, from, to);
						} else if (fromE) {
							return (function(values, from, to) {
								return function(time, delta) {
									var _from;
									values[0] = _from = attr.T.validate(fromE(time, delta), values[0], invalid);
									return values[1] = animator.lerp(attr.T, _from, toP, getLerpFactor(time), values[1]);
								};
							})(values, from, to);
						} else if (toE) {
							return (function(values, from, to) {
								return function(time, delta) {
									var _to;
									values[0] = _to = attr.T.validate(toE(time, delta), values[0], invalid);
									return values[1] = animator.lerp(attr.T, fromP, _to, getLerpFactor(time), values[1]);
								};
							})(values, from, to);
						} else {
							return (function(values, from, to) {
								return function(time, delta) {
									return values[0] = animator.lerp(attr.T, fromP, toP, getLerpFactor(time), values[0]);
								};
							})(values, from, to);
						}
					};
				})(this);
				expr = {};
				for (k in from.bind) {
					if (expr[k] == null) {
						expr[k] = live(k);
					}
				}
				for (k in to.bind) {
					if (expr[k] == null) {
						expr[k] = live(k);
					}
				}
				for (k in from.props) {
					if (expr[k] == null) {
						expr[k] = live(k);
					}
				}
				for (k in to.props) {
					if (expr[k] == null) {
						expr[k] = live(k);
					}
				}
				return this.bindExpr(expr);
			}
		};
	
		Track.prototype.change = function(changed, touched, init) {
			if (changed['track.target'] || changed['track.script'] || changed['track.mode']) {
				return this.rebuild();
			}
			if (changed['seek.seek'] || init) {
				return this.update();
			}
		};
	
		return Track;
	
	})(Primitive);
	
	module.exports = Track;
	
	
	/***/ }),
	/* 53 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var THREE, Types, Util, decorate,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	THREE = __webpack_require__(1);
	
	Util = __webpack_require__(0);
	
	Types = {
		array: function(type, size, value) {
			var lerp, op;
			if (value == null) {
				value = null;
			}
			lerp = type.lerp ? function(a, b, target, f) {
				var i, j, l, ref;
				l = Math.min(a.length, b.length);
				for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
					target[i] = type.lerp(a[i], b[i], target[i], f);
				}
				return target;
			} : void 0;
			op = type.op ? function(a, b, target, op) {
				var i, j, l, ref;
				l = Math.min(a.length, b.length);
				for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
					target[i] = type.op(a[i], b[i], target[i], op);
				}
				return target;
			} : void 0;
			if ((value != null) && !(value instanceof Array)) {
				value = [value];
			}
			return {
				uniform: function() {
					if (type.uniform) {
						return type.uniform() + 'v';
					} else {
						return void 0;
					}
				},
				make: function() {
					var i, j, ref, results;
					if (value != null) {
						return value.slice();
					}
					if (!size) {
						return [];
					}
					results = [];
					for (i = j = 0, ref = size; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
						results.push(type.make());
					}
					return results;
				},
				validate: function(value, target, invalid) {
					var i, input, j, l, ref, ref1;
					if (!(value instanceof Array)) {
						value = [value];
					}
					l = target.length = size ? size : value.length;
					for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
						input = (ref1 = value[i]) != null ? ref1 : type.make();
						target[i] = type.validate(input, target[i], invalid);
					}
					return target;
				},
				equals: function(a, b) {
					var al, bl, i, j, l, ref;
					al = a.length;
					bl = b.length;
					if (al !== bl) {
						return false;
					}
					l = Math.min(al, bl);
					for (i = j = 0, ref = l; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
						if (!(typeof type.equals === "function" ? type.equals(a[i], b[i]) : void 0)) {
							return false;
						}
					}
					return true;
				},
				lerp: lerp,
				op: op,
				clone: function(v) {
					var j, len, results, x;
					results = [];
					for (j = 0, len = v.length; j < len; j++) {
						x = v[j];
						results.push(type.clone(x));
					}
					return results;
				}
			};
		},
		letters: function(type, size, value) {
			var array, i, j, len, v;
			if (value == null) {
				value = null;
			}
			if (value != null) {
				if (value === "" + value) {
					value = value.split('');
				}
				for (i = j = 0, len = value.length; j < len; i = ++j) {
					v = value[i];
					value[i] = type.validate(v, v);
				}
			}
			array = Types.array(type, size, value);
			return {
				uniform: function() {
					return array.uniform();
				},
				make: function() {
					return array.make();
				},
				validate: function(value, target, invalid) {
					if (value === "" + value) {
						value = value.split('');
					}
					return array.validate(value, target, invalid);
				},
				equals: function(a, b) {
					return array.equals(a, b);
				},
				clone: array.clone
			};
		},
		nullable: function(type, make) {
			var emitter, lerp, op, value;
			if (make == null) {
				make = false;
			}
			value = make ? type.make() : null;
			emitter = type.emitter ? function(expr1, expr2) {
				if (expr2 == null) {
					return expr1;
				}
				if (expr1 == null) {
					return expr2;
				}
				return type.emitter(expr1, expr2);
			} : void 0;
			lerp = type.lerp ? function(a, b, target, f) {
				if (a === null || b === null) {
					if (f < .5) {
						return a;
					} else {
						return b;
					}
				}
				if (target == null) {
					target = type.make();
				}
				value = type.lerp(a, b, target, f);
				return target;
			} : void 0;
			op = type.op ? function(a, b, target, op) {
				if (a === null || b === null) {
					return null;
				}
				if (target == null) {
					target = type.make();
				}
				value = type.op(a, b, target, op);
				return value;
			} : void 0;
			return {
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					if (value === null) {
						return value;
					}
					if (target === null) {
						target = type.make();
					}
					return type.validate(value, target, invalid);
				},
				uniform: function() {
					return typeof type.uniform === "function" ? type.uniform() : void 0;
				},
				equals: function(a, b) {
					var an, bn, ref;
					an = a === null;
					bn = b === null;
					if (an && bn) {
						return true;
					}
					if (an ^ bn) {
						return false;
					}
					return (ref = typeof type.equals === "function" ? type.equals(a, b) : void 0) != null ? ref : a === b;
				},
				lerp: lerp,
				op: op,
				emitter: emitter
			};
		},
		"enum": function(value, keys, map) {
			var i, j, key, len, len1, n, values;
			if (keys == null) {
				keys = [];
			}
			if (map == null) {
				map = {};
			}
			i = 0;
			values = {};
			for (j = 0, len = keys.length; j < len; j++) {
				key = keys[j];
				if (key !== +key) {
					if (map[key] == null) {
						map[key] = i++;
					}
				}
			}
			for (n = 0, len1 = keys.length; n < len1; n++) {
				key = keys[n];
				if (key === +key) {
					values[key] = key;
				}
			}
			for (key in map) {
				i = map[key];
				values[i] = true;
			}
			if (values[value] == null) {
				value = map[value];
			}
			return {
				"enum": function() {
					return map;
				},
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					var v;
					v = values[value] ? value : map[value];
					if (v != null) {
						return v;
					}
					return invalid();
				}
			};
		},
		enumber: function(value, keys, map) {
			var _enum;
			if (map == null) {
				map = {};
			}
			_enum = Types["enum"](value, keys, map);
			return {
				"enum": _enum["enum"],
				uniform: function() {
					return 'f';
				},
				make: function() {
					var ref;
					return (ref = _enum.make()) != null ? ref : +value;
				},
				validate: function(value, target, invalid) {
					if (value === +value) {
						return value;
					}
					return _enum.validate(value, target, invalid);
				},
				op: function(a, b, target, op) {
					return op(a, b);
				}
			};
		},
		select: function(value) {
			if (value == null) {
				value = '<';
			}
			value;
			return {
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					if (typeof value === 'string') {
						return value;
					}
					if (typeof value === 'object') {
						return value;
					}
					return invalid();
				}
			};
		},
		bool: function(value) {
			value = !!value;
			return {
				uniform: function() {
					return 'f';
				},
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					return !!value;
				}
			};
		},
		int: function(value) {
			if (value == null) {
				value = 0;
			}
			value = +Math.round(value);
			return {
				uniform: function() {
					return 'i';
				},
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					var x;
					if (value !== (x = +value)) {
						return invalid();
					}
					return Math.round(x) || 0;
				},
				op: function(a, b, target, op) {
					return op(a, b);
				}
			};
		},
		round: function(value) {
			if (value == null) {
				value = 0;
			}
			value = +Math.round(value);
			return {
				uniform: function() {
					return 'f';
				},
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					var x;
					if (value !== (x = +value)) {
						return invalid();
					}
					return Math.round(x) || 0;
				},
				op: function(a, b, target, op) {
					return op(a, b);
				}
			};
		},
		number: function(value) {
			if (value == null) {
				value = 0;
			}
			return {
				uniform: function() {
					return 'f';
				},
				make: function() {
					return +value;
				},
				validate: function(value, target, invalid) {
					var x;
					if (value !== (x = +value)) {
						return invalid();
					}
					return x || 0;
				},
				op: function(a, b, target, op) {
					return op(a, b);
				}
			};
		},
		positive: function(type, strict) {
			if (strict == null) {
				strict = false;
			}
			return {
				uniform: type.uniform,
				make: type.make,
				validate: function(value, target, invalid) {
					value = type.validate(value, target, invalid);
					if ((value < 0) || (strict && value <= 0)) {
						return invalid();
					}
					return value;
				},
				op: function(a, b, target, op) {
					return op(a, b);
				}
			};
		},
		string: function(value) {
			if (value == null) {
				value = '';
			}
			return {
				make: function() {
					return "" + value;
				},
				validate: function(value, target, invalid) {
					var x;
					if (value !== (x = "" + value)) {
						return invalid();
					}
					return x;
				}
			};
		},
		func: function() {
			return {
				make: function() {
					return function() {};
				},
				validate: function(value, target, invalid) {
					if (typeof value === 'function') {
						return value;
					}
					return invalid();
				}
			};
		},
		emitter: function() {
			return {
				make: function() {
					return function(emit) {
						return emit(1, 1, 1, 1);
					};
				},
				validate: function(value, target, invalid) {
					if (typeof value === 'function') {
						return value;
					}
					return invalid();
				},
				emitter: function(a, b) {
					return Util.Data.getLerpEmitter(a, b);
				}
			};
		},
		object: function(value) {
			return {
				make: function() {
					return value != null ? value : {};
				},
				validate: function(value, target, invalid) {
					if (typeof value === 'object') {
						return value;
					}
					return invalid();
				},
				clone: function(v) {
					return JSON.parse(JSON.stringify(v));
				}
			};
		},
		timestamp: function(value) {
			if (value == null) {
				value = null;
			}
			if (typeof value === 'string') {
				value = Date.parse(value);
			}
			return {
				uniform: function() {
					return 'f';
				},
				make: function() {
					return value != null ? value : +new Date();
				},
				validate: function(value, target, invalid) {
					var x;
					value = Date.parse(value);
					if (value !== (x = +value)) {
						return invalid();
					}
					return value;
				},
				op: function(a, b, target, op) {
					return op(a, b);
				}
			};
		},
		vec2: function(x, y) {
			var defaults;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			defaults = [x, y];
			return {
				uniform: function() {
					return 'v2';
				},
				make: function() {
					return new THREE.Vector2(x, y);
				},
				validate: function(value, target, invalid) {
					var ref, ref1, xx, yy;
					if (value === +value) {
						value = [value];
					}
					if (value instanceof THREE.Vector2) {
						target.copy(value);
					} else if (value instanceof Array) {
						value = value.concat(defaults.slice(value.length));
						target.set.apply(target, value);
					} else if (value != null) {
						xx = (ref = value.x) != null ? ref : x;
						yy = (ref1 = value.y) != null ? ref1 : y;
						target.set(xx, yy);
					} else {
						return invalid();
					}
					return target;
				},
				equals: function(a, b) {
					return a.x === b.x && a.y === b.y;
				},
				op: function(a, b, target, op) {
					target.x = op(a.x, b.x);
					target.y = op(a.y, b.y);
					return target;
				}
			};
		},
		ivec2: function(x, y) {
			var validate, vec2;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			vec2 = Types.vec2(x, y);
			validate = vec2.validate;
			vec2.validate = function(value, target, invalid) {
				validate(value, target, invalid);
				target.x = Math.round(target.x);
				target.y = Math.round(target.y);
				return target;
			};
			return vec2;
		},
		vec3: function(x, y, z) {
			var defaults;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			if (z == null) {
				z = 0;
			}
			defaults = [x, y, z];
			return {
				uniform: function() {
					return 'v3';
				},
				make: function() {
					return new THREE.Vector3(x, y, z);
				},
				validate: function(value, target, invalid) {
					var ref, ref1, ref2, xx, yy, zz;
					if (value === +value) {
						value = [value];
					}
					if (value instanceof THREE.Vector3) {
						target.copy(value);
					} else if (value instanceof Array) {
						value = value.concat(defaults.slice(value.length));
						target.set.apply(target, value);
					} else if (value != null) {
						xx = (ref = value.x) != null ? ref : x;
						yy = (ref1 = value.y) != null ? ref1 : y;
						zz = (ref2 = value.z) != null ? ref2 : z;
						target.set(xx, yy, zz);
					} else {
						return invalid();
					}
					return target;
				},
				equals: function(a, b) {
					return a.x === b.x && a.y === b.y && a.z === b.z;
				},
				op: function(a, b, target, op) {
					target.x = op(a.x, b.x);
					target.y = op(a.y, b.y);
					target.z = op(a.z, b.z);
					return target;
				}
			};
		},
		ivec3: function(x, y, z) {
			var validate, vec3;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			if (z == null) {
				z = 0;
			}
			vec3 = Types.vec3(x, y, z);
			validate = vec3.validate;
			vec3.validate = function(value, target) {
				validate(value, target, invalid);
				target.x = Math.round(target.x);
				target.y = Math.round(target.y);
				target.z = Math.round(target.z);
				return target;
			};
			return vec3;
		},
		vec4: function(x, y, z, w) {
			var defaults;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			if (z == null) {
				z = 0;
			}
			if (w == null) {
				w = 0;
			}
			defaults = [x, y, z, w];
			return {
				uniform: function() {
					return 'v4';
				},
				make: function() {
					return new THREE.Vector4(x, y, z, w);
				},
				validate: function(value, target, invalid) {
					var ref, ref1, ref2, ref3, ww, xx, yy, zz;
					if (value === +value) {
						value = [value];
					}
					if (value instanceof THREE.Vector4) {
						target.copy(value);
					} else if (value instanceof Array) {
						value = value.concat(defaults.slice(value.length));
						target.set.apply(target, value);
					} else if (value != null) {
						xx = (ref = value.x) != null ? ref : x;
						yy = (ref1 = value.y) != null ? ref1 : y;
						zz = (ref2 = value.z) != null ? ref2 : z;
						ww = (ref3 = value.w) != null ? ref3 : w;
						target.set(xx, yy, zz, ww);
					} else {
						return invalid();
					}
					return target;
				},
				equals: function(a, b) {
					return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
				},
				op: function(a, b, target, op) {
					target.x = op(a.x, b.x);
					target.y = op(a.y, b.y);
					target.z = op(a.z, b.z);
					target.w = op(a.w, b.w);
					return target;
				}
			};
		},
		ivec4: function(x, y, z, w) {
			var validate, vec4;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			if (z == null) {
				z = 0;
			}
			if (w == null) {
				w = 0;
			}
			vec4 = Types.vec4(x, y, z, w);
			validate = vec4.validate;
			vec4.validate = function(value, target) {
				validate(value, target, invalid);
				target.x = Math.round(target.x);
				target.y = Math.round(target.y);
				target.z = Math.round(target.z);
				target.w = Math.round(target.w);
				return target;
			};
			return vec4;
		},
		mat3: function(n11, n12, n13, n21, n22, n23, n31, n32, n33) {
			var defaults;
			if (n11 == null) {
				n11 = 1;
			}
			if (n12 == null) {
				n12 = 0;
			}
			if (n13 == null) {
				n13 = 0;
			}
			if (n21 == null) {
				n21 = 0;
			}
			if (n22 == null) {
				n22 = 1;
			}
			if (n23 == null) {
				n23 = 0;
			}
			if (n31 == null) {
				n31 = 0;
			}
			if (n32 == null) {
				n32 = 0;
			}
			if (n33 == null) {
				n33 = 1;
			}
			defaults = [n11, n12, n13, n21, n22, n23, n31, n32, n33];
			return {
				uniform: function() {
					return 'm4';
				},
				make: function() {
					var m;
					m = new THREE.Matrix3;
					m.set(n11, n12, n13, n21, n22, n23, n31, n32, n33);
					return m;
				},
				validate: function(value, target, invalid) {
					if (value instanceof THREE.Matrix3) {
						target.copy(value);
					} else if (value instanceof Array) {
						value = value.concat(defaults.slice(value.length));
						target.set.apply(target, value);
					} else {
						return invalid();
					}
					return target;
				}
			};
		},
		mat4: function(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44) {
			var defaults;
			if (n11 == null) {
				n11 = 1;
			}
			if (n12 == null) {
				n12 = 0;
			}
			if (n13 == null) {
				n13 = 0;
			}
			if (n14 == null) {
				n14 = 0;
			}
			if (n21 == null) {
				n21 = 0;
			}
			if (n22 == null) {
				n22 = 1;
			}
			if (n23 == null) {
				n23 = 0;
			}
			if (n24 == null) {
				n24 = 0;
			}
			if (n31 == null) {
				n31 = 0;
			}
			if (n32 == null) {
				n32 = 0;
			}
			if (n33 == null) {
				n33 = 1;
			}
			if (n34 == null) {
				n34 = 0;
			}
			if (n41 == null) {
				n41 = 0;
			}
			if (n42 == null) {
				n42 = 0;
			}
			if (n43 == null) {
				n43 = 0;
			}
			if (n44 == null) {
				n44 = 1;
			}
			defaults = [n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44];
			return {
				uniform: function() {
					return 'm4';
				},
				make: function() {
					var m;
					m = new THREE.Matrix4;
					m.set(n11, n12, n13, n14, n21, n22, n23, n24, n31, n32, n33, n34, n41, n42, n43, n44);
					return m;
				},
				validate: function(value, target, invalid) {
					if (value instanceof THREE.Matrix4) {
						target.copy(value);
					} else if (value instanceof Array) {
						value = value.concat(defaults.slice(value.length));
						target.set.apply(target, value);
					} else {
						return invalid();
					}
					return target;
				}
			};
		},
		quat: function(x, y, z, w) {
			var vec4;
			if (x == null) {
				x = 0;
			}
			if (y == null) {
				y = 0;
			}
			if (z == null) {
				z = 0;
			}
			if (w == null) {
				w = 1;
			}
			vec4 = Types.vec4(x, y, z, w);
			return {
				uniform: function() {
					return 'v4';
				},
				make: function() {
					return new THREE.Quaternion;
				},
				validate: function(value, target, invalid) {
					if (value instanceof THREE.Quaternion) {
						target.copy(value);
					} else {
						target = vec4.validate(value, target, invalid);
					}
					target.normalize();
					return target;
				},
				equals: function(a, b) {
					return a.x === b.x && a.y === b.y && a.z === b.z && a.w === b.w;
				},
				op: function(a, b, target, op) {
					target.x = op(a.x, b.x);
					target.y = op(a.y, b.y);
					target.z = op(a.z, b.z);
					target.w = op(a.w, b.w);
					target.normalize();
					return target;
				},
				lerp: function(a, b, target, f) {
					THREE.Quaternion.slerp(a, b, target, f);
					return target;
				}
			};
		},
		color: function(r, g, b) {
			var defaults;
			if (r == null) {
				r = .5;
			}
			if (g == null) {
				g = .5;
			}
			if (b == null) {
				b = .5;
			}
			defaults = [r, g, b];
			return {
				uniform: function() {
					return 'c';
				},
				make: function() {
					return new THREE.Color(r, g, b);
				},
				validate: function(value, target, invalid) {
					var bb, gg, ref, ref1, ref2, rr;
					if (value === "" + value) {
						value = new THREE.Color().setStyle(value);
					} else if (value === +value) {
						value = new THREE.Color(value);
					}
					if (value instanceof THREE.Color) {
						target.copy(value);
					} else if (value instanceof Array) {
						value = value.concat(defaults.slice(value.length));
						target.setRGB.apply(target, value);
					} else if (value != null) {
						rr = (ref = value.r) != null ? ref : r;
						gg = (ref1 = value.g) != null ? ref1 : g;
						bb = (ref2 = value.b) != null ? ref2 : b;
						target.set(rr, gg, bb);
					} else {
						return invalid();
					}
					return target;
				},
				equals: function(a, b) {
					return a.r === b.r && a.g === b.g && a.b === b.b;
				},
				op: function(a, b, target, op) {
					target.r = op(a.r, b.r);
					target.g = op(a.g, b.g);
					target.b = op(a.b, b.b);
					return target;
				}
			};
		},
		axis: function(value, allowZero) {
			var map, range, v;
			if (value == null) {
				value = 1;
			}
			if (allowZero == null) {
				allowZero = false;
			}
			map = {
				x: 1,
				y: 2,
				z: 3,
				w: 4,
				W: 1,
				H: 2,
				D: 3,
				I: 4,
				zero: 0,
				"null": 0,
				width: 1,
				height: 2,
				depth: 3,
				items: 4
			};
			range = allowZero ? [0, 1, 2, 3, 4] : [1, 2, 3, 4];
			if ((v = map[value]) != null) {
				value = v;
			}
			return {
				make: function() {
					return value;
				},
				validate: function(value, target, invalid) {
					var ref;
					if ((v = map[value]) != null) {
						value = v;
					}
					value = (ref = Math.round(value)) != null ? ref : 0;
					if (indexOf.call(range, value) >= 0) {
						return value;
					}
					return invalid();
				}
			};
		},
		transpose: function(order) {
			var axesArray, looseArray;
			if (order == null) {
				order = [1, 2, 3, 4];
			}
			looseArray = Types.letters(Types.axis(null, false), 0, order);
			axesArray = Types.letters(Types.axis(null, false), 4, order);
			return {
				make: function() {
					return axesArray.make();
				},
				validate: function(value, target, invalid) {
					var i, letter, missing, temp, unique;
					temp = [1, 2, 3, 4];
					looseArray.validate(value, temp, invalid);
					if (temp.length < 4) {
						missing = [1, 2, 3, 4].filter(function(x) {
							return temp.indexOf(x) === -1;
						});
						temp = temp.concat(missing);
					}
					unique = (function() {
						var j, len, results;
						results = [];
						for (i = j = 0, len = temp.length; j < len; i = ++j) {
							letter = temp[i];
							results.push(temp.indexOf(letter) === i);
						}
						return results;
					})();
					if (unique.indexOf(false) < 0) {
						return axesArray.validate(temp, target, invalid);
					}
					return invalid();
				},
				equals: axesArray.equals,
				clone: axesArray.clone
			};
		},
		swizzle: function(order, size) {
			var axesArray, looseArray;
			if (order == null) {
				order = [1, 2, 3, 4];
			}
			if (size == null) {
				size = null;
			}
			if (size == null) {
				size = order.length;
			}
			order = order.slice(0, size);
			looseArray = Types.letters(Types.axis(null, false), 0, order);
			axesArray = Types.letters(Types.axis(null, true), size, order);
			return {
				make: function() {
					return axesArray.make();
				},
				validate: function(value, target, invalid) {
					var temp;
					temp = order.slice();
					looseArray.validate(value, temp, invalid);
					if (temp.length < size) {
						temp = temp.concat([0, 0, 0, 0]).slice(0, size);
					}
					return axesArray.validate(temp, target, invalid);
				},
				equals: axesArray.equals,
				clone: axesArray.clone
			};
		},
		classes: function() {
			var stringArray;
			stringArray = Types.array(Types.string());
			return {
				make: function() {
					return stringArray.make();
				},
				validate: function(value, target, invalid) {
					if (value === "" + value) {
						value = value.split(' ');
					}
					value = value.filter(function(x) {
						return !!x.length;
					});
					return stringArray.validate(value, target, invalid);
				},
				equals: stringArray.equals,
				clone: stringArray.clone
			};
		},
		blending: function(value) {
			var keys;
			if (value == null) {
				value = 'normal';
			}
			keys = ['no', 'normal', 'add', 'subtract', 'multiply', 'custom'];
			return Types["enum"](value, keys);
		},
		filter: function(value) {
			var map;
			if (value == null) {
				value = 'nearest';
			}
			map = {
				nearest: THREE.NearestFilter,
				nearestMipMapNearest: THREE.NearestMipMapNearestFilter,
				nearestMipMapLinear: THREE.NearestMipMapLinearFilter,
				linear: THREE.LinearFilter,
				linearMipMapNearest: THREE.LinearMipMapNearestFilter,
				linearMipmapLinear: THREE.LinearMipMapLinearFilter
			};
			return Types["enum"](value, [], map);
		},
		type: function(value) {
			var map;
			if (value == null) {
				value = 'unsignedByte';
			}
			map = {
				unsignedByte: THREE.UnsignedByteType,
				byte: THREE.ByteType,
				short: THREE.ShortType,
				unsignedShort: THREE.UnsignedShortType,
				int: THREE.IntType,
				unsignedInt: THREE.UnsignedIntType,
				float: THREE.FloatType
			};
			return Types["enum"](value, [], map);
		},
		scale: function(value) {
			var keys;
			if (value == null) {
				value = 'linear';
			}
			keys = ['linear', 'log'];
			return Types["enum"](value, keys);
		},
		mapping: function(value) {
			var keys;
			if (value == null) {
				value = 'relative';
			}
			keys = ['relative', 'absolute'];
			return Types["enum"](value, keys);
		},
		indexing: function(value) {
			var keys;
			if (value == null) {
				value = 'original';
			}
			keys = ['original', 'final'];
			return Types["enum"](value, keys);
		},
		shape: function(value) {
			var keys;
			if (value == null) {
				value = 'circle';
			}
			keys = ['circle', 'square', 'diamond', 'up', 'down', 'left', 'right'];
			return Types["enum"](value, keys);
		},
		join: function(value) {
			var keys;
			if (value == null) {
				value = 'miter';
			}
			keys = ['miter', 'round', 'bevel'];
			return Types["enum"](value, keys);
		},
		stroke: function(value) {
			var keys;
			if (value == null) {
				value = 'solid';
			}
			keys = ['solid', 'dotted', 'dashed'];
			return Types["enum"](value, keys);
		},
		vertexPass: function(value) {
			var keys;
			if (value == null) {
				value = 'view';
			}
			keys = ['data', 'view', 'world', 'eye'];
			return Types["enum"](value, keys);
		},
		fragmentPass: function(value) {
			var keys;
			if (value == null) {
				value = 'light';
			}
			keys = ['color', 'light', 'rgba'];
			return Types["enum"](value, keys);
		},
		ease: function(value) {
			var keys;
			if (value == null) {
				value = 'linear';
			}
			keys = ['linear', 'cosine', 'binary', 'hold'];
			return Types["enum"](value, keys);
		},
		fit: function(value) {
			var keys;
			if (value == null) {
				value = 'contain';
			}
			keys = ['x', 'y', 'contain', 'cover'];
			return Types["enum"](value, keys);
		},
		anchor: function(value) {
			var map;
			if (value == null) {
				value = 'middle';
			}
			map = {
				first: 1,
				middle: 0,
				last: -1
			};
			return Types.enumber(value, [], map);
		},
		transitionState: function(value) {
			var map;
			if (value == null) {
				value = 'enter';
			}
			map = {
				enter: -1,
				visible: 0,
				exit: 1
			};
			return Types.enumber(value, [], map);
		},
		font: function(value) {
			var parse, stringArray;
			if (value == null) {
				value = 'sans-serif';
			}
			parse = Util.JS.parseQuoted;
			if (!(value instanceof Array)) {
				value = parse(value);
			}
			stringArray = Types.array(Types.string(), 0, value);
			return {
				make: function() {
					return stringArray.make();
				},
				validate: function(value, target, invalid) {
					try {
						if (!(value instanceof Array)) {
							value = parse(value);
						}
					} catch (error) {
						return invalid();
					}
					value = value.filter(function(x) {
						return !!x.length;
					});
					return stringArray.validate(value, target, invalid);
				},
				equals: stringArray.equals,
				clone: stringArray.clone
			};
		},
		data: function(value) {
			if (value == null) {
				value = [];
			}
			return {
				make: function() {
					return [];
				},
				validate: function(value, target, invalid) {
					if (value instanceof Array) {
						return value;
					} else if ((value != null ? value.length : void 0) != null) {
						return value;
					} else {
						return invalid();
					}
				},
				emitter: function(a, b) {
					return Util.Data.getLerpThunk(a, b);
				}
			};
		}
	};
	
	decorate = function(types) {
		var k, type;
		for (k in types) {
			type = types[k];
			types[k] = (function(type) {
				return function() {
					var t;
					t = type.apply(type, arguments);
					if (t.validate == null) {
						t.validate = function(v) {
							return v != null;
						};
					}
					if (t.equals == null) {
						t.equals = function(a, b) {
							return a === b;
						};
					}
					if (t.clone == null) {
						t.clone = function(v) {
							var ref;
							return (ref = v != null ? typeof v.clone === "function" ? v.clone() : void 0 : void 0) != null ? ref : v;
						};
					}
					return t;
				};
			})(type);
		}
		return types;
	};
	
	module.exports = decorate(Types);
	
	
	/***/ }),
	/* 54 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Geometry, THREE, debug, tick,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	debug = false;
	
	tick = function() {
		var now;
		now = +(new Date);
		return function(label) {
			var delta;
			delta = +new Date() - now;
			console.log(label, delta + " ms");
			return delta;
		};
	};
	
	Geometry = (function(superClass) {
		extend(Geometry, superClass);
	
		function Geometry() {
			THREE.BufferGeometry.call(this);
			if (this.uniforms == null) {
				this.uniforms = {};
			}
			if (this.groups == null) {
				this.groups = [];
			}
		}
	
		Geometry.prototype._reduce = function(dims, maxs) {
			var dim, i, j, len, max, multiple, quads;
			multiple = false;
			for (i = j = 0, len = dims.length; j < len; i = ++j) {
				dim = dims[i];
				max = maxs[i];
				if (multiple) {
					dims[i] = max;
				}
				if (dim > 1) {
					multiple = true;
				}
			}
			return quads = dims.reduce(function(a, b) {
				return a * b;
			});
		};
	
		Geometry.prototype._emitter = function(name) {
			var array, attribute, dimensions, four, offset, one, three, two;
			if (name === 'index') {
				attribute = this.index;
			} else {
				attribute = this.attributes[name];
			}
			dimensions = attribute.itemSize;
			array = attribute.array;
			offset = 0;
			one = function(a) {
				return array[offset++] = a;
			};
			two = function(a, b) {
				array[offset++] = a;
				return array[offset++] = b;
			};
			three = function(a, b, c) {
				array[offset++] = a;
				array[offset++] = b;
				return array[offset++] = c;
			};
			four = function(a, b, c, d) {
				array[offset++] = a;
				array[offset++] = b;
				array[offset++] = c;
				return array[offset++] = d;
			};
			return [null, one, two, three, four][dimensions];
		};
	
		Geometry.prototype._finalize = function() {};
	
		Geometry.prototype._offsets = function(offsets) {
			return this.groups = offsets;
		};
	
		return Geometry;
	
	})(THREE.BufferGeometry);
	
	module.exports = Geometry;
	
	
	/***/ }),
	/* 55 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ClipGeometry, SurfaceGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	ClipGeometry = __webpack_require__(14);
	
	
	/*
	Grid Surface
	
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	 */
	
	SurfaceGeometry = (function(superClass) {
		extend(SurfaceGeometry, superClass);
	
		function SurfaceGeometry(options) {
			var base, closedX, closedY, height, i, index, j, k, l, layers, m, n, o, p, points, position, q, quads, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, s, segmentsX, segmentsY, surface, surfaces, triangles, width, x, y, z;
			SurfaceGeometry.__super__.constructor.call(this, options);
			this._clipUniforms();
			this.closedX = closedX = options.closedX || false;
			this.closedY = closedY = options.closedY || false;
			this.width = width = (+options.width || 2) + (closedX ? 1 : 0);
			this.height = height = (+options.height || 2) + (closedY ? 1 : 0);
			this.surfaces = surfaces = +options.surfaces || 1;
			this.layers = layers = +options.layers || 1;
			this.segmentsX = segmentsX = Math.max(0, width - 1);
			this.segmentsY = segmentsY = Math.max(0, height - 1);
			points = width * height * surfaces * layers;
			quads = segmentsX * segmentsY * surfaces * layers;
			triangles = quads * 2;
			this.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles * 3), 1));
			this.addAttribute('position4', new THREE.BufferAttribute(new Float32Array(points * 4), 4));
			this.addAttribute('surface', new THREE.BufferAttribute(new Float32Array(points * 2), 2));
			index = this._emitter('index');
			position = this._emitter('position4');
			surface = this._emitter('surface');
			base = 0;
			for (i = m = 0, ref = surfaces * layers; 0 <= ref ? m < ref : m > ref; i = 0 <= ref ? ++m : --m) {
				for (j = n = 0, ref1 = segmentsY; 0 <= ref1 ? n < ref1 : n > ref1; j = 0 <= ref1 ? ++n : --n) {
					for (k = o = 0, ref2 = segmentsX; 0 <= ref2 ? o < ref2 : o > ref2; k = 0 <= ref2 ? ++o : --o) {
						index(base);
						index(base + 1);
						index(base + width);
						index(base + width);
						index(base + 1);
						index(base + width + 1);
						base++;
					}
					base++;
				}
				base += width;
			}
			for (l = p = 0, ref3 = layers; 0 <= ref3 ? p < ref3 : p > ref3; l = 0 <= ref3 ? ++p : --p) {
				for (z = q = 0, ref4 = surfaces; 0 <= ref4 ? q < ref4 : q > ref4; z = 0 <= ref4 ? ++q : --q) {
					for (y = r = 0, ref5 = height; 0 <= ref5 ? r < ref5 : r > ref5; y = 0 <= ref5 ? ++r : --r) {
						for (x = s = 0, ref6 = width; 0 <= ref6 ? s < ref6 : s > ref6; x = 0 <= ref6 ? ++s : --s) {
							position(x, y, z, l);
						}
					}
				}
			}
			this._finalize();
			this.clip();
			return;
		}
	
		SurfaceGeometry.prototype.clip = function(width, height, surfaces, layers) {
			var segmentsX, segmentsY;
			if (width == null) {
				width = this.width - this.closedX;
			}
			if (height == null) {
				height = this.height - this.closedY;
			}
			if (surfaces == null) {
				surfaces = this.surfaces;
			}
			if (layers == null) {
				layers = this.layers;
			}
			width += this.closedX;
			height += this.closedY;
			segmentsX = Math.max(0, width - 1);
			segmentsY = Math.max(0, height - 1);
			this._clipGeometry(width, height, surfaces, layers);
			return this._clipOffsets(6, segmentsX, segmentsY, surfaces, layers, this.segmentsX, this.segmentsY, this.surfaces, this.layers);
		};
	
		SurfaceGeometry.prototype.map = function(width, height, surfaces, layers) {
			if (width == null) {
				width = this.width;
			}
			if (height == null) {
				height = this.height;
			}
			if (surfaces == null) {
				surfaces = this.surfaces;
			}
			if (layers == null) {
				layers = this.layers;
			}
			return this._clipMap(width, height, surfaces, layers);
		};
	
		return SurfaceGeometry;
	
	})(ClipGeometry);
	
	module.exports = SurfaceGeometry;
	
	
	/***/ }),
	/* 56 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Screen, ScreenGeometry, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	ScreenGeometry = __webpack_require__(8).ScreenGeometry;
	
	Util = __webpack_require__(0);
	
	Screen = (function(superClass) {
		extend(Screen, superClass);
	
		function Screen(renderer, shaders, options) {
			var combine, f, factory, hasStyle, linear, map, object, stpq, uniforms, v;
			Screen.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, map = options.map, combine = options.combine, stpq = options.stpq, linear = options.linear;
			if (uniforms == null) {
				uniforms = {};
			}
			hasStyle = uniforms.styleColor != null;
			this.geometry = new ScreenGeometry({
				width: options.width,
				height: options.height
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			factory = shaders.material();
			v = factory.vertex;
			v.pipe('raw.position.scale', this.uniforms);
			v.fan();
			v.pipe('stpq.xyzw.2d', this.uniforms);
			v.next();
			v.pipe('screen.position', this.uniforms);
			v.join();
			factory.fragment = f = this._fragmentColor(hasStyle, false, null, null, map, 2, stpq, combine, linear);
			f.pipe('fragment.color', this.uniforms);
			this.material = this._material(factory.link({
				side: THREE.DoubleSide
			}));
			object = new THREE.Mesh(this.geometry, this.material);
			object.frustumCulled = false;
			this._raw(object);
			this.renders = [object];
		}
	
		Screen.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.renders = this.geometry = this.material = null;
			return Screen.__super__.dispose.apply(this, arguments);
		};
	
		return Screen;
	
	})(Base);
	
	module.exports = Screen;
	
	
	/***/ }),
	/* 57 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var MemoScreen, Screen, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Screen = __webpack_require__(56);
	
	Util = __webpack_require__(0);
	
	MemoScreen = (function(superClass) {
		extend(MemoScreen, superClass);
	
		function MemoScreen(renderer, shaders, options) {
			var depth, height, i, inv, inv1, items, len, map, object, ref, stpq, width;
			this.memo = (items = options.items, width = options.width, height = options.height, depth = options.depth, stpq = options.stpq, options);
			inv = function(x) {
				return 1 / Math.max(1, x);
			};
			inv1 = function(x) {
				return 1 / Math.max(1, x - 1);
			};
			this.uniforms = {
				remapUVScale: {
					type: 'v2',
					value: new THREE.Vector2(items * width, height * depth)
				},
				remapModulus: {
					type: 'v2',
					value: new THREE.Vector2(items, height)
				},
				remapModulusInv: {
					type: 'v2',
					value: new THREE.Vector2(inv(items), inv(height))
				},
				remapSTPQScale: {
					type: 'v4',
					value: new THREE.Vector4(inv1(width), inv1(height), inv1(depth), inv1(items))
				}
			};
			map = shaders.shader();
			map.pipe('screen.map.xyzw', this.uniforms);
			if (options.map != null) {
				if (stpq) {
					map.pipe('screen.map.stpq', this.uniforms);
				}
				map.pipe(options.map);
			}
			MemoScreen.__super__.constructor.call(this, renderer, shaders, {
				map: map,
				linear: true
			});
			ref = this.renders;
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				object.transparent = false;
			}
			null;
		}
	
		MemoScreen.prototype.cover = function(width, height, depth, items) {
			var inv1, x, y;
			if (width == null) {
				width = this.memo.width;
			}
			if (height == null) {
				height = this.memo.height;
			}
			if (depth == null) {
				depth = this.memo.depth;
			}
			if (items == null) {
				items = this.memo.items;
			}
			inv1 = function(x) {
				return 1 / Math.max(1, x - 1);
			};
			this.uniforms.remapSTPQScale.value.set(inv1(width), inv1(height), inv1(depth), inv1(items));
			x = width / this.memo.width;
			y = depth / this.memo.depth;
			if (this.memo.depth === 1) {
				y = height / this.memo.height;
			}
			return this.geometry.cover(x, y);
		};
	
		return MemoScreen;
	
	})(Screen);
	
	module.exports = MemoScreen;
	
	
	/***/ }),
	/* 58 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var RenderTarget, RenderToTexture, Renderable, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Renderable = __webpack_require__(10);
	
	RenderTarget = __webpack_require__(198);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * Render-To-Texture with history
	 */
	
	RenderToTexture = (function(superClass) {
		extend(RenderToTexture, superClass);
	
		function RenderToTexture(renderer, shaders, options) {
			var ref;
			this.scene = (ref = options.scene) != null ? ref : new THREE.Scene();
			this.camera = options.camera;
			RenderToTexture.__super__.constructor.call(this, renderer, shaders);
			this.build(options);
		}
	
		RenderToTexture.prototype.shaderRelative = function(shader) {
			if (shader == null) {
				shader = this.shaders.shader();
			}
			return shader.pipe("sample.2d", this.uniforms);
		};
	
		RenderToTexture.prototype.shaderAbsolute = function(shader, frames, indices) {
			var sample2DArray;
			if (frames == null) {
				frames = 1;
			}
			if (indices == null) {
				indices = 4;
			}
			if (shader == null) {
				shader = this.shaders.shader();
			}
			if (frames <= 1) {
				if (indices > 2) {
					shader.pipe(Util.GLSL.truncateVec(indices, 2));
				}
				shader.pipe("map.2d.data", this.uniforms);
				return shader.pipe("sample.2d", this.uniforms);
			} else {
				sample2DArray = Util.GLSL.sample2DArray(Math.min(frames, this.target.frames));
				if (indices < 4) {
					shader.pipe(Util.GLSL.extendVec(indices, 4));
				}
				shader.pipe("map.xyzw.2dv");
				shader.split();
				shader.pipe("map.2d.data", this.uniforms);
				shader.pass();
				return shader.pipe(sample2DArray, this.uniforms);
			}
		};
	
		RenderToTexture.prototype.build = function(options) {
			var base;
			if (!this.camera) {
				this.camera = new THREE.PerspectiveCamera();
				this.camera.position.set(0, 0, 3);
				this.camera.lookAt(new THREE.Vector3());
			}
			if (typeof (base = this.scene).inject === "function") {
				base.inject();
			}
			this.target = new RenderTarget(this.gl, options.width, options.height, options.frames, options);
			this.target.warmup((function(_this) {
				return function(target) {
					return _this.renderer.setRenderTarget(target);
				};
			})(this));
			this.renderer.setRenderTarget(null);
			this._adopt(this.target.uniforms);
			this._adopt({
				dataPointer: {
					type: 'v2',
					value: new THREE.Vector2(.5, .5)
				}
			});
			return this.filled = 0;
		};
	
		RenderToTexture.prototype.adopt = function(renderable) {
			var i, len, object, ref, results;
			ref = renderable.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this.scene.add(object));
			}
			return results;
		};
	
		RenderToTexture.prototype.unadopt = function(renderable) {
			var i, len, object, ref, results;
			ref = renderable.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this.scene.remove(object));
			}
			return results;
		};
	
		RenderToTexture.prototype.render = function(camera) {
			var ref;
			if (camera == null) {
				camera = this.camera;
			}
			this.renderer.render((ref = this.scene.scene) != null ? ref : this.scene, camera, this.target.write);
			this.target.cycle();
			if (this.filled < this.target.frames) {
				return this.filled++;
			}
		};
	
		RenderToTexture.prototype.read = function(frame) {
			if (frame == null) {
				frame = 0;
			}
			return this.target.reads[Math.abs(frame)];
		};
	
		RenderToTexture.prototype.getFrames = function() {
			return this.target.frames;
		};
	
		RenderToTexture.prototype.getFilled = function() {
			return this.filled;
		};
	
		RenderToTexture.prototype.dispose = function() {
			var base;
			if (typeof (base = this.scene).unject === "function") {
				base.unject();
			}
			this.scene = this.camera = null;
			this.target.dispose();
			return RenderToTexture.__super__.dispose.apply(this, arguments);
		};
	
		return RenderToTexture;
	
	})(Renderable);
	
	module.exports = RenderToTexture;
	
	
	/***/ }),
	/* 59 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Memo, RenderToTexture, Renderable, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Renderable = __webpack_require__(10);
	
	RenderToTexture = __webpack_require__(58);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * Wrapped RTT for memoizing 4D arrays back to a 2D texture
	 */
	
	Memo = (function(superClass) {
		extend(Memo, superClass);
	
		function Memo(renderer, shaders, options) {
			if (this.items == null) {
				this.items = options.items || 1;
			}
			if (this.channels == null) {
				this.channels = options.channels || 4;
			}
			if (this.width == null) {
				this.width = options.width || 1;
			}
			if (this.height == null) {
				this.height = options.height || 1;
			}
			if (this.depth == null) {
				this.depth = options.depth || 1;
			}
			options.format = THREE.RGBAFormat;
			options.width = this._width = this.items * this.width;
			options.height = this._height = this.height * this.depth;
			options.frames = 1;
			delete options.items;
			delete options.depth;
			delete options.channels;
			Memo.__super__.constructor.call(this, renderer, shaders, options);
			this._adopt({
				textureItems: {
					type: 'f',
					value: this.items
				},
				textureHeight: {
					type: 'f',
					value: this.height
				}
			});
		}
	
		Memo.prototype.shaderAbsolute = function(shader) {
			if (shader == null) {
				shader = this.shaders.shader();
			}
			shader.pipe('map.xyzw.texture', this.uniforms);
			return Memo.__super__.shaderAbsolute.call(this, shader, 1, 2);
		};
	
		return Memo;
	
	})(RenderToTexture);
	
	module.exports = Memo;
	
	
	/***/ }),
	/* 60 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Atlas, BackedTexture, DataTexture, Renderable, Row, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Renderable = __webpack_require__(10);
	
	Util = __webpack_require__(0);
	
	DataTexture = __webpack_require__(31);
	
	BackedTexture = __webpack_require__(200);
	
	
	/*
	 * Dynamic sprite atlas
	 *
	 * - Allocates variable-sized sprites in rows
	 * - Will grow itself when full
	 */
	
	Atlas = (function(superClass) {
		extend(Atlas, superClass);
	
		function Atlas(renderer, shaders, options) {
			if (this.width == null) {
				this.width = options.width || 512;
			}
			if (this.height == null) {
				this.height = options.height || 512;
			}
			if (this.channels == null) {
				this.channels = options.channels || 4;
			}
			if (this.backed == null) {
				this.backed = options.backed || false;
			}
			this.samples = this.width * this.height;
			Atlas.__super__.constructor.call(this, renderer, shaders);
			this.build(options);
		}
	
		Atlas.prototype.shader = function(shader) {
			shader.pipe("map.2d.data", this.uniforms);
			shader.pipe("sample.2d", this.uniforms);
			if (this.channels < 4) {
				shader.pipe(Util.GLSL.swizzleVec4(['0000', 'x000', 'xw00', 'xyz0'][this.channels]));
			}
			return shader;
		};
	
		Atlas.prototype.build = function(options) {
			var klass;
			this.klass = klass = this.backed ? BackedTexture : DataTexture;
			this.texture = new klass(this.renderer, this.width, this.height, this.channels, options);
			this.uniforms = {
				dataPointer: {
					type: 'v2',
					value: new THREE.Vector2(0, 0)
				}
			};
			this._adopt(this.texture.uniforms);
			return this.reset();
		};
	
		Atlas.prototype.reset = function() {
			this.rows = [];
			return this.bottom = 0;
		};
	
		Atlas.prototype.resize = function(width, height) {
			if (!this.backed) {
				throw new Error("Cannot resize unbacked texture atlas");
			}
			if (width > 2048 && height > 2048) {
				console.warn("Giant text atlas " + width + "x" + height + ".");
			} else {
				console.info("Resizing text atlas " + width + "x" + height + ".");
			}
			this.texture.resize(width, height);
			this.width = width;
			this.height = height;
			return this.samples = width * height;
		};
	
		Atlas.prototype.collapse = function(row) {
			var ref, ref1, rows;
			rows = this.rows;
			rows.splice(rows.indexOf(row), 1);
			this.bottom = (ref = (ref1 = rows[rows.length - 1]) != null ? ref1.bottom : void 0) != null ? ref : 0;
			if (this.last === row) {
				return this.last = null;
			}
		};
	
		Atlas.prototype.allocate = function(key, width, height, emit) {
			var bottom, gap, h, i, index, j, len, max, ref, row, top, w;
			w = this.width;
			h = this.height;
			max = height * 2;
			if (width > w) {
				this.resize(w * 2, h * 2);
				this.last = null;
				return this.allocate(key, width, height, emit);
			}
			row = this.last;
			if (row != null) {
				if (row.height >= height && row.height < max && row.width + width <= w) {
					row.append(key, width, height, emit);
					return;
				}
			}
			bottom = 0;
			index = -1;
			top = 0;
			ref = this.rows;
			for (i = j = 0, len = ref.length; j < len; i = ++j) {
				row = ref[i];
				gap = row.top - bottom;
				if (gap >= height && index < 0) {
					index = i;
					top = bottom;
				}
				bottom = row.bottom;
				if (row.height >= height && row.height < max && row.width + width <= w) {
					row.append(key, width, height, emit);
					this.last = row;
					return;
				}
			}
			if (index >= 0) {
				row = new Row(top, height);
				this.rows.splice(index, 0, row);
			} else {
				top = bottom;
				bottom += height;
				if (bottom >= h) {
					this.resize(w * 2, h * 2);
					this.last = null;
					return this.allocate(key, width, height, emit);
				}
				row = new Row(top, height);
				this.rows.push(row);
				this.bottom = bottom;
			}
			row.append(key, width, height, emit);
			this.last = row;
		};
	
		Atlas.prototype.read = function() {
			return this.texture.textureObject;
		};
	
		Atlas.prototype.write = function(data, x, y, w, h) {
			return this.texture.write(data, x, y, w, h);
		};
	
		Atlas.prototype.dispose = function() {
			this.texture.dispose();
			this.data = null;
			return Atlas.__super__.dispose.apply(this, arguments);
		};
	
		return Atlas;
	
	})(Renderable);
	
	Row = (function() {
		function Row(top, height) {
			this.top = top;
			this.bottom = top + height;
			this.width = 0;
			this.height = height;
			this.alive = 0;
			this.keys = [];
		}
	
		Row.prototype.append = function(key, width, height, emit) {
			var x, y;
			x = this.width;
			y = this.top;
			this.alive++;
			this.width += width;
			this.keys.push(key);
			return emit(this, x, y);
		};
	
		return Row;
	
	})();
	
	module.exports = Atlas;
	
	
	/***/ }),
	/* 61 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Graph, Outlet;
	
	Graph = __webpack_require__(33);
	
	
	/*
		In/out outlet on node
	 */
	
	Outlet = (function() {
		Outlet.make = function(outlet, extra) {
			var key, meta, ref, value;
			if (extra == null) {
				extra = {};
			}
			meta = extra;
			if (outlet.meta != null) {
				ref = outlet.meta;
				for (key in ref) {
					value = ref[key];
					meta[key] = value;
				}
			}
			return new Outlet(outlet.inout, outlet.name, outlet.hint, outlet.type, meta);
		};
	
		Outlet.index = 0;
	
		Outlet.id = function(name) {
			return "_io_" + (++Outlet.index) + "_" + name;
		};
	
		Outlet.hint = function(name) {
			name = name.replace(/^_io_[0-9]+_/, '');
			name = name.replace(/_i_o$/, '');
			return name = name.replace(/(In|Out|Inout|InOut)$/, '');
		};
	
		function Outlet(inout, name1, hint, type, meta1, id) {
			this.inout = inout;
			this.name = name1;
			this.hint = hint;
			this.type = type;
			this.meta = meta1 != null ? meta1 : {};
			this.id = id;
			if (this.hint == null) {
				this.hint = Outlet.hint(this.name);
			}
			this.node = null;
			this.input = null;
			this.output = [];
			if (this.id == null) {
				this.id = Outlet.id(this.hint);
			}
		}
	
		Outlet.prototype.morph = function(outlet) {
			this.inout = outlet.inout;
			this.name = outlet.name;
			this.hint = outlet.hint;
			this.type = outlet.type;
			return this.meta = outlet.meta;
		};
	
		Outlet.prototype.dupe = function(name) {
			var outlet;
			if (name == null) {
				name = this.id;
			}
			outlet = Outlet.make(this);
			outlet.name = name;
			return outlet;
		};
	
		Outlet.prototype.connect = function(outlet) {
			if (this.inout === Graph.IN && outlet.inout === Graph.OUT) {
				return outlet.connect(this);
			}
			if (this.inout !== Graph.OUT || outlet.inout !== Graph.IN) {
				throw new Error("Can only connect out to in.");
			}
			if (outlet.input === this) {
				return;
			}
			outlet.disconnect();
			outlet.input = this;
			return this.output.push(outlet);
		};
	
		Outlet.prototype.disconnect = function(outlet) {
			var i, index, len, ref;
			if (this.input) {
				this.input.disconnect(this);
			}
			if (this.output.length) {
				if (outlet) {
					index = this.output.indexOf(outlet);
					if (index >= 0) {
						this.output.splice(index, 1);
						return outlet.input = null;
					}
				} else {
					ref = this.output;
					for (i = 0, len = ref.length; i < len; i++) {
						outlet = ref[i];
						outlet.input = null;
					}
					return this.output = [];
				}
			}
		};
	
		return Outlet;
	
	})();
	
	module.exports = Outlet;
	
	
	/***/ }),
	/* 62 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Graph, Priority, assemble;
	
	Graph = __webpack_require__(6);
	
	Priority = __webpack_require__(36);
	
	
	/*
		Program assembler
	
		Builds composite program that can act as new module/snippet
		Unconnected input/outputs and undefined callbacks are exposed in the new global/main scope
		If there is only one call with an identical call signature, a #define is output instead.
	 */
	
	assemble = function(language, namespace, calls, requires) {
		var adopt, attributes, externals, generate, handle, include, isDangling, library, lookup, process, required, symbols, uniforms, varyings;
		generate = language.generate;
		externals = {};
		symbols = [];
		uniforms = {};
		varyings = {};
		attributes = {};
		library = {};
		process = function() {
			var body, code, includes, lib, main, ns, r, ref, sorted;
			for (ns in requires) {
				r = requires[ns];
				required(r.node, r.module);
			}
			ref = handle(calls), body = ref[0], calls = ref[1];
			if (namespace != null) {
				body.entry = namespace;
			}
			main = generate.build(body, calls);
			sorted = ((function() {
				var results;
				results = [];
				for (ns in library) {
					lib = library[ns];
					results.push(lib);
				}
				return results;
			})()).sort(function(a, b) {
				return Priority.compare(a.priority, b.priority);
			});
			includes = sorted.map(function(x) {
				return x.code;
			});
			includes.push(main.code);
			code = generate.lines(includes);
			return {
				namespace: main.name,
				library: library,
				body: main.code,
				code: code,
				main: main,
				entry: main.name,
				symbols: symbols,
				externals: externals,
				uniforms: uniforms,
				varyings: varyings,
				attributes: attributes
			};
		};
		handle = (function(_this) {
			return function(calls) {
				var body, c, call, i, len, ns;
				calls = (function() {
					var results;
					results = [];
					for (ns in calls) {
						c = calls[ns];
						results.push(c);
					}
					return results;
				})();
				calls.sort(function(a, b) {
					return b.priority - a.priority;
				});
				call = function(node, module, priority) {
					var _dangling, _lookup, entry, main;
					include(node, module, priority);
					main = module.main;
					entry = module.entry;
					_lookup = function(name) {
						return lookup(node, name);
					};
					_dangling = function(name) {
						return isDangling(node, name);
					};
					return generate.call(_lookup, _dangling, entry, main.signature, body);
				};
				body = generate.body();
				for (i = 0, len = calls.length; i < len; i++) {
					c = calls[i];
					call(c.node, c.module, c.priority);
				}
				return [body, calls];
			};
		})(this);
		adopt = function(namespace, code, priority) {
			var record;
			record = library[namespace];
			if (record != null) {
				return record.priority = Priority.max(record.priority, priority);
			} else {
				return library[namespace] = {
					code: code,
					priority: priority
				};
			}
		};
		include = function(node, module, priority) {
			var def, key, lib, ns, ref, ref1, ref2, ref3;
			priority = Priority.make(priority);
			ref = module.library;
			for (ns in ref) {
				lib = ref[ns];
				adopt(ns, lib.code, Priority.nest(priority, lib.priority));
			}
			adopt(module.namespace, module.body, priority);
			ref1 = module.uniforms;
			for (key in ref1) {
				def = ref1[key];
				uniforms[key] = def;
			}
			ref2 = module.varyings;
			for (key in ref2) {
				def = ref2[key];
				varyings[key] = def;
			}
			ref3 = module.attributes;
			for (key in ref3) {
				def = ref3[key];
				attributes[key] = def;
			}
			return required(node, module);
		};
		required = function(node, module) {
			var copy, ext, i, k, key, len, ref, results, v;
			ref = module.symbols;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				key = ref[i];
				ext = module.externals[key];
				if (isDangling(node, ext.name)) {
					copy = {};
					for (k in ext) {
						v = ext[k];
						copy[k] = v;
					}
					copy.name = lookup(node, ext.name);
					externals[key] = copy;
					results.push(symbols.push(key));
				} else {
					results.push(void 0);
				}
			}
			return results;
		};
		isDangling = function(node, name) {
			var outlet;
			outlet = node.get(name);
			if (outlet.inout === Graph.IN) {
				return outlet.input === null;
			} else if (outlet.inout === Graph.OUT) {
				return outlet.output.length === 0;
			}
		};
		lookup = function(node, name) {
			var outlet;
			outlet = node.get(name);
			if (!outlet) {
				return null;
			}
			if (outlet.input) {
				outlet = outlet.input;
			}
			name = outlet.name;
			return outlet.id;
		};
		return process();
	};
	
	module.exports = assemble;
	
	
	/***/ }),
	/* 63 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Graph, Priority, link;
	
	Graph = __webpack_require__(6);
	
	Priority = __webpack_require__(36);
	
	
	/*
	 Callback linker
	 
	 Imports given modules and generates linkages for registered callbacks.
	
	 Builds composite program with single module as exported entry point
	 */
	
	link = function(language, links, modules, exported) {
		var adopt, attributes, externals, generate, include, includes, isDangling, library, process, symbols, uniforms, varyings;
		generate = language.generate;
		includes = [];
		symbols = [];
		externals = {};
		uniforms = {};
		attributes = {};
		varyings = {};
		library = {};
		process = function() {
			var code, e, exports, header, i, len, lib, m, ns, sorted;
			exports = generate.links(links);
			header = [];
			if (exports.defs != null) {
				header.push(exports.defs);
			}
			if (exports.bodies != null) {
				header.push(exports.bodies);
			}
			for (i = 0, len = modules.length; i < len; i++) {
				m = modules[i];
				include(m.node, m.module, m.priority);
			}
			sorted = ((function() {
				var results;
				results = [];
				for (ns in library) {
					lib = library[ns];
					results.push(lib);
				}
				return results;
			})()).sort(function(a, b) {
				return Priority.compare(a.priority, b.priority);
			});
			includes = sorted.map(function(x) {
				return x.code;
			});
			code = generate.lines(includes);
			code = generate.defuse(code);
			if (header.length) {
				code = [generate.lines(header), code].join("\n");
			}
			code = generate.hoist(code);
			code = generate.dedupe(code);
			e = exported;
			return {
				namespace: e.main.name,
				code: code,
				main: e.main,
				entry: e.main.name,
				externals: externals,
				uniforms: uniforms,
				attributes: attributes,
				varyings: varyings
			};
		};
		adopt = function(namespace, code, priority) {
			var record;
			record = library[namespace];
			if (record != null) {
				return record.priority = Priority.max(record.priority, priority);
			} else {
				return library[namespace] = {
					code: code,
					priority: priority
				};
			}
		};
		include = function(node, module, priority) {
			var def, ext, i, key, len, lib, ns, ref, ref1, ref2, ref3, ref4, results;
			priority = Priority.make(priority);
			ref = module.library;
			for (ns in ref) {
				lib = ref[ns];
				adopt(ns, lib.code, Priority.nest(priority, lib.priority));
			}
			adopt(module.namespace, module.body, priority);
			ref1 = module.uniforms;
			for (key in ref1) {
				def = ref1[key];
				uniforms[key] = def;
			}
			ref2 = module.varyings;
			for (key in ref2) {
				def = ref2[key];
				varyings[key] = def;
			}
			ref3 = module.attributes;
			for (key in ref3) {
				def = ref3[key];
				attributes[key] = def;
			}
			ref4 = module.symbols;
			results = [];
			for (i = 0, len = ref4.length; i < len; i++) {
				key = ref4[i];
				ext = module.externals[key];
				if (isDangling(node, ext.name)) {
					externals[key] = ext;
					results.push(symbols.push(key));
				} else {
					results.push(void 0);
				}
			}
			return results;
		};
		isDangling = function(node, name) {
			var module, outlet, ref, ref1;
			outlet = node.get(name);
			if (!outlet) {
				module = (ref = (ref1 = node.owner.snippet) != null ? ref1._name : void 0) != null ? ref : node.owner.namespace;
				throw new Error("Unable to link program. Unlinked callback `" + name + "` on `" + module + "`");
			}
			if (outlet.inout === Graph.IN) {
				return outlet.input === null;
			} else if (outlet.inout === Graph.OUT) {
				return outlet.output.length === 0;
			}
		};
		return process();
	};
	
	module.exports = link;
	
	
	/***/ }),
	/* 64 */
	/***/ (function(module, exports) {
	
	var queue;
	
	queue = function(limit) {
		var add, count, head, map, remove, tail;
		if (limit == null) {
			limit = 100;
		}
		map = {};
		head = null;
		tail = null;
		count = 0;
		add = function(item) {
			item.prev = null;
			item.next = head;
			if (head != null) {
				head.prev = item;
			}
			head = item;
			if (tail == null) {
				return tail = item;
			}
		};
		remove = function(item) {
			var next, prev;
			prev = item.prev;
			next = item.next;
			if (prev != null) {
				prev.next = next;
			}
			if (next != null) {
				next.prev = prev;
			}
			if (head === item) {
				head = next;
			}
			if (tail === item) {
				return tail = prev;
			}
		};
		return function(key) {
			var dead, item;
			if (item = map[key] && item !== head) {
				remove(item);
				add(item);
			} else {
				if (count === limit) {
					dead = tail.key;
					remove(tail);
					delete map[dead];
				} else {
					count++;
				}
				item = {
					next: head,
					prev: null,
					key: key
				};
				add(item);
				map[key] = item;
			}
			return dead;
		};
	};
	
	module.exports = queue;
	
	
	/***/ }),
	/* 65 */
	/***/ (function(module, exports) {
	
	var through;
	
	through = function(write, end) {
		var errors, output;
		output = [];
		errors = [];
		return {
			output: output,
			parser: null,
			write: write,
			end: end,
			process: function(parser, data) {
				this.parser = parser;
				write(data);
				this.flush();
				return this.parser.flush();
			},
			flush: function() {
				end();
				return [output, errors];
			},
			queue: function(obj) {
				var ref;
				if (obj != null) {
					return (ref = this.parser) != null ? ref.write(obj) : void 0;
				}
			},
			emit: function(type, node) {
				if (type === 'data') {
					if (node.parent == null) {
						output.push(node);
					}
				}
				if (type === 'error') {
					return errors.push(node);
				}
			}
		};
	};
	
	module.exports = through;
	
	
	/***/ }),
	/* 66 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var MathBox, THREE;
	
	THREE = __webpack_require__(1);
	
	MathBox = __webpack_require__(67);
	
	window.THREE = THREE;
	
	window.MathBox = MathBox;
	
	window.mathBox = MathBox.mathBox;
	
	window. = Math.PI;
	
	window. =  * 2;
	
	window.e = Math.E;
	
	
	/***/ }),
	/* 67 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Context, MathBox, THREE, Threestrap, k, mathBox, ref, v;
	
	THREE = __webpack_require__(1);
	
	Threestrap = __webpack_require__(68);
	
	Threestrap(THREE);
	
	mathBox = function(options) {
		var ref, three;
		three = THREE.Bootstrap(options);
		if (!three.fallback) {
			if (!three.Time) {
				three.install('time');
			}
			if (!three.MathBox) {
				three.install(['mathbox', 'splash']);
			}
		}
		return (ref = three.mathbox) != null ? ref : three;
	};
	
	MathBox = exports;
	
	MathBox.version = '0.0.5';
	
	MathBox.mathBox = mathBox;
	
	MathBox.THREE = THREE;
	
	MathBox.Context = Context = __webpack_require__(69);
	
	ref = Context.Namespace;
	for (k in ref) {
		v = ref[k];
		MathBox[k] = v;
	}
	
	__webpack_require__(237);
	
	THREE.Bootstrap.registerPlugin('mathbox', {
		defaults: {
			init: true,
			warmup: 2,
			inspect: true,
			splash: true
		},
		listen: ['ready', 'pre', 'update', 'post', 'resize'],
		install: function(three) {
			var inited;
			inited = false;
			this.first = true;
			return three.MathBox = {
				init: (function(_this) {
					return function(options) {
						var camera, scene;
						if (inited) {
							return;
						}
						inited = true;
						scene = (options != null ? options.scene : void 0) || _this.options.scene || three.scene;
						camera = (options != null ? options.camera : void 0) || _this.options.camera || three.camera;
						_this.context = new Context(three.renderer, scene, camera);
						_this.context.api.three = three.three = three;
						_this.context.api.mathbox = three.mathbox = _this.context.api;
						_this.context.api.start = function() {
							return three.Loop.start();
						};
						_this.context.api.stop = function() {
							return three.Loop.stop();
						};
						_this.context.init();
						_this.context.resize(three.Size);
						_this.context.setWarmup(_this.options.warmup);
						_this.pending = 0;
						_this.warm = !_this.options.warmup;
						console.log('MathBox', MathBox.version);
						return three.trigger({
							type: 'mathbox/init',
							version: MathBox.version,
							context: _this.context
						});
					};
				})(this),
				destroy: (function(_this) {
					return function() {
						if (!inited) {
							return;
						}
						inited = false;
						three.trigger({
							type: 'mathbox/destroy',
							context: _this.context
						});
						_this.context.destroy();
						delete three.mathbox;
						delete _this.context.api.three;
						return delete _this.context;
					};
				})(this),
				object: (function(_this) {
					return function() {
						var ref1;
						return (ref1 = _this.context) != null ? ref1.scene.root : void 0;
					};
				})(this)
			};
		},
		uninstall: function(three) {
			three.MathBox.destroy();
			return delete three.MathBox;
		},
		ready: function(event, three) {
			if (this.options.init) {
				three.MathBox.init();
				return setTimeout((function(_this) {
					return function() {
						if (_this.options.inspect) {
							return _this.inspect(three);
						}
					};
				})(this));
			}
		},
		inspect: function(three) {
			this.context.api.inspect();
			if (!this.options.warmup) {
				return this.info(three);
			}
		},
		info: function(three) {
			var fmt, info;
			fmt = function(x) {
				var out;
				out = [];
				while (x >= 1000) {
					out.unshift(("000" + (x % 1000)).slice(-3));
					x = Math.floor(x / 1000);
				}
				out.unshift(x);
				return out.join(',');
			};
			info = three.renderer.info.render;
			return console.log('Geometry  ', fmt(info.faces) + ' faces  ', fmt(info.vertices) + ' vertices  ', fmt(info.calls) + ' draw calls  ');
		},
		resize: function(event, three) {
			var ref1;
			return (ref1 = this.context) != null ? ref1.resize(three.Size) : void 0;
		},
		pre: function(event, three) {
			var ref1;
			return (ref1 = this.context) != null ? ref1.pre(three.Time) : void 0;
		},
		update: function(event, three) {
			var camera, ref1, ref2, ref3;
			if ((ref1 = this.context) != null) {
				ref1.update();
			}
			if ((camera = (ref2 = this.context) != null ? ref2.camera : void 0) && camera !== three.camera) {
				three.camera = camera;
			}
			three.Time.set({
				speed: this.context.speed
			});
			this.progress(this.context.getPending(), three);
			return (ref3 = this.context) != null ? ref3.render() : void 0;
		},
		post: function(event, three) {
			var ref1;
			return (ref1 = this.context) != null ? ref1.post() : void 0;
		},
		progress: function(remain, three) {
			var current, pending, total;
			if (!(remain || this.pending)) {
				return;
			}
			pending = Math.max(remain + this.options.warmup, this.pending);
			current = pending - remain;
			total = pending;
			three.trigger({
				type: 'mathbox/progress',
				current: pending - remain,
				total: pending
			});
			if (remain === 0) {
				pending = 0;
			}
			this.pending = pending;
			if (current === total && !this.warm) {
				this.warm = true;
				if (this.options.inspect) {
					return this.info(three);
				}
			}
		}
	});
	
	
	/***/ }),
	/* 68 */
	/***/ (function(module, exports) {
	
	module.exports=function(e){var t={};function n(i){if(t[i])return t[i].exports;var o=t[i]={i:i,l:!1,exports:{}};return e[i].call(o.exports,o,o.exports,n),o.l=!0,o.exports}return n.m=e,n.c=t,n.d=function(e,t,i){n.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:i})},n.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},n.t=function(e,t){if(1&t&&(e=n(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var i=Object.create(null);if(n.r(i),Object.defineProperty(i,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)n.d(i,o,function(t){return e[t]}.bind(null,o));return i},n.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return n.d(t,"a",t),t},n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},n.p="",n(n.s=3)}([function(e,t,n){(function(e,i){var o;
	/**
	 * @license
	 * Lo-Dash 2.4.2 (Custom Build) <https://lodash.com/>
	 * Build: `lodash modern -o ./dist/lodash.js`
	 * Copyright 2012-2013 The Dojo Foundation <http://dojofoundation.org/>
	 * Based on Underscore.js 1.5.2 <http://underscorejs.org/LICENSE>
	 * Copyright 2009-2013 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
	 * Available under MIT license <https://lodash.com/license>
	 */(function(){var r,a=[],s=[],c=0,l=+new Date+"",u=75,h=40,p=" \t\v\f\ufeff\n\r\u2028\u2029",f=/\b__p \+= '';/g,d=/\b(__p \+=) '' \+/g,m=/(__e\(.*?\)|\b__t\)) \+\n'';/g,v=/\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g,g=/\w*$/,b=/^\s*function[ \n\r\t]+\w/,y=/<%=([\s\S]+?)%>/g,w=RegExp("^["+p+"]*0+(?=.$)"),E=/($^)/,_=/\bthis\b/,k=/['\n\r\t\u2028\u2029\\]/g,x=["Array","Boolean","Date","Function","Math","Number","Object","RegExp","String","_","attachEvent","clearTimeout","isFinite","isNaN","parseInt","setTimeout"],R=0,O="[object Arguments]",C="[object Array]",j="[object Boolean]",P="[object Date]",M="[object Function]",T="[object Number]",L="[object Object]",V="[object RegExp]",S="[object String]",D={};D[M]=!1,D[O]=D[C]=D[j]=D[P]=D[T]=D[L]=D[V]=D[S]=!0;var A={leading:!1,maxWait:0,trailing:!1},F={configurable:!1,enumerable:!1,value:null,writable:!1},N={boolean:!1,function:!0,object:!0,number:!1,string:!1,undefined:!1},z={"\\":"\\","'":"'","\n":"n","\r":"r","\t":"t","\u2028":"u2028","\u2029":"u2029"},H=N[typeof window]&&window||this,B=N[typeof t]&&t&&!t.nodeType&&t,Y=N[typeof e]&&e&&!e.nodeType&&e,X=(Y&&Y.exports,N[typeof i]&&i);function I(e,t,n){for(var i=(n||0)-1,o=e?e.length:0;++i<o;)if(e[i]===t)return i;return-1}function U(e,t){var n=typeof t;if(e=e.cache,"boolean"==n||null==t)return e[t]?0:-1;"number"!=n&&"string"!=n&&(n="object");var i="number"==n?t:l+t;return e=(e=e[n])&&e[i],"object"==n?e&&I(e,t)>-1?0:-1:e?0:-1}function q(e){var t=this.cache,n=typeof e;if("boolean"==n||null==e)t[e]=!0;else{"number"!=n&&"string"!=n&&(n="object");var i="number"==n?e:l+e,o=t[n]||(t[n]={});"object"==n?(o[i]||(o[i]=[])).push(e):o[i]=!0}}function Z(e){return e.charCodeAt(0)}function W(e,t){for(var n=e.criteria,i=t.criteria,o=-1,r=n.length;++o<r;){var a=n[o],s=i[o];if(a!==s){if(a>s||void 0===a)return 1;if(a<s||void 0===s)return-1}}return e.index-t.index}function K(e){var t=-1,n=e.length,i=e[0],o=e[n/2|0],r=e[n-1];if(i&&"object"==typeof i&&o&&"object"==typeof o&&r&&"object"==typeof r)return!1;var a=$();a.false=a.null=a.true=a[void 0]=!1;var s=$();for(s.array=e,s.cache=a,s.push=q;++t<n;)s.push(e[t]);return s}function G(e){return"\\"+z[e]}function Q(){return a.pop()||[]}function $(){return s.pop()||{array:null,cache:null,criteria:null,false:!1,index:0,null:!1,number:null,object:null,push:null,string:null,true:!1,undefined:!1,value:null}}function J(e){e.length=0,a.length<h&&a.push(e)}function ee(e){var t=e.cache;t&&ee(t),e.array=e.cache=e.criteria=e.object=e.number=e.string=e.value=null,s.length<h&&s.push(e)}function te(e,t,n){t||(t=0),void 0===n&&(n=e?e.length:0);for(var i=-1,o=n-t||0,r=Array(o<0?0:o);++i<o;)r[i]=e[t+i];return r}!X||X.global!==X&&X.window!==X||(H=X);var ne=function e(t){var n=(t=t?ne.defaults(H.Object(),t,ne.pick(H,x)):H).Array,i=t.Boolean,o=t.Date,a=t.Function,s=t.Math,h=t.Number,z=t.Object,B=t.RegExp,Y=t.String,X=t.TypeError,q=[],ie=z.prototype,oe=t._,re=ie.toString,ae=B("^"+Y(re).replace(/[.*+?^${}()|[\]\\]/g,"\\$&").replace(/toString| for [^\]]+/g,".*?")+"$"),se=s.ceil,ce=t.clearTimeout,le=s.floor,ue=a.prototype.toString,he=qe(he=z.getPrototypeOf)&&he,pe=ie.hasOwnProperty,fe=q.push,de=t.setTimeout,me=q.splice,ve=q.unshift,ge=function(){try{var e={},t=qe(t=z.defineProperty)&&t,n=t(e,e,e)&&t}catch(e){}return n}(),be=qe(be=z.create)&&be,ye=qe(ye=n.isArray)&&ye,we=t.isFinite,Ee=t.isNaN,_e=qe(_e=z.keys)&&_e,ke=s.max,xe=s.min,Re=t.parseInt,Oe=s.random,Ce={};function je(e){return e&&"object"==typeof e&&!Qe(e)&&pe.call(e,"__wrapped__")?e:new Pe(e)}function Pe(e,t){this.__chain__=!!t,this.__wrapped__=e}Ce[C]=n,Ce[j]=i,Ce[P]=o,Ce[M]=a,Ce[L]=z,Ce[T]=h,Ce[V]=B,Ce[S]=Y,Pe.prototype=je.prototype;var Me=je.support={};function Te(e){var t=e[0],n=e[2],i=e[4];function o(){if(n){var e=te(n);fe.apply(e,arguments)}if(this instanceof o){var r=Ve(t.prototype),a=t.apply(r,e||arguments);return ht(a)?a:r}return t.apply(i,e||arguments)}return Ze(o,e),o}function Le(e,t,n,i,o){if(n){var r=n(e);if(void 0!==r)return r}if(!ht(e))return e;var a=re.call(e);if(!D[a])return e;var s=Ce[a];switch(a){case j:case P:return new s(+e);case T:case S:return new s(e);case V:return(r=s(e.source,g.exec(e))).lastIndex=e.lastIndex,r}var c=Qe(e);if(t){var l=!i;i||(i=Q()),o||(o=Q());for(var u=i.length;u--;)if(i[u]==e)return o[u];r=c?s(e.length):{}}else r=c?te(e):it({},e);return c&&(pe.call(e,"index")&&(r.index=e.index),pe.call(e,"input")&&(r.input=e.input)),t?(i.push(e),o.push(r),(c?Et:at)(e,(function(e,a){r[a]=Le(e,t,n,i,o)})),l&&(J(i),J(o)),r):r}function Ve(e,t){return ht(e)?be(e):{}}function Se(e,t,n){if("function"!=typeof e)return Yt;if(void 0===t||!("prototype"in e))return e;var i=e.__bindData__;if(void 0===i&&(Me.funcNames&&(i=!e.name),!(i=i||!Me.funcDecomp))){var o=ue.call(e);Me.funcNames||(i=!b.test(o)),i||(i=_.test(o),Ze(e,i))}if(!1===i||!0!==i&&1&i[1])return e;switch(n){case 1:return function(n){return e.call(t,n)};case 2:return function(n,i){return e.call(t,n,i)};case 3:return function(n,i,o){return e.call(t,n,i,o)};case 4:return function(n,i,o,r){return e.call(t,n,i,o,r)}}return Ht(e,t)}function De(e){var t=e[0],n=e[1],i=e[2],o=e[3],r=e[4],a=e[5],s=1&n,c=2&n,l=4&n,u=8&n,h=t;function p(){var e=s?r:this;if(i){var f=te(i);fe.apply(f,arguments)}if((o||l)&&(f||(f=te(arguments)),o&&fe.apply(f,o),l&&f.length<a))return n|=16,De([t,u?n:-4&n,f,null,r,a]);if(f||(f=arguments),c&&(t=e[h]),this instanceof p){e=Ve(t.prototype);var d=t.apply(e,f);return ht(d)?d:e}return t.apply(e,f)}return Ze(p,e),p}function Ae(e,t){var n=-1,i=Ue(),o=e?e.length:0,r=o>=u&&i===I,a=[];if(r){var s=K(t);s?(i=U,t=s):r=!1}for(;++n<o;){var c=e[n];i(t,c)<0&&a.push(c)}return r&&ee(t),a}function Fe(e,t,n,i){for(var o=(i||0)-1,r=e?e.length:0,a=[];++o<r;){var s=e[o];if(s&&"object"==typeof s&&"number"==typeof s.length&&(Qe(s)||Ge(s))){t||(s=Fe(s,t,n));var c=-1,l=s.length,u=a.length;for(a.length+=l;++c<l;)a[u++]=s[c]}else n||a.push(s)}return a}function Ne(e,t,n,i,o,r){if(n){var a=n(e,t);if(void 0!==a)return!!a}if(e===t)return 0!==e||1/e==1/t;var s=typeof t;if(!(e!=e||e&&N[typeof e]||t&&N[s]))return!1;if(null==e||null==t)return e===t;var c=re.call(e),l=re.call(t);if(c==O&&(c=L),l==O&&(l=L),c!=l)return!1;switch(c){case j:case P:return+e==+t;case T:return e!=+e?t!=+t:0==e?1/e==1/t:e==+t;case V:case S:return e==Y(t)}var u=c==C;if(!u){var h=pe.call(e,"__wrapped__"),p=pe.call(t,"__wrapped__");if(h||p)return Ne(h?e.__wrapped__:e,p?t.__wrapped__:t,n,i,o,r);if(c!=L)return!1;var f=e.constructor,d=t.constructor;if(f!=d&&!(ut(f)&&f instanceof f&&ut(d)&&d instanceof d)&&"constructor"in e&&"constructor"in t)return!1}var m=!o;o||(o=Q()),r||(r=Q());for(var v=o.length;v--;)if(o[v]==e)return r[v]==t;var g=0;if(a=!0,o.push(e),r.push(t),u){if(v=e.length,g=t.length,(a=g==v)||i)for(;g--;){var b=v,y=t[g];if(i)for(;b--&&!(a=Ne(e[b],y,n,i,o,r)););else if(!(a=Ne(e[g],y,n,i,o,r)))break}}else rt(t,(function(t,s,c){if(pe.call(c,s))return g++,a=pe.call(e,s)&&Ne(e[s],t,n,i,o,r)})),a&&!i&&rt(e,(function(e,t,n){if(pe.call(n,t))return a=--g>-1}));return o.pop(),r.pop(),m&&(J(o),J(r)),a}function ze(e,t,n,i,o){(Qe(t)?Et:at)(t,(function(t,r){var a,s,c=t,l=e[r];if(t&&((s=Qe(t))||ft(t))){for(var u,h=i.length;h--;)if(a=i[h]==t){l=o[h];break}if(!a)n&&(u=void 0!==(c=n(l,t)))&&(l=c),u||(l=s?Qe(l)?l:[]:ft(l)?l:{}),i.push(t),o.push(l),u||ze(l,t,n,i,o)}else n&&void 0===(c=n(l,t))&&(c=t),void 0!==c&&(l=c);e[r]=l}))}function He(e,t){return e+le(Oe()*(t-e+1))}function Be(e,t,n){var i=-1,o=Ue(),r=e?e.length:0,a=[],s=!t&&r>=u&&o===I,c=n||s?Q():a;s&&(o=U,c=K(c));for(;++i<r;){var l=e[i],h=n?n(l,i,e):l;(t?!i||c[c.length-1]!==h:o(c,h)<0)&&((n||s)&&c.push(h),a.push(l))}return s?(J(c.array),ee(c)):n&&J(c),a}function Ye(e){return function(t,n,i){var o={};n=je.createCallback(n,i,3);var r=-1,a=t?t.length:0;if("number"==typeof a)for(;++r<a;){var s=t[r];e(o,s,n(s,r,t),t)}else at(t,(function(t,i,r){e(o,t,n(t,i,r),r)}));return o}}function Xe(e,t,n,i,o,r){var a=1&t,s=4&t,c=16&t,l=32&t;if(!(2&t)&&!ut(e))throw new X;c&&!n.length&&(t&=-17,c=n=!1),l&&!i.length&&(t&=-33,l=i=!1);var u=e&&e.__bindData__;return u&&!0!==u?((u=te(u))[2]&&(u[2]=te(u[2])),u[3]&&(u[3]=te(u[3])),!a||1&u[1]||(u[4]=o),!a&&1&u[1]&&(t|=8),!s||4&u[1]||(u[5]=r),c&&fe.apply(u[2]||(u[2]=[]),n),l&&ve.apply(u[3]||(u[3]=[]),i),u[1]|=t,Xe.apply(null,u)):(1==t||17===t?Te:De)([e,t,n,i,o,r])}function Ie(e){return Je[e]}function Ue(){var e=(e=je.indexOf)===St?I:e;return e}function qe(e){return"function"==typeof e&&ae.test(e)}Me.funcDecomp=!qe(t.WinRTError)&&_.test(e),Me.funcNames="string"==typeof a.name,je.templateSettings={escape:/<%-([\s\S]+?)%>/g,evaluate:/<%([\s\S]+?)%>/g,interpolate:y,variable:"",imports:{_:je}},be||(Ve=function(){function e(){}return function(n){if(ht(n)){e.prototype=n;var i=new e;e.prototype=null}return i||t.Object()}}());var Ze=ge?function(e,t){F.value=t,ge(e,"__bindData__",F),F.value=null}:It;function We(e){var t,n;return!(!e||re.call(e)!=L||ut(t=e.constructor)&&!(t instanceof t))&&(rt(e,(function(e,t){n=t})),void 0===n||pe.call(e,n))}function Ke(e){return et[e]}function Ge(e){return e&&"object"==typeof e&&"number"==typeof e.length&&re.call(e)==O||!1}var Qe=ye||function(e){return e&&"object"==typeof e&&"number"==typeof e.length&&re.call(e)==C||!1},$e=_e?function(e){return ht(e)?_e(e):[]}:function(e){var t,n=e,i=[];if(!n)return i;if(!N[typeof e])return i;for(t in n)pe.call(n,t)&&i.push(t);return i},Je={"&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"},et=lt(Je),tt=B("("+$e(et).join("|")+")","g"),nt=B("["+$e(Je).join("")+"]","g"),it=function(e,t,n){var i,o=e,r=o;if(!o)return r;var a=arguments,s=0,c="number"==typeof n?2:a.length;if(c>3&&"function"==typeof a[c-2])var l=Se(a[--c-1],a[c--],2);else c>2&&"function"==typeof a[c-1]&&(l=a[--c]);for(;++s<c;)if((o=a[s])&&N[typeof o])for(var u=-1,h=N[typeof o]&&$e(o),p=h?h.length:0;++u<p;)r[i=h[u]]=l?l(r[i],o[i]):o[i];return r},ot=function(e,t,n){var i,o=e,r=o;if(!o)return r;for(var a=arguments,s=0,c="number"==typeof n?2:a.length;++s<c;)if((o=a[s])&&N[typeof o])for(var l=-1,u=N[typeof o]&&$e(o),h=u?u.length:0;++l<h;)void 0===r[i=u[l]]&&(r[i]=o[i]);return r},rt=function(e,t,n){var i,o=e,r=o;if(!o)return r;if(!N[typeof o])return r;for(i in t=t&&void 0===n?t:Se(t,n,3),o)if(!1===t(o[i],i,e))return r;return r},at=function(e,t,n){var i,o=e,r=o;if(!o)return r;if(!N[typeof o])return r;t=t&&void 0===n?t:Se(t,n,3);for(var a=-1,s=N[typeof o]&&$e(o),c=s?s.length:0;++a<c;)if(!1===t(o[i=s[a]],i,e))return r;return r};function st(e,t,n){var i=$e(e),o=i.length;for(t=Se(t,n,3);o--;){var r=i[o];if(!1===t(e[r],r,e))break}return e}function ct(e){var t=[];return rt(e,(function(e,n){ut(e)&&t.push(n)})),t.sort()}function lt(e){for(var t=-1,n=$e(e),i=n.length,o={};++t<i;){var r=n[t];o[e[r]]=r}return o}function ut(e){return"function"==typeof e}function ht(e){return!(!e||!N[typeof e])}function pt(e){return"number"==typeof e||e&&"object"==typeof e&&re.call(e)==T||!1}var ft=he?function(e){if(!e||re.call(e)!=L)return!1;var t=e.valueOf,n=qe(t)&&(n=he(t))&&he(n);return n?e==n||he(e)==n:We(e)}:We;function dt(e){return"string"==typeof e||e&&"object"==typeof e&&re.call(e)==S||!1}function mt(e){for(var t=-1,i=$e(e),o=i.length,r=n(o);++t<o;)r[t]=e[i[t]];return r}function vt(e,t,n){var i=-1,o=Ue(),r=e?e.length:0,a=!1;return n=(n<0?ke(0,r+n):n)||0,Qe(e)?a=o(e,t,n)>-1:"number"==typeof r?a=(dt(e)?e.indexOf(t,n):o(e,t,n))>-1:at(e,(function(e){if(++i>=n)return!(a=e===t)})),a}var gt=Ye((function(e,t,n){pe.call(e,n)?e[n]++:e[n]=1}));function bt(e,t,n){var i=!0;t=je.createCallback(t,n,3);var o=-1,r=e?e.length:0;if("number"==typeof r)for(;++o<r&&(i=!!t(e[o],o,e)););else at(e,(function(e,n,o){return i=!!t(e,n,o)}));return i}function yt(e,t,n){var i=[];t=je.createCallback(t,n,3);var o=-1,r=e?e.length:0;if("number"==typeof r)for(;++o<r;){var a=e[o];t(a,o,e)&&i.push(a)}else at(e,(function(e,n,o){t(e,n,o)&&i.push(e)}));return i}function wt(e,t,n){t=je.createCallback(t,n,3);var i,o=-1,r=e?e.length:0;if("number"!=typeof r)return at(e,(function(e,n,o){if(t(e,n,o))return i=e,!1})),i;for(;++o<r;){var a=e[o];if(t(a,o,e))return a}}function Et(e,t,n){var i=-1,o=e?e.length:0;if(t=t&&void 0===n?t:Se(t,n,3),"number"==typeof o)for(;++i<o&&!1!==t(e[i],i,e););else at(e,t);return e}function _t(e,t,n){var i=e?e.length:0;if(t=t&&void 0===n?t:Se(t,n,3),"number"==typeof i)for(;i--&&!1!==t(e[i],i,e););else{var o=$e(e);i=o.length,at(e,(function(e,n,r){return n=o?o[--i]:--i,t(r[n],n,r)}))}return e}var kt=Ye((function(e,t,n){(pe.call(e,n)?e[n]:e[n]=[]).push(t)})),xt=Ye((function(e,t,n){e[n]=t}));function Rt(e,t,i){var o=-1,r=e?e.length:0;if(t=je.createCallback(t,i,3),"number"==typeof r)for(var a=n(r);++o<r;)a[o]=t(e[o],o,e);else a=[],at(e,(function(e,n,i){a[++o]=t(e,n,i)}));return a}function Ot(e,t,n){var i=-1/0,o=i;if("function"!=typeof t&&n&&n[t]===e&&(t=null),null==t&&Qe(e))for(var r=-1,a=e.length;++r<a;){var s=e[r];s>o&&(o=s)}else t=null==t&&dt(e)?Z:je.createCallback(t,n,3),Et(e,(function(e,n,r){var a=t(e,n,r);a>i&&(i=a,o=e)}));return o}var Ct=Rt;function jt(e,t,n,i){if(!e)return n;var o=arguments.length<3;t=je.createCallback(t,i,4);var r=-1,a=e.length;if("number"==typeof a)for(o&&(n=e[++r]);++r<a;)n=t(n,e[r],r,e);else at(e,(function(e,i,r){n=o?(o=!1,e):t(n,e,i,r)}));return n}function Pt(e,t,n,i){var o=arguments.length<3;return t=je.createCallback(t,i,4),_t(e,(function(e,i,r){n=o?(o=!1,e):t(n,e,i,r)})),n}function Mt(e){var t=-1,i=e?e.length:0,o=n("number"==typeof i?i:0);return Et(e,(function(e){var n=He(0,++t);o[t]=o[n],o[n]=e})),o}function Tt(e,t,n){var i;t=je.createCallback(t,n,3);var o=-1,r=e?e.length:0;if("number"==typeof r)for(;++o<r&&!(i=t(e[o],o,e)););else at(e,(function(e,n,o){return!(i=t(e,n,o))}));return!!i}var Lt=yt;function Vt(e,t,n){var i=0,o=e?e.length:0;if("number"!=typeof t&&null!=t){var a=-1;for(t=je.createCallback(t,n,3);++a<o&&t(e[a],a,e);)i++}else if(null==(i=t)||n)return e?e[0]:r;return te(e,0,xe(ke(0,i),o))}function St(e,t,n){if("number"==typeof n){var i=e?e.length:0;n=n<0?ke(0,i+n):n||0}else if(n){var o=At(e,t);return e[o]===t?o:-1}return I(e,t,n)}function Dt(e,t,n){if("number"!=typeof t&&null!=t){var i=0,o=-1,r=e?e.length:0;for(t=je.createCallback(t,n,3);++o<r&&t(e[o],o,e);)i++}else i=null==t||n?1:ke(0,t);return te(e,i)}function At(e,t,n,i){var o=0,r=e?e.length:o;for(t=(n=n?je.createCallback(n,i,1):Yt)(t);o<r;){var a=o+r>>>1;n(e[a])<t?o=a+1:r=a}return o}function Ft(e,t,n,i){return"boolean"!=typeof t&&null!=t&&(i=n,n="function"!=typeof t&&i&&i[t]===e?null:t,t=!1),null!=n&&(n=je.createCallback(n,i,3)),Be(e,t,n)}function Nt(){for(var e=arguments.length>1?arguments:arguments[0],t=-1,i=e?Ot(Ct(e,"length")):0,o=n(i<0?0:i);++t<i;)o[t]=Ct(e,t);return o}function zt(e,t){var n=-1,i=e?e.length:0,o={};for(t||!i||Qe(e[0])||(t=[]);++n<i;){var r=e[n];t?o[r]=t[n]:r&&(o[r[0]]=r[1])}return o}function Ht(e,t){return arguments.length>2?Xe(e,17,te(arguments,2),null,t):Xe(e,1,null,null,t)}function Bt(e,t,n){var i,o,a,s,c,l,u,h=0,p=!1,f=!0;if(!ut(e))throw new X;if(t=ke(0,t)||0,!0===n){var d=!0;f=!1}else ht(n)&&(d=n.leading,p="maxWait"in n&&(ke(t,n.maxWait)||0),f="trailing"in n?n.trailing:f);var m=function(){var n=t-(qt()-s);if(n<=0){o&&ce(o);var p=u;o=l=u=r,p&&(h=qt(),a=e.apply(c,i),l||o||(i=c=null))}else l=de(m,n)},v=function(){l&&ce(l),o=l=u=r,(f||p!==t)&&(h=qt(),a=e.apply(c,i),l||o||(i=c=null))};return function(){if(i=arguments,s=qt(),c=this,u=f&&(l||!d),!1===p)var n=d&&!l;else{o||d||(h=s);var r=p-(s-h),g=r<=0;g?(o&&(o=ce(o)),h=s,a=e.apply(c,i)):o||(o=de(v,r))}return g&&l?l=ce(l):l||t===p||(l=de(m,t)),n&&(g=!0,a=e.apply(c,i)),!g||l||o||(i=c=null),a}}function Yt(e){return e}function Xt(e,t,n){var i=!0,o=t&&ct(t);t&&(n||o.length)||(null==n&&(n=t),r=Pe,t=e,e=je,o=ct(t)),!1===n?i=!1:ht(n)&&"chain"in n&&(i=n.chain);var r=e,a=ut(r);Et(o,(function(n){var o=e[n]=t[n];a&&(r.prototype[n]=function(){var t=this.__chain__,n=this.__wrapped__,a=[n];fe.apply(a,arguments);var s=o.apply(e,a);if(i||t){if(n===s&&ht(s))return this;(s=new r(s)).__chain__=t}return s})}))}function It(){}var Ut,qt=qe(qt=o.now)&&qt||function(){return(new o).getTime()},Zt=8==Re(p+"08")?Re:function(e,t){return Re(dt(e)?e.replace(w,""):e,t||0)};function Wt(e){return function(t){return t[e]}}function Kt(){return this.__wrapped__}return je.after=function(e,t){if(!ut(t))throw new X;return function(){if(--e<1)return t.apply(this,arguments)}},je.assign=it,je.at=function(e){for(var t=arguments,i=-1,o=Fe(t,!0,!1,1),r=t[2]&&t[2][t[1]]===e?1:o.length,a=n(r);++i<r;)a[i]=e[o[i]];return a},je.bind=Ht,je.bindAll=function(e){for(var t=arguments.length>1?Fe(arguments,!0,!1,1):ct(e),n=-1,i=t.length;++n<i;){var o=t[n];e[o]=Xe(e[o],1,null,null,e)}return e},je.bindKey=function(e,t){return arguments.length>2?Xe(t,19,te(arguments,2),null,e):Xe(t,3,null,null,e)},je.chain=function(e){return(e=new Pe(e)).__chain__=!0,e},je.compact=function(e){for(var t=-1,n=e?e.length:0,i=[];++t<n;){var o=e[t];o&&i.push(o)}return i},je.compose=function(){for(var e=arguments,t=e.length;t--;)if(!ut(e[t]))throw new X;return function(){for(var t=arguments,n=e.length;n--;)t=[e[n].apply(this,t)];return t[0]}},je.constant=function(e){return function(){return e}},je.countBy=gt,je.create=function(e,t){var n=Ve(e);return t?it(n,t):n},je.createCallback=function(e,t,n){var i=typeof e;if(null==e||"function"==i)return Se(e,t,n);if("object"!=i)return Wt(e);var o=$e(e),r=o[0],a=e[r];return 1!=o.length||a!=a||ht(a)?function(t){for(var n=o.length,i=!1;n--&&(i=Ne(t[o[n]],e[o[n]],null,!0)););return i}:function(e){var t=e[r];return a===t&&(0!==a||1/a==1/t)}},je.curry=function(e,t){return Xe(e,4,null,null,null,t="number"==typeof t?t:+t||e.length)},je.debounce=Bt,je.defaults=ot,je.defer=function(e){if(!ut(e))throw new X;var t=te(arguments,1);return de((function(){e.apply(r,t)}),1)},je.delay=function(e,t){if(!ut(e))throw new X;var n=te(arguments,2);return de((function(){e.apply(r,n)}),t)},je.difference=function(e){return Ae(e,Fe(arguments,!0,!0,1))},je.filter=yt,je.flatten=function(e,t,n,i){return"boolean"!=typeof t&&null!=t&&(i=n,n="function"!=typeof t&&i&&i[t]===e?null:t,t=!1),null!=n&&(e=Rt(e,n,i)),Fe(e,t)},je.forEach=Et,je.forEachRight=_t,je.forIn=rt,je.forInRight=function(e,t,n){var i=[];rt(e,(function(e,t){i.push(t,e)}));var o=i.length;for(t=Se(t,n,3);o--&&!1!==t(i[o--],i[o],e););return e},je.forOwn=at,je.forOwnRight=st,je.functions=ct,je.groupBy=kt,je.indexBy=xt,je.initial=function(e,t,n){var i=0,o=e?e.length:0;if("number"!=typeof t&&null!=t){var r=o;for(t=je.createCallback(t,n,3);r--&&t(e[r],r,e);)i++}else i=null==t||n?1:t||i;return te(e,0,xe(ke(0,o-i),o))},je.intersection=function(){for(var e=[],t=-1,n=arguments.length,i=Q(),o=Ue(),r=o===I,a=Q();++t<n;){var s=arguments[t];(Qe(s)||Ge(s))&&(e.push(s),i.push(r&&s.length>=u&&K(t?e[t]:a)))}var c=e[0],l=-1,h=c?c.length:0,p=[];e:for(;++l<h;){var f=i[0];if(s=c[l],(f?U(f,s):o(a,s))<0){for(t=n,(f||a).push(s);--t;)if(((f=i[t])?U(f,s):o(e[t],s))<0)continue e;p.push(s)}}for(;n--;)(f=i[n])&&ee(f);return J(i),J(a),p},je.invert=lt,je.invoke=function(e,t){var i=te(arguments,2),o=-1,r="function"==typeof t,a=e?e.length:0,s=n("number"==typeof a?a:0);return Et(e,(function(e){s[++o]=(r?t:e[t]).apply(e,i)})),s},je.keys=$e,je.map=Rt,je.mapValues=function(e,t,n){var i={};return t=je.createCallback(t,n,3),at(e,(function(e,n,o){i[n]=t(e,n,o)})),i},je.max=Ot,je.memoize=function(e,t){if(!ut(e))throw new X;var n=function(){var i=n.cache,o=t?t.apply(this,arguments):l+arguments[0];return pe.call(i,o)?i[o]:i[o]=e.apply(this,arguments)};return n.cache={},n},je.merge=function(e){var t=arguments,n=2;if(!ht(e))return e;if("number"!=typeof t[2]&&(n=t.length),n>3&&"function"==typeof t[n-2])var i=Se(t[--n-1],t[n--],2);else n>2&&"function"==typeof t[n-1]&&(i=t[--n]);for(var o=te(arguments,1,n),r=-1,a=Q(),s=Q();++r<n;)ze(e,o[r],i,a,s);return J(a),J(s),e},je.min=function(e,t,n){var i=1/0,o=i;if("function"!=typeof t&&n&&n[t]===e&&(t=null),null==t&&Qe(e))for(var r=-1,a=e.length;++r<a;){var s=e[r];s<o&&(o=s)}else t=null==t&&dt(e)?Z:je.createCallback(t,n,3),Et(e,(function(e,n,r){var a=t(e,n,r);a<i&&(i=a,o=e)}));return o},je.omit=function(e,t,n){var i={};if("function"!=typeof t){var o=[];rt(e,(function(e,t){o.push(t)}));for(var r=-1,a=(o=Ae(o,Fe(arguments,!0,!1,1))).length;++r<a;){var s=o[r];i[s]=e[s]}}else t=je.createCallback(t,n,3),rt(e,(function(e,n,o){t(e,n,o)||(i[n]=e)}));return i},je.once=function(e){var t,n;if(!ut(e))throw new X;return function(){return t?n:(t=!0,n=e.apply(this,arguments),e=null,n)}},je.pairs=function(e){for(var t=-1,i=$e(e),o=i.length,r=n(o);++t<o;){var a=i[t];r[t]=[a,e[a]]}return r},je.partial=function(e){return Xe(e,16,te(arguments,1))},je.partialRight=function(e){return Xe(e,32,null,te(arguments,1))},je.pick=function(e,t,n){var i={};if("function"!=typeof t)for(var o=-1,r=Fe(arguments,!0,!1,1),a=ht(e)?r.length:0;++o<a;){var s=r[o];s in e&&(i[s]=e[s])}else t=je.createCallback(t,n,3),rt(e,(function(e,n,o){t(e,n,o)&&(i[n]=e)}));return i},je.pluck=Ct,je.property=Wt,je.pull=function(e){for(var t=arguments,n=0,i=t.length,o=e?e.length:0;++n<i;)for(var r=-1,a=t[n];++r<o;)e[r]===a&&(me.call(e,r--,1),o--);return e},je.range=function(e,t,i){e=+e||0,null==t&&(t=e,e=0);for(var o=-1,r=ke(0,se((t-e)/((i="number"==typeof i?i:+i||1)||1))),a=n(r);++o<r;)a[o]=e,e+=i;return a},je.reject=function(e,t,n){return t=je.createCallback(t,n,3),yt(e,(function(e,n,i){return!t(e,n,i)}))},je.remove=function(e,t,n){var i=-1,o=e?e.length:0,r=[];for(t=je.createCallback(t,n,3);++i<o;){var a=e[i];t(a,i,e)&&(r.push(a),me.call(e,i--,1),o--)}return r},je.rest=Dt,je.shuffle=Mt,je.sortBy=function(e,t,i){var o=-1,r=Qe(t),a=e?e.length:0,s=n("number"==typeof a?a:0);for(r||(t=je.createCallback(t,i,3)),Et(e,(function(e,n,i){var a=s[++o]=$();r?a.criteria=Rt(t,(function(t){return e[t]})):(a.criteria=Q())[0]=t(e,n,i),a.index=o,a.value=e})),a=s.length,s.sort(W);a--;){var c=s[a];s[a]=c.value,r||J(c.criteria),ee(c)}return s},je.tap=function(e,t){return t(e),e},je.throttle=function(e,t,n){var i=!0,o=!0;if(!ut(e))throw new X;return!1===n?i=!1:ht(n)&&(i="leading"in n?n.leading:i,o="trailing"in n?n.trailing:o),A.leading=i,A.maxWait=t,A.trailing=o,Bt(e,t,A)},je.times=function(e,t,i){e=(e=+e)>-1?e:0;var o=-1,r=n(e);for(t=Se(t,i,1);++o<e;)r[o]=t(o);return r},je.toArray=function(e){return e&&"number"==typeof e.length?te(e):mt(e)},je.transform=function(e,t,n,i){var o=Qe(e);if(null==n)if(o)n=[];else{var r=e&&e.constructor,a=r&&r.prototype;n=Ve(a)}return t&&(t=je.createCallback(t,i,4),(o?Et:at)(e,(function(e,i,o){return t(n,e,i,o)}))),n},je.union=function(){return Be(Fe(arguments,!0,!0))},je.uniq=Ft,je.values=mt,je.where=Lt,je.without=function(e){return Ae(e,te(arguments,1))},je.wrap=function(e,t){return Xe(t,16,[e])},je.xor=function(){for(var e=-1,t=arguments.length;++e<t;){var n=arguments[e];if(Qe(n)||Ge(n))var i=i?Be(Ae(i,n).concat(Ae(n,i))):n}return i||[]},je.zip=Nt,je.zipObject=zt,je.collect=Rt,je.drop=Dt,je.each=Et,je.eachRight=_t,je.extend=it,je.methods=ct,je.object=zt,je.select=yt,je.tail=Dt,je.unique=Ft,je.unzip=Nt,Xt(je),je.clone=function(e,t,n,i){return"boolean"!=typeof t&&null!=t&&(i=n,n=t,t=!1),Le(e,t,"function"==typeof n&&Se(n,i,1))},je.cloneDeep=function(e,t,n){return Le(e,!0,"function"==typeof t&&Se(t,n,1))},je.contains=vt,je.escape=function(e){return null==e?"":Y(e).replace(nt,Ie)},je.every=bt,je.find=wt,je.findIndex=function(e,t,n){var i=-1,o=e?e.length:0;for(t=je.createCallback(t,n,3);++i<o;)if(t(e[i],i,e))return i;return-1},je.findKey=function(e,t,n){var i;return t=je.createCallback(t,n,3),at(e,(function(e,n,o){if(t(e,n,o))return i=n,!1})),i},je.findLast=function(e,t,n){var i;return t=je.createCallback(t,n,3),_t(e,(function(e,n,o){if(t(e,n,o))return i=e,!1})),i},je.findLastIndex=function(e,t,n){var i=e?e.length:0;for(t=je.createCallback(t,n,3);i--;)if(t(e[i],i,e))return i;return-1},je.findLastKey=function(e,t,n){var i;return t=je.createCallback(t,n,3),st(e,(function(e,n,o){if(t(e,n,o))return i=n,!1})),i},je.has=function(e,t){return!!e&&pe.call(e,t)},je.identity=Yt,je.indexOf=St,je.isArguments=Ge,je.isArray=Qe,je.isBoolean=function(e){return!0===e||!1===e||e&&"object"==typeof e&&re.call(e)==j||!1},je.isDate=function(e){return e&&"object"==typeof e&&re.call(e)==P||!1},je.isElement=function(e){return e&&1===e.nodeType||!1},je.isEmpty=function(e){var t=!0;if(!e)return t;var n=re.call(e),i=e.length;return n==C||n==S||n==O||n==L&&"number"==typeof i&&ut(e.splice)?!i:(at(e,(function(){return t=!1})),t)},je.isEqual=function(e,t,n,i){return Ne(e,t,"function"==typeof n&&Se(n,i,2))},je.isFinite=function(e){return we(e)&&!Ee(parseFloat(e))},je.isFunction=ut,je.isNaN=function(e){return pt(e)&&e!=+e},je.isNull=function(e){return null===e},je.isNumber=pt,je.isObject=ht,je.isPlainObject=ft,je.isRegExp=function(e){return e&&"object"==typeof e&&re.call(e)==V||!1},je.isString=dt,je.isUndefined=function(e){return void 0===e},je.lastIndexOf=function(e,t,n){var i=e?e.length:0;for("number"==typeof n&&(i=(n<0?ke(0,i+n):xe(n,i-1))+1);i--;)if(e[i]===t)return i;return-1},je.mixin=Xt,je.noConflict=function(){return t._=oe,this},je.noop=It,je.now=qt,je.parseInt=Zt,je.random=function(e,t,n){var i=null==e,o=null==t;if(null==n&&("boolean"==typeof e&&o?(n=e,e=1):o||"boolean"!=typeof t||(n=t,o=!0)),i&&o&&(t=1),e=+e||0,o?(t=e,e=0):t=+t||0,n||e%1||t%1){var r=Oe();return xe(e+r*(t-e+parseFloat("1e-"+((r+"").length-1))),t)}return He(e,t)},je.reduce=jt,je.reduceRight=Pt,je.result=function(e,t){if(e){var n=e[t];return ut(n)?e[t]():n}},je.runInContext=e,je.size=function(e){var t=e?e.length:0;return"number"==typeof t?t:$e(e).length},je.some=Tt,je.sortedIndex=At,je.template=function(e,t,n){var i=je.templateSettings;e=Y(e||""),n=ot({},n,i);var o,s=ot({},n.imports,i.imports),c=$e(s),l=mt(s),u=0,h=n.interpolate||E,p="__p += '",g=B((n.escape||E).source+"|"+h.source+"|"+(h===y?v:E).source+"|"+(n.evaluate||E).source+"|$","g");e.replace(g,(function(t,n,i,r,a,s){return i||(i=r),p+=e.slice(u,s).replace(k,G),n&&(p+="' +\n__e("+n+") +\n'"),a&&(o=!0,p+="';\n"+a+";\n__p += '"),i&&(p+="' +\n((__t = ("+i+")) == null ? '' : __t) +\n'"),u=s+t.length,t})),p+="';\n";var b=n.variable,w=b;w||(p="with ("+(b="obj")+") {\n"+p+"\n}\n"),p=(o?p.replace(f,""):p).replace(d,"$1").replace(m,"$1;"),p="function("+b+") {\n"+(w?"":b+" || ("+b+" = {});\n")+"var __t, __p = '', __e = _.escape"+(o?", __j = Array.prototype.join;\nfunction print() { __p += __j.call(arguments, '') }\n":";\n")+p+"return __p\n}";var _="\n/*\n//# sourceURL="+(n.sourceURL||"/lodash/template/source["+R+++"]")+"\n*/";try{var x=a(c,"return "+p+_).apply(r,l)}catch(e){throw e.source=p,e}return t?x(t):(x.source=p,x)},je.unescape=function(e){return null==e?"":Y(e).replace(tt,Ke)},je.uniqueId=function(e){var t=++c;return Y(null==e?"":e)+t},je.all=bt,je.any=Tt,je.detect=wt,je.findWhere=wt,je.foldl=jt,je.foldr=Pt,je.include=vt,je.inject=jt,Xt((Ut={},at(je,(function(e,t){je.prototype[t]||(Ut[t]=e)})),Ut),!1),je.first=Vt,je.last=function(e,t,n){var i=0,o=e?e.length:0;if("number"!=typeof t&&null!=t){var a=o;for(t=je.createCallback(t,n,3);a--&&t(e[a],a,e);)i++}else if(null==(i=t)||n)return e?e[o-1]:r;return te(e,ke(0,o-i))},je.sample=function(e,t,n){if(e&&"number"!=typeof e.length&&(e=mt(e)),null==t||n)return e?e[He(0,e.length-1)]:r;var i=Mt(e);return i.length=xe(ke(0,t),i.length),i},je.take=Vt,je.head=Vt,at(je,(function(e,t){var n="sample"!==t;je.prototype[t]||(je.prototype[t]=function(t,i){var o=this.__chain__,r=e(this.__wrapped__,t,i);return o||null!=t&&(!i||n&&"function"==typeof t)?new Pe(r,o):r})})),je.VERSION="2.4.2",je.prototype.chain=function(){return this.__chain__=!0,this},je.prototype.toString=function(){return Y(this.__wrapped__)},je.prototype.value=Kt,je.prototype.valueOf=Kt,Et(["join","pop","shift"],(function(e){var t=q[e];je.prototype[e]=function(){var e=this.__chain__,n=t.apply(this.__wrapped__,arguments);return e?new Pe(n,e):n}})),Et(["push","reverse","sort","unshift"],(function(e){var t=q[e];je.prototype[e]=function(){return t.apply(this.__wrapped__,arguments),this}})),Et(["concat","slice","splice"],(function(e){var t=q[e];je.prototype[e]=function(){return new Pe(t.apply(this.__wrapped__,arguments),this.__chain__)}})),je}();H._=ne,(o=function(){return ne}.call(t,n,t,e))===r||(e.exports=o)}).call(this)}).call(this,n(1)(e),n(2))},function(e,t){e.exports=function(e){return e.webpackPolyfill||(e.deprecate=function(){},e.paths=[],e.children||(e.children=[]),Object.defineProperty(e,"loaded",{enumerable:!0,get:function(){return e.l}}),Object.defineProperty(e,"id",{enumerable:!0,get:function(){return e.i}}),e.webpackPolyfill=1),e}},function(e,t){var n;n=function(){return this}();try{n=n||new Function("return this")()}catch(e){"object"==typeof window&&(n=window)}e.exports=n},function(e,t,n){"use strict";n.r(t);var i=n(0),o=n.n(i);var r=function(e){e.Binder={bind:function(t,n){return function(i,r){r.__binds||(r.__binds=[]);var a=t;o.a.isArray(i)&&(a=i[0],i=i[1]);for(var s=/^([^.:]*(?:\.[^.:]+)*)?(?:\:(.*))?$/.exec(i),c=s[1].split(/\./g),l=c.pop(),u=s[2]||l,h=c.shift(),p={this:r}[h]||n[h]||t[h]||a;p&&(i=c.shift());)p=p[i];if(p&&(p.on||p.addEventListener)){var f=function(e){r[u]&&r[u](e,t)};e.Binder._polyfill(p,["addEventListener","on"],(function(e){p[e](l,f)}));var d={target:p,name:l,callback:f};return r.__binds.push(d),f}throw"Cannot bind '"+i+"' in "+this.__name}},unbind:function(){return function(t){t.__binds&&(t.__binds.forEach(function(t){e.Binder._polyfill(t.target,["removeEventListener","off"],(function(e){t.target[e](t.name,t.callback)}))}.bind(this)),t.__binds=[])}},apply:function(t){Object.assign(t,e.EventDispatcher.prototype),t.trigger=e.Binder._trigger,t.triggerOnce=e.Binder._triggerOnce,t.on=t.addEventListener,t.off=t.removeEventListener,t.dispatchEvent=t.trigger},_triggerOnce:function(e){this.trigger(e),this._listeners&&delete this._listeners[e.type]},_trigger:function(e){if(void 0!==this._listeners){var t=e.type,n=this._listeners[t];if(void 0!==n){var i=(n=n.slice()).length;e.target=this;for(var o=0;o<i;o++)n[o].call(this,e,this)}}},_polyfill:function(e,t,n){t.map((function(t){return e.method})),t.length&&n(t[0])}}};var a=function(e){e.Api={apply:function(e){e.set=function(e){var t=this.options||{},n=o.a.reduce(e,(function(e,n,i){return t[i]!==n&&(e[i]=n),e}),{});this.options=o.a.extend(t,n),this.trigger({type:"change",options:e,changes:n})},e.get=function(){return this.options},e.api=function(e,t){return e=e||{},t&&o.a.each(e,(function(e,n,i){o.a.isFunction(e)&&(i[n]=o.a.partialRight(e,t))})),e.set=this.set.bind(this),e.get=this.get.bind(this),e}}}};var s=function(e){e.Bootstrap=function(t){if(t){var n=[].slice.apply(arguments);if(t={},n[0]instanceof Node){var i=n[0];n=n.slice(1),t.element=i}o.a.isString(n[0])&&(t.plugins=n),o.a.isArray(n[0])&&(t.plugins=n[0]),n[0]&&(t=o.a.defaults(t,n[0]))}if(!(this instanceof e.Bootstrap))return new e.Bootstrap(t);var r={init:!0,element:document.body,plugins:["core"],aliases:{},plugindb:e.Bootstrap.Plugins||{},aliasdb:e.Bootstrap.Aliases||{}};this.__options=o.a.defaults(t||{},r),this.__inited=!1,this.__destroyed=!1,this.__installed=[];var a=this.__options.element;a===""+a&&(a=document.querySelector(a)),this.plugins={},this.element=a,this.__options.init&&this.init()},e.Bootstrap.prototype={init:function(){if(!this.__inited)return this.__inited=!0,this.install(this.__options.plugins),this},destroy:function(){if(this.__inited&&!this.__destroyed)return this.__destroyed=!0,this.trigger({type:"destroy"}),this.uninstall(),this},resolve:function(e){e=o.a.isArray(e)?e:[e];var t=this.__options,n=o.a.extend({},t.aliasdb,t.aliases),i=function(e){var t=e.split(":");return!t[1]||(n[t[0]]=[t[1]],!1)};return e=o.a.filter(e,i),o.a.each(n,(function(e,t){n[t]=o.a.isArray(e)?e:[e]})),function e(t,r,a){if(a>=256)throw"Plug-in alias recursion detected.";return t=o.a.filter(t,i),o.a.each(t,(function(t){var i=n[t];i?r=r.concat(e(i,[],a+1)):r.push(t)})),r}(e,[],0)},install:function(e){e=o.a.isArray(e)?e:[e],e=this.resolve(e),o.a.each(e,this.__install,this),this.__ready()},uninstall:function(e){e&&(e=o.a.isArray(e)?e:[e],e=this.resolve(e)),o.a.eachRight(e||this.__installed,this.__uninstall,this)},__install:function(e){var t=this.__options.plugindb[e];if(!t)throw"[three.install] Cannot install. '"+e+"' is not registered.";if(this.plugins[e])return console.warn("[three.install] "+e+" is already installed.");var n=new t(this.__options[e]||{},e);this.plugins[e]=n;var i=n.install(this);return this.__installed.push(n),this.trigger({type:"install",plugin:n}),i},__uninstall:function(e,t){var n=o.a.isString(e)?this.plugins[e]:e;if(!n)return console.warn("[three.uninstall] "+e+"' is not installed.");e=n.__name,n.uninstall(this),this.__installed=o.a.without(this.__installed,n),delete this.plugins[e],this.trigger({type:"uninstall",plugin:n})},__ready:function(){this.triggerOnce({type:"ready"})}},e.Binder.apply(e.Bootstrap.prototype)};var c=function(e){e.Bootstrap.Plugins={},e.Bootstrap.Aliases={},e.Bootstrap.Plugin=function(e){this.options=o.a.defaults(e||{},this.defaults)},e.Bootstrap.Plugin.prototype={listen:[],defaults:{},install:function(e){},uninstall:function(e){}},e.Binder.apply(e.Bootstrap.Plugin.prototype),e.Api.apply(e.Bootstrap.Plugin.prototype),e.Bootstrap.registerPlugin=function(t,n){var i=function(n){e.Bootstrap.Plugin.call(this,n),this.__name=t};i.prototype=o.a.extend(new e.Bootstrap.Plugin,n),e.Bootstrap.Plugins[t]=i},e.Bootstrap.unregisterPlugin=function(t){delete e.Bootstrap.Plugins[t]},e.Bootstrap.registerAlias=function(t,n){e.Bootstrap.Aliases[t]=n},e.Bootstrap.unregisterAlias=function(t){delete e.Bootstrap.Aliases[t]}};var l=function(e){e.Bootstrap.registerAlias("empty",["fallback","bind","renderer","size","fill","loop","time"]),e.Bootstrap.registerAlias("core",["empty","scene","camera","render","warmup"]),e.Bootstrap.registerAlias("VR",["core","cursor","fullscreen","render:vr"])};var u=function(e){[r,a,s,c,l].forEach(t=>t(e))},h=function(e){e.Bootstrap.registerPlugin("fallback",{defaults:{force:!1,fill:!0,begin:'<div class="threestrap-fallback" style="display: table; width: 100%; height: 100%;box-sizing: border-box; border: 1px dashed rgba(0, 0, 0, .25);"><div style="display: table-cell; padding: 10px; vertical-align: middle; text-align: center;">',end:"</div></div>",message:'<big><strong>This example requires WebGL</strong></big><br>Visit <a target="_blank" href="http://get.webgl.org/">get.webgl.org</a> for more info</a>'},install:function(e){var t;try{if(!((t=document.createElement("canvas")).getContext("webgl")||t.getContext("experimental-webgl"))||this.options.force)throw"WebGL unavailable.";e.fallback=!1}catch(t){var n=this.options.message,i=this.options.begin,o=this.options.end,r=this.options.fill,a=document.createElement("div");for(a.innerHTML=i+n+o,this.children=[];a.childNodes.length>0;)this.children.push(a.firstChild),e.element.appendChild(a.firstChild);return r&&e.install("fill"),this.div=a,e.fallback=!0,!1}},uninstall:function(e){this.children&&(this.children.forEach((function(e){e.parentNode.removeChild(e)})),this.children=null),delete e.fallback}})},p=function(e){e.Bootstrap.registerPlugin("renderer",{defaults:{klass:e.WebGLRenderer,parameters:{depth:!0,stencil:!0,preserveDrawingBuffer:!0,antialias:!0}},listen:["resize"],install:function(e){var t=e.renderer=new this.options.klass(this.options.parameters);e.canvas=t.domElement,e.element.appendChild(t.domElement)},uninstall:function(e){e.element.removeChild(e.renderer.domElement),delete e.renderer,delete e.canvas},resize:function(e,t){var n=t.renderer,i=n.domElement;i&&"CANVAS"==i.tagName?n.setSize(e.renderWidth,e.renderHeight,!1):(n.setRenderSize&&n.setRenderSize(e.renderWidth,e.renderHeight),n.setSize(e.viewWidth,e.viewHeight,!1))}})},f=function(e){e.Bootstrap.registerPlugin("bind",{install:function(t){var n={three:t,window:window};t.bind=e.Binder.bind(t,n),t.unbind=e.Binder.unbind(t),t.bind("install:bind",this),t.bind("uninstall:unbind",this)},uninstall:function(e){e.unbind(this),delete e.bind,delete e.unbind},bind:function(e,t){var n=e.plugin,i=n.listen;i&&i.forEach((function(e){t.bind(e,n)}))},unbind:function(e,t){t.unbind(e.plugin)}})},d=function(e){e.Bootstrap.registerPlugin("size",{defaults:{width:null,height:null,aspect:null,scale:1,maxRenderWidth:1/0,maxRenderHeight:1/0,devicePixelRatio:!0},listen:["window.resize:queue","element.resize:queue","this.change:queue","ready:resize","pre:pre"],install:function(e){e.Size=this.api({renderWidth:0,renderHeight:0,viewWidth:0,viewHeight:0}),this.resized=!1},uninstall:function(e){delete e.Size},queue:function(e,t){this.resized=!0},pre:function(e,t){this.resized&&(this.resized=!1,this.resize(e,t))},resize:function(e,t){var n,i,r,a,s,c,l,u,h,p=this.options,f=t.element,d=t.renderer,m=0,v=0;l=(n=r=void 0===p.width||null==p.width?f.offsetWidth||f.innerWidth||0:p.width)/(i=a=void 0===p.height||null==p.height?f.offsetHeight||f.innerHeight||0:p.height),p.aspect&&(p.aspect>l?(i=Math.round(n/p.aspect),v=Math.floor((a-i)/2)):(n=Math.round(i*p.aspect),m=Math.floor((r-n)/2)),l=n/i),h=1,p.devicePixelRatio&&"undefined"!=typeof window&&(h=window.devicePixelRatio||1),(s=Math.round(Math.min(n*h*p.scale,p.maxRenderWidth)))/(c=Math.round(Math.min(i*h*p.scale,p.maxRenderHeight)))>l?s=Math.round(c*l):c=Math.round(s/l),h=c/i,(u=d.domElement.style).width=n+"px",u.height=i+"px",u.marginLeft=m+"px",u.marginTop=v+"px",o.a.extend(t.Size,{renderWidth:s,renderHeight:c,viewWidth:n,viewHeight:i,aspect:l,pixelRatio:h}),t.trigger({type:"resize",renderWidth:s,renderHeight:c,viewWidth:n,viewHeight:i,aspect:l,pixelRatio:h})}})},m=function(e){e.Bootstrap.registerPlugin("fill",{defaults:{block:!0,body:!0,layout:!0},install:function(e){(this.options.body&&e.element==document.body&&(this.applied=[e.element,document.documentElement].filter((function(e){var t=e.style.height;return"auto"==t||""==t})).map((function(e){return e.style.height="100%",e.style.margin=0,e.style.padding=0,e}))),this.options.block&&e.canvas&&(e.canvas.style.display="block",this.block=!0),this.options.layout&&e.element)&&("static"==window.getComputedStyle(e.element).position&&(e.element.style.position="relative",this.layout=!0))},uninstall:function(e){if(this.applied){this.applied.map((function(e){return e.style.height="",e.style.margin="",e.style.padding="",e})),delete this.applied}this.block&&e.canvas&&(e.canvas.style.display="",delete this.block),this.layout&&e.element&&(e.element.style.position="",delete this.layout)},change:function(e){this.uninstall(e),this.install(e)}})},v=function(e){e.Bootstrap.registerPlugin("loop",{defaults:{start:!0},listen:["ready"],install:function(e){this.running=!1,this.lastRequestId=null,e.Loop=this.api({start:this.start.bind(this),stop:this.stop.bind(this),running:!1,window:window},e),this.events=["pre","update","render","post"].map((function(e){return{type:e}}))},uninstall:function(e){this.stop(e)},ready:function(e,t){this.options.start&&this.start(t)},start:function(e){if(!this.running){e.Loop.running=this.running=!0;var t=e.trigger.bind(e),n=function(){this.running&&(this.lastRequestId=e.Loop.window.requestAnimationFrame(n),this.events.map(t))}.bind(this);this.lastRequestId=e.Loop.window.requestAnimationFrame(n),e.trigger({type:"start"})}},stop:function(e){this.running&&(e.Loop.running=this.running=!1,e.Loop.window.cancelAnimationFrame(this.lastRequestId),this.lastRequestId=null,e.trigger({type:"stop"}))}})},g=function(e){e.Bootstrap.registerPlugin("time",{defaults:{speed:1,warmup:0,timeout:1},listen:["pre:tick","this.change"],now:function(){return+new Date/1e3},install:function(e){e.Time=this.api({now:this.now(),clock:0,step:1/60,frames:0,time:0,delta:1/60,average:0,fps:0}),this.last=0,this.time=0,this.clock=0,this.wait=this.options.warmup,this.clockStart=0,this.timeStart=0},tick:function(e,t){var n=this.options.speed,i=this.options.timeout,o=t.Time,r=o.now=this.now(),a=this.last,s=this.time,c=this.clock;if(a){var l=o.delta=r-a,u=o.average||l;l>i&&(l=0);var h=l*n;s+=l,c+=h,o.frames>0&&(o.average=u+.1*(l-u),o.fps=1/u),o.step=h,o.clock=c-this.clockStart,o.time=s-this.timeStart,o.frames++,this.wait-- >0&&(this.clockStart=c,this.timeStart=s,o.clock=0,o.step=1e-100)}this.last=r,this.clock=c,this.time=s},uninstall:function(e){delete e.Time}})},b=function(e){e.Bootstrap.registerPlugin("scene",{install:function(t){t.scene=new e.Scene},uninstall:function(e){delete e.scene}})},y=function(e){e.Bootstrap.registerPlugin("camera",{defaults:{near:.01,far:1e4,type:"perspective",fov:60,aspect:null,left:-1,right:1,bottom:-1,top:1,klass:null,parameters:null},listen:["resize","this.change"],install:function(e){e.Camera=this.api(),e.camera=null,this.aspect=1,this.change({},e)},uninstall:function(e){delete e.Camera,delete e.camera},change:function(t,n){var i=this.options,r=n.camera;if(!n.camera||t.changes.type||t.changes.klass){var a=i.klass||{perspective:e.PerspectiveCamera,orthographic:e.OrthographicCamera}[i.type]||e.Camera;n.camera=i.parameters?new a(i.parameters):new a}o.a.each(i,function(e,t){n.camera.hasOwnProperty(t)&&(n.camera[t]=i[t])}.bind(this)),this.update(n),r===n.camera||n.trigger({type:"camera",camera:n.camera})},resize:function(e,t){this.aspect=e.viewWidth/Math.max(1,e.viewHeight),this.update(t)},update:function(e){e.camera.aspect=this.options.aspect||this.aspect,e.camera.updateProjectionMatrix()}})},w=function(e){e.Bootstrap.registerPlugin("render",{listen:["render"],render:function(e,t){t.scene&&t.camera&&t.renderer.render(t.scene,t.camera)}})},E=function(e){e.Bootstrap.registerPlugin("warmup",{defaults:{delay:2},listen:["ready","post"],ready:function(e,t){t.renderer.domElement.style.visibility="hidden",this.frame=0,this.hidden=!0},post:function(e,t){this.hidden&&this.frame>=this.options.delay&&(t.renderer.domElement.style.visibility="visible",this.hidden=!1),this.frame++}})};var _=function(e){[h,p,f,d,m,v,g,b,y,w,E].forEach(t=>t(e))},k=function(e){e.Bootstrap.registerPlugin("stats",{listen:["pre","post"],install:function(t){var n=this.stats=new e.Stats,i=n.domElement.style;i.position="absolute",i.top=i.left=0,t.element.appendChild(n.domElement),t.stats=n},uninstall:function(e){document.body.removeChild(this.stats.domElement),delete e.stats},pre:function(e,t){this.stats.begin()},post:function(e,t){this.stats.end()}})},x=function(e){e.Bootstrap.registerPlugin("controls",{listen:["update","resize","camera","this.change"],defaults:{klass:null,parameters:{}},install:function(t){if(!this.options.klass)throw"Must provide class for `controls.klass`";t.controls=null,this._camera=t.camera||new e.PerspectiveCamera,this.change(null,t)},uninstall:function(e){delete e.controls},change:function(e,t){this.options.klass?(e&&!e.changes.klass||(t.controls=new this.options.klass(this._camera,t.renderer.domElement)),o.a.extend(t.controls,this.options.parameters)):t.controls=null},update:function(e,t){var n=t.Time&&t.Time.delta||1/60,i=t.VR&&t.VR.state;t.controls.vr&&t.controls.vr(i),t.controls.update(n)},camera:function(e,t){t.controls.object=this._camera=e.camera},resize:function(e,t){t.controls.handleResize&&t.controls.handleResize()}})},R=function(e){e.Bootstrap.registerPlugin("cursor",{listen:["update","this.change","install:change","uninstall:change","element.mousemove","vr"],defaults:{cursor:null,hide:!1,timeout:3},install:function(e){this.timeout=this.options.timeout,this.element=e.element,this.change(null,e)},uninstall:function(e){delete e.controls},change:function(e,t){this.applyCursor(t)},mousemove:function(e,t){this.options.hide&&(this.applyCursor(t),this.timeout=+this.options.timeout||0)},update:function(e,t){var n=t.Time&&t.Time.delta||1/60;this.options.hide&&(this.timeout-=n,this.timeout<0&&this.applyCursor(t,"none"))},vr:function(e,t){this.hide=e.active&&!e.hmd.fake,this.applyCursor(t)},applyCursor:function(e,t){var n=e.controls?"move":"";t=t||this.options.cursor||n,this.hide&&(t="none"),this.cursor!=t&&(this.element.style.cursor=t)}})},O=function(e){e.Bootstrap.registerPlugin("fullscreen",{defaults:{key:"f"},listen:["ready","update"],install:function(e){e.Fullscreen=this.api({active:!1,toggle:this.toggle.bind(this)},e)},uninstall:function(e){delete e.Fullscreen},ready:function(e,t){document.body.addEventListener("keypress",function(e){this.options.key&&e.charCode==this.options.key.charCodeAt(0)&&this.toggle(t)}.bind(this));var n=function(){var e=!!(document.fullscreenElement||document.mozFullScreenElement||document.webkitFullscreenElement||document.msFullscreenElement);t.Fullscreen.active=this.active=e,t.trigger({type:"fullscreen",active:e})}.bind(this);document.addEventListener("fullscreenchange",n,!1),document.addEventListener("webkitfullscreenchange",n,!1),document.addEventListener("mozfullscreenchange",n,!1)},toggle:function(e){var t=e.canvas,n=e.VR&&e.VR.active?{vrDisplay:e.VR.hmd}:{};this.active?document.exitFullscreen?document.exitFullscreen():document.msExitFullscreen?document.msExitFullscreen():document.webkitExitFullscreen?document.webkitExitFullscreen():document.mozCancelFullScreen&&document.mozCancelFullScreen():t.requestFullScreen?t.requestFullScreen(n):t.msRequestFullScreen?t.msRequestFullscreen(n):t.webkitRequestFullscreen?t.webkitRequestFullscreen(n):t.mozRequestFullScreen&&t.mozRequestFullScreen(n)}})},C=function(e){e.Bootstrap.registerPlugin("vr",{defaults:{mode:"auto",device:null,fov:80},listen:["window.load","pre","render","resize","this.change"],install:function(e){e.VR=this.api({active:!1,devices:[],hmd:null,sensor:null,renderer:null,state:null},e)},uninstall:function(e){delete e.VR},mocks:function(e,t,n){return[{fake:!0,force:1,deviceId:"emu",deviceName:"Emulated",getEyeTranslation:function(e){return{left:{x:-.03,y:0,z:0},right:{x:.03,y:0,z:0}}[e]},getRecommendedEyeFieldOfView:function(i){var o=e.camera,r=o&&o.aspect||16/9,a=(t||o&&o.fov||n)/2,s=180*Math.atan(Math.tan(a*Math.PI/180)*r/2)/Math.PI;return{left:{rightDegrees:s,leftDegrees:s,downDegrees:a,upDegrees:a},right:{rightDegrees:s,leftDegrees:s,downDegrees:a,upDegrees:a}}[i]}},{force:2,getState:function(){return{}}}]},load:function(e,t){var n=function(e){this.callback(e,t)}.bind(this);navigator.getVRDevices?navigator.getVRDevices().then(n):navigator.mozGetVRDevices?navigator.mozGetVRDevices(n):(console.warn("No native VR support detected."),n(this.mocks(t,this.options.fov,this.defaults.fov),t))},callback:function(e,t){var n,i,o=window.HMDVRDevice||function(){},r=window.PositionSensorVRDevice||function(){};e=t.VR.devices=e||t.VR.devices;for(var a=this.options.device,s=0;s<e.length;++s){if(1==(c=e[s]).force||c instanceof o){if(a&&a!=c.deviceId)continue;n=c;break}}if(n){for(s=0;s<e.length;++s){var c;if(2==(c=e[s]).force||c instanceof r&&c.hardwareUnitId==n.hardwareUnitId){i=c;break}}this.hookup(n,i,t)}},hookup:function(t,n,i){e.VRRenderer||console.log("THREE.VRRenderer not found");var o=e.VRRenderer||function(){};this.renderer=new o(i.renderer,t),this.hmd=t,this.sensor=n,i.VR.renderer=this.renderer,i.VR.hmd=t,i.VR.sensor=n,console.log("THREE.VRRenderer",t.deviceName)},change:function(e,t){e.changes.device&&this.callback(null,t),this.pre(e,t)},pre:function(e,t){var n=this.active,i=this.active=this.renderer&&"2d"!=this.options.mode;if(t.VR.active=i,i&&this.sensor){var o=this.sensor.getState();t.VR.state=o}else t.VR.state=null;n!=this.active&&t.trigger({type:"vr",active:i,hmd:this.hmd,sensor:this.sensor})},resize:function(e,t){this.active&&this.renderer.initialize()},render:function(e,t){if(t.scene&&t.camera){var n=this.active?this.renderer:t.renderer;if(this.last!=n&&n==t.renderer){var i=n.getPixelRatio(),o=n.domElement.width/i,r=n.domElement.height/i;n.enableScissorTest(!1),n.setViewport(0,0,o,r)}this.last=n,n.render(t.scene,t.camera)}}})},j=function(e){e.Bootstrap.registerPlugin("ui",{defaults:{theme:"white",style:".threestrap-ui { position: absolute; bottom: 5px; right: 5px; float: left; }.threestrap-ui button { border: 0; background: none;  vertical-align: middle; font-weight: bold; } .threestrap-ui .glyphicon { top: 2px; font-weight: bold; } @media (max-width: 640px) { .threestrap-ui button { font-size: 120% } }.threestrap-white button { color: #fff; text-shadow: 0 1px 1px rgba(0, 0, 0, 1), 0 1px 3px rgba(0, 0, 0, 1); }.threestrap-black button { color: #000; text-shadow: 0 0px 1px rgba(255, 255, 255, 1), 0 0px 2px rgba(255, 255, 255, 1), 0 0px 2px rgba(255, 255, 255, 1) }"},listen:["fullscreen"],markup:function(e,t,n){var i="//netdna.bootstrapcdn.com/bootstrap/3.0.0/css/bootstrap-glyphicons.css";location.href.match(/^file:\/\//)&&(i="http://"+i);var o=[];return e.Fullscreen&&o.push('<button class="fullscreen" title="Full Screen"><span class="glyphicon glyphicon-fullscreen"></span></button>'),e.VR&&o.push('<button class="vr" title="VR Headset">VR</button>'),'<style type="text/css">@import url("'+i+'"); '+n+'</style><div class="threestrap-ui threestrap-'+t+'">'+o.join("\n")+"</div>"},install:function(e){var t=this.ui=document.createElement("div");t.innerHTML=this.markup(e,this.options.theme,this.options.style),document.body.appendChild(t);var n=this.ui.fullscreen=t.querySelector("button.fullscreen");n&&e.bind([n,"click:goFullscreen"],this);var i=this.ui.vr=t.querySelector("button.vr");i&&e.VR&&(e.VR.set({mode:"2d"}),e.bind([i,"click:goVR"],this))},uninstall:function(e){document.body.removeChild(ui)},fullscreen:function(e,t){this.ui.style.display=e.active?"none":"block",e.active||t.VR&&t.VR.set({mode:"2d"})},goFullscreen:function(e,t){t.Fullscreen&&t.Fullscreen.toggle()},goVR:function(e,t){t.VR&&(t.VR.set({mode:"auto"}),t.Fullscreen.toggle())},uninstall:function(e){document.body.removeChild(this.ui)}})},P=function(e){e.DeviceOrientationControls=function(t){var n=this;this.object=t,this.object.rotation.reorder("YXZ"),this.enabled=!0,this.deviceOrientation={},this.screenOrientation=0,this.alpha=0,this.alphaOffsetAngle=0;var i,o,r,a,s=function(e){n.deviceOrientation=e},c=function(){n.screenOrientation=window.orientation||0},l=(i=new e.Vector3(0,0,1),o=new e.Euler,r=new e.Quaternion,a=new e.Quaternion(-Math.sqrt(.5),0,0,Math.sqrt(.5)),function(e,t,n,s,c){o.set(n,t,-s,"YXZ"),e.setFromEuler(o),e.multiply(a),e.multiply(r.setFromAxisAngle(i,-c))});this.connect=function(){c(),window.addEventListener("orientationchange",c,!1),window.addEventListener("deviceorientation",s,!1),n.enabled=!0},this.disconnect=function(){window.removeEventListener("orientationchange",c,!1),window.removeEventListener("deviceorientation",s,!1),n.enabled=!1},this.update=function(){if(!1!==n.enabled){var t=n.deviceOrientation.alpha?e.Math.degToRad(n.deviceOrientation.alpha)+this.alphaOffsetAngle:0,i=n.deviceOrientation.beta?e.Math.degToRad(n.deviceOrientation.beta):0,o=n.deviceOrientation.gamma?e.Math.degToRad(n.deviceOrientation.gamma):0,r=n.screenOrientation?e.Math.degToRad(n.screenOrientation):0;l(n.object.quaternion,t,i,o,r),this.alpha=t}},this.updateAlphaOffsetAngle=function(e){this.alphaOffsetAngle=e,this.update()},this.dispose=function(){this.disconnect()},this.connect()}},M=function(e){e.FirstPersonControls=function(t,n){function i(e){e.preventDefault()}this.object=t,this.target=new e.Vector3(0,0,0),this.domElement=void 0!==n?n:document,this.enabled=!0,this.movementSpeed=1,this.lookSpeed=.005,this.lookVertical=!0,this.autoForward=!1,this.activeLook=!0,this.heightSpeed=!1,this.heightCoef=1,this.heightMin=0,this.heightMax=1,this.constrainVertical=!1,this.verticalMin=0,this.verticalMax=Math.PI,this.autoSpeedFactor=0,this.mouseX=0,this.mouseY=0,this.lat=0,this.lon=0,this.phi=0,this.theta=0,this.moveForward=!1,this.moveBackward=!1,this.moveLeft=!1,this.moveRight=!1,this.mouseDragOn=!1,this.viewHalfX=0,this.viewHalfY=0,this.domElement!==document&&this.domElement.setAttribute("tabindex",-1),this.handleResize=function(){this.domElement===document?(this.viewHalfX=window.innerWidth/2,this.viewHalfY=window.innerHeight/2):(this.viewHalfX=this.domElement.offsetWidth/2,this.viewHalfY=this.domElement.offsetHeight/2)},this.onMouseDown=function(e){if(this.domElement!==document&&this.domElement.focus(),e.preventDefault(),e.stopPropagation(),this.activeLook)switch(e.button){case 0:this.moveForward=!0;break;case 2:this.moveBackward=!0}this.mouseDragOn=!0},this.onMouseUp=function(e){if(e.preventDefault(),e.stopPropagation(),this.activeLook)switch(e.button){case 0:this.moveForward=!1;break;case 2:this.moveBackward=!1}this.mouseDragOn=!1},this.onMouseMove=function(e){this.domElement===document?(this.mouseX=e.pageX-this.viewHalfX,this.mouseY=e.pageY-this.viewHalfY):(this.mouseX=e.pageX-this.domElement.offsetLeft-this.viewHalfX,this.mouseY=e.pageY-this.domElement.offsetTop-this.viewHalfY)},this.onKeyDown=function(e){switch(e.keyCode){case 38:case 87:this.moveForward=!0;break;case 37:case 65:this.moveLeft=!0;break;case 40:case 83:this.moveBackward=!0;break;case 39:case 68:this.moveRight=!0;break;case 82:this.moveUp=!0;break;case 70:this.moveDown=!0}},this.onKeyUp=function(e){switch(e.keyCode){case 38:case 87:this.moveForward=!1;break;case 37:case 65:this.moveLeft=!1;break;case 40:case 83:this.moveBackward=!1;break;case 39:case 68:this.moveRight=!1;break;case 82:this.moveUp=!1;break;case 70:this.moveDown=!1}},this.update=function(t){if(!1!==this.enabled){if(this.heightSpeed){var n=e.Math.clamp(this.object.position.y,this.heightMin,this.heightMax)-this.heightMin;this.autoSpeedFactor=t*(n*this.heightCoef)}else this.autoSpeedFactor=0;var i=t*this.movementSpeed;(this.moveForward||this.autoForward&&!this.moveBackward)&&this.object.translateZ(-(i+this.autoSpeedFactor)),this.moveBackward&&this.object.translateZ(i),this.moveLeft&&this.object.translateX(-i),this.moveRight&&this.object.translateX(i),this.moveUp&&this.object.translateY(i),this.moveDown&&this.object.translateY(-i);var o=t*this.lookSpeed;this.activeLook||(o=0);var r=1;this.constrainVertical&&(r=Math.PI/(this.verticalMax-this.verticalMin)),this.lon+=this.mouseX*o,this.lookVertical&&(this.lat-=this.mouseY*o*r),this.lat=Math.max(-85,Math.min(85,this.lat)),this.phi=e.Math.degToRad(90-this.lat),this.theta=e.Math.degToRad(this.lon),this.constrainVertical&&(this.phi=e.Math.mapLinear(this.phi,0,Math.PI,this.verticalMin,this.verticalMax));var a=this.target,s=this.object.position;a.x=s.x+100*Math.sin(this.phi)*Math.cos(this.theta),a.y=s.y+100*Math.cos(this.phi),a.z=s.z+100*Math.sin(this.phi)*Math.sin(this.theta),this.object.lookAt(a)}},this.dispose=function(){this.domElement.removeEventListener("contextmenu",i,!1),this.domElement.removeEventListener("mousedown",r,!1),this.domElement.removeEventListener("mousemove",o,!1),this.domElement.removeEventListener("mouseup",a,!1),window.removeEventListener("keydown",s,!1),window.removeEventListener("keyup",c,!1)};var o=l(this,this.onMouseMove),r=l(this,this.onMouseDown),a=l(this,this.onMouseUp),s=l(this,this.onKeyDown),c=l(this,this.onKeyUp);function l(e,t){return function(){t.apply(e,arguments)}}this.domElement.addEventListener("contextmenu",i,!1),this.domElement.addEventListener("mousemove",o,!1),this.domElement.addEventListener("mousedown",r,!1),this.domElement.addEventListener("mouseup",a,!1),window.addEventListener("keydown",s,!1),window.addEventListener("keyup",c,!1),this.handleResize()}},T=function(e){e.OrbitControls=function(t,n){var i,o,r,a,s;this.object=t,this.domElement=void 0!==n?n:document,this.enabled=!0,this.target=new e.Vector3,this.minDistance=0,this.maxDistance=1/0,this.minZoom=0,this.maxZoom=1/0,this.minPolarAngle=0,this.maxPolarAngle=Math.PI,this.minAzimuthAngle=-1/0,this.maxAzimuthAngle=1/0,this.enableDamping=!1,this.dampingFactor=.25,this.enableZoom=!0,this.zoomSpeed=1,this.enableRotate=!0,this.rotateSpeed=1,this.enablePan=!0,this.keyPanSpeed=7,this.autoRotate=!1,this.autoRotateSpeed=2,this.enableKeys=!0,this.keys={LEFT:37,UP:38,RIGHT:39,BOTTOM:40},this.mouseButtons={ORBIT:e.MOUSE.LEFT,ZOOM:e.MOUSE.MIDDLE,PAN:e.MOUSE.RIGHT},this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.zoom0=this.object.zoom,this.getPolarAngle=function(){return m.phi},this.getAzimuthalAngle=function(){return m.theta},this.reset=function(){c.target.copy(c.target0),c.object.position.copy(c.position0),c.object.zoom=c.zoom0,c.object.updateProjectionMatrix(),c.dispatchEvent(l),c.update(),f=p.NONE},this.update=(i=new e.Vector3,o=(new e.Quaternion).setFromUnitVectors(t.up,new e.Vector3(0,1,0)),r=o.clone().inverse(),a=new e.Vector3,s=new e.Quaternion,function(){var e=c.object.position;return i.copy(e).sub(c.target),i.applyQuaternion(o),m.setFromVector3(i),c.autoRotate&&f===p.NONE&&M(2*Math.PI/60/60*c.autoRotateSpeed),m.theta+=v.theta,m.phi+=v.phi,m.theta=Math.max(c.minAzimuthAngle,Math.min(c.maxAzimuthAngle,m.theta)),m.phi=Math.max(c.minPolarAngle,Math.min(c.maxPolarAngle,m.phi)),m.makeSafe(),m.radius*=g,m.radius=Math.max(c.minDistance,Math.min(c.maxDistance,m.radius)),c.target.add(b),i.setFromSpherical(m),i.applyQuaternion(r),e.copy(c.target).add(i),c.object.lookAt(c.target),!0===c.enableDamping?(v.theta*=1-c.dampingFactor,v.phi*=1-c.dampingFactor):v.set(0,0,0),g=1,b.set(0,0,0),!!(y||a.distanceToSquared(c.object.position)>d||8*(1-s.dot(c.object.quaternion))>d)&&(c.dispatchEvent(l),a.copy(c.object.position),s.copy(c.object.quaternion),y=!1,!0)}),this.dispose=function(){c.domElement.removeEventListener("contextmenu",q,!1),c.domElement.removeEventListener("mousedown",N,!1),c.domElement.removeEventListener("wheel",B,!1),c.domElement.removeEventListener("touchstart",X,!1),c.domElement.removeEventListener("touchend",U,!1),c.domElement.removeEventListener("touchmove",I,!1),document.removeEventListener("mousemove",z,!1),document.removeEventListener("mouseup",H,!1),window.removeEventListener("keydown",Y,!1)};var c=this,l={type:"change"},u={type:"start"},h={type:"end"},p={NONE:-1,ROTATE:0,DOLLY:1,PAN:2,TOUCH_ROTATE:3,TOUCH_DOLLY:4,TOUCH_PAN:5},f=p.NONE,d=1e-6,m=new e.Spherical,v=new e.Spherical,g=1,b=new e.Vector3,y=!1,w=new e.Vector2,E=new e.Vector2,_=new e.Vector2,k=new e.Vector2,x=new e.Vector2,R=new e.Vector2,O=new e.Vector2,C=new e.Vector2,j=new e.Vector2;function P(){return Math.pow(.95,c.zoomSpeed)}function M(e){v.theta-=e}function T(e){v.phi-=e}var L,V=(L=new e.Vector3,function(e,t){L.setFromMatrixColumn(t,0),L.multiplyScalar(-e),b.add(L)}),S=function(){var t=new e.Vector3;return function(e,n){t.setFromMatrixColumn(n,1),t.multiplyScalar(e),b.add(t)}}(),D=function(){var t=new e.Vector3;return function(n,i){var o=c.domElement===document?c.domElement.body:c.domElement;if(c.object instanceof e.PerspectiveCamera){var r=c.object.position;t.copy(r).sub(c.target);var a=t.length();a*=Math.tan(c.object.fov/2*Math.PI/180),V(2*n*a/o.clientHeight,c.object.matrix),S(2*i*a/o.clientHeight,c.object.matrix)}else c.object instanceof e.OrthographicCamera?(V(n*(c.object.right-c.object.left)/c.object.zoom/o.clientWidth,c.object.matrix),S(i*(c.object.top-c.object.bottom)/c.object.zoom/o.clientHeight,c.object.matrix)):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - pan disabled."),c.enablePan=!1)}}();function A(t){c.object instanceof e.PerspectiveCamera?g/=t:c.object instanceof e.OrthographicCamera?(c.object.zoom=Math.max(c.minZoom,Math.min(c.maxZoom,c.object.zoom*t)),c.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),c.enableZoom=!1)}function F(t){c.object instanceof e.PerspectiveCamera?g*=t:c.object instanceof e.OrthographicCamera?(c.object.zoom=Math.max(c.minZoom,Math.min(c.maxZoom,c.object.zoom/t)),c.object.updateProjectionMatrix(),y=!0):(console.warn("WARNING: OrbitControls.js encountered an unknown camera type - dolly/zoom disabled."),c.enableZoom=!1)}function N(e){if(!1!==c.enabled){if(e.preventDefault(),e.button===c.mouseButtons.ORBIT){if(!1===c.enableRotate)return;!function(e){w.set(e.clientX,e.clientY)}(e),f=p.ROTATE}else if(e.button===c.mouseButtons.ZOOM){if(!1===c.enableZoom)return;!function(e){O.set(e.clientX,e.clientY)}(e),f=p.DOLLY}else if(e.button===c.mouseButtons.PAN){if(!1===c.enablePan)return;!function(e){k.set(e.clientX,e.clientY)}(e),f=p.PAN}f!==p.NONE&&(document.addEventListener("mousemove",z,!1),document.addEventListener("mouseup",H,!1),c.dispatchEvent(u))}}function z(e){if(!1!==c.enabled)if(e.preventDefault(),f===p.ROTATE){if(!1===c.enableRotate)return;!function(e){E.set(e.clientX,e.clientY),_.subVectors(E,w);var t=c.domElement===document?c.domElement.body:c.domElement;M(2*Math.PI*_.x/t.clientWidth*c.rotateSpeed),T(2*Math.PI*_.y/t.clientHeight*c.rotateSpeed),w.copy(E),c.update()}(e)}else if(f===p.DOLLY){if(!1===c.enableZoom)return;!function(e){C.set(e.clientX,e.clientY),j.subVectors(C,O),j.y>0?A(P()):j.y<0&&F(P()),O.copy(C),c.update()}(e)}else if(f===p.PAN){if(!1===c.enablePan)return;!function(e){x.set(e.clientX,e.clientY),R.subVectors(x,k),D(R.x,R.y),k.copy(x),c.update()}(e)}}function H(e){!1!==c.enabled&&(document.removeEventListener("mousemove",z,!1),document.removeEventListener("mouseup",H,!1),c.dispatchEvent(h),f=p.NONE)}function B(e){!1===c.enabled||!1===c.enableZoom||f!==p.NONE&&f!==p.ROTATE||(e.preventDefault(),e.stopPropagation(),function(e){e.deltaY<0?F(P()):e.deltaY>0&&A(P()),c.update()}(e),c.dispatchEvent(u),c.dispatchEvent(h))}function Y(e){!1!==c.enabled&&!1!==c.enableKeys&&!1!==c.enablePan&&function(e){switch(e.keyCode){case c.keys.UP:D(0,c.keyPanSpeed),c.update();break;case c.keys.BOTTOM:D(0,-c.keyPanSpeed),c.update();break;case c.keys.LEFT:D(c.keyPanSpeed,0),c.update();break;case c.keys.RIGHT:D(-c.keyPanSpeed,0),c.update()}}(e)}function X(e){if(!1!==c.enabled){switch(e.touches.length){case 1:if(!1===c.enableRotate)return;!function(e){w.set(e.touches[0].pageX,e.touches[0].pageY)}(e),f=p.TOUCH_ROTATE;break;case 2:if(!1===c.enableZoom)return;!function(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+n*n);O.set(0,i)}(e),f=p.TOUCH_DOLLY;break;case 3:if(!1===c.enablePan)return;!function(e){k.set(e.touches[0].pageX,e.touches[0].pageY)}(e),f=p.TOUCH_PAN;break;default:f=p.NONE}f!==p.NONE&&c.dispatchEvent(u)}}function I(e){if(!1!==c.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:if(!1===c.enableRotate)return;if(f!==p.TOUCH_ROTATE)return;!function(e){E.set(e.touches[0].pageX,e.touches[0].pageY),_.subVectors(E,w);var t=c.domElement===document?c.domElement.body:c.domElement;M(2*Math.PI*_.x/t.clientWidth*c.rotateSpeed),T(2*Math.PI*_.y/t.clientHeight*c.rotateSpeed),w.copy(E),c.update()}(e);break;case 2:if(!1===c.enableZoom)return;if(f!==p.TOUCH_DOLLY)return;!function(e){var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY,i=Math.sqrt(t*t+n*n);C.set(0,i),j.subVectors(C,O),j.y>0?F(P()):j.y<0&&A(P()),O.copy(C),c.update()}(e);break;case 3:if(!1===c.enablePan)return;if(f!==p.TOUCH_PAN)return;!function(e){x.set(e.touches[0].pageX,e.touches[0].pageY),R.subVectors(x,k),D(R.x,R.y),k.copy(x),c.update()}(e);break;default:f=p.NONE}}function U(e){!1!==c.enabled&&(c.dispatchEvent(h),f=p.NONE)}function q(e){e.preventDefault()}c.domElement.addEventListener("contextmenu",q,!1),c.domElement.addEventListener("mousedown",N,!1),c.domElement.addEventListener("wheel",B,!1),c.domElement.addEventListener("touchstart",X,!1),c.domElement.addEventListener("touchend",U,!1),c.domElement.addEventListener("touchmove",I,!1),window.addEventListener("keydown",Y,!1),this.update()},e.OrbitControls.prototype=Object.create(e.EventDispatcher.prototype),e.OrbitControls.prototype.constructor=e.OrbitControls,Object.defineProperties(e.OrbitControls.prototype,{center:{get:function(){return console.warn("THREE.OrbitControls: .center has been renamed to .target"),this.target}},noZoom:{get:function(){return console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),!this.enableZoom},set:function(e){console.warn("THREE.OrbitControls: .noZoom has been deprecated. Use .enableZoom instead."),this.enableZoom=!e}},noRotate:{get:function(){return console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),!this.enableRotate},set:function(e){console.warn("THREE.OrbitControls: .noRotate has been deprecated. Use .enableRotate instead."),this.enableRotate=!e}},noPan:{get:function(){return console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),!this.enablePan},set:function(e){console.warn("THREE.OrbitControls: .noPan has been deprecated. Use .enablePan instead."),this.enablePan=!e}},noKeys:{get:function(){return console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),!this.enableKeys},set:function(e){console.warn("THREE.OrbitControls: .noKeys has been deprecated. Use .enableKeys instead."),this.enableKeys=!e}},staticMoving:{get:function(){return console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),!this.enableDamping},set:function(e){console.warn("THREE.OrbitControls: .staticMoving has been deprecated. Use .enableDamping instead."),this.enableDamping=!e}},dynamicDampingFactor:{get:function(){return console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor},set:function(e){console.warn("THREE.OrbitControls: .dynamicDampingFactor has been renamed. Use .dampingFactor instead."),this.dampingFactor=e}}})},L=function(e){e.TrackballControls=function(t,n){var i=this,o={NONE:-1,ROTATE:0,ZOOM:1,PAN:2,TOUCH_ROTATE:3,TOUCH_ZOOM_PAN:4};this.object=t,this.domElement=void 0!==n?n:document,this.enabled=!0,this.screen={left:0,top:0,width:0,height:0},this.rotateSpeed=1,this.zoomSpeed=1.2,this.panSpeed=.3,this.noRotate=!1,this.noZoom=!1,this.noPan=!1,this.staticMoving=!1,this.dynamicDampingFactor=.2,this.minDistance=0,this.maxDistance=1/0,this.keys=[65,83,68],this.target=new e.Vector3;var r=new e.Vector3,a=o.NONE,s=o.NONE,c=new e.Vector3,l=new e.Vector2,u=new e.Vector2,h=new e.Vector3,p=0,f=new e.Vector2,d=new e.Vector2,m=0,v=0,g=new e.Vector2,b=new e.Vector2;this.target0=this.target.clone(),this.position0=this.object.position.clone(),this.up0=this.object.up.clone();var y={type:"change"},w={type:"start"},E={type:"end"};this.handleResize=function(){if(this.domElement===document)this.screen.left=0,this.screen.top=0,this.screen.width=window.innerWidth,this.screen.height=window.innerHeight;else{var e=this.domElement.getBoundingClientRect(),t=this.domElement.ownerDocument.documentElement;this.screen.left=e.left+window.pageXOffset-t.clientLeft,this.screen.top=e.top+window.pageYOffset-t.clientTop,this.screen.width=e.width,this.screen.height=e.height}},this.handleEvent=function(e){"function"==typeof this[e.type]&&this[e.type](e)};var _,k,x,R,O,C,j,P,M,T,L,V=(_=new e.Vector2,function(e,t){return _.set((e-i.screen.left)/i.screen.width,(t-i.screen.top)/i.screen.height),_}),S=function(){var t=new e.Vector2;return function(e,n){return t.set((e-.5*i.screen.width-i.screen.left)/(.5*i.screen.width),(i.screen.height+2*(i.screen.top-n))/i.screen.width),t}}();function D(e){!1!==i.enabled&&(window.removeEventListener("keydown",D),s=a,a===o.NONE&&(e.keyCode!==i.keys[o.ROTATE]||i.noRotate?e.keyCode!==i.keys[o.ZOOM]||i.noZoom?e.keyCode!==i.keys[o.PAN]||i.noPan||(a=o.PAN):a=o.ZOOM:a=o.ROTATE))}function A(e){!1!==i.enabled&&(a=s,window.addEventListener("keydown",D,!1))}function F(e){!1!==i.enabled&&(e.preventDefault(),e.stopPropagation(),a===o.NONE&&(a=e.button),a!==o.ROTATE||i.noRotate?a!==o.ZOOM||i.noZoom?a!==o.PAN||i.noPan||(g.copy(V(e.pageX,e.pageY)),b.copy(g)):(f.copy(V(e.pageX,e.pageY)),d.copy(f)):(u.copy(S(e.pageX,e.pageY)),l.copy(u)),document.addEventListener("mousemove",N,!1),document.addEventListener("mouseup",z,!1),i.dispatchEvent(w))}function N(e){!1!==i.enabled&&(e.preventDefault(),e.stopPropagation(),a!==o.ROTATE||i.noRotate?a!==o.ZOOM||i.noZoom?a!==o.PAN||i.noPan||b.copy(V(e.pageX,e.pageY)):d.copy(V(e.pageX,e.pageY)):(l.copy(u),u.copy(S(e.pageX,e.pageY))))}function z(e){!1!==i.enabled&&(e.preventDefault(),e.stopPropagation(),a=o.NONE,document.removeEventListener("mousemove",N),document.removeEventListener("mouseup",z),i.dispatchEvent(E))}function H(e){if(!1!==i.enabled){switch(e.preventDefault(),e.stopPropagation(),e.deltaMode){case 2:f.y-=.025*e.deltaY;break;case 1:f.y-=.01*e.deltaY;break;default:f.y-=25e-5*e.deltaY}i.dispatchEvent(w),i.dispatchEvent(E)}}function B(e){if(!1!==i.enabled){switch(e.touches.length){case 1:a=o.TOUCH_ROTATE,u.copy(S(e.touches[0].pageX,e.touches[0].pageY)),l.copy(u);break;default:a=o.TOUCH_ZOOM_PAN;var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY;v=m=Math.sqrt(t*t+n*n);var r=(e.touches[0].pageX+e.touches[1].pageX)/2,s=(e.touches[0].pageY+e.touches[1].pageY)/2;g.copy(V(r,s)),b.copy(g)}i.dispatchEvent(w)}}function Y(e){if(!1!==i.enabled)switch(e.preventDefault(),e.stopPropagation(),e.touches.length){case 1:l.copy(u),u.copy(S(e.touches[0].pageX,e.touches[0].pageY));break;default:var t=e.touches[0].pageX-e.touches[1].pageX,n=e.touches[0].pageY-e.touches[1].pageY;v=Math.sqrt(t*t+n*n);var o=(e.touches[0].pageX+e.touches[1].pageX)/2,r=(e.touches[0].pageY+e.touches[1].pageY)/2;b.copy(V(o,r))}}function X(e){if(!1!==i.enabled){switch(e.touches.length){case 0:a=o.NONE;break;case 1:a=o.TOUCH_ROTATE,u.copy(S(e.touches[0].pageX,e.touches[0].pageY)),l.copy(u)}i.dispatchEvent(E)}}function I(e){e.preventDefault()}this.rotateCamera=(x=new e.Vector3,R=new e.Quaternion,O=new e.Vector3,C=new e.Vector3,j=new e.Vector3,P=new e.Vector3,function(){P.set(u.x-l.x,u.y-l.y,0),(k=P.length())?(c.copy(i.object.position).sub(i.target),O.copy(c).normalize(),C.copy(i.object.up).normalize(),j.crossVectors(C,O).normalize(),C.setLength(u.y-l.y),j.setLength(u.x-l.x),P.copy(C.add(j)),x.crossVectors(P,c).normalize(),k*=i.rotateSpeed,R.setFromAxisAngle(x,k),c.applyQuaternion(R),i.object.up.applyQuaternion(R),h.copy(x),p=k):!i.staticMoving&&p&&(p*=Math.sqrt(1-i.dynamicDampingFactor),c.copy(i.object.position).sub(i.target),R.setFromAxisAngle(h,p),c.applyQuaternion(R),i.object.up.applyQuaternion(R)),l.copy(u)}),this.zoomCamera=function(){var e;a===o.TOUCH_ZOOM_PAN?(e=m/v,m=v,c.multiplyScalar(e)):(1!==(e=1+(d.y-f.y)*i.zoomSpeed)&&e>0&&c.multiplyScalar(e),i.staticMoving?f.copy(d):f.y+=(d.y-f.y)*this.dynamicDampingFactor)},this.panCamera=(M=new e.Vector2,T=new e.Vector3,L=new e.Vector3,function(){M.copy(b).sub(g),M.lengthSq()&&(M.multiplyScalar(c.length()*i.panSpeed),L.copy(c).cross(i.object.up).setLength(M.x),L.add(T.copy(i.object.up).setLength(M.y)),i.object.position.add(L),i.target.add(L),i.staticMoving?g.copy(b):g.add(M.subVectors(b,g).multiplyScalar(i.dynamicDampingFactor)))}),this.checkDistances=function(){i.noZoom&&i.noPan||(c.lengthSq()>i.maxDistance*i.maxDistance&&(i.object.position.addVectors(i.target,c.setLength(i.maxDistance)),f.copy(d)),c.lengthSq()<i.minDistance*i.minDistance&&(i.object.position.addVectors(i.target,c.setLength(i.minDistance)),f.copy(d)))},this.update=function(){c.subVectors(i.object.position,i.target),i.noRotate||i.rotateCamera(),i.noZoom||i.zoomCamera(),i.noPan||i.panCamera(),i.object.position.addVectors(i.target,c),i.checkDistances(),i.object.lookAt(i.target),r.distanceToSquared(i.object.position)>1e-6&&(i.dispatchEvent(y),r.copy(i.object.position))},this.reset=function(){a=o.NONE,s=o.NONE,i.target.copy(i.target0),i.object.position.copy(i.position0),i.object.up.copy(i.up0),c.subVectors(i.object.position,i.target),i.object.lookAt(i.target),i.dispatchEvent(y),r.copy(i.object.position)},this.dispose=function(){this.domElement.removeEventListener("contextmenu",I,!1),this.domElement.removeEventListener("mousedown",F,!1),this.domElement.removeEventListener("wheel",H,!1),this.domElement.removeEventListener("touchstart",B,!1),this.domElement.removeEventListener("touchend",X,!1),this.domElement.removeEventListener("touchmove",Y,!1),document.removeEventListener("mousemove",N,!1),document.removeEventListener("mouseup",z,!1),window.removeEventListener("keydown",D,!1),window.removeEventListener("keyup",A,!1)},this.domElement.addEventListener("contextmenu",I,!1),this.domElement.addEventListener("mousedown",F,!1),this.domElement.addEventListener("wheel",H,!1),this.domElement.addEventListener("touchstart",B,!1),this.domElement.addEventListener("touchend",X,!1),this.domElement.addEventListener("touchmove",Y,!1),window.addEventListener("keydown",D,!1),window.addEventListener("keyup",A,!1),this.handleResize(),this.update()},e.TrackballControls.prototype=Object.create(e.EventDispatcher.prototype),e.TrackballControls.prototype.constructor=e.TrackballControls},V=function(e){e.VRControls=function(t,n){var i,o,r=this,a=new e.Matrix4,s=null;"VRFrameData"in window&&(s=new VRFrameData),navigator.getVRDisplays&&navigator.getVRDisplays().then((function(e){o=e,e.length>0?i=e[0]:n&&n("VR input not available.")})).catch((function(){console.warn("THREE.VRControls: Unable to get VR Displays")})),this.scale=1,this.standing=!1,this.userHeight=1.6,this.getVRDisplay=function(){return i},this.setVRDisplay=function(e){i=e},this.getVRDisplays=function(){return console.warn("THREE.VRControls: getVRDisplays() is being deprecated."),o},this.getStandingMatrix=function(){return a},this.update=function(){var e;i&&(i.getFrameData?(i.getFrameData(s),e=s.pose):i.getPose&&(e=i.getPose()),null!==e.orientation&&t.quaternion.fromArray(e.orientation),null!==e.position?t.position.fromArray(e.position):t.position.set(0,0,0),this.standing&&(i.stageParameters?(t.updateMatrix(),a.fromArray(i.stageParameters.sittingToStandingTransform),t.applyMatrix(a)):t.position.setY(t.position.y+this.userHeight)),t.position.multiplyScalar(r.scale))},this.resetPose=function(){i&&i.resetPose()},this.resetSensor=function(){console.warn("THREE.VRControls: .resetSensor() is now .resetPose()."),this.resetPose()},this.zeroSensor=function(){console.warn("THREE.VRControls: .zeroSensor() is now .resetPose()."),this.resetPose()},this.dispose=function(){i=null}}},S=function(e){[P,M,T,L,V].forEach(t=>t(e))},D=function(e){e.Stats=function(){var e=Date.now(),t=e,n=0,i=1/0,o=0,r=0,a=1/0,s=0,c=0,l=0,u=document.createElement("div");u.id="stats",u.addEventListener("mousedown",(function(e){e.preventDefault(),b(++l%2)}),!1),u.style.cssText="width:80px;opacity:0.9;cursor:pointer";var h=document.createElement("div");h.id="fps",h.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#002",u.appendChild(h);var p=document.createElement("div");p.id="fpsText",p.style.cssText="color:#0ff;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",p.innerHTML="FPS",h.appendChild(p);var f=document.createElement("div");for(f.id="fpsGraph",f.style.cssText="position:relative;width:74px;height:30px;background-color:#0ff",h.appendChild(f);74>f.children.length;){var d=document.createElement("span");d.style.cssText="width:1px;height:30px;float:left;background-color:#113",f.appendChild(d)}var m=document.createElement("div");m.id="ms",m.style.cssText="padding:0 0 3px 3px;text-align:left;background-color:#020;display:none",u.appendChild(m);var v=document.createElement("div");v.id="msText",v.style.cssText="color:#0f0;font-family:Helvetica,Arial,sans-serif;font-size:9px;font-weight:bold;line-height:15px",v.innerHTML="MS",m.appendChild(v);var g=document.createElement("div");for(g.id="msGraph",g.style.cssText="position:relative;width:74px;height:30px;background-color:#0f0",m.appendChild(g);74>g.children.length;)(d=document.createElement("span")).style.cssText="width:1px;height:30px;float:left;background-color:#131",g.appendChild(d);var b=function(e){switch(l=e){case 0:h.style.display="block",m.style.display="none";break;case 1:h.style.display="none",m.style.display="block"}};return{REVISION:11,domElement:u,setMode:b,begin:function(){e=Date.now()},end:function(){var l=Date.now();n=l-e,i=Math.min(i,n),o=Math.max(o,n),v.textContent=n+" MS ("+i+"-"+o+")";var u=Math.min(30,30-n/200*30);return g.appendChild(g.firstChild).style.height=u+"px",c++,l>t+1e3&&(r=Math.round(1e3*c/(l-t)),a=Math.min(a,r),s=Math.max(s,r),p.textContent=r+" FPS ("+a+"-"+s+")",u=Math.min(30,30-r/100*30),f.appendChild(f.firstChild).style.height=u+"px",t=l,c=0),l},update:function(){e=this.end()}}}};var A=function(e){[S,D,k,x,R,O,C,j].forEach(t=>t(e))};t.default=function(e){u(e),_(e),A(e)}}]).default;
	
	/***/ }),
	/* 69 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Context, Model, Overlay, Primitives, Render, Shaders, Stage, THREE, Util;
	
	THREE = __webpack_require__(1);
	
	Model = __webpack_require__(23);
	
	Overlay = __webpack_require__(103);
	
	Primitives = __webpack_require__(107);
	
	Render = __webpack_require__(177);
	
	Shaders = __webpack_require__(202);
	
	Stage = __webpack_require__(233);
	
	Util = __webpack_require__(0);
	
	Context = (function() {
		Context.Namespace = {
			Model: Model,
			Overlay: Overlay,
			Primitives: Primitives,
			Render: Render,
			Shaders: Shaders,
			Stage: Stage,
			Util: Util,
			DOM: Util.VDOM
		};
	
		Context.Version = '0.0.6-dev';
	
		function Context(renderer, scene, camera) {
			var canvas;
			if (scene == null) {
				scene = null;
			}
			if (camera == null) {
				camera = null;
			}
			this.canvas = canvas = renderer.domElement;
			this.element = null;
			this.shaders = new Shaders.Factory(Shaders.Snippets);
			this.renderables = new Render.Factory(Render.Classes, renderer, this.shaders);
			this.overlays = new Overlay.Factory(Overlay.Classes, canvas);
			this.scene = this.renderables.make('scene', {
				scene: scene
			});
			this.camera = this.defaultCamera = camera != null ? camera : new THREE.PerspectiveCamera();
			this.attributes = new Model.Attributes(Primitives.Types, this);
			this.primitives = new Primitives.Factory(Primitives.Types, this);
			this.root = this.primitives.make('root');
			this.model = new Model.Model(this.root);
			this.guard = new Model.Guard;
			this.controller = new Stage.Controller(this.model, this.primitives);
			this.animator = new Stage.Animator(this);
			this.api = new Stage.API(this);
			this.speed = 1;
			this.time = {
				now: +new Date() / 1000,
				time: 0,
				delta: 0,
				clock: 0,
				step: 0
			};
		}
	
		Context.prototype.init = function() {
			this.scene.inject();
			this.overlays.inject();
			return this;
		};
	
		Context.prototype.destroy = function() {
			this.scene.unject();
			this.overlays.unject();
			return this;
		};
	
		Context.prototype.resize = function(size) {
	
			/*
			{
				viewWidth, viewHeight, renderWidth, renderHeight, aspect, pixelRatio
			}
			 */
			if (size == null) {
				size = {};
			}
			if (size.renderWidth == null) {
				size.renderWidth = size.viewWidth != null ? size.viewWidth : size.viewWidth = 1280;
			}
			if (size.renderHeight == null) {
				size.renderHeight = size.viewHeight != null ? size.viewHeight : size.viewHeight = 720;
			}
			if (size.pixelRatio == null) {
				size.pixelRatio = size.renderWidth / Math.max(.000001, size.viewWidth);
			}
			if (size.aspect == null) {
				size.aspect = size.viewWidth / Math.max(.000001, size.viewHeight);
			}
			this.root.controller.resize(size);
			return this;
		};
	
		Context.prototype.frame = function(time) {
	
			/*
			{
				now, clock, step
			}
			 */
			this.pre(time);
			this.update();
			this.render();
			this.post();
			return this;
		};
	
		Context.prototype.pre = function(time) {
			var base;
			if (!time) {
				time = {
					now: +new Date() / 1000,
					time: 0,
					delta: 0,
					clock: 0,
					step: 0
				};
				time.delta = this.time.now != null ? time.now - this.time.now : 0;
				if (time.delta > 1) {
					time.delta = 1 / 60;
				}
				time.step = time.delta * this.speed;
				time.time = this.time.time + time.delta;
				time.clock = this.time.clock + time.step;
			}
			this.time = time;
			if (typeof (base = this.root.controller).pre === "function") {
				base.pre();
			}
			return this;
		};
	
		Context.prototype.update = function() {
			var base;
			this.animator.update();
			this.attributes.compute();
			this.guard.iterate({
				step: (function(_this) {
					return function() {
						var change;
						change = _this.attributes.digest();
						return change || (change = _this.model.digest());
					};
				})(this),
				last: function() {
					return {
						attribute: this.attributes.getLastTrigger(),
						model: this.model.getLastTrigger()
					};
				}
			});
			if (typeof (base = this.root.controller).update === "function") {
				base.update();
			}
			this.camera = this.root.controller.getCamera();
			this.speed = this.root.controller.getSpeed();
			return this;
		};
	
		Context.prototype.render = function() {
			var base;
			if (typeof (base = this.root.controller).render === "function") {
				base.render();
			}
			this.scene.render();
			return this;
		};
	
		Context.prototype.post = function() {
			var base;
			if (typeof (base = this.root.controller).post === "function") {
				base.post();
			}
			return this;
		};
	
		Context.prototype.setWarmup = function(n) {
			this.scene.warmup(n);
			return this;
		};
	
		Context.prototype.getPending = function() {
			return this.scene.pending.length;
		};
	
		return Context;
	
	})();
	
	module.exports = Context;
	
	
	/***/ }),
	/* 70 */
	/***/ (function(module, exports) {
	
	
	/*
	 Custom attribute model
	 - Organizes attributes by trait in .attributes
	 - Provides constant-time .props / .get() access to flat dictionary
	 - Provides .get(key) with or without trait namespaces
	 - Change attributes with .set(key) or .set(dictionary)
	 - Validation is double-buffered and in-place to detect changes and nops
	 - Change notifications are coalesced per object and per trait, digested later
	 - Values are stored in three.js uniform-style objects so they can be bound as GL uniforms
	 - Originally passed (unnormalized) values are preserved and can be fetched via .orig()
	 - Attributes can be defined as final/const
	 - Attributes can be computed from both public or private expressions with .bind(key, false/true)
	 - Expressions are time-dependent, can be time-travelled with .evaluate()
	 - This enables continous simulation and data logging despite choppy animation updates
	 
		Actual type and trait definitions are injected from Primitives
	 */
	var Attributes, Data, shallowCopy;
	
	Attributes = (function() {
		function Attributes(definitions, context) {
			this.context = context;
			this.traits = definitions.Traits;
			this.types = definitions.Types;
			this.pending = [];
			this.bound = [];
			this.last = null;
		}
	
		Attributes.prototype.make = function(type) {
			return {
				"enum": typeof type["enum"] === "function" ? type["enum"]() : void 0,
				type: typeof type.uniform === "function" ? type.uniform() : void 0,
				value: type.make()
			};
		};
	
		Attributes.prototype.apply = function(object, config) {
			return new Data(object, config, this);
		};
	
		Attributes.prototype.bind = function(callback) {
			return this.bound.push(callback);
		};
	
		Attributes.prototype.unbind = function(callback) {
			var cb;
			return this.bound = (function() {
				var j, len, ref, results;
				ref = this.bound;
				results = [];
				for (j = 0, len = ref.length; j < len; j++) {
					cb = ref[j];
					if (cb !== callback) {
						results.push(cb);
					}
				}
				return results;
			}).call(this);
		};
	
		Attributes.prototype.queue = function(callback, object, key, value) {
			this.lastObject = object;
			this.lastKey = key;
			this.lastValue = value;
			return this.pending.push(callback);
		};
	
		Attributes.prototype.invoke = function(callback) {
			return callback(this.context.time.clock, this.context.time.step);
		};
	
		Attributes.prototype.compute = function() {
			var cb, j, len, ref;
			if (this.bound.length) {
				ref = this.bound;
				for (j = 0, len = ref.length; j < len; j++) {
					cb = ref[j];
					this.invoke(cb);
				}
			}
		};
	
		Attributes.prototype.digest = function() {
			var callback, calls, j, len, ref;
			if (!this.pending.length) {
				return false;
			}
			ref = [this.pending, []], calls = ref[0], this.pending = ref[1];
			for (j = 0, len = calls.length; j < len; j++) {
				callback = calls[j];
				callback();
			}
			return true;
		};
	
		Attributes.prototype.getTrait = function(name) {
			return this.traits[name];
		};
	
		Attributes.prototype.getLastTrigger = function() {
			return (this.lastObject.toString()) + " - " + this.lastKey + "=`" + this.lastValue + "`";
		};
	
		return Attributes;
	
	})();
	
	shallowCopy = function(x) {
		var k, out, v;
		out = {};
		for (k in x) {
			v = x[k];
			out[k] = v;
		}
		return out;
	};
	
	Data = (function() {
		function Data(object, config, _attributes) {
			var _bound, _computed, _eval, _expr, _finals, addSpec, bind, change, changed, changes, constant, data, define, digest, dirty, equalors, equals, evaluate, event, expr, finals, flattened, freeform, get, getNS, j, key, len, list, makers, mapTo, name, ns, oldComputed, oldExpr, oldOrig, oldProps, originals, props, ref, ref1, set, shorthand, spec, to, touched, touches, trait, traits, unbind, unique, validate, validators, value, values;
			traits = config.traits, props = config.props, finals = config.finals, freeform = config.freeform;
			data = this;
			if ((object.props != null) && (object.expr != null) && (object.orig != null) && (object.computed != null) && (object.attributes != null)) {
				oldProps = shallowCopy(object.props);
				oldExpr = shallowCopy(object.expr);
				oldOrig = object.orig();
				oldComputed = object.computed();
				if ((ref = object.attributes) != null) {
					ref.dispose();
				}
			}
			flattened = {};
			originals = {};
			mapTo = {};
			to = function(name) {
				var ref1;
				return (ref1 = mapTo[name]) != null ? ref1 : name;
			};
			define = function(name, alias) {
				if (mapTo[alias]) {
					throw new Error((object.toString()) + " - Duplicate property `" + alias + "`");
				}
				return mapTo[alias] = name;
			};
			get = function(key) {
				var ref1, ref2, ref3;
				return (ref1 = (ref2 = data[key]) != null ? ref2.value : void 0) != null ? ref1 : (ref3 = data[to(key)]) != null ? ref3.value : void 0;
			};
			set = function(key, value, ignore, initial) {
				var attr, ref1, short, valid, validated;
				key = to(key);
				if ((attr = data[key]) == null) {
					if (!freeform) {
						throw new Error((object.toString()) + " - Setting unknown property `" + key + "={" + value + "}`");
					}
					attr = data[key] = {
						short: key,
						type: null,
						last: null,
						value: null
					};
					validators[key] = function(v) {
						return v;
					};
				}
				if (!ignore) {
					if (_expr[key]) {
						throw new Error((object.toString()) + " - Can't set bound property `" + key + "={" + value + "}`");
					}
					if (_computed[key]) {
						throw new Error((object.toString()) + " - Can't set computed property `" + key + "={" + value + "}`");
					}
					if (_finals[key]) {
						throw new Error((object.toString()) + " - Can't set final property `" + key + "={" + value + "}`");
					}
				}
				valid = true;
				validated = validate(key, value, attr.last, function() {
					valid = false;
					return null;
				});
				if (valid) {
					ref1 = [validated, attr.value], attr.value = ref1[0], attr.last = ref1[1];
					short = attr.short;
					flattened[short] = validated;
					if (!ignore) {
						originals[short] = value;
					}
					if (!(initial || equals(key, attr.value, attr.last))) {
						change(key, value);
					}
				}
				return valid;
			};
			constant = function(key, value, initial) {
				key = to(key);
				set(key, value, true, initial);
				return _finals[key] = true;
			};
			expr = {};
			_bound = {};
			_eval = {};
			_expr = {};
			_computed = {};
			_finals = {};
			bind = function(key, expression, computed) {
				var list, short;
				if (computed == null) {
					computed = false;
				}
				key = to(key);
				if (typeof expression !== 'function') {
					throw new Error((object.toString()) + " - Expression `" + key + "=>{" + expr + "}` is not a function");
				}
				if (_expr[key]) {
					throw new Error((object.toString()) + " - Property `" + key + "=>{" + expr + "}` is already bound");
				}
				if (_computed[key]) {
					throw new Error((object.toString()) + " - Property `" + key + "` is computed");
				}
				if (_finals[key]) {
					throw new Error((object.toString()) + " - Property `" + key + "` is final");
				}
				list = computed ? _computed : _expr;
				list[key] = expression;
				short = data[key] != null ? data[key].short : key;
				if (!computed) {
					expr[short] = expression;
				}
				_eval[key] = expression;
				expression = expression.bind(object);
				_bound[key] = function(t, d) {
					var clock, ref1;
					if (clock = (ref1 = object.clock) != null ? ref1.getTime() : void 0) {
						t = clock.clock;
						d = clock.step;
					}
					return object.set(key, expression(t, d), true);
				};
				return _attributes.bind(_bound[key]);
			};
			unbind = function(key, computed) {
				var list;
				if (computed == null) {
					computed = false;
				}
				key = to(key);
				list = computed ? _computed : _expr;
				if (!list[key]) {
					return;
				}
				_attributes.unbind(_bound[key]);
				delete _bound[key];
				delete list[key];
				if (data[key] != null) {
					key = data[key].short;
				}
				return delete expr[key];
			};
			evaluate = function(key, time) {
				var ref1;
				key = to(key);
				return (ref1 = typeof _eval[key] === "function" ? _eval[key](time, 0) : void 0) != null ? ref1 : data[key].value;
			};
			object.expr = expr;
			object.props = flattened;
			object.evaluate = function(key, time) {
				var out;
				if (key != null) {
					return evaluate(key, time);
				} else {
					out = {};
					for (key in props) {
						out[key] = evaluate(key, time);
					}
					return out;
				}
			};
			object.get = function(key) {
				if (key != null) {
					return get(key);
				} else {
					return flattened;
				}
			};
			object.set = function(key, value, ignore, initial) {
				var options;
				if (typeof key === 'string') {
					set(key, value, ignore, initial);
				} else {
					initial = ignore;
					ignore = value;
					options = key;
					for (key in options) {
						value = options[key];
						set(key, value, ignore, initial);
					}
				}
			};
			object.bind = function(key, expr, computed) {
				var binds;
				if (typeof key === 'string') {
					bind(key, expr, computed);
				} else {
					computed = expr;
					binds = key;
					for (key in binds) {
						expr = binds[key];
						bind(key, expr, computed);
					}
				}
			};
			object.unbind = function(key, computed) {
				var binds;
				if (typeof key === 'string') {
					unbind(key, computed);
				} else {
					computed = expr;
					binds = key;
					for (key in binds) {
						unbind(key, computed);
					}
				}
			};
			object.attribute = function(key) {
				if (key != null) {
					return data[to(key)];
				} else {
					return data;
				}
			};
			object.orig = function(key) {
				if (key != null) {
					return originals[to(key)];
				} else {
					return shallowCopy(originals);
				}
			};
			object.computed = function(key) {
				if (key != null) {
					return _computed[to(key)];
				} else {
					return shallowCopy(_computed);
				}
			};
			makers = {};
			validators = {};
			equalors = {};
			equals = function(key, value, target) {
				return equalors[key](value, target);
			};
			validate = function(key, value, target, invalid) {
				return validators[key](value, target, invalid);
			};
			object.validate = function(key, value) {
				var make, target;
				key = to(key);
				make = makers[key];
				if (make != null) {
					target = make();
				}
				return target = validate(key, value, target, function() {
					throw new Error((object.toString()) + " - Invalid value `" + key + "={" + value + "}`");
				});
			};
			dirty = false;
			changes = {};
			touches = {};
			changed = {};
			touched = {};
			getNS = function(key) {
				return key.split('.')[0];
			};
			change = function(key, value) {
				var trait;
				if (!dirty) {
					dirty = true;
					_attributes.queue(digest, object, key, value);
				}
				trait = getNS(key);
				changes[key] = true;
				return touches[trait] = true;
			};
			event = {
				type: 'change',
				changed: null,
				touched: null
			};
			digest = function() {
				var k, results, trait;
				event.changed = changes;
				event.touched = touches;
				changes = changed;
				touches = touched;
				changed = event.changed;
				touched = event.touched;
				dirty = false;
				for (k in changes) {
					changes[k] = false;
				}
				for (k in touches) {
					touches[k] = false;
				}
				event.type = 'change';
				object.trigger(event);
				results = [];
				for (trait in event.touched) {
					event.type = "change:" + trait;
					results.push(object.trigger(event));
				}
				return results;
			};
			shorthand = function(name) {
				var parts, suffix;
				parts = name.split(/\./g);
				suffix = parts.pop();
				parts.pop();
				parts.unshift(suffix);
				return parts.reduce(function(a, b) {
					return a + b.charAt(0).toUpperCase() + b.substring(1);
				});
			};
			addSpec = function(name, spec) {
				var attr, key, ref1, ref2, results, short, type, value;
				results = [];
				for (key in spec) {
					type = spec[key];
					key = [name, key].join('.');
					short = shorthand(key);
					data[key] = attr = {
						T: type,
						ns: name,
						short: short,
						"enum": typeof type["enum"] === "function" ? type["enum"]() : void 0,
						type: typeof type.uniform === "function" ? type.uniform() : void 0,
						last: type.make(),
						value: value = type.make()
					};
					define(key, short);
					flattened[short] = value;
					makers[key] = type.make;
					validators[key] = (ref1 = type.validate) != null ? ref1 : function(a) {
						return a;
					};
					results.push(equalors[key] = (ref2 = type.equals) != null ? ref2 : function(a, b) {
						return a === b;
					});
				}
				return results;
			};
			list = [];
			values = {};
			for (j = 0, len = traits.length; j < len; j++) {
				trait = traits[j];
				ref1 = trait.split(':'), trait = ref1[0], ns = ref1[1];
				name = ns ? [ns, trait].join('.') : trait;
				spec = _attributes.getTrait(trait);
				list.push(trait);
				if (spec != null) {
					addSpec(name, spec);
				}
			}
			if (props != null) {
				for (ns in props) {
					spec = props[ns];
					addSpec(ns, spec);
				}
			}
			unique = list.filter(function(object, i) {
				return list.indexOf(object) === i;
			});
			object.traits = unique;
			if (oldProps != null) {
				object.set(oldProps, true, true);
			}
			if (finals != null) {
				for (key in finals) {
					value = finals[key];
					constant(key, value, true);
				}
			}
			if (oldOrig != null) {
				object.set(oldOrig, false, true);
			}
			if (oldComputed != null) {
				object.bind(oldComputed, true);
			}
			if (oldExpr != null) {
				object.bind(oldExpr, false);
			}
			this.dispose = function() {
				for (key in _computed) {
					unbind(key, true);
				}
				for (key in _expr) {
					unbind(key, false);
				}
				props = {};
				delete object.attributes;
				delete object.get;
				return delete object.set;
			};
			null;
		}
	
		return Data;
	
	})();
	
	module.exports = Attributes;
	
	
	/***/ }),
	/* 71 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Group, Node,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Node = __webpack_require__(40);
	
	Group = (function(superClass) {
		extend(Group, superClass);
	
		function Group(type, defaults, options, binds, config, attributes) {
			Group.__super__.constructor.call(this, type, defaults, options, binds, config, attributes);
			this.children = [];
			this.on('reindex', (function(_this) {
				return function(event) {
					var child, j, len, ref, results;
					ref = _this.children;
					results = [];
					for (j = 0, len = ref.length; j < len; j++) {
						child = ref[j];
						results.push(child.trigger(event));
					}
					return results;
				};
			})(this));
		}
	
		Group.prototype.add = function(node) {
			var ref;
			if ((ref = node.parent) != null) {
				ref.remove(node);
			}
			node._index(this.children.length, this);
			this.children.push(node);
			return node._added(this);
		};
	
		Group.prototype.remove = function(node) {
			var i, index, j, len, ref, ref1;
			if ((ref = node.children) != null ? ref.length : void 0) {
				node.empty();
			}
			index = this.children.indexOf(node);
			if (index === -1) {
				return;
			}
			this.children.splice(index, 1);
			node._index(null);
			node._removed(this);
			ref1 = this.children;
			for (i = j = 0, len = ref1.length; j < len; i = ++j) {
				node = ref1[i];
				if (i >= index) {
					node._index(i);
				}
			}
		};
	
		Group.prototype.empty = function() {
			var children, j, len, node;
			children = this.children.slice().reverse();
			for (j = 0, len = children.length; j < len; j++) {
				node = children[j];
				this.remove(node);
			}
		};
	
		return Group;
	
	})(Node);
	
	module.exports = Group;
	
	
	/***/ }),
	/* 72 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var THREE,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	THREE = __webpack_require__(1);
	
	exports.setOrigin = function(vec, dimensions, origin) {
		var w, x, y, z;
		if (+dimensions === dimensions) {
			dimensions = [dimensions];
		}
		x = indexOf.call(dimensions, 1) >= 0 ? 0 : origin.x;
		y = indexOf.call(dimensions, 2) >= 0 ? 0 : origin.y;
		z = indexOf.call(dimensions, 3) >= 0 ? 0 : origin.z;
		w = indexOf.call(dimensions, 4) >= 0 ? 0 : origin.w;
		return vec.set(x, y, z, w);
	};
	
	exports.addOrigin = (function() {
		var v;
		v = new THREE.Vector4;
		return function(vec, dimension, origin) {
			exports.setOrigin(v, dimension, origin);
			return vec.add(v);
		};
	})();
	
	exports.setDimension = function(vec, dimension) {
		var w, x, y, z;
		x = dimension === 1 ? 1 : 0;
		y = dimension === 2 ? 1 : 0;
		z = dimension === 3 ? 1 : 0;
		w = dimension === 4 ? 1 : 0;
		return vec.set(x, y, z, w);
	};
	
	exports.setDimensionNormal = function(vec, dimension) {
		var w, x, y, z;
		x = dimension === 1 ? 1 : 0;
		y = dimension === 2 ? 1 : 0;
		z = dimension === 3 ? 1 : 0;
		w = dimension === 4 ? 1 : 0;
		return vec.set(y, z + x, w, 0);
	};
	
	exports.recenterAxis = (function() {
		var axis;
		axis = [0, 0];
		return function(x, dx, bend, f) {
			var abs, fabs, max, min, x1, x2;
			if (f == null) {
				f = 0;
			}
			if (bend > 0) {
				x1 = x;
				x2 = x + dx;
				abs = Math.max(Math.abs(x1), Math.abs(x2));
				fabs = abs * f;
				min = Math.min(x1, x2);
				max = Math.max(x1, x2);
				x = min + (-abs + fabs - min) * bend;
				dx = max + (abs + fabs - max) * bend - x;
			}
			axis[0] = x;
			axis[1] = dx;
			return axis;
		};
	})();
	
	
	/***/ }),
	/* 73 */
	/***/ (function(module, exports) {
	
	var getSizes;
	
	exports.getSizes = getSizes = function(data) {
		var array, sizes;
		sizes = [];
		array = data;
		while (typeof array !== 'string' && ((array != null ? array.length : void 0) != null)) {
			sizes.push(array.length);
			array = array[0];
		}
		return sizes;
	};
	
	exports.getDimensions = function(data, spec) {
		var channels, depth, dims, height, items, levels, n, nesting, ref, ref1, ref2, ref3, ref4, sizes, width;
		if (spec == null) {
			spec = {};
		}
		items = spec.items, channels = spec.channels, width = spec.width, height = spec.height, depth = spec.depth;
		dims = {};
		if (!data || !data.length) {
			return {
				items: items,
				channels: channels,
				width: width != null ? width : 0,
				height: height != null ? height : 0,
				depth: depth != null ? depth : 0
			};
		}
		sizes = getSizes(data);
		nesting = sizes.length;
		dims.channels = channels !== 1 && sizes.length > 1 ? sizes.pop() : channels;
		dims.items = items !== 1 && sizes.length > 1 ? sizes.pop() : items;
		dims.width = width !== 1 && sizes.length > 1 ? sizes.pop() : width;
		dims.height = height !== 1 && sizes.length > 1 ? sizes.pop() : height;
		dims.depth = depth !== 1 && sizes.length > 1 ? sizes.pop() : depth;
		levels = nesting;
		if (channels === 1) {
			levels++;
		}
		if (items === 1 && levels > 1) {
			levels++;
		}
		if (width === 1 && levels > 2) {
			levels++;
		}
		if (height === 1 && levels > 3) {
			levels++;
		}
		n = (ref = sizes.pop()) != null ? ref : 1;
		if (levels <= 1) {
			n /= (ref1 = dims.channels) != null ? ref1 : 1;
		}
		if (levels <= 2) {
			n /= (ref2 = dims.items) != null ? ref2 : 1;
		}
		if (levels <= 3) {
			n /= (ref3 = dims.width) != null ? ref3 : 1;
		}
		if (levels <= 4) {
			n /= (ref4 = dims.height) != null ? ref4 : 1;
		}
		n = Math.floor(n);
		if (dims.width == null) {
			dims.width = n;
			n = 1;
		}
		if (dims.height == null) {
			dims.height = n;
			n = 1;
		}
		if (dims.depth == null) {
			dims.depth = n;
			n = 1;
		}
		return dims;
	};
	
	exports.repeatCall = function(call, times) {
		switch (times) {
			case 0:
				return function() {
					return true;
				};
			case 1:
				return function() {
					return call();
				};
			case 2:
				return function() {
					call();
					return call();
				};
			case 3:
				return function() {
					call();
					call();
					call();
					return call();
				};
			case 4:
				return function() {
					call();
					call();
					call();
					return call();
				};
			case 6:
				return function() {
					call();
					call();
					call();
					call();
					call();
					return call();
				};
			case 8:
				return function() {
					call();
					call();
					call();
					call();
					call();
					return call();
				};
		}
	};
	
	exports.makeEmitter = function(thunk, items, channels) {
		var inner, n, next, outer;
		inner = (function() {
			switch (channels) {
				case 0:
					return function() {
						return true;
					};
				case 1:
					return function(emit) {
						return emit(thunk());
					};
				case 2:
					return function(emit) {
						return emit(thunk(), thunk());
					};
				case 3:
					return function(emit) {
						return emit(thunk(), thunk(), thunk());
					};
				case 4:
					return function(emit) {
						return emit(thunk(), thunk(), thunk(), thunk());
					};
				case 6:
					return function(emit) {
						return emit(thunk(), thunk(), thunk(), thunk(), thunk(), thunk());
					};
				case 8:
					return function(emit) {
						return emit(thunk(), thunk(), thunk(), thunk(), thunk(), thunk(), thunk(), thunk());
					};
			}
		})();
		next = null;
		while (items > 0) {
			n = Math.min(items, 8);
			outer = (function() {
				switch (n) {
					case 1:
						return function(emit) {
							return inner(emit);
						};
					case 2:
						return function(emit) {
							inner(emit);
							return inner(emit);
						};
					case 3:
						return function(emit) {
							inner(emit);
							inner(emit);
							return inner(emit);
						};
					case 4:
						return function(emit) {
							inner(emit);
							inner(emit);
							inner(emit);
							return inner(emit);
						};
					case 5:
						return function(emit) {
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							return inner(emit);
						};
					case 6:
						return function(emit) {
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							return inner(emit);
						};
					case 7:
						return function(emit) {
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							return inner(emit);
						};
					case 8:
						return function(emit) {
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							inner(emit);
							return inner(emit);
						};
				}
			})();
			if (next != null) {
				next = (function(outer, next) {
					return function(emit) {
						outer(emit);
						return next(emit);
					};
				})(outer, next);
			} else {
				next = outer;
			}
			items -= n;
		}
		outer = next != null ? next : function() {
			return true;
		};
		outer.reset = thunk.reset;
		outer.rebind = thunk.rebind;
		return outer;
	};
	
	exports.getThunk = function(data) {
		var a, b, c, d, done, first, fourth, i, j, k, l, m, nesting, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, second, sizes, third, thunk;
		sizes = getSizes(data);
		nesting = sizes.length;
		a = sizes.pop();
		b = sizes.pop();
		c = sizes.pop();
		d = sizes.pop();
		done = false;
		switch (nesting) {
			case 0:
				thunk = function() {
					return 0;
				};
				thunk.reset = function() {};
				break;
			case 1:
				i = 0;
				thunk = function() {
					return data[i++];
				};
				thunk.reset = function() {
					return i = 0;
				};
				break;
			case 2:
				i = j = 0;
				first = (ref = data[j]) != null ? ref : [];
				thunk = function() {
					var ref1, x;
					x = first[i++];
					if (i === a) {
						i = 0;
						j++;
						first = (ref1 = data[j]) != null ? ref1 : [];
					}
					return x;
				};
				thunk.reset = function() {
					var ref1;
					i = j = 0;
					first = (ref1 = data[j]) != null ? ref1 : [];
				};
				break;
			case 3:
				i = j = k = 0;
				second = (ref1 = data[k]) != null ? ref1 : [];
				first = (ref2 = second[j]) != null ? ref2 : [];
				thunk = function() {
					var ref3, ref4, x;
					x = first[i++];
					if (i === a) {
						i = 0;
						j++;
						if (j === b) {
							j = 0;
							k++;
							second = (ref3 = data[k]) != null ? ref3 : [];
						}
						first = (ref4 = second[j]) != null ? ref4 : [];
					}
					return x;
				};
				thunk.reset = function() {
					var ref3, ref4;
					i = j = k = 0;
					second = (ref3 = data[k]) != null ? ref3 : [];
					first = (ref4 = second[j]) != null ? ref4 : [];
				};
				break;
			case 4:
				i = j = k = l = 0;
				third = (ref3 = data[l]) != null ? ref3 : [];
				second = (ref4 = third[k]) != null ? ref4 : [];
				first = (ref5 = second[j]) != null ? ref5 : [];
				thunk = function() {
					var ref6, ref7, ref8, x;
					x = first[i++];
					if (i === a) {
						i = 0;
						j++;
						if (j === b) {
							j = 0;
							k++;
							if (k === c) {
								k = 0;
								l++;
								third = (ref6 = data[l]) != null ? ref6 : [];
							}
							second = (ref7 = third[k]) != null ? ref7 : [];
						}
						first = (ref8 = second[j]) != null ? ref8 : [];
					}
					return x;
				};
				thunk.reset = function() {
					var ref6, ref7, ref8;
					i = j = k = l = 0;
					third = (ref6 = data[l]) != null ? ref6 : [];
					second = (ref7 = third[k]) != null ? ref7 : [];
					first = (ref8 = second[j]) != null ? ref8 : [];
				};
				break;
			case 5:
				i = j = k = l = m = 0;
				fourth = (ref6 = data[m]) != null ? ref6 : [];
				third = (ref7 = fourth[l]) != null ? ref7 : [];
				second = (ref8 = third[k]) != null ? ref8 : [];
				first = (ref9 = second[j]) != null ? ref9 : [];
				thunk = function() {
					var ref10, ref11, ref12, ref13, x;
					x = first[i++];
					if (i === a) {
						i = 0;
						j++;
						if (j === b) {
							j = 0;
							k++;
							if (k === c) {
								k = 0;
								l++;
								if (l === d) {
									l = 0;
									m++;
									fourth = (ref10 = data[m]) != null ? ref10 : [];
								}
								third = (ref11 = fourth[l]) != null ? ref11 : [];
							}
							second = (ref12 = third[k]) != null ? ref12 : [];
						}
						first = (ref13 = second[j]) != null ? ref13 : [];
					}
					return x;
				};
				thunk.reset = function() {
					var ref10, ref11, ref12, ref13;
					i = j = k = l = m = 0;
					fourth = (ref10 = data[m]) != null ? ref10 : [];
					third = (ref11 = fourth[l]) != null ? ref11 : [];
					second = (ref12 = third[k]) != null ? ref12 : [];
					first = (ref13 = second[j]) != null ? ref13 : [];
				};
		}
		thunk.rebind = function(d) {
			data = d;
			sizes = getSizes(data);
			if (sizes.length) {
				a = sizes.pop();
			}
			if (sizes.length) {
				b = sizes.pop();
			}
			if (sizes.length) {
				c = sizes.pop();
			}
			if (sizes.length) {
				return d = sizes.pop();
			}
		};
		return thunk;
	};
	
	exports.getStreamer = function(array, samples, channels, items) {
		var consume, count, done, emit, i, j, limit, reset, skip;
		limit = i = j = 0;
		reset = function() {
			limit = samples * channels * items;
			return i = j = 0;
		};
		count = function() {
			return j;
		};
		done = function() {
			return limit - i <= 0;
		};
		skip = (function() {
			switch (channels) {
				case 1:
					return function(n) {
						i += n;
						j += n;
					};
				case 2:
					return function(n) {
						i += n * 2;
						j += n;
					};
				case 3:
					return function(n) {
						i += n * 3;
						j += n;
					};
				case 4:
					return function(n) {
						i += n * 4;
						j += n;
					};
			}
		})();
		consume = (function() {
			switch (channels) {
				case 1:
					return function(emit) {
						emit(array[i++]);
						++j;
					};
				case 2:
					return function(emit) {
						emit(array[i++], array[i++]);
						++j;
					};
				case 3:
					return function(emit) {
						emit(array[i++], array[i++], array[i++]);
						++j;
					};
				case 4:
					return function(emit) {
						emit(array[i++], array[i++], array[i++], array[i++]);
						++j;
					};
			}
		})();
		emit = (function() {
			switch (channels) {
				case 1:
					return function(x) {
						array[i++] = x;
						++j;
					};
				case 2:
					return function(x, y) {
						array[i++] = x;
						array[i++] = y;
						++j;
					};
				case 3:
					return function(x, y, z) {
						array[i++] = x;
						array[i++] = y;
						array[i++] = z;
						++j;
					};
				case 4:
					return function(x, y, z, w) {
						array[i++] = x;
						array[i++] = y;
						array[i++] = z;
						array[i++] = w;
						++j;
					};
			}
		})();
		consume.reset = reset;
		emit.reset = reset;
		reset();
		return {
			emit: emit,
			consume: consume,
			skip: skip,
			count: count,
			done: done,
			reset: reset
		};
	};
	
	exports.getLerpEmitter = function(expr1, expr2) {
		var args, emit1, emit2, emitter, lerp1, lerp2, p, q, r, s, scratch;
		scratch = new Float32Array(4096);
		lerp1 = lerp2 = 0.5;
		p = q = r = s = 0;
		emit1 = function(x, y, z, w) {
			r++;
			scratch[p++] = x * lerp1;
			scratch[p++] = y * lerp1;
			scratch[p++] = z * lerp1;
			return scratch[p++] = w * lerp1;
		};
		emit2 = function(x, y, z, w) {
			s++;
			scratch[q++] += x * lerp2;
			scratch[q++] += y * lerp2;
			scratch[q++] += z * lerp2;
			return scratch[q++] += w * lerp2;
		};
		args = Math.max(expr1.length, expr2.length);
		if (args <= 3) {
			emitter = function(emit, x, i) {
				var k, l, n, o, ref, results;
				p = q = r = s = 0;
				expr1(emit1, x, i);
				expr2(emit2, x, i);
				n = Math.min(r, s);
				l = 0;
				results = [];
				for (k = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
					results.push(emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++]));
				}
				return results;
			};
		} else if (args <= 5) {
			emitter = function(emit, x, y, i, j) {
				var k, l, n, o, ref, results;
				p = q = r = s = 0;
				expr1(emit1, x, y, i, j);
				expr2(emit2, x, y, i, j);
				n = Math.min(r, s);
				l = 0;
				results = [];
				for (k = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
					results.push(emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++]));
				}
				return results;
			};
		} else if (args <= 7) {
			emitter = function(emit, x, y, z, i, j, k) {
				var l, n, o, ref, results;
				p = q = r = s = 0;
				expr1(emit1, x, y, z, i, j, k);
				expr2(emit2, x, y, z, i, j, k);
				n = Math.min(r, s);
				l = 0;
				results = [];
				for (k = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
					results.push(emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++]));
				}
				return results;
			};
		} else if (args <= 9) {
			emitter = function(emit, x, y, z, w, i, j, k, l) {
				var n, o, ref, results;
				p = q = r = s = 0;
				expr1(emit1, x, y, z, w, i, j, k, l);
				expr2(emit2, x, y, z, w, i, j, k, l);
				n = Math.min(r, s);
				l = 0;
				results = [];
				for (k = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
					results.push(emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++]));
				}
				return results;
			};
		} else {
			emitter = function(emit, x, y, z, w, i, j, k, l, d, t) {
				var n, o, ref, results;
				p = q = 0;
				expr1(emit1, x, y, z, w, i, j, k, l, d, t);
				expr2(emit2, x, y, z, w, i, j, k, l, d, t);
				n = Math.min(r, s);
				l = 0;
				results = [];
				for (k = o = 0, ref = n; 0 <= ref ? o < ref : o > ref; k = 0 <= ref ? ++o : --o) {
					results.push(emit(scratch[l++], scratch[l++], scratch[l++], scratch[l++]));
				}
				return results;
			};
		}
		emitter.lerp = function(f) {
			var ref;
			return ref = [1 - f, f], lerp1 = ref[0], lerp2 = ref[1], ref;
		};
		return emitter;
	};
	
	exports.getLerpThunk = function(data1, data2) {
		var n, n1, n2, scratch, thunk1, thunk2;
		n1 = exports.getSizes(data1).reduce(function(a, b) {
			return a * b;
		});
		n2 = exports.getSizes(data2).reduce(function(a, b) {
			return a * b;
		});
		n = Math.min(n1, n2);
		thunk1 = exports.getThunk(data1);
		thunk2 = exports.getThunk(data2);
		scratch = new Float32Array(n);
		scratch.lerp = function(f) {
			var a, b, i, results;
			thunk1.reset();
			thunk2.reset();
			i = 0;
			results = [];
			while (i < n) {
				a = thunk1();
				b = thunk2();
				results.push(scratch[i++] = a + (b - a) * f);
			}
			return results;
		};
		return scratch;
	};
	
	
	/***/ }),
	/* 74 */
	/***/ (function(module, exports) {
	
	var ease, ;
	
	 = Math.PI;
	
	ease = {
		clamp: function(x, a, b) {
			return Math.max(a, Math.min(b, x));
		},
		cosine: function(x) {
			return .5 - .5 * Math.cos(ease.clamp(x, 0, 1) * );
		},
		binary: function(x) {
			return +(x >= .5);
		},
		hold: function(x) {
			return +(x >= 1);
		}
	};
	
	module.exports = ease;
	
	
	/***/ }),
	/* 75 */
	/***/ (function(module, exports) {
	
	var index, letters, parseOrder, toFloatString, toType,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	letters = 'xyzw'.split('');
	
	index = {
		0: -1,
		x: 0,
		y: 1,
		z: 2,
		w: 3
	};
	
	parseOrder = function(order) {
		if (order === "" + order) {
			order = order.split('');
		}
		if (order === +order) {
			order = [order];
		}
		return order;
	};
	
	toType = function(type) {
		if (type === +type) {
			type = 'vec' + type;
		}
		if (type === 'vec1') {
			type = 'float';
		}
		return type;
	};
	
	toFloatString = function(value) {
		value = "" + value;
		if (value.indexOf('.') < 0) {
			return value += '.0';
		}
	};
	
	exports.mapByte2FloatOffset = function(stretch) {
		var factor;
		if (stretch == null) {
			stretch = 4;
		}
		factor = toFloatString(stretch);
		return "vec4 float2ByteIndex(vec4 xyzw, out float channelIndex) {\n  float relative = xyzw.w / " + factor + ";\n  float w = floor(relative);\n  channelIndex = (relative - w) * " + factor + ";\n  return vec4(xyzw.xyz, w);\n}";
	};
	
	exports.sample2DArray = function(textures) {
		var body, divide;
		divide = function(a, b) {
			var mid, out;
			if (a === b) {
				out = "return texture2D(dataTextures[" + a + "], uv);";
			} else {
				mid = Math.ceil(a + (b - a) / 2);
				out = "if (z < " + (mid - .5) + ") {\n  " + (divide(a, mid - 1)) + "\n}\nelse {\n  " + (divide(mid, b)) + "\n}";
			}
			return out = out.replace(/\n/g, "\n  ");
		};
		body = divide(0, textures - 1);
		return "uniform sampler2D dataTextures[" + textures + "];\n\nvec4 sample2DArray(vec2 uv, float z) {\n  " + body + "\n}";
	};
	
	exports.binaryOperator = function(type, op, curry) {
		type = toType(type);
		if (curry != null) {
			return type + " binaryOperator(" + type + " a) {\n  return a " + op + " " + curry + ";\n}";
		} else {
			return type + " binaryOperator(" + type + " a, " + type + " b) {\n  return a " + op + " b;\n}";
		}
	};
	
	exports.extendVec = function(from, to, value) {
		var ctor, diff, k, parts, results;
		if (value == null) {
			value = 0;
		}
		if (from > to) {
			return exports.truncateVec(from, to);
		}
		diff = to - from;
		from = toType(from);
		to = toType(to);
		value = toFloatString(value);
		parts = (function() {
			results = [];
			for (var k = 0; 0 <= diff ? k <= diff : k >= diff; 0 <= diff ? k++ : k--){ results.push(k); }
			return results;
		}).apply(this).map(function(x) {
			if (x) {
				return value;
			} else {
				return 'v';
			}
		});
		ctor = parts.join(',');
		return to + " extendVec(" + from + " v) { return " + to + "(" + ctor + "); }";
	};
	
	exports.truncateVec = function(from, to) {
		var swizzle;
		if (from < to) {
			return exports.extendVec(from, to);
		}
		swizzle = '.' + ('xyzw'.substr(0, to));
		from = toType(from);
		to = toType(to);
		return to + " truncateVec(" + from + " v) { return v" + swizzle + "; }";
	};
	
	exports.injectVec4 = function(order) {
		var args, channel, i, k, len, mask, swizzler;
		swizzler = ['0.0', '0.0', '0.0', '0.0'];
		order = parseOrder(order);
		order = order.map(function(v) {
			if (v === "" + v) {
				return index[v];
			} else {
				return v;
			}
		});
		for (i = k = 0, len = order.length; k < len; i = ++k) {
			channel = order[i];
			swizzler[channel] = ['a', 'b', 'c', 'd'][i];
		}
		mask = swizzler.slice(0, 4).join(', ');
		args = ['float a', 'float b', 'float c', 'float d'].slice(0, order.length);
		return "vec4 inject(" + args + ") {\n  return vec4(" + mask + ");\n}";
	};
	
	exports.swizzleVec4 = function(order, size) {
		var lookup, mask;
		if (size == null) {
			size = null;
		}
		lookup = ['0.0', 'xyzw.x', 'xyzw.y', 'xyzw.z', 'xyzw.w'];
		if (size == null) {
			size = order.length;
		}
		order = parseOrder(order);
		order = order.map(function(v) {
			var ref;
			if (ref = +v, indexOf.call([0, 1, 2, 3, 4], ref) >= 0) {
				v = +v;
			}
			if (v === "" + v) {
				v = index[v] + 1;
			}
			return lookup[v];
		});
		while (order.length < size) {
			order.push('0.0');
		}
		mask = order.join(', ');
		return ("vec" + size + " swizzle(vec4 xyzw) {\n  return vec" + size + "(" + mask + ");\n}").replace(/vec1/g, 'float');
	};
	
	exports.invertSwizzleVec4 = function(order) {
		var i, j, k, len, letter, mask, src, swizzler;
		swizzler = ['0.0', '0.0', '0.0', '0.0'];
		order = parseOrder(order);
		order = order.map(function(v) {
			if (v === +v) {
				return letters[v - 1];
			} else {
				return v;
			}
		});
		for (i = k = 0, len = order.length; k < len; i = ++k) {
			letter = order[i];
			src = letters[i];
			j = index[letter];
			swizzler[j] = "xyzw." + src;
		}
		mask = swizzler.join(', ');
		return "vec4 invertSwizzle(vec4 xyzw) {\n  return vec4(" + mask + ");\n}";
	};
	
	exports.identity = function(type) {
		var args;
		args = [].slice.call(arguments);
		if (args.length > 1) {
			args = args.map(function(t, i) {
				return ['inout', t, String.fromCharCode(97 + i)].join(' ');
			});
			args = args.join(', ');
			return "void identity(" + args + ") { }";
		} else {
			return type + " identity(" + type + " x) {\n  return x;\n}";
		}
	};
	
	exports.constant = function(type, value) {
		return type + " constant() {\n  return " + value + ";\n}";
	};
	
	exports.toType = toType;
	
	
	/***/ }),
	/* 76 */
	/***/ (function(module, exports) {
	
	exports.merge = function() {
		var i, k, len, obj, v, x;
		x = {};
		for (i = 0, len = arguments.length; i < len; i++) {
			obj = arguments[i];
			for (k in obj) {
				v = obj[k];
				x[k] = v;
			}
		}
		return x;
	};
	
	exports.clone = function(o) {
		return JSON.parse(JSON.serialize(o));
	};
	
	exports.parseQuoted = function(str) {
		var accum, char, chunk, i, len, list, munch, quote, token, unescape;
		accum = "";
		unescape = function(str) {
			return str = str.replace(/\\/g, '');
		};
		munch = function(next) {
			if (accum.length) {
				list.push(unescape(accum));
			}
			return accum = next != null ? next : "";
		};
		str = str.split(/(?=(?:\\.|["' ,]))/g);
		quote = false;
		list = [];
		for (i = 0, len = str.length; i < len; i++) {
			chunk = str[i];
			char = chunk[0];
			token = chunk.slice(1);
			switch (char) {
				case '"':
				case "'":
					if (quote) {
						if (quote === char) {
							quote = false;
							munch(token);
						} else {
							accum += chunk;
						}
					} else {
						if (accum !== '') {
							throw new Error("ParseError: String `" + str + "` does not contain comma-separated quoted tokens.");
						}
						quote = char;
						accum += token;
					}
					break;
				case ' ':
				case ',':
					if (!quote) {
						munch(token);
					} else {
						accum += chunk;
					}
					break;
				default:
					accum += chunk;
			}
		}
		munch();
		return list;
	};
	
	
	/***/ }),
	/* 77 */
	/***/ (function(module, exports) {
	
	var NUMBER_PRECISION, NUMBER_THRESHOLD, checkFactor, checkUnit, escapeHTML, formatFactors, formatFraction, formatMultiple, formatPrimes, prettyFormat, prettyJSXBind, prettyJSXPair, prettyJSXProp, prettyMarkup, prettyNumber, prettyPrint;
	
	NUMBER_PRECISION = 5;
	
	NUMBER_THRESHOLD = 0.0001;
	
	checkFactor = function(v, f) {
		return Math.abs(v / f - Math.round(v / f)) < NUMBER_THRESHOLD;
	};
	
	checkUnit = function(v) {
		return checkFactor(v, 1);
	};
	
	formatMultiple = function(v, f, k, compact) {
		var d;
		d = Math.round(v / f);
		if (d === 1) {
			return "" + k;
		}
		if (d === -1) {
			return "-" + k;
		}
		if (k === '1') {
			return "" + d;
		}
		if (compact) {
			return "" + d + k;
		} else {
			return d + "*" + k;
		}
	};
	
	formatFraction = function(v, f, k, compact) {
		var d;
		d = Math.round(v * f);
		if (Math.abs(d) === 1) {
			d = d < 0 ? "-" : "";
			d += k;
		} else if (k !== '1') {
			d += compact ? "" + k : "*" + k;
		}
		return d + "/" + f;
	};
	
	formatFactors = [
		{
			1: 1
		}, {
			1: 1,
			: Math.PI * 2
		}, {
			1: 1,
			: Math.PI
		}, {
			1: 1,
			: Math.PI * 2,
			: Math.PI
		}, {
			1: 1,
			e: Math.E
		}, {
			1: 1,
			: Math.PI * 2,
			e: Math.E
		}, {
			1: 1,
			: Math.PI,
			e: Math.E
		}, {
			1: 1,
			: Math.PI * 2,
			: Math.PI,
			e: Math.E
		}
	];
	
	formatPrimes = [[2 * 2 * 3 * 5 * 7, [2, 3, 5, 7]], [2 * 2 * 2 * 3 * 3 * 5 * 5 * 7 * 7, [2, 3, 5, 7]], [2 * 2 * 3 * 5 * 7 * 11 * 13, [2, 3, 5, 7, 11, 13]], [2 * 2 * 17 * 19 * 23 * 29, [2, 17, 19, 23, 29]], [256 * 256, [2]], [1000000, [2, 5]]];
	
	prettyNumber = function(options) {
		var cache, cacheIndex, compact, e, formatIndex, numberCache, pi, precision, tau, threshold;
		if (options) {
			cache = options.cache, compact = options.compact, tau = options.tau, pi = options.pi, e = options.e, threshold = options.threshold, precision = options.precision;
		}
		compact = +(!!(compact != null ? compact : true));
		tau = +(!!(tau != null ? tau : true));
		pi = +(!!(pi != null ? pi : true));
		e = +(!!(e != null ? e : true));
		cache = +(!!(cache != null ? cache : true));
		threshold = +(threshold != null ? threshold : NUMBER_THRESHOLD);
		precision = +(precision != null ? precision : NUMBER_PRECISION);
		formatIndex = tau + pi * 2 + e * 4;
		cacheIndex = formatIndex + threshold + precision;
		numberCache = cache ? {} : null;
		return function(v) {
			var best, cached, d, denom, f, i, j, k, len, len1, list, match, n, numer, out, p, ref, ref1;
			if (numberCache != null) {
				if ((cached = numberCache[v]) != null) {
					return cached;
				}
				if (v === Math.round(v)) {
					return numberCache[v] = "" + v;
				}
			}
			out = "" + v;
			best = out.length + out.indexOf('.') + 2;
			match = function(x) {
				var d;
				d = x.length;
				if (d <= best) {
					out = "" + x;
					return best = d;
				}
			};
			ref = formatFactors[formatIndex];
			for (k in ref) {
				f = ref[k];
				if (checkUnit(v / f)) {
					match("" + (formatMultiple(v / f, 1, k, compact)));
				} else {
					for (i = 0, len = formatPrimes.length; i < len; i++) {
						ref1 = formatPrimes[i], denom = ref1[0], list = ref1[1];
						numer = v / f * denom;
						if (checkUnit(numer)) {
							for (j = 0, len1 = list.length; j < len1; j++) {
								p = list[j];
								while (checkUnit(n = numer / p) && checkUnit(d = denom / p)) {
									numer = n;
									denom = d;
								}
							}
							match("" + (formatFraction(v / f, denom, k, compact)));
							break;
						}
					}
				}
			}
			if (("" + v).length > NUMBER_PRECISION) {
				match("" + (v.toPrecision(NUMBER_PRECISION)));
			}
			if (numberCache != null) {
				numberCache[v] = out;
			}
			return out;
		};
	};
	
	prettyPrint = function(markup, level) {
		if (level == null) {
			level = 'info';
		}
		markup = prettyMarkup(markup);
		return console[level].apply(console, markup);
	};
	
	prettyMarkup = function(markup) {
		var args, attr, nested, obj, quoted, str, tag, txt;
		tag = 'color:rgb(128,0,128)';
		attr = 'color:rgb(144,64,0)';
		str = 'color:rgb(0,0,192)';
		obj = 'color:rgb(0,70,156)';
		txt = 'color:inherit';
		quoted = false;
		nested = 0;
		args = [];
		markup = markup.replace(/(\\[<={}> "'])|(=>|[<={}> "'])/g, function(_, escape, char) {
			var res;
			if (escape != null ? escape.length : void 0) {
				return escape;
			}
			if (quoted && (char !== '"' && char !== "'")) {
				return char;
			}
			if (nested && (char !== '"' && char !== "'" && char !== '{' && char !== "}")) {
				return char;
			}
			return res = (function() {
				switch (char) {
					case '<':
						args.push(tag);
						return "%c<";
					case '>':
						args.push(tag);
						args.push(txt);
						return "%c>%c";
					case ' ':
						args.push(attr);
						return " %c";
					case '=':
					case '=>':
						args.push(tag);
						return "%c" + char;
					case '"':
					case "'":
						quoted = !quoted;
						if (quoted) {
							args.push(nested ? attr : str);
							return char + "%c";
						} else {
							args.push(nested ? obj : tag);
							return "%c" + char;
						}
						break;
					case '{':
						if (nested++ === 0) {
							args.push(obj);
							return "%c" + char;
						} else {
							return char;
						}
						break;
					case '}':
						if (--nested === 0) {
							args.push(tag);
							return char + "%c";
						} else {
							return char;
						}
						break;
					default:
						return char;
				}
			})();
		});
		return [markup].concat(args);
	};
	
	prettyJSXProp = function(k, v) {
		return prettyJSXPair(k, v, '=');
	};
	
	prettyJSXBind = function(k, v) {
		return prettyJSXPair(k, v, '=>');
	};
	
	prettyJSXPair = (function() {
		var formatNumber;
		formatNumber = prettyNumber({
			compact: false
		});
		return function(k, v, op) {
			var key, value, wrap;
			key = function(k) {
				if ((k === "" + +k) || k.match(/^[A-Za-z_][A-Za-z0-9]*$/)) {
					return k;
				} else {
					return JSON.stringify(k);
				}
			};
			wrap = function(v) {
				if (v.match('\n*"')) {
					return v;
				} else {
					return "{" + v + "}";
				}
			};
			value = function(v) {
				var kk, vv;
				if (v instanceof Array) {
					return "[" + (v.map(value).join(', ')) + "]";
				}
				switch (typeof v) {
					case 'string':
						if (v.match("\n")) {
							return "\"\n" + v + "\"\n";
						} else {
							return "\"" + v + "\"";
						}
						break;
					case 'function':
						v = "" + v;
						if (v.match("\n")) {
							"\n" + v + "\n";
						} else {
							"" + v;
						}
						v = v.replace(/^function (\([^)]*\))/, "$1 =>");
						return v = v.replace(/^(\([^)]*\)) =>\s*{\s*return\s*([^}]+)\s*;\s*}/, "$1 => $2");
					case 'number':
						return formatNumber(v);
					default:
						if ((v != null) && v !== !!v) {
							if (v._up != null) {
								return value(v.map(function(v) {
									return v;
								}));
							}
							if (v.toMarkup) {
								return v.toString();
							} else {
								return "{" + ((function() {
									var results;
									results = [];
									for (kk in v) {
										vv = v[kk];
										if (v.hasOwnProperty(kk)) {
											results.push((key(kk)) + ": " + (value(vv)));
										}
									}
									return results;
								})()).join(", ") + "}";
							}
						} else {
							return "" + (JSON.stringify(v));
						}
				}
			};
			return [k, op, wrap(value(v))].join('');
		};
	})();
	
	escapeHTML = function(str) {
		str = str.replace(/&/g, '&amp;');
		str = str.replace(/</g, '&lt;');
		return str = str.replace(/"/g, '&quot;');
	};
	
	prettyFormat = function(str) {
		var arg, args, i, len, out;
		args = [].slice.call(arguments);
		args.shift();
		out = "<span>";
		str = escapeHTML(str);
		for (i = 0, len = args.length; i < len; i++) {
			arg = args[i];
			str = str.replace(/%([a-z])/, function(_, f) {
				var v;
				v = args.shift();
				switch (f) {
					case 'c':
						return "</span><span style=\"" + (escapeHTML(v)) + "\">";
					default:
						return escapeHTML(v);
				}
			});
		}
		out += str;
		return out += "</span>";
	};
	
	module.exports = {
		markup: prettyMarkup,
		number: prettyNumber,
		print: prettyPrint,
		format: prettyFormat,
		JSX: {
			prop: prettyJSXProp,
			bind: prettyJSXBind
		}
	};
	
	
	/*
	for x in [1, 2, 1/2, 3, 1/3, Math.PI, Math.PI / 2, Math.PI * 2, Math.PI * 3, Math.PI * 4, Math.PI * 3 / 4, Math.E * 100, Math.E / 100]
		console.log prettyNumber({})(x)
	 */
	
	
	/***/ }),
	/* 78 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var THREE;
	
	THREE = __webpack_require__(1);
	
	exports.paramToGL = function(gl, p) {
		if (p === THREE.RepeatWrapping) {
			return gl.REPEAT;
		}
		if (p === THREE.ClampToEdgeWrapping) {
			return gl.CLAMP_TO_EDGE;
		}
		if (p === THREE.MirroredRepeatWrapping) {
			return gl.MIRRORED_REPEAT;
		}
		if (p === THREE.NearestFilter) {
			return gl.NEAREST;
		}
		if (p === THREE.NearestMipMapNearestFilter) {
			return gl.NEAREST_MIPMAP_NEAREST;
		}
		if (p === THREE.NearestMipMapLinearFilter) {
			return gl.NEAREST_MIPMAP_LINEAR;
		}
		if (p === THREE.LinearFilter) {
			return gl.LINEAR;
		}
		if (p === THREE.LinearMipMapNearestFilter) {
			return gl.LINEAR_MIPMAP_NEAREST;
		}
		if (p === THREE.LinearMipMapLinearFilter) {
			return gl.LINEAR_MIPMAP_LINEAR;
		}
		if (p === THREE.UnsignedByteType) {
			return gl.UNSIGNED_BYTE;
		}
		if (p === THREE.UnsignedShort4444Type) {
			return gl.UNSIGNED_SHORT_4_4_4_4;
		}
		if (p === THREE.UnsignedShort5551Type) {
			return gl.UNSIGNED_SHORT_5_5_5_1;
		}
		if (p === THREE.UnsignedShort565Type) {
			return gl.UNSIGNED_SHORT_5_6_5;
		}
		if (p === THREE.ByteType) {
			return gl.BYTE;
		}
		if (p === THREE.ShortType) {
			return gl.SHORT;
		}
		if (p === THREE.UnsignedShortType) {
			return gl.UNSIGNED_SHORT;
		}
		if (p === THREE.IntType) {
			return gl.INT;
		}
		if (p === THREE.UnsignedIntType) {
			return gl.UNSIGNED_INT;
		}
		if (p === THREE.FloatType) {
			return gl.FLOAT;
		}
		if (p === THREE.AlphaFormat) {
			return gl.ALPHA;
		}
		if (p === THREE.RGBFormat) {
			return gl.RGB;
		}
		if (p === THREE.RGBAFormat) {
			return gl.RGBA;
		}
		if (p === THREE.LuminanceFormat) {
			return gl.LUMINANCE;
		}
		if (p === THREE.LuminanceAlphaFormat) {
			return gl.LUMINANCE_ALPHA;
		}
		if (p === THREE.AddEquation) {
			return gl.FUNC_ADD;
		}
		if (p === THREE.SubtractEquation) {
			return gl.FUNC_SUBTRACT;
		}
		if (p === THREE.ReverseSubtractEquation) {
			return gl.FUNC_REVERSE_SUBTRACT;
		}
		if (p === THREE.ZeroFactor) {
			return gl.ZERO;
		}
		if (p === THREE.OneFactor) {
			return gl.ONE;
		}
		if (p === THREE.SrcColorFactor) {
			return gl.SRC_COLOR;
		}
		if (p === THREE.OneMinusSrcColorFactor) {
			return gl.ONE_MINUS_SRC_COLOR;
		}
		if (p === THREE.SrcAlphaFactor) {
			return gl.SRC_ALPHA;
		}
		if (p === THREE.OneMinusSrcAlphaFactor) {
			return gl.ONE_MINUS_SRC_ALPHA;
		}
		if (p === THREE.DstAlphaFactor) {
			return gl.DST_ALPHA;
		}
		if (p === THREE.OneMinusDstAlphaFactor) {
			return gl.ONE_MINUS_DST_ALPHA;
		}
		if (p === THREE.DstColorFactor) {
			return gl.DST_COLOR;
		}
		if (p === THREE.OneMinusDstColorFactor) {
			return gl.ONE_MINUS_DST_COLOR;
		}
		if (p === THREE.SrcAlphaSaturateFactor) {
			return gl.SRC_ALPHA_SATURATE;
		}
		return 0;
	};
	
	exports.paramToArrayStorage = function(type) {
		switch (type) {
			case THREE.UnsignedByteType:
				return Uint8Array;
			case THREE.ByteType:
				return Int8Array;
			case THREE.ShortType:
				return Int16Array;
			case THREE.UnsignedShortType:
				return Uint16Array;
			case THREE.IntType:
				return Int32Array;
			case THREE.UnsignedIntType:
				return Uint32Array;
			case THREE.FloatType:
				return Float32Array;
		}
	};
	
	exports.swizzleToEulerOrder = function(swizzle) {
		return swizzle.map(function(i) {
			return ['', 'X', 'Y', 'Z'][i];
		}).join('');
	};
	
	exports.transformComposer = function() {
		var euler, pos, quat, scl, transform;
		euler = new THREE.Euler;
		quat = new THREE.Quaternion;
		pos = new THREE.Vector3;
		scl = new THREE.Vector3;
		transform = new THREE.Matrix4;
		return function(position, rotation, quaternion, scale, matrix, eulerOrder) {
			if (eulerOrder == null) {
				eulerOrder = 'XYZ';
			}
			if (rotation != null) {
				if (eulerOrder instanceof Array) {
					eulerOrder = exports.swizzleToEulerOrder(eulerOrder);
				}
				euler.setFromVector3(rotation, eulerOrder);
				quat.setFromEuler(euler);
			} else {
				quat.set(0, 0, 0, 1);
			}
			if (quaternion != null) {
				quat.multiply(quaternion);
			}
			if (position != null) {
				pos.copy(position);
			} else {
				pos.set(0, 0, 0);
			}
			if (scale != null) {
				scl.copy(scale);
			} else {
				scl.set(1, 1, 1);
			}
			transform.compose(pos, quat, scl);
			if (matrix != null) {
				transform.multiplyMatrices(transform, matrix);
			}
			return transform;
		};
	};
	
	
	/***/ }),
	/* 79 */
	/***/ (function(module, exports) {
	
	
	/*
	 Generate equally spaced ticks in a range at sensible positions.
	 
	 @param min/max - Minimum and maximum of range
	 @param n - Desired number of ticks in range
	 @param unit - Base unit of scale (e.g. 1 or ).
	 @param scale - Division scale (e.g. 2 = binary division, or 10 = decimal division).
	 @param bias - Integer to bias divisions one or more levels up or down (to create nested scales)
	 @param start - Whether to include a tick at the start
	 @param end - Whether to include a tick at the end
	 @param zero - Whether to include zero as a tick
	 @param nice - Whether to round to a more reasonable interval
	 */
	var LINEAR, LOG, linear, log, make;
	
	linear = function(min, max, n, unit, base, factor, start, end, zero, nice) {
		var distance, f, factors, i, ideal, ref, span, step, steps, ticks;
		if (nice == null) {
			nice = true;
		}
		n || (n = 10);
		unit || (unit = 1);
		base || (base = 10);
		factor || (factor = 1);
		span = max - min;
		ideal = span / n;
		if (!nice) {
			ticks = (function() {
				var j, ref1, results;
				results = [];
				for (i = j = 0, ref1 = n; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
					results.push(min + i * ideal);
				}
				return results;
			})();
			if (!start) {
				ticks.shift();
			}
			if (!end) {
				ticks.pop();
			}
			if (!zero) {
				ticks = ticks.filter(function(x) {
					return x !== 0;
				});
			}
			return ticks;
		}
		unit || (unit = 1);
		base || (base = 10);
		ref = unit * (Math.pow(base, Math.floor(Math.log(ideal / unit) / Math.log(base))));
		factors = base % 2 === 0 ? [base / 2, 1, 1 / 2] : base % 3 === 0 ? [base / 3, 1, 1 / 3] : [1];
		steps = (function() {
			var j, len, results;
			results = [];
			for (j = 0, len = factors.length; j < len; j++) {
				f = factors[j];
				results.push(ref * f);
			}
			return results;
		})();
		distance = 2e308;
		step = steps.reduce(function(ref, step) {
			var d;
			f = step / ideal;
			d = Math.max(f, 1 / f);
			if (d < distance) {
				distance = d;
				return step;
			} else {
				return ref;
			}
		}, ref);
		step *= factor;
		min = (Math.ceil((min / step) + +(!start))) * step;
		max = (Math.floor(max / step) - +(!end)) * step;
		n = Math.ceil((max - min) / step);
		ticks = (function() {
			var j, ref1, results;
			results = [];
			for (i = j = 0, ref1 = n; 0 <= ref1 ? j <= ref1 : j >= ref1; i = 0 <= ref1 ? ++j : --j) {
				results.push(min + i * step);
			}
			return results;
		})();
		if (!zero) {
			ticks = ticks.filter(function(x) {
				return x !== 0;
			});
		}
		return ticks;
	};
	
	
	/*
	 Generate logarithmically spaced ticks in a range at sensible positions.
	 */
	
	log = function(min, max, n, unit, base, bias, start, end, zero, nice) {
		throw new Error("Log ticks not yet implemented.");
	};
	
	LINEAR = 0;
	
	LOG = 1;
	
	make = function(type, min, max, n, unit, base, bias, start, end, zero, nice) {
		switch (type) {
			case LINEAR:
				return linear(min, max, n, unit, base, bias, start, end, zero, nice);
			case LOG:
				return log(min, max, n, unit, base, bias, start, end, zero, nice);
		}
	};
	
	exports.make = make;
	
	exports.linear = linear;
	
	exports.log = log;
	
	
	/***/ }),
	/* 80 */
	/***/ (function(module, exports) {
	
	var HEAP, Types, apply, createClass, descriptor, element, hint, id, j, key, len, map, mount, prop, recycle, ref1, set, unmount, unset;
	
	HEAP = [];
	
	id = 0;
	
	Types = {
	
		/*
		 * el('example', props, children);
		example: MathBox.DOM.createClass({
			render: (el, props, children) ->
				 * VDOM node
				return el('span', { className: "foo" }, "Hello World")
		})
		 */
	};
	
	descriptor = function() {
		return {
			id: id++,
			type: null,
			props: null,
			children: null,
			rendered: null,
			instance: null
		};
	};
	
	hint = function(n) {
		var i, j, ref1, results;
		n *= 2;
		n = Math.max(0, HEAP.length - n);
		results = [];
		for (i = j = 0, ref1 = n; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
			results.push(HEAP.push(descriptor()));
		}
		return results;
	};
	
	element = function(type, props, children) {
		var el;
		el = HEAP.length ? HEAP.pop() : descriptor();
		el.type = type != null ? type : 'div';
		el.props = props != null ? props : null;
		el.children = children != null ? children : null;
		return el;
	};
	
	recycle = function(el) {
		var child, children, j, len;
		if (!el.type) {
			return;
		}
		children = el.children;
		el.type = el.props = el.children = el.instance = null;
		HEAP.push(el);
		if (children != null) {
			for (j = 0, len = children.length; j < len; j++) {
				child = children[j];
				recycle(child);
			}
		}
	};
	
	apply = function(el, last, node, parent, index) {
		var base, child, childNodes, children, comp, dirty, i, j, k, key, l, len, len1, nextChildren, nextProps, nextState, prevProps, prevState, props, ref, ref1, ref2, ref3, ref4, ref5, same, should, type, v, value;
		if (el != null) {
			if (last == null) {
				return mount(el, parent, index);
			} else {
				if (el instanceof Node) {
					same = el === last;
					if (same) {
						return;
					}
				} else {
					same = typeof el === typeof last && last !== null && el !== null && el.type === last.type;
				}
				if (!same) {
					unmount(last.instance, node);
					node.remove();
					return mount(el, parent, index);
				} else {
					el.instance = last.instance;
					type = ((ref1 = el.type) != null ? ref1.isComponentClass : void 0) ? el.type : Types[el.type];
					props = last != null ? last.props : void 0;
					nextProps = el.props;
					children = (ref2 = last != null ? last.children : void 0) != null ? ref2 : null;
					nextChildren = el.children;
					if (nextProps != null) {
						nextProps.children = nextChildren;
					}
					if (type != null) {
						dirty = node._COMPONENT_DIRTY;
						if ((props != null) !== (nextProps != null)) {
							dirty = true;
						}
						if (children !== nextChildren) {
							dirty = true;
						}
						if ((props != null) && (nextProps != null)) {
							if (!dirty) {
								for (key in props) {
									if (!nextProps.hasOwnProperty(key)) {
										dirty = true;
									}
								}
							}
							if (!dirty) {
								for (key in nextProps) {
									value = nextProps[key];
									if ((ref = props[key]) !== value) {
										dirty = true;
									}
								}
							}
						}
						if (dirty) {
							comp = last.instance;
							if (el.props == null) {
								el.props = {};
							}
							ref3 = comp.defaultProps;
							for (k in ref3) {
								v = ref3[k];
								if ((base = el.props)[k] == null) {
									base[k] = v;
								}
							}
							el.props.children = el.children;
							if (typeof comp.willReceiveProps === "function") {
								comp.willReceiveProps(el.props);
							}
							should = node._COMPONENT_FORCE || ((ref4 = typeof comp.shouldUpdate === "function" ? comp.shouldUpdate(el.props) : void 0) != null ? ref4 : true);
							if (should) {
								nextState = comp.getNextState();
								if (typeof comp.willUpdate === "function") {
									comp.willUpdate(el.props, nextState);
								}
							}
							prevProps = comp.props;
							prevState = comp.applyNextState();
							comp.props = el.props;
							comp.children = el.children;
							if (should) {
								el = el.rendered = typeof comp.render === "function" ? comp.render(element, el.props, el.children) : void 0;
								apply(el, last.rendered, node, parent, index);
								if (typeof comp.didUpdate === "function") {
									comp.didUpdate(prevProps, prevState);
								}
							}
						} else {
							el.rendered = last.rendered;
						}
						return;
					} else {
						if (props != null) {
							for (key in props) {
								if (!nextProps.hasOwnProperty(key)) {
									unset(node, key, props[key]);
								}
							}
						}
						if (nextProps != null) {
							for (key in nextProps) {
								value = nextProps[key];
								if ((ref = props[key]) !== value && key !== 'children') {
									set(node, key, value, ref);
								}
							}
						}
						if (nextChildren != null) {
							if ((ref5 = typeof nextChildren) === 'string' || ref5 === 'number') {
								if (nextChildren !== children) {
									node.textContent = nextChildren;
								}
							} else {
								if (nextChildren.type != null) {
									apply(nextChildren, children, node.childNodes[0], node, 0);
								} else {
									childNodes = node.childNodes;
									if (children != null) {
										for (i = j = 0, len = nextChildren.length; j < len; i = ++j) {
											child = nextChildren[i];
											apply(child, children[i], childNodes[i], node, i);
										}
									} else {
										for (i = l = 0, len1 = nextChildren.length; l < len1; i = ++l) {
											child = nextChildren[i];
											apply(child, null, childNodes[i], node, i);
										}
									}
								}
							}
						} else if (children != null) {
							unmount(null, node);
							node.innerHTML = '';
						}
					}
					return;
				}
			}
		}
		if (last != null) {
			unmount(last.instance, node);
			return last.node.remove();
		}
	};
	
	mount = function(el, parent, index) {
		var base, child, children, comp, ctor, i, j, k, key, len, node, ref1, ref2, ref3, ref4, ref5, ref6, type, v, value;
		if (index == null) {
			index = 0;
		}
		type = ((ref1 = el.type) != null ? ref1.isComponentClass : void 0) ? el.type : Types[el.type];
		if (el instanceof Node) {
			node = el;
		} else {
			if (type != null) {
				ctor = ((ref2 = el.type) != null ? ref2.isComponentClass : void 0) ? el.type : Types[el.type];
				if (!ctor) {
					el = el.rendered = element('noscript');
					node = mount(el, parent, index);
					return node;
				}
				el.instance = comp = new ctor(parent);
				if (el.props == null) {
					el.props = {};
				}
				ref3 = comp.defaultProps;
				for (k in ref3) {
					v = ref3[k];
					if ((base = el.props)[k] == null) {
						base[k] = v;
					}
				}
				el.props.children = el.children;
				comp.props = el.props;
				comp.children = el.children;
				comp.setState(typeof comp.getInitialState === "function" ? comp.getInitialState() : void 0);
				if (typeof comp.willMount === "function") {
					comp.willMount();
				}
				el = el.rendered = typeof comp.render === "function" ? comp.render(element, el.props, el.children) : void 0;
				node = mount(el, parent, index);
				if (typeof comp.didMount === "function") {
					comp.didMount(el);
				}
				node._COMPONENT = comp;
				return node;
			} else if ((ref4 = typeof el) === 'string' || ref4 === 'number') {
				node = document.createTextNode(el);
			} else {
				node = document.createElement(el.type);
				ref5 = el.props;
				for (key in ref5) {
					value = ref5[key];
					set(node, key, value);
				}
			}
			children = el.children;
			if (children != null) {
				if ((ref6 = typeof children) === 'string' || ref6 === 'number') {
					node.textContent = children;
				} else {
					if (children.type != null) {
						mount(children, node, 0);
					} else {
						for (i = j = 0, len = children.length; j < len; i = ++j) {
							child = children[i];
							mount(child, node, i);
						}
					}
				}
			}
		}
		parent.insertBefore(node, parent.childNodes[index]);
		return node;
	};
	
	unmount = function(comp, node) {
		var child, j, k, len, ref1, results;
		if (comp) {
			if (typeof comp.willUnmount === "function") {
				comp.willUnmount();
			}
			for (k in comp) {
				delete comp[k];
			}
		}
		ref1 = node.childNodes;
		results = [];
		for (j = 0, len = ref1.length; j < len; j++) {
			child = ref1[j];
			unmount(child._COMPONENT, child);
			results.push(delete child._COMPONENT);
		}
		return results;
	};
	
	prop = function(key) {
		var j, len, prefix, prefixes;
		if (typeof document === 'undefined') {
			return true;
		}
		if (document.documentElement.style[key] != null) {
			return key;
		}
		key = key[0].toUpperCase() + key.slice(1);
		prefixes = ['webkit', 'moz', 'ms', 'o'];
		for (j = 0, len = prefixes.length; j < len; j++) {
			prefix = prefixes[j];
			if (document.documentElement.style[prefix + key] != null) {
				return prefix + key;
			}
		}
	};
	
	map = {};
	
	ref1 = ['transform'];
	for (j = 0, len = ref1.length; j < len; j++) {
		key = ref1[j];
		map[key] = prop(key);
	}
	
	set = function(node, key, value, orig) {
		var k, ref2, v;
		if (key === 'style') {
			for (k in value) {
				v = value[k];
				if ((orig != null ? orig[k] : void 0) !== v) {
					node.style[(ref2 = map[k]) != null ? ref2 : k] = v;
				}
			}
			return;
		}
		if (node[key] != null) {
			node[key] = value;
			return;
		}
		if (node instanceof Node) {
			node.setAttribute(key, value);
		}
	};
	
	unset = function(node, key, orig) {
		var k, ref2, v;
		if (key === 'style') {
			for (k in orig) {
				v = orig[k];
				node.style[(ref2 = map[k]) != null ? ref2 : k] = '';
			}
			return;
		}
		if (node[key] != null) {
			node[key] = void 0;
		}
		if (node instanceof Node) {
			node.removeAttribute(key);
		}
	};
	
	createClass = function(prototype) {
		var Component, a, aliases, b, ref2;
		aliases = {
			willMount: 'componentWillMount',
			didMount: 'componentDidMount',
			willReceiveProps: 'componentWillReceiveProps',
			shouldUpdate: 'shouldComponentUpdate',
			willUpdate: 'componentWillUpdate',
			didUpdate: 'componentDidUpdate',
			willUnmount: 'componentWillUnmount'
		};
		for (a in aliases) {
			b = aliases[a];
			if (prototype[a] == null) {
				prototype[a] = prototype[b];
			}
		}
		Component = (function() {
			function Component(node, props1, state1, children1) {
				var bind, k, nextState, v;
				this.props = props1 != null ? props1 : {};
				this.state = state1 != null ? state1 : null;
				this.children = children1 != null ? children1 : null;
				bind = function(f, self) {
					if (typeof f === 'function') {
						return f.bind(self);
					} else {
						return f;
					}
				};
				for (k in prototype) {
					v = prototype[k];
					this[k] = bind(v, this);
				}
				nextState = null;
				this.setState = function(state) {
					if (nextState == null) {
						nextState = state ? nextState != null ? nextState : {} : null;
					}
					for (k in state) {
						v = state[k];
						nextState[k] = v;
					}
					node._COMPONENT_DIRTY = true;
				};
				this.forceUpdate = function() {
					var el, results;
					node._COMPONENT_FORCE = node._COMPONENT_DIRTY = true;
					el = node;
					results = [];
					while (el = el.parentNode) {
						if (el._COMPONENT) {
							results.push(el._COMPONENT_FORCE = true);
						} else {
							results.push(void 0);
						}
					}
					return results;
				};
				this.getNextState = function() {
					return nextState;
				};
				this.applyNextState = function() {
					var prevState, ref2;
					node._COMPONENT_FORCE = node._COMPONENT_DIRTY = false;
					prevState = this.state;
					ref2 = [null, nextState], nextState = ref2[0], this.state = ref2[1];
					return prevState;
				};
				return;
			}
	
			return Component;
	
		})();
		Component.isComponentClass = true;
		Component.prototype.defaultProps = (ref2 = typeof prototype.getDefaultProps === "function" ? prototype.getDefaultProps() : void 0) != null ? ref2 : {};
		return Component;
	};
	
	module.exports = {
		element: element,
		recycle: recycle,
		apply: apply,
		hint: hint,
		Types: Types,
		createClass: createClass
	};
	
	
	/***/ }),
	/* 81 */
	/***/ (function(module, exports) {
	
	var Guard;
	
	Guard = (function() {
		function Guard(limit1) {
			this.limit = limit1 != null ? limit1 : 10;
		}
	
		Guard.prototype.iterate = function(options) {
			var last, limit, run, step;
			step = options.step, last = options.last;
			limit = this.limit;
			while (run = step()) {
				if (!--limit) {
					console.warn("Last iteration", typeof last === "function" ? last() : void 0);
					throw new Error("Exceeded iteration limit.");
				}
			}
			return null;
		};
	
		return Guard;
	
	})();
	
	module.exports = Guard;
	
	
	/***/ }),
	/* 82 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ALL, AUTO, CLASS, ID, Model, TRAIT, TYPE, cssauron, language,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	cssauron = __webpack_require__(83);
	
	ALL = '*';
	
	ID = /^#([A-Za-z0-9_])$/;
	
	CLASS = /^\.([A-Za-z0-9_]+)$/;
	
	TRAIT = /^\[([A-Za-z0-9_]+)\]$/;
	
	TYPE = /^[A-Za-z0-9_]+$/;
	
	AUTO = /^<([0-9]+|<*)$/;
	
	language = null;
	
	
	/*
	
		Model that wraps a root node and its children.
		
		Monitors adds, removals and ID/class changes.
		Enables CSS selectors, both querying and watching.
	
		Watchers are primed differentially as changes come in,
		and fired with digest().
	 */
	
	Model = (function() {
		function Model(root) {
			var add, addClasses, addID, addNode, addTags, addTraits, addType, adopt, check, dispose, force, hashTags, prime, remove, removeClasses, removeID, removeNode, removeTags, removeTraits, removeType, unhashTags, update;
			this.root = root;
			this.root.model = this;
			this.root.root = this.root;
			this.ids = {};
			this.classes = {};
			this.traits = {};
			this.types = {};
			this.nodes = [];
			this.watchers = [];
			this.fire = false;
			this.lastNode = null;
			this.event = {
				type: 'update'
			};
			if (language == null) {
				language = cssauron({
					tag: 'type',
					id: 'id',
					"class": "classes.join(' ')",
					parent: 'parent',
					children: 'children',
					attr: 'traits.hash[attr]'
				});
			}
			add = (function(_this) {
				return function(event) {
					return adopt(event.node);
				};
			})(this);
			remove = (function(_this) {
				return function(event) {
					return dispose(event.node);
				};
			})(this);
			this.root.on('add', add);
			this.root.on('remove', remove);
			adopt = (function(_this) {
				return function(node) {
					addNode(node);
					addType(node);
					addTraits(node);
					node.on('change:node', update);
					update(null, node, true);
					return force(node);
				};
			})(this);
			dispose = (function(_this) {
				return function(node) {
					removeNode(node);
					removeType(node);
					removeTraits(node);
					removeID(node.id, node);
					removeClasses(node.classes, node);
					node.off('change:node', update);
					return force(node);
				};
			})(this);
			prime = (function(_this) {
				return function(node) {
					var i, len, ref, watcher;
					ref = _this.watchers;
					for (i = 0, len = ref.length; i < len; i++) {
						watcher = ref[i];
						watcher.match = watcher.matcher(node);
					}
					return null;
				};
			})(this);
			check = (function(_this) {
				return function(node) {
					var fire, i, len, ref, watcher;
					ref = _this.watchers;
					for (i = 0, len = ref.length; i < len; i++) {
						watcher = ref[i];
						fire = watcher.fire || (watcher.fire = watcher.match !== watcher.matcher(node));
						if (fire) {
							_this.lastNode = node;
						}
						_this.fire || (_this.fire = fire);
					}
					return null;
				};
			})(this);
			force = (function(_this) {
				return function(node) {
					var fire, i, len, ref, watcher;
					ref = _this.watchers;
					for (i = 0, len = ref.length; i < len; i++) {
						watcher = ref[i];
						fire = watcher.fire || (watcher.fire = watcher.matcher(node));
						if (fire) {
							_this.lastNode = node;
						}
						_this.fire || (_this.fire = fire);
					}
					return null;
				};
			})(this);
			this.digest = (function(_this) {
				return function() {
					var i, len, ref, watcher;
					if (!_this.fire) {
						return false;
					}
					ref = _this.watchers.slice();
					for (i = 0, len = ref.length; i < len; i++) {
						watcher = ref[i];
						if (!watcher.fire) {
							continue;
						}
						watcher.fire = false;
						watcher.handler();
					}
					_this.fire = false;
					return true;
				};
			})(this);
			update = (function(_this) {
				return function(event, node, init) {
					var _id, _klass, classes, id, klass, primed, ref, ref1;
					_id = init || event.changed['node.id'];
					_klass = init || event.changed['node.classes'];
					primed = false;
					if (_id) {
						id = node.get('node.id');
						if (id !== node.id) {
							if (!init) {
								prime(node);
							}
							primed = true;
							if (node.id != null) {
								removeID(node.id, node);
							}
							addID(id, node);
						}
					}
					if (_klass) {
						classes = (ref = node.get('node.classes')) != null ? ref : [];
						klass = classes.join(',');
						if (klass !== ((ref1 = node.classes) != null ? ref1.klass : void 0)) {
							classes = classes.slice();
							if (!(init || primed)) {
								prime(node);
							}
							primed = true;
							if (node.classes != null) {
								removeClasses(node.classes, node);
							}
							addClasses(classes, node);
							node.classes = classes;
							node.classes.klass = klass;
						}
					}
					if (!init && primed) {
						check(node);
					}
					return null;
				};
			})(this);
			addTags = function(sets, tags, node) {
				var i, k, len, list, ref;
				if (tags == null) {
					return;
				}
				for (i = 0, len = tags.length; i < len; i++) {
					k = tags[i];
					list = (ref = sets[k]) != null ? ref : [];
					list.push(node);
					sets[k] = list;
				}
				return null;
			};
			removeTags = function(sets, tags, node) {
				var i, index, k, len, list;
				if (tags == null) {
					return;
				}
				for (i = 0, len = tags.length; i < len; i++) {
					k = tags[i];
					list = sets[k];
					index = list.indexOf(node);
					if (index >= 0) {
						list.splice(index, 1);
					}
					if (list.length === 0) {
						delete sets[k];
					}
				}
				return null;
			};
			hashTags = function(array) {
				var hash, i, klass, len, results;
				if (!(array.length > 0)) {
					return;
				}
				hash = array.hash = {};
				results = [];
				for (i = 0, len = array.length; i < len; i++) {
					klass = array[i];
					results.push(hash[klass] = true);
				}
				return results;
			};
			unhashTags = function(array) {
				return delete array.hash;
			};
			addID = (function(_this) {
				return function(id, node) {
					if (_this.ids[id]) {
						throw new Error("Duplicate node id `" + id + "`");
					}
					if (id != null) {
						_this.ids[id] = [node];
					}
					return node.id = id != null ? id : node._id;
				};
			})(this);
			removeID = (function(_this) {
				return function(id, node) {
					if (id != null) {
						delete _this.ids[id];
					}
					return node.id = node._id;
				};
			})(this);
			addClasses = (function(_this) {
				return function(classes, node) {
					addTags(_this.classes, classes, node);
					if (classes != null) {
						return hashTags(classes);
					}
				};
			})(this);
			removeClasses = (function(_this) {
				return function(classes, node) {
					removeTags(_this.classes, classes, node);
					if (classes != null) {
						return unhashTags(classes);
					}
				};
			})(this);
			addNode = (function(_this) {
				return function(node) {
					return _this.nodes.push(node);
				};
			})(this);
			removeNode = (function(_this) {
				return function(node) {
					return _this.nodes.splice(_this.nodes.indexOf(node), 1);
				};
			})(this);
			addType = (function(_this) {
				return function(node) {
					return addTags(_this.types, [node.type], node);
				};
			})(this);
			removeType = (function(_this) {
				return function(node) {
					return removeTags(_this.types, [node.type], node);
				};
			})(this);
			addTraits = (function(_this) {
				return function(node) {
					addTags(_this.traits, node.traits, node);
					return hashTags(node.traits);
				};
			})(this);
			removeTraits = (function(_this) {
				return function(node) {
					removeTags(_this.traits, node.traits, node);
					return unhashTags(node.traits);
				};
			})(this);
			adopt(this.root);
			this.root.trigger({
				type: 'added'
			});
		}
	
		Model.prototype.filter = function(nodes, selector) {
			var i, len, matcher, node, results;
			matcher = this._matcher(selector);
			results = [];
			for (i = 0, len = nodes.length; i < len; i++) {
				node = nodes[i];
				if (matcher(node)) {
					results.push(node);
				}
			}
			return results;
		};
	
		Model.prototype.ancestry = function(nodes, parents) {
			var i, len, node, out, parent;
			out = [];
			for (i = 0, len = nodes.length; i < len; i++) {
				node = nodes[i];
				parent = node.parent;
				while (parent != null) {
					if (indexOf.call(parents, parent) >= 0) {
						out.push(node);
						break;
					}
					parent = parent.parent;
				}
			}
			return out;
		};
	
		Model.prototype.select = function(selector, parents) {
			var matches;
			matches = this._select(selector);
			if (parents != null) {
				matches = this.ancestry(matches, parents);
			}
			matches.sort(function(a, b) {
				return b.order - a.order;
			});
			return matches;
		};
	
		Model.prototype.watch = function(selector, handler) {
			var watcher;
			handler.unwatch = (function(_this) {
				return function() {
					return _this.unwatch(handler);
				};
			})(this);
			handler.watcher = watcher = {
				selector: selector,
				handler: handler,
				matcher: this._matcher(selector),
				match: false,
				fire: false
			};
			this.watchers.push(watcher);
			return this.select(selector);
		};
	
		Model.prototype.unwatch = function(handler) {
			var watcher;
			watcher = handler.watcher;
			if (watcher == null) {
				return;
			}
			this.watchers.splice(this.watchers.indexOf(watcher), 1);
			delete handler.unwatch;
			return delete handler.watcher;
		};
	
		Model.prototype._simplify = function(s) {
			var all, auto, found, id, klass, ref, ref1, ref2, ref3, ref4, trait, type;
			s = s.replace(/^\s+/, '');
			s = s.replace(/\s+$/, '');
			found = all = s === ALL;
			if (!found) {
				found = id = (ref = s.match(ID)) != null ? ref[1] : void 0;
			}
			if (!found) {
				found = klass = (ref1 = s.match(CLASS)) != null ? ref1[1] : void 0;
			}
			if (!found) {
				found = trait = (ref2 = s.match(TRAIT)) != null ? ref2[1] : void 0;
			}
			if (!found) {
				found = type = (ref3 = s.match(TYPE)) != null ? ref3[0] : void 0;
			}
			if (!found) {
				found = auto = (ref4 = s.match(AUTO)) != null ? ref4[0] : void 0;
			}
			return [all, id, klass, trait, type, auto];
		};
	
		Model.prototype._matcher = function(s) {
			var all, auto, id, klass, ref, trait, type;
			ref = this._simplify(s), all = ref[0], id = ref[1], klass = ref[2], trait = ref[3], type = ref[4], auto = ref[5];
			if (all) {
				return (function(node) {
					return true;
				});
			}
			if (id) {
				return (function(node) {
					return node.id === id;
				});
			}
			if (klass) {
				return (function(node) {
					var ref1, ref2;
					return (ref1 = node.classes) != null ? (ref2 = ref1.hash) != null ? ref2[klass] : void 0 : void 0;
				});
			}
			if (trait) {
				return (function(node) {
					var ref1, ref2;
					return (ref1 = node.traits) != null ? (ref2 = ref1.hash) != null ? ref2[trait] : void 0 : void 0;
				});
			}
			if (type) {
				return (function(node) {
					return node.type === type;
				});
			}
			if (auto) {
				throw "Auto-link matcher unsupported";
			}
			return language(s);
		};
	
		Model.prototype._select = function(s) {
			var all, id, klass, ref, ref1, ref2, ref3, ref4, trait, type;
			ref = this._simplify(s), all = ref[0], id = ref[1], klass = ref[2], trait = ref[3], type = ref[4];
			if (all) {
				return this.nodes;
			}
			if (id) {
				return (ref1 = this.ids[id]) != null ? ref1 : [];
			}
			if (klass) {
				return (ref2 = this.classes[klass]) != null ? ref2 : [];
			}
			if (trait) {
				return (ref3 = this.traits[trait]) != null ? ref3 : [];
			}
			if (type) {
				return (ref4 = this.types[type]) != null ? ref4 : [];
			}
			return this.filter(this.nodes, s);
		};
	
		Model.prototype.getRoot = function() {
			return this.root;
		};
	
		Model.prototype.getLastTrigger = function() {
			return this.lastNode.toString();
		};
	
		return Model;
	
	})();
	
	module.exports = Model;
	
	
	/***/ }),
	/* 83 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = language
	
	var tokenizer = __webpack_require__(84)
	
	function language(lookups, matchComparison) {
		return function(selector) {
			return parse(selector, remap(lookups),
									 matchComparison || caseSensitiveComparison)
		}
	}
	
	function remap(opts) {
		for(var key in opts) if(opt_okay(opts, key)) {
			opts[key] = Function(
					'return function(node, attr) { return node.' + opts[key] + ' }'
			)
			opts[key] = opts[key]()
		}
	
		return opts
	}
	
	function opt_okay(opts, key) {
		return opts.hasOwnProperty(key) && typeof opts[key] === 'string'
	}
	
	function parse(selector, options, matchComparison) {
		var stream = tokenizer()
			, default_subj = true
			, selectors = [[]]
			, traversal
			, bits
	
		bits = selectors[0]
	
		traversal = {
				'': any_parents
			, '>': direct_parent
			, '+': direct_sibling
			, '~': any_sibling
		}
	
		stream
			.on('data', group)
			.end(selector)
	
		function group(token) {
			var crnt
	
			if(token.type === 'comma') {
				selectors.unshift(bits = [])
	
				return
			}
	
			if(token.type === 'op' || token.type === 'any-child') {
				bits.unshift(traversal[token.data])
				bits.unshift(check())
	
				return
			}
	
			bits[0] = bits[0] || check()
			crnt = bits[0]
	
			if(token.type === '!') {
				crnt.subject =
				selectors[0].subject = true
	
				return
			}
	
			crnt.push(
					token.type === 'class' ? listContains(token.type, token.data) :
					token.type === 'attr' ? attr(token) :
					token.type === ':' || token.type === '::' ? pseudo(token) :
					token.type === '*' ? Boolean :
					matches(token.type, token.data, matchComparison)
			)
		}
	
		return selector_fn
	
		function selector_fn(node, as_boolean) {
			var current
				, length
				, orig
				, subj
				, set
	
			orig = node
			set = []
	
			for(var i = 0, len = selectors.length; i < len; ++i) {
				bits = selectors[i]
				current = entry
				length = bits.length
				node = orig
				subj = []
	
				for(var j = 0; j < length; j += 2) {
					node = current(node, bits[j], subj)
	
					if(!node) {
						break
					}
	
					current = bits[j + 1]
				}
	
				if(j >= length) {
					if(as_boolean) {
						return true
					}
	
					add(!bits.subject ? [orig] : subj)
				}
			}
	
			if(as_boolean) {
				return false
			}
	
			return !set.length ? false :
							set.length === 1 ? set[0] :
							set
	
			function add(items) {
				var next
	
				while(items.length) {
					next = items.shift()
	
					if(set.indexOf(next) === -1) {
						set.push(next)
					}
				}
			}
		}
	
		function check() {
			_check.bits = []
			_check.subject = false
			_check.push = function(token) {
				_check.bits.push(token)
			}
	
			return _check
	
			function _check(node, subj) {
				for(var i = 0, len = _check.bits.length; i < len; ++i) {
					if(!_check.bits[i](node)) {
						return false
					}
				}
	
				if(_check.subject) {
					subj.push(node)
				}
	
				return true
			}
		}
	
		function listContains(type, data) {
			return function(node) {
				var val = options[type](node)
				val =
					Array.isArray(val) ? val :
					val ? val.toString().split(/\s+/) :
					[]
				return val.indexOf(data) >= 0
			}
		}
	
		function attr(token) {
			return token.data.lhs ?
				valid_attr(
						options.attr
					, token.data.lhs
					, token.data.cmp
					, token.data.rhs
				) :
				valid_attr(options.attr, token.data)
		}
	
		function matches(type, data, matchComparison) {
			return function(node) {
				return matchComparison(type, options[type](node), data);
			}
		}
	
		function any_parents(node, next, subj) {
			do {
				node = options.parent(node)
			} while(node && !next(node, subj))
	
			return node
		}
	
		function direct_parent(node, next, subj) {
			node = options.parent(node)
	
			return node && next(node, subj) ? node : null
		}
	
		function direct_sibling(node, next, subj) {
			var parent = options.parent(node)
				, idx = 0
				, children
	
			children = options.children(parent)
	
			for(var i = 0, len = children.length; i < len; ++i) {
				if(children[i] === node) {
					idx = i
	
					break
				}
			}
	
			return children[idx - 1] && next(children[idx - 1], subj) ?
				children[idx - 1] :
				null
		}
	
		function any_sibling(node, next, subj) {
			var parent = options.parent(node)
				, children
	
			children = options.children(parent)
	
			for(var i = 0, len = children.length; i < len; ++i) {
				if(children[i] === node) {
					return null
				}
	
				if(next(children[i], subj)) {
					return children[i]
				}
			}
	
			return null
		}
	
		function pseudo(token) {
			return valid_pseudo(options, token.data, matchComparison)
		}
	
	}
	
	function entry(node, next, subj) {
		return next(node, subj) ? node : null
	}
	
	function valid_pseudo(options, match, matchComparison) {
		switch(match) {
			case 'empty': return valid_empty(options)
			case 'first-child': return valid_first_child(options)
			case 'last-child': return valid_last_child(options)
			case 'root': return valid_root(options)
		}
	
		if(match.indexOf('contains') === 0) {
			return valid_contains(options, match.slice(9, -1))
		}
	
		if(match.indexOf('any') === 0) {
			return valid_any_match(options, match.slice(4, -1), matchComparison)
		}
	
		if(match.indexOf('not') === 0) {
			return valid_not_match(options, match.slice(4, -1), matchComparison)
		}
	
		if(match.indexOf('nth-child') === 0) {
			return valid_nth_child(options, match.slice(10, -1))
		}
	
		return function() {
			return false
		}
	}
	
	function valid_not_match(options, selector, matchComparison) {
		var fn = parse(selector, options, matchComparison)
	
		return not_function
	
		function not_function(node) {
			return !fn(node, true)
		}
	}
	
	function valid_any_match(options, selector, matchComparison) {
		var fn = parse(selector, options, matchComparison)
	
		return fn
	}
	
	function valid_attr(fn, lhs, cmp, rhs) {
		return function(node) {
			var attr = fn(node, lhs)
	
			if(!cmp) {
				return !!attr
			}
	
			if(cmp.length === 1) {
				return attr == rhs
			}
	
			if(attr === void 0 || attr === null) {
				return false
			}
	
			return checkattr[cmp.charAt(0)](attr, rhs)
		}
	}
	
	function valid_first_child(options) {
		return function(node) {
			return options.children(options.parent(node))[0] === node
		}
	}
	
	function valid_last_child(options) {
		return function(node) {
			var children = options.children(options.parent(node))
	
			return children[children.length - 1] === node
		}
	}
	
	function valid_empty(options) {
		return function(node) {
			return options.children(node).length === 0
		}
	}
	
	function valid_root(options) {
		return function(node) {
			return !options.parent(node)
		}
	}
	
	function valid_contains(options, contents) {
		return function(node) {
			return options.contents(node).indexOf(contents) !== -1
		}
	}
	
	function valid_nth_child(options, nth) {
		var test = function(){ return false }
		if (nth == 'odd') {
			nth = '2n+1'
		} else if (nth == 'even') {
			nth = '2n'
		}
		var regexp = /( ?([-|\+])?(\d*)n)? ?((\+|-)? ?(\d+))? ?/
		var matches = nth.match(regexp)
		if (matches) {
			var growth = 0;
			if (matches[1]) {
				var positiveGrowth = (matches[2] != '-')
				growth = parseInt(matches[3] == '' ? 1 : matches[3])
				growth = growth * (positiveGrowth ? 1 : -1)
			}
			var offset = 0
			if (matches[4]) {
				offset = parseInt(matches[6])
				var positiveOffset = (matches[5] != '-')
				offset = offset * (positiveOffset ? 1 : -1)
			}
			if (growth == 0) {
				if (offset != 0) {
					test = function(children, node) {
						return children[offset - 1] === node
					}
				}
			} else {
				test = function(children, node) {
					var validPositions = []
					var len = children.length
					for (var position=1; position <= len; position++) {
						var divisible = ((position - offset) % growth) == 0;
						if (divisible) {
							if (growth > 0) {
								validPositions.push(position);
							} else {
								if ((position - offset) / growth >= 0) {
									validPositions.push(position);
								}
							}
						}
					}
					for(var i=0; i < validPositions.length; i++) {
						if (children[validPositions[i] - 1] === node) {
							return true
						}
					}
					return false
				}
			}
		}
		return function(node) {
			var children = options.children(options.parent(node))
	
			return test(children, node)
		}
	}
	
	var checkattr = {
			'$': check_end
		, '^': check_beg
		, '*': check_any
		, '~': check_spc
		, '|': check_dsh
	}
	
	function check_end(l, r) {
		return l.slice(l.length - r.length) === r
	}
	
	function check_beg(l, r) {
		return l.slice(0, r.length) === r
	}
	
	function check_any(l, r) {
		return l.indexOf(r) > -1
	}
	
	function check_spc(l, r) {
		return l.split(/\s+/).indexOf(r) > -1
	}
	
	function check_dsh(l, r) {
		return l.split('-').indexOf(r) > -1
	}
	
	function caseSensitiveComparison(type, pattern, data) {
		return pattern === data;
	}
	
	
	/***/ }),
	/* 84 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = tokenize
	
	var through = __webpack_require__(85)
	
	var PSEUDOSTART = 'pseudo-start'
		, ATTR_START = 'attr-start'
		, ANY_CHILD = 'any-child'
		, ATTR_COMP = 'attr-comp'
		, ATTR_END = 'attr-end'
		, PSEUDOPSEUDO = '::'
		, PSEUDOCLASS = ':'
		, READY = '(ready)'
		, OPERATION = 'op'
		, CLASS = 'class'
		, COMMA = 'comma'
		, ATTR = 'attr'
		, SUBJECT = '!'
		, TAG = 'tag'
		, STAR = '*'
		, ID = 'id'
	
	function tokenize() {
		var escaped = false
			, gathered = []
			, state = READY 
			, data = []
			, idx = 0
			, stream
			, length
			, quote
			, depth
			, lhs
			, rhs
			, cmp
			, c
	
		return stream = through(ondata, onend)
	
		function ondata(chunk) {
			data = data.concat(chunk.split(''))
			length = data.length
	
			while(idx < length && (c = data[idx++])) {
				switch(state) {
					case READY: state_ready(); break
					case ANY_CHILD: state_any_child(); break
					case OPERATION: state_op(); break
					case ATTR_START: state_attr_start(); break
					case ATTR_COMP: state_attr_compare(); break
					case ATTR_END: state_attr_end(); break
					case PSEUDOCLASS:
					case PSEUDOPSEUDO: state_pseudo(); break
					case PSEUDOSTART: state_pseudostart(); break
					case ID:
					case TAG:
					case CLASS: state_gather(); break
				}
			}
	
			data = data.slice(idx)
		}
	
		function onend(chunk) {
			if(arguments.length) {
				ondata(chunk)
			}
	
			if(gathered.length) {
				stream.queue(token())
			}
		}
	
		function state_ready() {
			switch(true) {
				case '#' === c: state = ID; break
				case '.' === c: state = CLASS; break
				case ':' === c: state = PSEUDOCLASS; break
				case '[' === c: state = ATTR_START; break
				case '!' === c: subject(); break
				case '*' === c: star(); break
				case ',' === c: comma(); break
				case /[>\+~]/.test(c): state = OPERATION; break
				case /\s/.test(c): state = ANY_CHILD; break
				case /[\w\d\-_]/.test(c): state = TAG; --idx; break
			}
		}
	
		function subject() {
			state = SUBJECT
			gathered = ['!']
			stream.queue(token())
			state = READY
		}
	
		function star() {
			state = STAR
			gathered = ['*']
			stream.queue(token())
			state = READY
		}
	
		function comma() {
			state = COMMA
			gathered = [',']
			stream.queue(token())
			state = READY
		}
	
		function state_op() {
			if(/[>\+~]/.test(c)) {
				return gathered.push(c)
			}
	
			// chomp down the following whitespace.
			if(/\s/.test(c)) {
				return
			}
	
			stream.queue(token())
			state = READY
			--idx
		}
	
		function state_any_child() {
			if(/\s/.test(c)) {
				return
			}
	
			if(/[>\+~]/.test(c)) {
				return --idx, state = OPERATION
			}
	
			stream.queue(token())
			state = READY
			--idx
		}
	
		function state_pseudo() {
			rhs = state
			state_gather(true)
	
			if(state !== READY) {
				return
			}
	
			if(c === '(') {
				lhs = gathered.join('')
				state = PSEUDOSTART
				gathered.length = 0
				depth = 1
				++idx
	
				return
			}
	
			state = PSEUDOCLASS
			stream.queue(token())
			state = READY
		}
	
		function state_pseudostart() {
			if(gathered.length === 0 && !quote) {
				quote = /['"]/.test(c) ? c : null
	
				if(quote) {
					return
				}
			}
	
			if(quote) {
				if(!escaped && c === quote) {
					quote = null
	
					return
				}
	
				if(c === '\\') {
					escaped ? gathered.push(c) : (escaped = true)
	
					return
				}
	
				escaped = false
				gathered.push(c)
	
				return
			}
	
			gathered.push(c)
	
			if(c === '(') {
				++depth
			} else if(c === ')') {
				--depth
			}
			
			if(!depth) {
				gathered.pop()
				stream.queue({
						type: rhs 
					, data: lhs + '(' + gathered.join('') + ')'
				})
	
				state = READY
				lhs = rhs = cmp = null
				gathered.length = 0
			}
	
			return 
		}
	
		function state_attr_start() {
			state_gather(true)
	
			if(state !== READY) {
				return
			}
	
			if(c === ']') {
				state = ATTR
				stream.queue(token())
				state = READY
	
				return
			}
	
			lhs = gathered.join('')
			gathered.length = 0
			state = ATTR_COMP
		}
	
		function state_attr_compare() {
			if(/[=~|$^*]/.test(c)) {
				gathered.push(c)
			}
	
			if(gathered.length === 2 || c === '=') {
				cmp = gathered.join('')
				gathered.length = 0
				state = ATTR_END
				quote = null
	
				return
			}
		}
	
		function state_attr_end() {
			if(!gathered.length && !quote) {
				quote = /['"]/.test(c) ? c : null
	
				if(quote) {
					return
				}
			}
	
			if(quote) {
				if(!escaped && c === quote) {
					quote = null
	
					return
				}
	
				if(c === '\\') {
					if(escaped) {
						gathered.push(c)
					}
	
					escaped = !escaped
	
					return
				}
	
				escaped = false
				gathered.push(c)
	
				return
			}
	
			state_gather(true)
	
			if(state !== READY) {
				return
			}
	
			stream.queue({
					type: ATTR
				, data: {
							lhs: lhs
						, rhs: gathered.join('')
						, cmp: cmp
					}
			})
	
			state = READY
			lhs = rhs = cmp = null
			gathered.length = 0
	
			return 
		}
	
		function state_gather(quietly) {
			if(/[^\d\w\-_]/.test(c) && !escaped) {
				if(c === '\\') {
					escaped = true
				} else {
					!quietly && stream.queue(token())
					state = READY
					--idx
				}
	
				return
			}
	
			escaped = false
			gathered.push(c)
		}
	
		function token() {
			var data = gathered.join('')
	
			gathered.length = 0
	
			return {
					type: state
				, data: data
			}
		}
	}
	
	
	/***/ }),
	/* 85 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(process) {var Stream = __webpack_require__(86)
	
	// through
	//
	// a stream that does nothing but re-emit the input.
	// useful for aggregating a series of changing but not ending streams into one stream)
	
	exports = module.exports = through
	through.through = through
	
	//create a readable writable stream.
	
	function through (write, end, opts) {
		write = write || function (data) { this.queue(data) }
		end = end || function () { this.queue(null) }
	
		var ended = false, destroyed = false, buffer = [], _ended = false
		var stream = new Stream()
		stream.readable = stream.writable = true
		stream.paused = false
	
	//  stream.autoPause   = !(opts && opts.autoPause   === false)
		stream.autoDestroy = !(opts && opts.autoDestroy === false)
	
		stream.write = function (data) {
			write.call(this, data)
			return !stream.paused
		}
	
		function drain() {
			while(buffer.length && !stream.paused) {
				var data = buffer.shift()
				if(null === data)
					return stream.emit('end')
				else
					stream.emit('data', data)
			}
		}
	
		stream.queue = stream.push = function (data) {
	//    console.error(ended)
			if(_ended) return stream
			if(data === null) _ended = true
			buffer.push(data)
			drain()
			return stream
		}
	
		//this will be registered as the first 'end' listener
		//must call destroy next tick, to make sure we're after any
		//stream piped from here.
		//this is only a problem if end is not emitted synchronously.
		//a nicer way to do this is to make sure this is the last listener for 'end'
	
		stream.on('end', function () {
			stream.readable = false
			if(!stream.writable && stream.autoDestroy)
				process.nextTick(function () {
					stream.destroy()
				})
		})
	
		function _end () {
			stream.writable = false
			end.call(stream)
			if(!stream.readable && stream.autoDestroy)
				stream.destroy()
		}
	
		stream.end = function (data) {
			if(ended) return
			ended = true
			if(arguments.length) stream.write(data)
			_end() // will emit or queue
			return stream
		}
	
		stream.destroy = function () {
			if(destroyed) return
			destroyed = true
			ended = true
			buffer.length = 0
			stream.writable = stream.readable = false
			stream.emit('close')
			return stream
		}
	
		stream.pause = function () {
			if(stream.paused) return
			stream.paused = true
			return stream
		}
	
		stream.resume = function () {
			if(stream.paused) {
				stream.paused = false
				stream.emit('resume')
			}
			drain()
			//may have become paused again,
			//as drain emits 'data'.
			if(!stream.paused)
				stream.emit('drain')
			return stream
		}
		return stream
	}
	
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(15)))
	
	/***/ }),
	/* 86 */
	/***/ (function(module, exports, __webpack_require__) {
	
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	module.exports = Stream;
	
	var EE = __webpack_require__(24).EventEmitter;
	var inherits = __webpack_require__(11);
	
	inherits(Stream, EE);
	Stream.Readable = __webpack_require__(25);
	Stream.Writable = __webpack_require__(99);
	Stream.Duplex = __webpack_require__(100);
	Stream.Transform = __webpack_require__(101);
	Stream.PassThrough = __webpack_require__(102);
	
	// Backwards-compat with node 0.4.x
	Stream.Stream = Stream;
	
	
	
	// old-style streams.  Note that the pipe method (the only relevant
	// part of this class) is overridden in the Readable class.
	
	function Stream() {
		EE.call(this);
	}
	
	Stream.prototype.pipe = function(dest, options) {
		var source = this;
	
		function ondata(chunk) {
			if (dest.writable) {
				if (false === dest.write(chunk) && source.pause) {
					source.pause();
				}
			}
		}
	
		source.on('data', ondata);
	
		function ondrain() {
			if (source.readable && source.resume) {
				source.resume();
			}
		}
	
		dest.on('drain', ondrain);
	
		// If the 'end' option is not supplied, dest.end() will be called when
		// source gets the 'end' or 'close' events.  Only dest.end() once.
		if (!dest._isStdio && (!options || options.end !== false)) {
			source.on('end', onend);
			source.on('close', onclose);
		}
	
		var didOnEnd = false;
		function onend() {
			if (didOnEnd) return;
			didOnEnd = true;
	
			dest.end();
		}
	
	
		function onclose() {
			if (didOnEnd) return;
			didOnEnd = true;
	
			if (typeof dest.destroy === 'function') dest.destroy();
		}
	
		// don't leave dangling pipes when there are errors.
		function onerror(er) {
			cleanup();
			if (EE.listenerCount(this, 'error') === 0) {
				throw er; // Unhandled stream error in pipe.
			}
		}
	
		source.on('error', onerror);
		dest.on('error', onerror);
	
		// remove all the event listeners that were added.
		function cleanup() {
			source.removeListener('data', ondata);
			dest.removeListener('drain', ondrain);
	
			source.removeListener('end', onend);
			source.removeListener('close', onclose);
	
			source.removeListener('error', onerror);
			dest.removeListener('error', onerror);
	
			source.removeListener('end', cleanup);
			source.removeListener('close', cleanup);
	
			dest.removeListener('close', cleanup);
		}
	
		source.on('end', cleanup);
		source.on('close', cleanup);
	
		dest.on('close', cleanup);
	
		dest.emit('pipe', source);
	
		// Allow for unix-like usage: A.pipe(B).pipe(C)
		return dest;
	};
	
	
	/***/ }),
	/* 87 */
	/***/ (function(module, exports) {
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
		return toString.call(arr) == '[object Array]';
	};
	
	
	/***/ }),
	/* 88 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	
	
	exports.byteLength = byteLength
	exports.toByteArray = toByteArray
	exports.fromByteArray = fromByteArray
	
	var lookup = []
	var revLookup = []
	var Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array
	
	var code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'
	for (var i = 0, len = code.length; i < len; ++i) {
		lookup[i] = code[i]
		revLookup[code.charCodeAt(i)] = i
	}
	
	// Support decoding URL-safe base64 strings, as Node.js does.
	// See: https://en.wikipedia.org/wiki/Base64#URL_applications
	revLookup['-'.charCodeAt(0)] = 62
	revLookup['_'.charCodeAt(0)] = 63
	
	function getLens (b64) {
		var len = b64.length
	
		if (len % 4 > 0) {
			throw new Error('Invalid string. Length must be a multiple of 4')
		}
	
		// Trim off extra bytes after placeholder bytes are found
		// See: https://github.com/beatgammit/base64-js/issues/42
		var validLen = b64.indexOf('=')
		if (validLen === -1) validLen = len
	
		var placeHoldersLen = validLen === len
			? 0
			: 4 - (validLen % 4)
	
		return [validLen, placeHoldersLen]
	}
	
	// base64 is 4/3 + up to two characters of the original data
	function byteLength (b64) {
		var lens = getLens(b64)
		var validLen = lens[0]
		var placeHoldersLen = lens[1]
		return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function _byteLength (b64, validLen, placeHoldersLen) {
		return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen
	}
	
	function toByteArray (b64) {
		var tmp
		var lens = getLens(b64)
		var validLen = lens[0]
		var placeHoldersLen = lens[1]
	
		var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))
	
		var curByte = 0
	
		// if there are placeholders, only get up to the last complete 4 chars
		var len = placeHoldersLen > 0
			? validLen - 4
			: validLen
	
		var i
		for (i = 0; i < len; i += 4) {
			tmp =
				(revLookup[b64.charCodeAt(i)] << 18) |
				(revLookup[b64.charCodeAt(i + 1)] << 12) |
				(revLookup[b64.charCodeAt(i + 2)] << 6) |
				revLookup[b64.charCodeAt(i + 3)]
			arr[curByte++] = (tmp >> 16) & 0xFF
			arr[curByte++] = (tmp >> 8) & 0xFF
			arr[curByte++] = tmp & 0xFF
		}
	
		if (placeHoldersLen === 2) {
			tmp =
				(revLookup[b64.charCodeAt(i)] << 2) |
				(revLookup[b64.charCodeAt(i + 1)] >> 4)
			arr[curByte++] = tmp & 0xFF
		}
	
		if (placeHoldersLen === 1) {
			tmp =
				(revLookup[b64.charCodeAt(i)] << 10) |
				(revLookup[b64.charCodeAt(i + 1)] << 4) |
				(revLookup[b64.charCodeAt(i + 2)] >> 2)
			arr[curByte++] = (tmp >> 8) & 0xFF
			arr[curByte++] = tmp & 0xFF
		}
	
		return arr
	}
	
	function tripletToBase64 (num) {
		return lookup[num >> 18 & 0x3F] +
			lookup[num >> 12 & 0x3F] +
			lookup[num >> 6 & 0x3F] +
			lookup[num & 0x3F]
	}
	
	function encodeChunk (uint8, start, end) {
		var tmp
		var output = []
		for (var i = start; i < end; i += 3) {
			tmp =
				((uint8[i] << 16) & 0xFF0000) +
				((uint8[i + 1] << 8) & 0xFF00) +
				(uint8[i + 2] & 0xFF)
			output.push(tripletToBase64(tmp))
		}
		return output.join('')
	}
	
	function fromByteArray (uint8) {
		var tmp
		var len = uint8.length
		var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes
		var parts = []
		var maxChunkLength = 16383 // must be multiple of 3
	
		// go through the array every three bytes, we'll deal with trailing stuff later
		for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {
			parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))
		}
	
		// pad the end with zeros, but make sure to not forget the extra bytes
		if (extraBytes === 1) {
			tmp = uint8[len - 1]
			parts.push(
				lookup[tmp >> 2] +
				lookup[(tmp << 4) & 0x3F] +
				'=='
			)
		} else if (extraBytes === 2) {
			tmp = (uint8[len - 2] << 8) + uint8[len - 1]
			parts.push(
				lookup[tmp >> 10] +
				lookup[(tmp >> 4) & 0x3F] +
				lookup[(tmp << 2) & 0x3F] +
				'='
			)
		}
	
		return parts.join('')
	}
	
	
	/***/ }),
	/* 89 */
	/***/ (function(module, exports) {
	
	/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */
	exports.read = function (buffer, offset, isLE, mLen, nBytes) {
		var e, m
		var eLen = (nBytes * 8) - mLen - 1
		var eMax = (1 << eLen) - 1
		var eBias = eMax >> 1
		var nBits = -7
		var i = isLE ? (nBytes - 1) : 0
		var d = isLE ? -1 : 1
		var s = buffer[offset + i]
	
		i += d
	
		e = s & ((1 << (-nBits)) - 1)
		s >>= (-nBits)
		nBits += eLen
		for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
		m = e & ((1 << (-nBits)) - 1)
		e >>= (-nBits)
		nBits += mLen
		for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}
	
		if (e === 0) {
			e = 1 - eBias
		} else if (e === eMax) {
			return m ? NaN : ((s ? -1 : 1) * Infinity)
		} else {
			m = m + Math.pow(2, mLen)
			e = e - eBias
		}
		return (s ? -1 : 1) * m * Math.pow(2, e - mLen)
	}
	
	exports.write = function (buffer, value, offset, isLE, mLen, nBytes) {
		var e, m, c
		var eLen = (nBytes * 8) - mLen - 1
		var eMax = (1 << eLen) - 1
		var eBias = eMax >> 1
		var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)
		var i = isLE ? 0 : (nBytes - 1)
		var d = isLE ? 1 : -1
		var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0
	
		value = Math.abs(value)
	
		if (isNaN(value) || value === Infinity) {
			m = isNaN(value) ? 1 : 0
			e = eMax
		} else {
			e = Math.floor(Math.log(value) / Math.LN2)
			if (value * (c = Math.pow(2, -e)) < 1) {
				e--
				c *= 2
			}
			if (e + eBias >= 1) {
				value += rt / c
			} else {
				value += rt * Math.pow(2, 1 - eBias)
			}
			if (value * c >= 2) {
				e++
				c /= 2
			}
	
			if (e + eBias >= eMax) {
				m = 0
				e = eMax
			} else if (e + eBias >= 1) {
				m = ((value * c) - 1) * Math.pow(2, mLen)
				e = e + eBias
			} else {
				m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)
				e = 0
			}
		}
	
		for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}
	
		e = (e << mLen) | m
		eLen += mLen
		for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}
	
		buffer[offset + i - d] |= s * 128
	}
	
	
	/***/ }),
	/* 90 */
	/***/ (function(module, exports) {
	
	var toString = {}.toString;
	
	module.exports = Array.isArray || function (arr) {
		return toString.call(arr) == '[object Array]';
	};
	
	
	/***/ }),
	/* 91 */
	/***/ (function(module, exports) {
	
	/* (ignored) */
	
	/***/ }),
	/* 92 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	
	
	function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
	
	var Buffer = __webpack_require__(26).Buffer;
	var util = __webpack_require__(93);
	
	function copyBuffer(src, target, offset) {
		src.copy(target, offset);
	}
	
	module.exports = function () {
		function BufferList() {
			_classCallCheck(this, BufferList);
	
			this.head = null;
			this.tail = null;
			this.length = 0;
		}
	
		BufferList.prototype.push = function push(v) {
			var entry = { data: v, next: null };
			if (this.length > 0) this.tail.next = entry;else this.head = entry;
			this.tail = entry;
			++this.length;
		};
	
		BufferList.prototype.unshift = function unshift(v) {
			var entry = { data: v, next: this.head };
			if (this.length === 0) this.tail = entry;
			this.head = entry;
			++this.length;
		};
	
		BufferList.prototype.shift = function shift() {
			if (this.length === 0) return;
			var ret = this.head.data;
			if (this.length === 1) this.head = this.tail = null;else this.head = this.head.next;
			--this.length;
			return ret;
		};
	
		BufferList.prototype.clear = function clear() {
			this.head = this.tail = null;
			this.length = 0;
		};
	
		BufferList.prototype.join = function join(s) {
			if (this.length === 0) return '';
			var p = this.head;
			var ret = '' + p.data;
			while (p = p.next) {
				ret += s + p.data;
			}return ret;
		};
	
		BufferList.prototype.concat = function concat(n) {
			if (this.length === 0) return Buffer.alloc(0);
			if (this.length === 1) return this.head.data;
			var ret = Buffer.allocUnsafe(n >>> 0);
			var p = this.head;
			var i = 0;
			while (p) {
				copyBuffer(p.data, ret, i);
				i += p.data.length;
				p = p.next;
			}
			return ret;
		};
	
		return BufferList;
	}();
	
	if (util && util.inspect && util.inspect.custom) {
		module.exports.prototype[util.inspect.custom] = function () {
			var obj = util.inspect({ length: this.length });
			return this.constructor.name + ' ' + obj;
		};
	}
	
	/***/ }),
	/* 93 */
	/***/ (function(module, exports) {
	
	/* (ignored) */
	
	/***/ }),
	/* 94 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {var scope = (typeof global !== "undefined" && global) ||
							(typeof self !== "undefined" && self) ||
							window;
	var apply = Function.prototype.apply;
	
	// DOM APIs, for completeness
	
	exports.setTimeout = function() {
		return new Timeout(apply.call(setTimeout, scope, arguments), clearTimeout);
	};
	exports.setInterval = function() {
		return new Timeout(apply.call(setInterval, scope, arguments), clearInterval);
	};
	exports.clearTimeout =
	exports.clearInterval = function(timeout) {
		if (timeout) {
			timeout.close();
		}
	};
	
	function Timeout(id, clearFn) {
		this._id = id;
		this._clearFn = clearFn;
	}
	Timeout.prototype.unref = Timeout.prototype.ref = function() {};
	Timeout.prototype.close = function() {
		this._clearFn.call(scope, this._id);
	};
	
	// Does not start the time, just sets up the members needed.
	exports.enroll = function(item, msecs) {
		clearTimeout(item._idleTimeoutId);
		item._idleTimeout = msecs;
	};
	
	exports.unenroll = function(item) {
		clearTimeout(item._idleTimeoutId);
		item._idleTimeout = -1;
	};
	
	exports._unrefActive = exports.active = function(item) {
		clearTimeout(item._idleTimeoutId);
	
		var msecs = item._idleTimeout;
		if (msecs >= 0) {
			item._idleTimeoutId = setTimeout(function onTimeout() {
				if (item._onTimeout)
					item._onTimeout();
			}, msecs);
		}
	};
	
	// setimmediate attaches itself to the global object
	__webpack_require__(95);
	// On some exotic environments, it's not clear which object `setimmediate` was
	// able to install onto.  Search each possibility in the same order as the
	// `setimmediate` library.
	exports.setImmediate = (typeof self !== "undefined" && self.setImmediate) ||
												 (typeof global !== "undefined" && global.setImmediate) ||
												 (this && this.setImmediate);
	exports.clearImmediate = (typeof self !== "undefined" && self.clearImmediate) ||
													 (typeof global !== "undefined" && global.clearImmediate) ||
													 (this && this.clearImmediate);
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))
	
	/***/ }),
	/* 95 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global, process) {(function (global, undefined) {
			"use strict";
	
			if (global.setImmediate) {
					return;
			}
	
			var nextHandle = 1; // Spec says greater than zero
			var tasksByHandle = {};
			var currentlyRunningATask = false;
			var doc = global.document;
			var registerImmediate;
	
			function setImmediate(callback) {
				// Callback can either be a function or a string
				if (typeof callback !== "function") {
					callback = new Function("" + callback);
				}
				// Copy function arguments
				var args = new Array(arguments.length - 1);
				for (var i = 0; i < args.length; i++) {
						args[i] = arguments[i + 1];
				}
				// Store and register the task
				var task = { callback: callback, args: args };
				tasksByHandle[nextHandle] = task;
				registerImmediate(nextHandle);
				return nextHandle++;
			}
	
			function clearImmediate(handle) {
					delete tasksByHandle[handle];
			}
	
			function run(task) {
					var callback = task.callback;
					var args = task.args;
					switch (args.length) {
					case 0:
							callback();
							break;
					case 1:
							callback(args[0]);
							break;
					case 2:
							callback(args[0], args[1]);
							break;
					case 3:
							callback(args[0], args[1], args[2]);
							break;
					default:
							callback.apply(undefined, args);
							break;
					}
			}
	
			function runIfPresent(handle) {
					// From the spec: "Wait until any invocations of this algorithm started before this one have completed."
					// So if we're currently running a task, we'll need to delay this invocation.
					if (currentlyRunningATask) {
							// Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
							// "too much recursion" error.
							setTimeout(runIfPresent, 0, handle);
					} else {
							var task = tasksByHandle[handle];
							if (task) {
									currentlyRunningATask = true;
									try {
											run(task);
									} finally {
											clearImmediate(handle);
											currentlyRunningATask = false;
									}
							}
					}
			}
	
			function installNextTickImplementation() {
					registerImmediate = function(handle) {
							process.nextTick(function () { runIfPresent(handle); });
					};
			}
	
			function canUsePostMessage() {
					// The test against `importScripts` prevents this implementation from being installed inside a web worker,
					// where `global.postMessage` means something completely different and can't be used for this purpose.
					if (global.postMessage && !global.importScripts) {
							var postMessageIsAsynchronous = true;
							var oldOnMessage = global.onmessage;
							global.onmessage = function() {
									postMessageIsAsynchronous = false;
							};
							global.postMessage("", "*");
							global.onmessage = oldOnMessage;
							return postMessageIsAsynchronous;
					}
			}
	
			function installPostMessageImplementation() {
					// Installs an event handler on `global` for the `message` event: see
					// * https://developer.mozilla.org/en/DOM/window.postMessage
					// * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages
	
					var messagePrefix = "setImmediate$" + Math.random() + "$";
					var onGlobalMessage = function(event) {
							if (event.source === global &&
									typeof event.data === "string" &&
									event.data.indexOf(messagePrefix) === 0) {
									runIfPresent(+event.data.slice(messagePrefix.length));
							}
					};
	
					if (global.addEventListener) {
							global.addEventListener("message", onGlobalMessage, false);
					} else {
							global.attachEvent("onmessage", onGlobalMessage);
					}
	
					registerImmediate = function(handle) {
							global.postMessage(messagePrefix + handle, "*");
					};
			}
	
			function installMessageChannelImplementation() {
					var channel = new MessageChannel();
					channel.port1.onmessage = function(event) {
							var handle = event.data;
							runIfPresent(handle);
					};
	
					registerImmediate = function(handle) {
							channel.port2.postMessage(handle);
					};
			}
	
			function installReadyStateChangeImplementation() {
					var html = doc.documentElement;
					registerImmediate = function(handle) {
							// Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
							// into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
							var script = doc.createElement("script");
							script.onreadystatechange = function () {
									runIfPresent(handle);
									script.onreadystatechange = null;
									html.removeChild(script);
									script = null;
							};
							html.appendChild(script);
					};
			}
	
			function installSetTimeoutImplementation() {
					registerImmediate = function(handle) {
							setTimeout(runIfPresent, 0, handle);
					};
			}
	
			// If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
			var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
			attachTo = attachTo && attachTo.setTimeout ? attachTo : global;
	
			// Don't get fooled by e.g. browserify environments.
			if ({}.toString.call(global.process) === "[object process]") {
					// For Node.js before 0.9
					installNextTickImplementation();
	
			} else if (canUsePostMessage()) {
					// For non-IE10 modern browsers
					installPostMessageImplementation();
	
			} else if (global.MessageChannel) {
					// For web workers, where supported
					installMessageChannelImplementation();
	
			} else if (doc && "onreadystatechange" in doc.createElement("script")) {
					// For IE 68
					installReadyStateChangeImplementation();
	
			} else {
					// For older browsers
					installSetTimeoutImplementation();
			}
	
			attachTo.setImmediate = setImmediate;
			attachTo.clearImmediate = clearImmediate;
	}(typeof self === "undefined" ? typeof global === "undefined" ? this : global : self));
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12), __webpack_require__(15)))
	
	/***/ }),
	/* 96 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/* WEBPACK VAR INJECTION */(function(global) {
	/**
	 * Module exports.
	 */
	
	module.exports = deprecate;
	
	/**
	 * Mark that a method should not be used.
	 * Returns a modified function which warns once by default.
	 *
	 * If `localStorage.noDeprecation = true` is set, then it is a no-op.
	 *
	 * If `localStorage.throwDeprecation = true` is set, then deprecated functions
	 * will throw an Error when invoked.
	 *
	 * If `localStorage.traceDeprecation = true` is set, then deprecated functions
	 * will invoke `console.trace()` instead of `console.error()`.
	 *
	 * @param {Function} fn - the function to deprecate
	 * @param {String} msg - the string to print to the console when `fn` is invoked
	 * @returns {Function} a new "deprecated" version of `fn`
	 * @api public
	 */
	
	function deprecate (fn, msg) {
		if (config('noDeprecation')) {
			return fn;
		}
	
		var warned = false;
		function deprecated() {
			if (!warned) {
				if (config('throwDeprecation')) {
					throw new Error(msg);
				} else if (config('traceDeprecation')) {
					console.trace(msg);
				} else {
					console.warn(msg);
				}
				warned = true;
			}
			return fn.apply(this, arguments);
		}
	
		return deprecated;
	}
	
	/**
	 * Checks `localStorage` for boolean values for the given `name`.
	 *
	 * @param {String} name
	 * @returns {Boolean}
	 * @api private
	 */
	
	function config (name) {
		// accessing global.localStorage can trigger a DOMException in sandboxed iframes
		try {
			if (!global.localStorage) return false;
		} catch (_) {
			return false;
		}
		var val = global.localStorage[name];
		if (null == val) return false;
		return String(val).toLowerCase() === 'true';
	}
	
	/* WEBPACK VAR INJECTION */}.call(this, __webpack_require__(12)))
	
	/***/ }),
	/* 97 */
	/***/ (function(module, exports, __webpack_require__) {
	
	/*! safe-buffer. MIT License. Feross Aboukhadijeh <https://feross.org/opensource> */
	/* eslint-disable node/no-deprecated-api */
	var buffer = __webpack_require__(27)
	var Buffer = buffer.Buffer
	
	// alternative to using Object.keys for old browsers
	function copyProps (src, dst) {
		for (var key in src) {
			dst[key] = src[key]
		}
	}
	if (Buffer.from && Buffer.alloc && Buffer.allocUnsafe && Buffer.allocUnsafeSlow) {
		module.exports = buffer
	} else {
		// Copy properties from require('buffer')
		copyProps(buffer, exports)
		exports.Buffer = SafeBuffer
	}
	
	function SafeBuffer (arg, encodingOrOffset, length) {
		return Buffer(arg, encodingOrOffset, length)
	}
	
	SafeBuffer.prototype = Object.create(Buffer.prototype)
	
	// Copy static methods from Buffer
	copyProps(Buffer, SafeBuffer)
	
	SafeBuffer.from = function (arg, encodingOrOffset, length) {
		if (typeof arg === 'number') {
			throw new TypeError('Argument must not be a number')
		}
		return Buffer(arg, encodingOrOffset, length)
	}
	
	SafeBuffer.alloc = function (size, fill, encoding) {
		if (typeof size !== 'number') {
			throw new TypeError('Argument must be a number')
		}
		var buf = Buffer(size)
		if (fill !== undefined) {
			if (typeof encoding === 'string') {
				buf.fill(fill, encoding)
			} else {
				buf.fill(fill)
			}
		} else {
			buf.fill(0)
		}
		return buf
	}
	
	SafeBuffer.allocUnsafe = function (size) {
		if (typeof size !== 'number') {
			throw new TypeError('Argument must be a number')
		}
		return Buffer(size)
	}
	
	SafeBuffer.allocUnsafeSlow = function (size) {
		if (typeof size !== 'number') {
			throw new TypeError('Argument must be a number')
		}
		return buffer.SlowBuffer(size)
	}
	
	
	/***/ }),
	/* 98 */
	/***/ (function(module, exports, __webpack_require__) {
	
	"use strict";
	// Copyright Joyent, Inc. and other Node contributors.
	//
	// Permission is hereby granted, free of charge, to any person obtaining a
	// copy of this software and associated documentation files (the
	// "Software"), to deal in the Software without restriction, including
	// without limitation the rights to use, copy, modify, merge, publish,
	// distribute, sublicense, and/or sell copies of the Software, and to permit
	// persons to whom the Software is furnished to do so, subject to the
	// following conditions:
	//
	// The above copyright notice and this permission notice shall be included
	// in all copies or substantial portions of the Software.
	//
	// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
	// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
	// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
	// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
	// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
	// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
	// USE OR OTHER DEALINGS IN THE SOFTWARE.
	
	// a passthrough stream.
	// basically just the most minimal sort of Transform stream.
	// Every written chunk gets output as-is.
	
	
	
	module.exports = PassThrough;
	
	var Transform = __webpack_require__(46);
	
	/*<replacement>*/
	var util = __webpack_require__(16);
	util.inherits = __webpack_require__(11);
	/*</replacement>*/
	
	util.inherits(PassThrough, Transform);
	
	function PassThrough(options) {
		if (!(this instanceof PassThrough)) return new PassThrough(options);
	
		Transform.call(this, options);
	}
	
	PassThrough.prototype._transform = function (chunk, encoding, cb) {
		cb(null, chunk);
	};
	
	/***/ }),
	/* 99 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(28);
	
	
	/***/ }),
	/* 100 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(9);
	
	
	/***/ }),
	/* 101 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(25).Transform
	
	
	/***/ }),
	/* 102 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(25).PassThrough
	
	
	/***/ }),
	/* 103 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Factory = __webpack_require__(104);
	
	exports.Classes = __webpack_require__(105);
	
	exports.Overlay = __webpack_require__(47);
	
	
	/***/ }),
	/* 104 */
	/***/ (function(module, exports) {
	
	var OverlayFactory;
	
	OverlayFactory = (function() {
		function OverlayFactory(classes, canvas) {
			var div;
			this.classes = classes;
			this.canvas = canvas;
			div = document.createElement('div');
			div.classList.add('mathbox-overlays');
			this.div = div;
		}
	
		OverlayFactory.prototype.inject = function() {
			var element;
			element = this.canvas.parentNode;
			if (!element) {
				throw new Error("Canvas not inserted into document.");
			}
			return element.insertBefore(this.div, this.canvas);
		};
	
		OverlayFactory.prototype.unject = function() {
			var element;
			element = this.div.parentNode;
			return element.removeChild(this.div);
		};
	
		OverlayFactory.prototype.getTypes = function() {
			return Object.keys(this.classes);
		};
	
		OverlayFactory.prototype.make = function(type, options) {
			return new this.classes[type](this.div, options);
		};
	
		return OverlayFactory;
	
	})();
	
	module.exports = OverlayFactory;
	
	
	/***/ }),
	/* 105 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Classes;
	
	Classes = {
		dom: __webpack_require__(106)
	};
	
	module.exports = Classes;
	
	
	/***/ }),
	/* 106 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var DOM, Overlay, VDOM,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Overlay = __webpack_require__(47);
	
	VDOM = __webpack_require__(0).VDOM;
	
	DOM = (function(superClass) {
		extend(DOM, superClass);
	
		function DOM() {
			return DOM.__super__.constructor.apply(this, arguments);
		}
	
		DOM.prototype.el = VDOM.element;
	
		DOM.prototype.hint = VDOM.hint;
	
		DOM.prototype.apply = VDOM.apply;
	
		DOM.prototype.recycle = VDOM.recycle;
	
		DOM.prototype.init = function(options) {
			return this.last = null;
		};
	
		DOM.prototype.dispose = function() {
			this.unmount();
			return DOM.__super__.dispose.apply(this, arguments);
		};
	
		DOM.prototype.mount = function() {
			var overlay;
			overlay = document.createElement('div');
			overlay.classList.add('mathbox-overlay');
			this.element.appendChild(overlay);
			return this.overlay = overlay;
		};
	
		DOM.prototype.unmount = function(overlay) {
			if (this.overlay.parentNode) {
				this.element.removeChild(this.overlay);
			}
			return this.overlay = null;
		};
	
		DOM.prototype.render = function(el) {
			var last, naked, node, overlay, parent, ref;
			if (!this.overlay) {
				this.mount();
			}
			if ((ref = typeof el) === 'string' || ref === 'number') {
				el = this.el('div', null, el);
			}
			if (el instanceof Array) {
				el = this.el('div', null, el);
			}
			naked = el.type === 'div';
			last = this.last;
			overlay = this.overlay;
			node = naked ? overlay : overlay.childNodes[0];
			parent = naked ? overlay.parentNode : overlay;
			if (!last && node) {
				last = this.el('div');
			}
			this.apply(el, last, node, parent, 0);
			this.last = el;
			if (last != null) {
				this.recycle(last);
			}
		};
	
		return DOM;
	
	})(Overlay);
	
	module.exports = DOM;
	
	
	/***/ }),
	/* 107 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Factory = __webpack_require__(108);
	
	exports.Primitive = __webpack_require__(2);
	
	exports.Types = __webpack_require__(109);
	
	
	/***/ }),
	/* 108 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var PrimitiveFactory, Util;
	
	Util = __webpack_require__(0);
	
	PrimitiveFactory = (function() {
		function PrimitiveFactory(definitions, context) {
			this.context = context;
			this.classes = definitions.Classes;
			this.helpers = definitions.Helpers;
		}
	
		PrimitiveFactory.prototype.getTypes = function() {
			return Object.keys(this.classes);
		};
	
		PrimitiveFactory.prototype.make = function(type, options, binds) {
			var klass, node, primitive;
			if (options == null) {
				options = {};
			}
			if (binds == null) {
				binds = null;
			}
			klass = this.classes[type];
			if (klass == null) {
				throw new Error("Unknown primitive class `" + type + "`");
			}
			node = new klass.model(type, klass.defaults, options, binds, klass, this.context.attributes);
			primitive = new klass(node, this.context, this.helpers);
			return node;
		};
	
		return PrimitiveFactory;
	
	})();
	
	module.exports = PrimitiveFactory;
	
	
	/***/ }),
	/* 109 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Model;
	
	Model = __webpack_require__(23);
	
	exports.Classes = __webpack_require__(110);
	
	exports.Types = __webpack_require__(53);
	
	exports.Traits = __webpack_require__(175);
	
	exports.Helpers = __webpack_require__(176);
	
	
	/***/ }),
	/* 110 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Classes;
	
	Classes = {
		axis: __webpack_require__(111),
		face: __webpack_require__(112),
		grid: __webpack_require__(113),
		line: __webpack_require__(114),
		point: __webpack_require__(115),
		strip: __webpack_require__(116),
		surface: __webpack_require__(117),
		ticks: __webpack_require__(118),
		vector: __webpack_require__(119),
		view: __webpack_require__(7),
		cartesian: __webpack_require__(120),
		cartesian4: __webpack_require__(121),
		polar: __webpack_require__(122),
		spherical: __webpack_require__(123),
		stereographic: __webpack_require__(124),
		stereographic4: __webpack_require__(125),
		transform: __webpack_require__(126),
		transform4: __webpack_require__(127),
		vertex: __webpack_require__(128),
		fragment: __webpack_require__(129),
		layer: __webpack_require__(130),
		mask: __webpack_require__(131),
		array: __webpack_require__(48),
		interval: __webpack_require__(133),
		matrix: __webpack_require__(49),
		area: __webpack_require__(134),
		voxel: __webpack_require__(21),
		volume: __webpack_require__(135),
		scale: __webpack_require__(136),
		latch: __webpack_require__(137),
		image: __webpack_require__(138),
		html: __webpack_require__(139),
		dom: __webpack_require__(140),
		text: __webpack_require__(141),
		format: __webpack_require__(142),
		label: __webpack_require__(143),
		retext: __webpack_require__(144),
		clamp: __webpack_require__(145),
		grow: __webpack_require__(146),
		join: __webpack_require__(147),
		lerp: __webpack_require__(148),
		memo: __webpack_require__(149),
		readback: __webpack_require__(150),
		resample: __webpack_require__(50),
		repeat: __webpack_require__(151),
		reverse: __webpack_require__(152),
		swizzle: __webpack_require__(153),
		spread: __webpack_require__(154),
		split: __webpack_require__(155),
		slice: __webpack_require__(156),
		subdivide: __webpack_require__(157),
		transpose: __webpack_require__(158),
		group: __webpack_require__(159),
		inherit: __webpack_require__(160),
		root: __webpack_require__(161),
		unit: __webpack_require__(162),
		shader: __webpack_require__(163),
		camera: __webpack_require__(164),
		rtt: __webpack_require__(165),
		compose: __webpack_require__(166),
		clock: __webpack_require__(167),
		now: __webpack_require__(168),
		move: __webpack_require__(169),
		play: __webpack_require__(170),
		present: __webpack_require__(171),
		reveal: __webpack_require__(172),
		slide: __webpack_require__(173),
		step: __webpack_require__(174)
	};
	
	module.exports = Classes;
	
	
	/***/ }),
	/* 111 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Axis, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Axis = (function(superClass) {
		extend(Axis, superClass);
	
		Axis.traits = ['node', 'object', 'visible', 'style', 'line', 'axis', 'span', 'interval', 'arrow', 'position', 'origin', 'shade'];
	
		Axis.defaults = {
			end: true,
			zBias: -1
		};
	
		function Axis(node, context, helpers) {
			Axis.__super__.constructor.call(this, node, context, helpers);
			this.axisPosition = this.axisStep = this.resolution = this.line = this.arrows = null;
		}
	
		Axis.prototype.make = function() {
			var arrowUniforms, axis, crossed, detail, end, join, lineUniforms, mask, material, position, positionUniforms, ref, ref1, ref2, samples, start, stroke, styleUniforms, swizzle, uniforms, unitUniforms;
			positionUniforms = {
				axisPosition: this._attributes.make(this._types.vec4()),
				axisStep: this._attributes.make(this._types.vec4())
			};
			this.axisPosition = positionUniforms.axisPosition.value;
			this.axisStep = positionUniforms.axisStep.value;
			position = this._shaders.shader();
			position.pipe('axis.position', positionUniforms);
			position = this._helpers.position.pipeline(position);
			styleUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			arrowUniforms = this._helpers.arrow.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			detail = this.props.detail;
			samples = detail + 1;
			this.resolution = 1 / detail;
			ref = this.props, start = ref.start, end = ref.end;
			ref1 = this.props, stroke = ref1.stroke, join = ref1.join;
			mask = this._helpers.object.mask();
			material = this._helpers.shade.pipeline() || false;
			ref2 = this.props, crossed = ref2.crossed, axis = ref2.axis;
			if (!crossed && (mask != null) && axis > 1) {
				swizzle = ['x000', 'y000', 'z000', 'w000'][axis];
				mask = this._helpers.position.swizzle(mask, swizzle);
			}
			uniforms = Util.JS.merge(arrowUniforms, lineUniforms, styleUniforms, unitUniforms);
			this.line = this._renderables.make('line', {
				uniforms: uniforms,
				samples: samples,
				position: position,
				clip: start || end,
				stroke: stroke,
				join: join,
				mask: mask,
				material: material
			});
			this.arrows = [];
			if (start) {
				this.arrows.push(this._renderables.make('arrow', {
					uniforms: uniforms,
					flip: true,
					samples: samples,
					position: position,
					mask: mask,
					material: material
				}));
			}
			if (end) {
				this.arrows.push(this._renderables.make('arrow', {
					uniforms: uniforms,
					samples: samples,
					position: position,
					mask: mask,
					material: material
				}));
			}
			this._helpers.visible.make();
			this._helpers.object.make(this.arrows.concat([this.line]));
			this._helpers.span.make();
			return this._listen(this, 'span.range', this.updateRanges);
		};
	
		Axis.prototype.unmake = function() {
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this._helpers.span.unmake();
		};
	
		Axis.prototype.change = function(changed, touched, init) {
			if (changed['axis.detail'] || changed['line.stroke'] || changed['line.join'] || changed['axis.crossed'] || (changed['interval.axis'] && this.props.crossed)) {
				return this.rebuild();
			}
			if (touched['interval'] || touched['span'] || touched['view'] || touched['origin'] || init) {
				return this.updateRanges();
			}
		};
	
		Axis.prototype.updateRanges = function() {
			var axis, max, min, origin, range, ref;
			ref = this.props, axis = ref.axis, origin = ref.origin;
			range = this._helpers.span.get('', axis);
			min = range.x;
			max = range.y;
			Util.Axis.setDimension(this.axisPosition, axis).multiplyScalar(min);
			Util.Axis.setDimension(this.axisStep, axis).multiplyScalar((max - min) * this.resolution);
			return Util.Axis.addOrigin(this.axisPosition, axis, origin);
		};
	
		return Axis;
	
	})(Primitive);
	
	module.exports = Axis;
	
	
	/***/ }),
	/* 112 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Face, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Face = (function(superClass) {
		extend(Face, superClass);
	
		Face.traits = ['node', 'object', 'visible', 'style', 'line', 'mesh', 'face', 'geometry', 'position', 'bind', 'shade'];
	
		function Face(node, context, helpers) {
			Face.__super__.constructor.call(this, node, context, helpers);
			this.face = null;
		}
	
		Face.prototype.resize = function() {
			var depth, dims, height, items, map, width;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			if (this.face) {
				this.face.geometry.clip(width, height, depth, items);
			}
			if (this.line) {
				this.line.geometry.clip(items, width, height, depth);
			}
			if (this.bind.map != null) {
				map = this.bind.map.getActiveDimensions();
				if (this.face) {
					return this.face.geometry.map(map.width, map.height, map.depth, map.items);
				}
			}
		};
	
		Face.prototype.make = function() {
			var color, depth, dims, faceMaterial, fill, height, items, join, line, lineMaterial, lineUniforms, map, mask, material, objects, position, ref, ref1, shaded, stroke, styleUniforms, swizzle, uniforms, unitUniforms, width, wireUniforms;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}, {
					to: 'mesh.map',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			position = this.bind.points.sourceShader(this._shaders.shader());
			position = this._helpers.position.pipeline(position);
			styleUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			wireUniforms = {};
			wireUniforms.styleZBias = this._attributes.make(this._types.number());
			this.wireZBias = wireUniforms.styleZBias;
			dims = this.bind.points.getDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			ref = this.props, line = ref.line, shaded = ref.shaded, fill = ref.fill, stroke = ref.stroke, join = ref.join;
			if (this.bind.colors) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			map = this._helpers.shade.map((ref1 = this.bind.map) != null ? ref1.sourceShader(this._shaders.shader()) : void 0);
			material = this._helpers.shade.pipeline();
			faceMaterial = material || shaded;
			lineMaterial = material || false;
			objects = [];
			if (line) {
				swizzle = this._shaders.shader();
				swizzle.pipe(Util.GLSL.swizzleVec4('yzwx'));
				swizzle.pipe(position);
				uniforms = Util.JS.merge(unitUniforms, lineUniforms, styleUniforms, wireUniforms);
				this.line = this._renderables.make('line', {
					uniforms: uniforms,
					samples: items,
					strips: width,
					ribbons: height,
					layers: depth,
					position: swizzle,
					color: color,
					stroke: stroke,
					join: join,
					material: lineMaterial,
					mask: mask,
					closed: true
				});
				objects.push(this.line);
			}
			if (fill) {
				uniforms = Util.JS.merge(unitUniforms, styleUniforms, {});
				this.face = this._renderables.make('face', {
					uniforms: uniforms,
					width: width,
					height: height,
					depth: depth,
					items: items,
					position: position,
					color: color,
					material: faceMaterial,
					mask: mask,
					map: map
				});
				objects.push(this.face);
			}
			this._helpers.visible.make();
			return this._helpers.object.make(objects);
		};
	
		Face.prototype.made = function() {
			return this.resize();
		};
	
		Face.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.face = this.line = null;
		};
	
		Face.prototype.change = function(changed, touched, init) {
			var fill, lineBias, ref, zBias;
			if (changed['geometry.points'] || touched['mesh']) {
				return this.rebuild();
			}
			if (changed['style.zBias'] || changed['mesh.lineBias'] || init) {
				ref = this.props, fill = ref.fill, zBias = ref.zBias, lineBias = ref.lineBias;
				return this.wireZBias.value = zBias + (fill ? lineBias : 0);
			}
		};
	
		return Face;
	
	})(Primitive);
	
	module.exports = Face;
	
	
	/***/ }),
	/* 113 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Grid, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Grid = (function(superClass) {
		extend(Grid, superClass);
	
		Grid.traits = ['node', 'object', 'visible', 'style', 'line', 'grid', 'area', 'position', 'origin', 'shade', 'axis:x', 'axis:y', 'scale:x', 'scale:y', 'span:x', 'span:y'];
	
		Grid.defaults = {
			width: 1,
			zBias: -2
		};
	
		function Grid(node, context, helpers) {
			Grid.__super__.constructor.call(this, node, context, helpers);
			this.axes = null;
		}
	
		Grid.prototype.make = function() {
			var axes, axis, crossed, join, lineX, lineY, lines, mask, material, ref, ref1, stroke, transpose;
			mask = this._helpers.object.mask();
			material = this._helpers.shade.pipeline() || false;
			axis = (function(_this) {
				return function(first, second, transpose) {
					var buffer, detail, line, lineUniforms, p, position, positionUniforms, resolution, samples, strips, styleUniforms, uniforms, unitUniforms, values;
					detail = _this._get(first + 'axis.detail');
					samples = detail + 1;
					resolution = 1 / detail;
					strips = _this._helpers.scale.divide(second);
					buffer = _this._renderables.make('dataBuffer', {
						width: strips,
						channels: 1
					});
					positionUniforms = {
						gridPosition: _this._attributes.make(_this._types.vec4()),
						gridStep: _this._attributes.make(_this._types.vec4()),
						gridAxis: _this._attributes.make(_this._types.vec4())
					};
					values = {
						gridPosition: positionUniforms.gridPosition.value,
						gridStep: positionUniforms.gridStep.value,
						gridAxis: positionUniforms.gridAxis.value
					};
					p = position = _this._shaders.shader();
					if ((transpose != null) && (mask != null)) {
						mask = _this._helpers.position.swizzle(mask, transpose);
					}
					p.require(buffer.shader(_this._shaders.shader(), 2));
					p.pipe('grid.position', positionUniforms);
					position = _this._helpers.position.pipeline(p);
					styleUniforms = _this._helpers.style.uniforms();
					lineUniforms = _this._helpers.line.uniforms();
					unitUniforms = _this._inherit('unit').getUnitUniforms();
					uniforms = Util.JS.merge(lineUniforms, styleUniforms, unitUniforms);
					line = _this._renderables.make('line', {
						uniforms: uniforms,
						samples: samples,
						strips: strips,
						position: position,
						stroke: stroke,
						join: join,
						mask: mask,
						material: material
					});
					return {
						first: first,
						second: second,
						resolution: resolution,
						samples: samples,
						line: line,
						buffer: buffer,
						values: values
					};
				};
			})(this);
			ref = this.props, lineX = ref.lineX, lineY = ref.lineY, crossed = ref.crossed, axes = ref.axes;
			transpose = ['0000', 'x000', 'y000', 'z000', 'w000'][axes[1]];
			ref1 = this.props, stroke = ref1.stroke, join = ref1.join;
			this.axes = [];
			lineX && this.axes.push(axis('x.', 'y.', null));
			lineY && this.axes.push(axis('y.', 'x.', crossed ? null : transpose));
			lines = (function() {
				var i, len, ref2, results;
				ref2 = this.axes;
				results = [];
				for (i = 0, len = ref2.length; i < len; i++) {
					axis = ref2[i];
					results.push(axis.line);
				}
				return results;
			}).call(this);
			this._helpers.visible.make();
			this._helpers.object.make(lines);
			this._helpers.span.make();
			return this._listen(this, 'span.range', this.updateRanges);
		};
	
		Grid.prototype.unmake = function() {
			var axis, i, len, ref;
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			this._helpers.span.unmake();
			ref = this.axes;
			for (i = 0, len = ref.length; i < len; i++) {
				axis = ref[i];
				axis.buffer.dispose();
			}
			return this.axes = null;
		};
	
		Grid.prototype.change = function(changed, touched, init) {
			if (changed['x.axis.detail'] || changed['y.axis.detail'] || changed['x.axis.factor'] || changed['y.axis.factor'] || changed['grid.lineX'] || changed['grid.lineY'] || changed['line.stroke'] || changed['line.join'] || changed['grid.crossed'] || (changed['grid.axes'] && this.props.crossed)) {
				return this.rebuild();
			}
			if (touched['x'] || touched['y'] || touched['area'] || touched['grid'] || touched['view'] || touched['origin'] || init) {
				return this.updateRanges();
			}
		};
	
		Grid.prototype.updateRanges = function() {
			var axes, axis, lineX, lineY, origin, range1, range2, ref, ref1;
			axis = (function(_this) {
				return function(x, y, range1, range2, axis) {
					var buffer, first, line, max, min, n, resolution, samples, second, ticks, values;
					first = axis.first, second = axis.second, resolution = axis.resolution, samples = axis.samples, line = axis.line, buffer = axis.buffer, values = axis.values;
					min = range1.x;
					max = range1.y;
					Util.Axis.setDimension(values.gridPosition, x).multiplyScalar(min);
					Util.Axis.setDimension(values.gridStep, x).multiplyScalar((max - min) * resolution);
					Util.Axis.addOrigin(values.gridPosition, axes, origin);
					min = range2.x;
					max = range2.y;
					ticks = _this._helpers.scale.generate(second, buffer, min, max);
					Util.Axis.setDimension(values.gridAxis, y);
					n = ticks.length;
					return line.geometry.clip(samples, n, 1, 1);
				};
			})(this);
			ref = this.props, axes = ref.axes, origin = ref.origin;
			range1 = this._helpers.span.get('x.', axes[0]);
			range2 = this._helpers.span.get('y.', axes[1]);
			ref1 = this.props, lineX = ref1.lineX, lineY = ref1.lineY;
			if (lineX) {
				axis(axes[0], axes[1], range1, range2, this.axes[0]);
			}
			if (lineY) {
				return axis(axes[1], axes[0], range2, range1, this.axes[+lineX]);
			}
		};
	
		return Grid;
	
	})(Primitive);
	
	module.exports = Grid;
	
	
	/***/ }),
	/* 114 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Line, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Line = (function(superClass) {
		extend(Line, superClass);
	
		Line.traits = ['node', 'object', 'visible', 'style', 'line', 'arrow', 'geometry', 'position', 'bind', 'shade', 'closed'];
	
		function Line(node, context, helpers) {
			Line.__super__.constructor.call(this, node, context, helpers);
			this.line = this.arrows = null;
		}
	
		Line.prototype.resize = function() {
			var arrow, dims, i, layers, len, ref, results, ribbons, samples, strips;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			samples = dims.width;
			strips = dims.height;
			ribbons = dims.depth;
			layers = dims.items;
			this.line.geometry.clip(samples, strips, ribbons, layers);
			ref = this.arrows;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				arrow = ref[i];
				results.push(arrow.geometry.clip(samples, strips, ribbons, layers));
			}
			return results;
		};
	
		Line.prototype.make = function() {
			var arrowUniforms, closed, color, dims, end, join, layers, lineUniforms, mask, material, position, proximity, ref, ref1, ribbons, samples, start, strips, stroke, styleUniforms, uniforms, unitUniforms;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			position = this._shaders.shader();
			position = this.bind.points.sourceShader(position);
			position = this._helpers.position.pipeline(position);
			styleUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			arrowUniforms = this._helpers.arrow.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			ref = this.props, start = ref.start, end = ref.end;
			closed = this.props.closed;
			ref1 = this.props, stroke = ref1.stroke, join = ref1.join, proximity = ref1.proximity, closed = ref1.closed;
			this.proximity = proximity;
			dims = this.bind.points.getDimensions();
			samples = dims.width;
			strips = dims.height;
			ribbons = dims.depth;
			layers = dims.items;
			if (this.bind.colors) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			material = this._helpers.shade.pipeline() || false;
			uniforms = Util.JS.merge(arrowUniforms, lineUniforms, styleUniforms, unitUniforms);
			this.line = this._renderables.make('line', {
				uniforms: uniforms,
				samples: samples,
				strips: strips,
				ribbons: ribbons,
				layers: layers,
				position: position,
				color: color,
				clip: start || end,
				closed: closed,
				stroke: stroke,
				join: join,
				proximity: proximity,
				closed: closed,
				mask: mask,
				material: material
			});
			this.arrows = [];
			if (start) {
				this.arrows.push(this._renderables.make('arrow', {
					uniforms: uniforms,
					flip: true,
					samples: samples,
					strips: strips,
					ribbons: ribbons,
					layers: layers,
					position: position,
					color: color,
					closed: closed,
					mask: mask,
					material: material
				}));
			}
			if (end) {
				this.arrows.push(this._renderables.make('arrow', {
					uniforms: uniforms,
					samples: samples,
					strips: strips,
					ribbons: ribbons,
					layers: layers,
					position: position,
					color: color,
					closed: closed,
					mask: mask,
					material: material
				}));
			}
			this._helpers.visible.make();
			return this._helpers.object.make(this.arrows.concat([this.line]));
		};
	
		Line.prototype.made = function() {
			return this.resize();
		};
	
		Line.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.line = this.arrows = null;
		};
	
		Line.prototype.change = function(changed, touched, init) {
			if (changed['geometry.points'] || changed['line.stroke'] || changed['line.join'] || changed['arrow.start'] || changed['arrow.end']) {
				return this.rebuild();
			}
			if (changed['line.proximity']) {
				if ((this.proximity != null) !== (this.props.proximity != null)) {
					return this.rebuild();
				}
			}
		};
	
		return Line;
	
	})(Primitive);
	
	module.exports = Line;
	
	
	/***/ }),
	/* 115 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Point, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Point = (function(superClass) {
		extend(Point, superClass);
	
		Point.traits = ['node', 'object', 'visible', 'style', 'point', 'geometry', 'position', 'bind', 'shade'];
	
		function Point(node, context, helpers) {
			Point.__super__.constructor.call(this, node, context, helpers);
			this.point = null;
		}
	
		Point.prototype.resize = function() {
			var depth, dims, height, items, width;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			return this.point.geometry.clip(width, height, depth, items);
		};
	
		Point.prototype.make = function() {
			var color, depth, dims, fill, height, items, mask, material, optical, pointUniforms, position, shape, size, styleUniforms, uniforms, unitUniforms, width;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}, {
					to: 'point.sizes',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			position = this._shaders.shader();
			position = this.bind.points.sourceShader(position);
			position = this._helpers.position.pipeline(position);
			dims = this.bind.points.getDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			styleUniforms = this._helpers.style.uniforms();
			pointUniforms = this._helpers.point.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			if (this.bind.colors) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			if (this.bind.sizes) {
				size = this._shaders.shader();
				this.bind.sizes.sourceShader(size);
			}
			mask = this._helpers.object.mask();
			material = this._helpers.shade.pipeline() || false;
			shape = this.props.shape;
			fill = this.props.fill;
			optical = this.props.optical;
			uniforms = Util.JS.merge(unitUniforms, pointUniforms, styleUniforms);
			this.point = this._renderables.make('point', {
				uniforms: uniforms,
				width: width,
				height: height,
				depth: depth,
				items: items,
				position: position,
				color: color,
				size: size,
				shape: shape,
				optical: optical,
				fill: fill,
				mask: mask,
				material: material
			});
			this._helpers.visible.make();
			return this._helpers.object.make([this.point]);
		};
	
		Point.prototype.made = function() {
			return this.resize();
		};
	
		Point.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.point = null;
		};
	
		Point.prototype.change = function(changed, touched, init) {
			if (changed['geometry.points'] || changed['point.shape'] || changed['point.fill']) {
				return this.rebuild();
			}
		};
	
		return Point;
	
	})(Primitive);
	
	module.exports = Point;
	
	
	/***/ }),
	/* 116 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Strip, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Strip = (function(superClass) {
		extend(Strip, superClass);
	
		Strip.traits = ['node', 'object', 'visible', 'style', 'line', 'mesh', 'strip', 'geometry', 'position', 'bind', 'shade'];
	
		function Strip(node, context, helpers) {
			Strip.__super__.constructor.call(this, node, context, helpers);
			this.strip = null;
		}
	
		Strip.prototype.resize = function() {
			var depth, dims, height, items, map, width;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			if (this.strip) {
				this.strip.geometry.clip(width, height, depth, items);
			}
			if (this.line) {
				this.line.geometry.clip(items, width, height, depth);
			}
			if (this.bind.map != null) {
				map = this.bind.map.getActiveDimensions();
				if (this.strip) {
					return this.strip.geometry.map(map.width, map.height, map.depth, map.items);
				}
			}
		};
	
		Strip.prototype.make = function() {
			var color, depth, dims, faceMaterial, fill, height, items, join, line, lineMaterial, lineUniforms, map, mask, material, objects, position, ref, ref1, shaded, stroke, styleUniforms, swizzle, uniforms, unitUniforms, width, wireUniforms;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}, {
					to: 'mesh.map',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			position = this._shaders.shader();
			position = this.bind.points.sourceShader(position);
			position = this._helpers.position.pipeline(position);
			styleUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			line = this.props.line;
			shaded = this.props.shaded;
			fill = this.props.fill;
			wireUniforms = {};
			wireUniforms.styleZBias = this._attributes.make(this._types.number());
			this.wireZBias = wireUniforms.styleZBias;
			dims = this.bind.points.getDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			ref = this.props, line = ref.line, shaded = ref.shaded, fill = ref.fill, stroke = ref.stroke, join = ref.join;
			if (this.bind.colors) {
				color = this._shaders.shader();
				color = this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			map = this._helpers.shade.map((ref1 = this.bind.map) != null ? ref1.sourceShader(this._shaders.shader()) : void 0);
			material = this._helpers.shade.pipeline();
			faceMaterial = material || shaded;
			lineMaterial = material || false;
			objects = [];
			if (line) {
				swizzle = this._shaders.shader();
				swizzle.pipe(Util.GLSL.swizzleVec4('yzwx'));
				swizzle.pipe(position);
				uniforms = Util.JS.merge(unitUniforms, lineUniforms, styleUniforms, wireUniforms);
				this.line = this._renderables.make('line', {
					uniforms: uniforms,
					samples: items,
					strips: width,
					ribbons: height,
					layers: depth,
					position: swizzle,
					color: color,
					stroke: stroke,
					join: join,
					mask: mask,
					material: lineMaterial
				});
				objects.push(this.line);
			}
			if (fill) {
				uniforms = Util.JS.merge(styleUniforms, {});
				this.strip = this._renderables.make('strip', {
					uniforms: uniforms,
					width: width,
					height: height,
					depth: depth,
					items: items,
					position: position,
					color: color,
					material: faceMaterial
				});
				objects.push(this.strip);
			}
			this._helpers.visible.make();
			return this._helpers.object.make(objects);
		};
	
		Strip.prototype.made = function() {
			return this.resize();
		};
	
		Strip.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.strip = null;
		};
	
		Strip.prototype.change = function(changed, touched, init) {
			var fill, lineBias, ref, zBias;
			if (changed['geometry.points'] || touched['mesh']) {
				return this.rebuild();
			}
			if (changed['style.zBias'] || changed['mesh.lineBias'] || init) {
				ref = this.props, fill = ref.fill, zBias = ref.zBias, lineBias = ref.lineBias;
				return this.wireZBias.value = zBias + (fill ? lineBias : 0);
			}
		};
	
		return Strip;
	
	})(Primitive);
	
	module.exports = Strip;
	
	
	/***/ }),
	/* 117 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Surface, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Surface = (function(superClass) {
		extend(Surface, superClass);
	
		Surface.traits = ['node', 'object', 'visible', 'style', 'line', 'mesh', 'geometry', 'surface', 'position', 'grid', 'bind', 'shade'];
	
		Surface.defaults = {
			lineX: false,
			lineY: false
		};
	
		function Surface(node, context, helpers) {
			Surface.__super__.constructor.call(this, node, context, helpers);
			this.lineX = this.lineY = this.surface = null;
		}
	
		Surface.prototype.resize = function() {
			var depth, dims, height, items, map, width;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			width = dims.width, height = dims.height, depth = dims.depth, items = dims.items;
			if (this.surface) {
				this.surface.geometry.clip(width, height, depth, items);
			}
			if (this.lineX) {
				this.lineX.geometry.clip(width, height, depth, items);
			}
			if (this.lineY) {
				this.lineY.geometry.clip(height, width, depth, items);
			}
			if (this.bind.map != null) {
				map = this.bind.map.getActiveDimensions();
				if (this.surface) {
					return this.surface.geometry.map(map.width, map.height, map.depth, map.items);
				}
			}
		};
	
		Surface.prototype.make = function() {
			var closedX, closedY, color, crossed, depth, dims, faceMaterial, fill, height, items, join, lineMaterial, lineUniforms, lineX, lineY, map, mask, material, normal, objects, position, proximity, ref, ref1, ref2, shaded, stroke, styleUniforms, surfaceUniforms, swizzle, swizzle2, uniforms, unitUniforms, width, wireUniforms, zUnits;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}, {
					to: 'mesh.normals',
					trait: 'source'
				}, {
					to: 'mesh.map',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			position = this._shaders.shader();
			position = this.bind.points.sourceShader(position);
			position = this._helpers.position.pipeline(position);
			styleUniforms = this._helpers.style.uniforms();
			wireUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			surfaceUniforms = this._helpers.surface.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			wireUniforms.styleColor = this._attributes.make(this._types.color());
			wireUniforms.styleZBias = this._attributes.make(this._types.number());
			this.wireColor = wireUniforms.styleColor.value;
			this.wireZBias = wireUniforms.styleZBias;
			this.wireScratch = new THREE.Color;
			dims = this.bind.points.getDimensions();
			width = dims.width, height = dims.height, depth = dims.depth, items = dims.items;
			ref = this.props, shaded = ref.shaded, fill = ref.fill, lineX = ref.lineX, lineY = ref.lineY, closedX = ref.closedX, closedY = ref.closedY, stroke = ref.stroke, join = ref.join, proximity = ref.proximity, crossed = ref.crossed;
			objects = [];
			this.proximity = proximity;
			if (this.bind.normals != null) {
				normal = this._shaders.shader();
				this.bind.normals.sourceShader(normal);
				this._helpers.shade.normal(normal);
			}
			if (this.bind.colors != null) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			map = this._helpers.shade.map((ref1 = this.bind.map) != null ? ref1.sourceShader(this._shaders.shader()) : void 0);
			material = this._helpers.shade.pipeline();
			faceMaterial = material || shaded;
			lineMaterial = material || false;
			ref2 = this._helpers.position, swizzle = ref2.swizzle, swizzle2 = ref2.swizzle2;
			uniforms = Util.JS.merge(unitUniforms, lineUniforms, styleUniforms, wireUniforms);
			zUnits = lineX || lineY ? -50 : 0;
			if (lineX) {
				this.lineX = this._renderables.make('line', {
					uniforms: uniforms,
					samples: width,
					strips: height,
					ribbons: depth,
					layers: items,
					position: position,
					color: color,
					zUnits: -zUnits,
					stroke: stroke,
					join: join,
					mask: mask,
					material: lineMaterial,
					proximity: proximity,
					closed: closedX || closed
				});
				objects.push(this.lineX);
			}
			if (lineY) {
				this.lineY = this._renderables.make('line', {
					uniforms: uniforms,
					samples: height,
					strips: width,
					ribbons: depth,
					layers: items,
					position: swizzle2(position, 'yxzw', 'yxzw'),
					color: swizzle(color, 'yxzw'),
					zUnits: -zUnits,
					stroke: stroke,
					join: join,
					mask: swizzle(mask, crossed ? 'xyzw' : 'yxzw'),
					material: lineMaterial,
					proximity: proximity,
					closed: closedY || closed
				});
				objects.push(this.lineY);
			}
			if (fill) {
				uniforms = Util.JS.merge(unitUniforms, surfaceUniforms, styleUniforms);
				this.surface = this._renderables.make('surface', {
					uniforms: uniforms,
					width: width,
					height: height,
					surfaces: depth,
					layers: items,
					position: position,
					color: color,
					normal: normal,
					zUnits: zUnits,
					stroke: stroke,
					material: faceMaterial,
					mask: mask,
					map: map,
					intUV: true,
					closedX: closedX || closed,
					closedY: closedY || closed
				});
				objects.push(this.surface);
			}
			this._helpers.visible.make();
			return this._helpers.object.make(objects);
		};
	
		Surface.prototype.made = function() {
			return this.resize();
		};
	
		Surface.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.lineX = this.lineY = this.surface = null;
		};
	
		Surface.prototype.change = function(changed, touched, init) {
			var c, color, fill, lineBias, ref, zBias;
			if (changed['geometry.points'] || changed['mesh.shaded'] || changed['mesh.fill'] || changed['line.stroke'] || changed['line.join'] || touched['grid']) {
				return this.rebuild();
			}
			if (changed['style.color'] || changed['style.zBias'] || changed['mesh.fill'] || changed['mesh.lineBias'] || init) {
				ref = this.props, fill = ref.fill, color = ref.color, zBias = ref.zBias, lineBias = ref.lineBias;
				this.wireZBias.value = zBias + (fill ? lineBias : 0);
				this.wireColor.copy(color);
				if (fill) {
					c = this.wireScratch;
					c.setRGB(color.x, color.y, color.z);
					c.convertGammaToLinear().multiplyScalar(.75).convertLinearToGamma();
					this.wireColor.x = c.r;
					this.wireColor.y = c.g;
					this.wireColor.z = c.b;
				}
			}
			if (changed['line.proximity']) {
				if ((this.proximity != null) !== (this.props.proximity != null)) {
					return this.rebuild();
				}
			}
		};
	
		return Surface;
	
	})(Primitive);
	
	module.exports = Surface;
	
	
	/***/ }),
	/* 118 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Ticks, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Ticks = (function(superClass) {
		extend(Ticks, superClass);
	
		function Ticks() {
			return Ticks.__super__.constructor.apply(this, arguments);
		}
	
		Ticks.traits = ['node', 'object', 'visible', 'style', 'line', 'ticks', 'geometry', 'position', 'bind', 'shade'];
	
		Ticks.prototype.init = function() {
			return this.tickStrip = this.line = null;
		};
	
		Ticks.prototype.resize = function() {
			var active, dims, layers, ribbons, strips;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			active = +(dims.items > 0);
			strips = dims.width * active;
			ribbons = dims.height * active;
			layers = dims.depth * active;
			this.line.geometry.clip(2, strips, ribbons, layers);
			return this.tickStrip.set(0, strips - 1);
		};
	
		Ticks.prototype.make = function() {
			var color, dims, join, layers, lineUniforms, mask, material, p, position, positionUniforms, ref, ref1, ribbons, strips, stroke, styleUniforms, swizzle, swizzle2, uniforms, unitUniforms;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			styleUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			uniforms = Util.JS.merge(lineUniforms, styleUniforms, unitUniforms);
			positionUniforms = {
				tickEpsilon: this.node.attributes['ticks.epsilon'],
				tickSize: this.node.attributes['ticks.size'],
				tickNormal: this.node.attributes['ticks.normal'],
				tickStrip: this._attributes.make(this._types.vec2(0, 0)),
				worldUnit: uniforms.worldUnit,
				focusDepth: uniforms.focusDepth
			};
			this.tickStrip = positionUniforms.tickStrip.value;
			p = position = this._shaders.shader();
			p.require(this.bind.points.sourceShader(this._shaders.shader()));
			p.require(this._helpers.position.pipeline(this._shaders.shader()));
			p.pipe('ticks.position', positionUniforms);
			ref = this.props, stroke = ref.stroke, join = ref.join;
			dims = this.bind.points.getDimensions();
			strips = dims.width;
			ribbons = dims.height;
			layers = dims.depth;
			if (this.bind.colors) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			material = this._helpers.shade.pipeline() || false;
			ref1 = this._helpers.position, swizzle = ref1.swizzle, swizzle2 = ref1.swizzle2;
			this.line = this._renderables.make('line', {
				uniforms: uniforms,
				samples: 2,
				strips: strips,
				ribbons: ribbons,
				layers: layers,
				position: position,
				color: color,
				stroke: stroke,
				join: join,
				mask: swizzle(mask, 'yzwx'),
				material: material
			});
			this._helpers.visible.make();
			return this._helpers.object.make([this.line]);
		};
	
		Ticks.prototype.made = function() {
			return this.resize();
		};
	
		Ticks.prototype.unmake = function() {
			this.line = null;
			this._helpers.visible.unmake();
			return this._helpers.object.unmake();
		};
	
		Ticks.prototype.change = function(changed, touched, init) {
			if (changed['geometry.points'] || changed['line.stroke'] || changed['line.join']) {
				return this.rebuild();
			}
		};
	
		return Ticks;
	
	})(Primitive);
	
	module.exports = Ticks;
	
	
	/***/ }),
	/* 119 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Util, Vector,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Vector = (function(superClass) {
		extend(Vector, superClass);
	
		Vector.traits = ['node', 'object', 'visible', 'style', 'line', 'arrow', 'geometry', 'position', 'bind', 'shade'];
	
		function Vector(node, context, helpers) {
			Vector.__super__.constructor.call(this, node, context, helpers);
			this.line = this.arrows = null;
		}
	
		Vector.prototype.resize = function() {
			var arrow, dims, i, layers, len, ref, results, ribbons, samples, strips;
			if (this.bind.points == null) {
				return;
			}
			dims = this.bind.points.getActiveDimensions();
			samples = dims.items;
			strips = dims.width;
			ribbons = dims.height;
			layers = dims.depth;
			this.line.geometry.clip(samples, strips, ribbons, layers);
			ref = this.arrows;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				arrow = ref[i];
				results.push(arrow.geometry.clip(samples, strips, ribbons, layers));
			}
			return results;
		};
	
		Vector.prototype.make = function() {
			var arrowUniforms, closed, color, dims, end, join, layers, lineUniforms, mask, material, position, proximity, ref, ref1, ref2, ribbons, samples, start, strips, stroke, styleUniforms, swizzle, swizzle2, uniforms, unitUniforms;
			this._helpers.bind.make([
				{
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			position = this._shaders.shader();
			this.bind.points.sourceShader(position);
			this._helpers.position.pipeline(position);
			styleUniforms = this._helpers.style.uniforms();
			lineUniforms = this._helpers.line.uniforms();
			arrowUniforms = this._helpers.arrow.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			ref = this.props, start = ref.start, end = ref.end;
			ref1 = this.props, stroke = ref1.stroke, join = ref1.join, proximity = ref1.proximity, closed = ref1.closed;
			this.proximity = proximity;
			dims = this.bind.points.getDimensions();
			samples = dims.items;
			strips = dims.width;
			ribbons = dims.height;
			layers = dims.depth;
			if (this.bind.colors) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			material = this._helpers.shade.pipeline() || false;
			ref2 = this._helpers.position, swizzle = ref2.swizzle, swizzle2 = ref2.swizzle2;
			position = swizzle2(position, 'yzwx', 'yzwx');
			color = swizzle(color, 'yzwx');
			mask = swizzle(mask, 'yzwx');
			material = swizzle(material, 'yzwx');
			uniforms = Util.JS.merge(arrowUniforms, lineUniforms, styleUniforms, unitUniforms);
			this.line = this._renderables.make('line', {
				uniforms: uniforms,
				samples: samples,
				ribbons: ribbons,
				strips: strips,
				layers: layers,
				position: position,
				color: color,
				clip: start || end,
				stroke: stroke,
				join: join,
				proximity: proximity,
				closed: closed,
				mask: mask,
				material: material
			});
			this.arrows = [];
			if (start) {
				this.arrows.push(this._renderables.make('arrow', {
					uniforms: uniforms,
					flip: true,
					samples: samples,
					ribbons: ribbons,
					strips: strips,
					layers: layers,
					position: position,
					color: color,
					closed: closed,
					mask: mask,
					material: material
				}));
			}
			if (end) {
				this.arrows.push(this._renderables.make('arrow', {
					uniforms: uniforms,
					samples: samples,
					ribbons: ribbons,
					strips: strips,
					layers: layers,
					position: position,
					color: color,
					closed: closed,
					mask: mask,
					material: material
				}));
			}
			this._helpers.visible.make();
			return this._helpers.object.make(this.arrows.concat([this.line]));
		};
	
		Vector.prototype.made = function() {
			return this.resize();
		};
	
		Vector.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.line = this.arrows = null;
		};
	
		Vector.prototype.change = function(changed, touched, init) {
			if (changed['geometry.points'] || changed['line.stroke'] || changed['line.join'] || changed['arrow.start'] || changed['arrow.end']) {
				return this.rebuild();
			}
			if (changed['line.proximity']) {
				if ((this.proximity != null) !== (this.props.proximity != null)) {
					return this.rebuild();
				}
			}
		};
	
		return Vector;
	
	})(Primitive);
	
	module.exports = Vector;
	
	
	/***/ }),
	/* 120 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Cartesian, Util, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	View = __webpack_require__(7);
	
	Util = __webpack_require__(0);
	
	Cartesian = (function(superClass) {
		extend(Cartesian, superClass);
	
		function Cartesian() {
			return Cartesian.__super__.constructor.apply(this, arguments);
		}
	
		Cartesian.traits = ['node', 'object', 'visible', 'view', 'view3', 'vertex'];
	
		Cartesian.prototype.make = function() {
			Cartesian.__super__.make.apply(this, arguments);
			this.uniforms = {
				viewMatrix: this._attributes.make(this._types.mat4())
			};
			this.viewMatrix = this.uniforms.viewMatrix.value;
			return this.composer = Util.Three.transformComposer();
		};
	
		Cartesian.prototype.unmake = function() {
			Cartesian.__super__.unmake.apply(this, arguments);
			delete this.viewMatrix;
			delete this.objectMatrix;
			return delete this.uniforms;
		};
	
		Cartesian.prototype.change = function(changed, touched, init) {
			var dx, dy, dz, e, g, p, q, r, s, sx, sy, sz, transformMatrix, x, y, z;
			if (!(touched['view'] || touched['view3'] || init)) {
				return;
			}
			p = this.props.position;
			s = this.props.scale;
			q = this.props.quaternion;
			r = this.props.rotation;
			g = this.props.range;
			e = this.props.eulerOrder;
			x = g[0].x;
			y = g[1].x;
			z = g[2].x;
			dx = (g[0].y - x) || 1;
			dy = (g[1].y - y) || 1;
			dz = (g[2].y - z) || 1;
			sx = s.x;
			sy = s.y;
			sz = s.z;
			this.viewMatrix.set(2 / dx, 0, 0, -(2 * x + dx) / dx, 0, 2 / dy, 0, -(2 * y + dy) / dy, 0, 0, 2 / dz, -(2 * z + dz) / dz, 0, 0, 0, 1);
			transformMatrix = this.composer(p, r, q, s, null, e);
			this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);
			if (changed['view.range']) {
				return this.trigger({
					type: 'view.range'
				});
			}
		};
	
		Cartesian.prototype.vertex = function(shader, pass) {
			if (pass === 1) {
				shader.pipe('cartesian.position', this.uniforms);
			}
			return Cartesian.__super__.vertex.call(this, shader, pass);
		};
	
		return Cartesian;
	
	})(View);
	
	module.exports = Cartesian;
	
	
	/***/ }),
	/* 121 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Cartesian4, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	View = __webpack_require__(7);
	
	Cartesian4 = (function(superClass) {
		extend(Cartesian4, superClass);
	
		function Cartesian4() {
			return Cartesian4.__super__.constructor.apply(this, arguments);
		}
	
		Cartesian4.traits = ['node', 'object', 'visible', 'view', 'view4', 'vertex'];
	
		Cartesian4.prototype.make = function() {
			Cartesian4.__super__.make.apply(this, arguments);
			this.uniforms = {
				basisOffset: this._attributes.make(this._types.vec4()),
				basisScale: this._attributes.make(this._types.vec4())
			};
			this.basisScale = this.uniforms.basisScale.value;
			return this.basisOffset = this.uniforms.basisOffset.value;
		};
	
		Cartesian4.prototype.unmake = function() {
			Cartesian4.__super__.unmake.apply(this, arguments);
			delete this.basisScale;
			delete this.basisOffset;
			return delete this.uniforms;
		};
	
		Cartesian4.prototype.change = function(changed, touched, init) {
			var dw, dx, dy, dz, g, mult, p, s, w, x, y, z;
			if (!(touched['view'] || touched['view4'] || init)) {
				return;
			}
			p = this.props.position;
			s = this.props.scale;
			g = this.props.range;
			x = g[0].x;
			y = g[1].x;
			z = g[2].x;
			w = g[3].x;
			dx = (g[0].y - x) || 1;
			dy = (g[1].y - y) || 1;
			dz = (g[2].y - z) || 1;
			dw = (g[3].y - w) || 1;
			mult = function(a, b) {
				a.x *= b.x;
				a.y *= b.y;
				a.z *= b.z;
				return a.w *= b.w;
			};
			this.basisScale.set(2 / dx, 2 / dy, 2 / dz, 2 / dw);
			this.basisOffset.set(-(2 * x + dx) / dx, -(2 * y + dy) / dy, -(2 * z + dz) / dz, -(2 * w + dw) / dw);
			mult(this.basisScale, s);
			mult(this.basisOffset, s);
			this.basisOffset.add(p);
			if (changed['view.range']) {
				return this.trigger({
					type: 'view.range'
				});
			}
		};
	
		Cartesian4.prototype.vertex = function(shader, pass) {
			if (pass === 1) {
				shader.pipe('cartesian4.position', this.uniforms);
			}
			return Cartesian4.__super__.vertex.call(this, shader, pass);
		};
	
		return Cartesian4;
	
	})(View);
	
	module.exports = Cartesian4;
	
	
	/***/ }),
	/* 122 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Polar, THREE, Util, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	View = __webpack_require__(7);
	
	Util = __webpack_require__(0);
	
	Polar = (function(superClass) {
		extend(Polar, superClass);
	
		function Polar() {
			return Polar.__super__.constructor.apply(this, arguments);
		}
	
		Polar.traits = ['node', 'object', 'visible', 'view', 'view3', 'polar', 'vertex'];
	
		Polar.prototype.make = function() {
			var types;
			Polar.__super__.make.apply(this, arguments);
			types = this._attributes.types;
			this.uniforms = {
				polarBend: this.node.attributes['polar.bend'],
				polarHelix: this.node.attributes['polar.helix'],
				polarFocus: this._attributes.make(types.number()),
				polarAspect: this._attributes.make(types.number()),
				viewMatrix: this._attributes.make(types.mat4())
			};
			this.viewMatrix = this.uniforms.viewMatrix.value;
			this.composer = Util.Three.transformComposer();
			return this.aspect = 1;
		};
	
		Polar.prototype.unmake = function() {
			Polar.__super__.unmake.apply(this, arguments);
			delete this.viewMatrix;
			delete this.objectMatrix;
			delete this.aspect;
			return delete this.uniforms;
		};
	
		Polar.prototype.change = function(changed, touched, init) {
			var ady, aspect, bend, dx, dy, dz, e, fdx, focus, g, helix, idx, p, q, r, ref, s, sdx, sdy, sx, sy, sz, transformMatrix, x, y, z;
			if (!(touched['view'] || touched['view3'] || touched['polar'] || init)) {
				return;
			}
			this.helix = helix = this.props.helix;
			this.bend = bend = this.props.bend;
			this.focus = focus = bend > 0 ? 1 / bend - 1 : 0;
			p = this.props.position;
			s = this.props.scale;
			q = this.props.quaternion;
			r = this.props.rotation;
			g = this.props.range;
			e = this.props.eulerOrder;
			x = g[0].x;
			y = g[1].x;
			z = g[2].x;
			dx = (g[0].y - x) || 1;
			dy = (g[1].y - y) || 1;
			dz = (g[2].y - z) || 1;
			sx = s.x;
			sy = s.y;
			sz = s.z;
			idx = dx > 0 ? 1 : -1;
			ref = Util.Axis.recenterAxis(y, dy, bend), y = ref[0], dy = ref[1];
			ady = Math.abs(dy);
			fdx = dx + (ady * idx - dx) * bend;
			sdx = fdx / sx;
			sdy = dy / sy;
			this.aspect = aspect = Math.abs(sdx / sdy);
			this.uniforms.polarFocus.value = focus;
			this.uniforms.polarAspect.value = aspect;
			this.viewMatrix.set(2 / fdx, 0, 0, -(2 * x + dx) / dx, 0, 2 / dy, 0, -(2 * y + dy) / dy, 0, 0, 2 / dz, -(2 * z + dz) / dz, 0, 0, 0, 1);
			transformMatrix = this.composer(p, r, q, s, null, e);
			this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);
			if (changed['view.range'] || touched['polar']) {
				return this.trigger({
					type: 'view.range'
				});
			}
		};
	
		Polar.prototype.vertex = function(shader, pass) {
			if (pass === 1) {
				shader.pipe('polar.position', this.uniforms);
			}
			return Polar.__super__.vertex.call(this, shader, pass);
		};
	
		Polar.prototype.axis = function(dimension) {
			var max, min, range;
			range = this.props.range[dimension - 1];
			min = range.x;
			max = range.y;
			if (dimension === 2 && this.bend > 0) {
				max = Math.max(Math.abs(max), Math.abs(min));
				min = Math.max(-this.focus / this.aspect, min);
			}
			return new THREE.Vector2(min, max);
		};
	
		return Polar;
	
	})(View);
	
	module.exports = Polar;
	
	
	/***/ }),
	/* 123 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Spherical, THREE, Util, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	View = __webpack_require__(7);
	
	Util = __webpack_require__(0);
	
	Spherical = (function(superClass) {
		extend(Spherical, superClass);
	
		function Spherical() {
			return Spherical.__super__.constructor.apply(this, arguments);
		}
	
		Spherical.traits = ['node', 'object', 'visible', 'view', 'view3', 'spherical', 'vertex'];
	
		Spherical.prototype.make = function() {
			var types;
			Spherical.__super__.make.apply(this, arguments);
			types = this._attributes.types;
			this.uniforms = {
				sphericalBend: this.node.attributes['spherical.bend'],
				sphericalFocus: this._attributes.make(this._types.number()),
				sphericalAspectX: this._attributes.make(this._types.number()),
				sphericalAspectY: this._attributes.make(this._types.number()),
				sphericalScaleY: this._attributes.make(this._types.number()),
				viewMatrix: this._attributes.make(this._types.mat4())
			};
			this.viewMatrix = this.uniforms.viewMatrix.value;
			this.composer = Util.Three.transformComposer();
			this.aspectX = 1;
			return this.aspectY = 1;
		};
	
		Spherical.prototype.unmake = function() {
			Spherical.__super__.unmake.apply(this, arguments);
			delete this.viewMatrix;
			delete this.objectMatrix;
			delete this.aspectX;
			delete this.aspectY;
			return delete this.uniforms;
		};
	
		Spherical.prototype.change = function(changed, touched, init) {
			var adz, aspectX, aspectY, aspectZ, bend, dx, dy, dz, e, fdx, fdy, focus, g, idx, idy, p, q, r, ref, ref1, s, scaleY, sdx, sdy, sdz, sx, sy, sz, transformMatrix, x, y, z;
			if (!(touched['view'] || touched['view3'] || touched['spherical'] || init)) {
				return;
			}
			this.bend = bend = this.props.bend;
			this.focus = focus = bend > 0 ? 1 / bend - 1 : 0;
			p = this.props.position;
			s = this.props.scale;
			q = this.props.quaternion;
			r = this.props.rotation;
			g = this.props.range;
			e = this.props.eulerOrder;
			x = g[0].x;
			y = g[1].x;
			z = g[2].x;
			dx = (g[0].y - x) || 1;
			dy = (g[1].y - y) || 1;
			dz = (g[2].y - z) || 1;
			sx = s.x;
			sy = s.y;
			sz = s.z;
			ref = Util.Axis.recenterAxis(y, dy, bend), y = ref[0], dy = ref[1];
			ref1 = Util.Axis.recenterAxis(z, dz, bend), z = ref1[0], dz = ref1[1];
			idx = dx > 0 ? 1 : -1;
			idy = dy > 0 ? 1 : -1;
			adz = Math.abs(dz);
			fdx = dx + (adz * idx - dx) * bend;
			fdy = dy + (adz * idy - dy) * bend;
			sdx = fdx / sx;
			sdy = fdy / sy;
			sdz = dz / sz;
			this.aspectX = aspectX = Math.abs(sdx / sdz);
			this.aspectY = aspectY = Math.abs(sdy / sdz / aspectX);
			aspectZ = dy / dx * sx / sy * 2;
			this.scaleY = scaleY = Math.min(aspectY / bend, 1 + (aspectZ - 1) * bend);
			this.uniforms.sphericalBend.value = bend;
			this.uniforms.sphericalFocus.value = focus;
			this.uniforms.sphericalAspectX.value = aspectX;
			this.uniforms.sphericalAspectY.value = aspectY;
			this.uniforms.sphericalScaleY.value = scaleY;
			this.viewMatrix.set(2 / fdx, 0, 0, -(2 * x + dx) / dx, 0, 2 / fdy, 0, -(2 * y + dy) / dy, 0, 0, 2 / dz, -(2 * z + dz) / dz, 0, 0, 0, 1);
			transformMatrix = this.composer(p, r, q, s, null, e);
			this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);
			if (changed['view.range'] || touched['spherical']) {
				return this.trigger({
					type: 'view.range'
				});
			}
		};
	
		Spherical.prototype.vertex = function(shader, pass) {
			if (pass === 1) {
				shader.pipe('spherical.position', this.uniforms);
			}
			return Spherical.__super__.vertex.call(this, shader, pass);
		};
	
		Spherical.prototype.axis = function(dimension) {
			var max, min, range;
			range = this.props.range[dimension - 1];
			min = range.x;
			max = range.y;
			if (dimension === 3 && this.bend > 0) {
				max = Math.max(Math.abs(max), Math.abs(min));
				min = Math.max(-this.focus / this.aspectX + .001, min);
			}
			return new THREE.Vector2(min, max);
		};
	
		return Spherical;
	
	})(View);
	
	module.exports = Spherical;
	
	
	/***/ }),
	/* 124 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Stereographic, Util, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	View = __webpack_require__(7);
	
	Util = __webpack_require__(0);
	
	Stereographic = (function(superClass) {
		extend(Stereographic, superClass);
	
		function Stereographic() {
			return Stereographic.__super__.constructor.apply(this, arguments);
		}
	
		Stereographic.traits = ['node', 'object', 'visible', 'view', 'view3', 'stereographic', 'vertex'];
	
		Stereographic.prototype.make = function() {
			var types;
			Stereographic.__super__.make.apply(this, arguments);
			types = this._attributes.types;
			this.uniforms = {
				stereoBend: this.node.attributes['stereographic.bend'],
				viewMatrix: this._attributes.make(this._types.mat4())
			};
			this.viewMatrix = this.uniforms.viewMatrix.value;
			return this.composer = Util.Three.transformComposer();
		};
	
		Stereographic.prototype.unmake = function() {
			Stereographic.__super__.unmake.apply(this, arguments);
			delete this.viewMatrix;
			delete this.rotationMatrix;
			return delete this.uniforms;
		};
	
		Stereographic.prototype.change = function(changed, touched, init) {
			var bend, dx, dy, dz, e, g, p, q, r, ref, s, sx, sy, sz, transformMatrix, x, y, z;
			if (!(touched['view'] || touched['view3'] || touched['stereographic'] || init)) {
				return;
			}
			this.bend = bend = this.props.bend;
			p = this.props.position;
			s = this.props.scale;
			q = this.props.quaternion;
			r = this.props.rotation;
			g = this.props.range;
			e = this.props.eulerOrder;
			x = g[0].x;
			y = g[1].x;
			z = g[2].x;
			dx = (g[0].y - x) || 1;
			dy = (g[1].y - y) || 1;
			dz = (g[2].y - z) || 1;
			sx = s.x;
			sy = s.y;
			sz = s.z;
			ref = Util.Axis.recenterAxis(z, dz, bend, 1), z = ref[0], dz = ref[1];
			this.uniforms.stereoBend.value = bend;
			this.viewMatrix.set(2 / dx, 0, 0, -(2 * x + dx) / dx, 0, 2 / dy, 0, -(2 * y + dy) / dy, 0, 0, 2 / dz, -(2 * z + dz) / dz, 0, 0, 0, 1);
			transformMatrix = this.composer(p, r, q, s, null, e);
			this.viewMatrix.multiplyMatrices(transformMatrix, this.viewMatrix);
			if (changed['view.range'] || touched['stereographic']) {
				return this.trigger({
					type: 'view.range'
				});
			}
		};
	
		Stereographic.prototype.vertex = function(shader, pass) {
			if (pass === 1) {
				shader.pipe('stereographic.position', this.uniforms);
			}
			return Stereographic.__super__.vertex.call(this, shader, pass);
		};
	
		return Stereographic;
	
	})(View);
	
	module.exports = Stereographic;
	
	
	/***/ }),
	/* 125 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Stereographic4, Util, View,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	View = __webpack_require__(7);
	
	Util = __webpack_require__(0);
	
	Stereographic4 = (function(superClass) {
		extend(Stereographic4, superClass);
	
		function Stereographic4() {
			return Stereographic4.__super__.constructor.apply(this, arguments);
		}
	
		Stereographic4.traits = ['node', 'object', 'visible', 'view', 'view4', 'stereographic', 'vertex'];
	
		Stereographic4.prototype.make = function() {
			Stereographic4.__super__.make.apply(this, arguments);
			this.uniforms = {
				basisOffset: this._attributes.make(this._types.vec4()),
				basisScale: this._attributes.make(this._types.vec4()),
				stereoBend: this.node.attributes['stereographic.bend']
			};
			this.basisScale = this.uniforms.basisScale.value;
			return this.basisOffset = this.uniforms.basisOffset.value;
		};
	
		Stereographic4.prototype.unmake = function() {
			Stereographic4.__super__.unmake.apply(this, arguments);
			delete this.basisScale;
			delete this.basisOffset;
			return delete this.uniforms;
		};
	
		Stereographic4.prototype.change = function(changed, touched, init) {
			var bend, dw, dx, dy, dz, g, mult, p, ref, s, w, x, y, z;
			if (!(touched['view'] || touched['view4'] || touched['stereographic'] || init)) {
				return;
			}
			this.bend = bend = this.props.bend;
			p = this.props.position;
			s = this.props.scale;
			g = this.props.range;
			x = g[0].x;
			y = g[1].x;
			z = g[2].x;
			w = g[3].x;
			dx = (g[0].y - x) || 1;
			dy = (g[1].y - y) || 1;
			dz = (g[2].y - z) || 1;
			dw = (g[3].y - w) || 1;
			mult = function(a, b) {
				a.x *= b.x;
				a.y *= b.y;
				a.z *= b.z;
				return a.w *= b.w;
			};
			ref = Util.Axis.recenterAxis(w, dw, bend, 1), w = ref[0], dw = ref[1];
			this.basisScale.set(2 / dx, 2 / dy, 2 / dz, 2 / dw);
			this.basisOffset.set(-(2 * x + dx) / dx, -(2 * y + dy) / dy, -(2 * z + dz) / dz, -(2 * w + dw) / dw);
			mult(this.basisScale, s);
			mult(this.basisOffset, s);
			this.basisOffset.add(p);
			if (changed['view.range'] || touched['stereographic']) {
				return this.trigger({
					type: 'view.range'
				});
			}
		};
	
		Stereographic4.prototype.vertex = function(shader, pass) {
			if (pass === 1) {
				shader.pipe('stereographic4.position', this.uniforms);
			}
			return Stereographic4.__super__.vertex.call(this, shader, pass);
		};
	
		return Stereographic4;
	
	})(View);
	
	module.exports = Stereographic4;
	
	
	/***/ }),
	/* 126 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Transform, Transform3, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transform = __webpack_require__(13);
	
	Util = __webpack_require__(0);
	
	Transform3 = (function(superClass) {
		extend(Transform3, superClass);
	
		function Transform3() {
			return Transform3.__super__.constructor.apply(this, arguments);
		}
	
		Transform3.traits = ['node', 'vertex', 'transform3'];
	
		Transform3.prototype.make = function() {
			this.uniforms = {
				transformMatrix: this._attributes.make(this._types.mat4())
			};
			return this.composer = Util.Three.transformComposer();
		};
	
		Transform3.prototype.unmake = function() {
			return delete this.uniforms;
		};
	
		Transform3.prototype.change = function(changed, touched, init) {
			var e, m, p, q, r, s;
			if (changed['transform3.pass']) {
				return this.rebuild();
			}
			if (!(touched['transform3'] || init)) {
				return;
			}
			p = this.props.position;
			q = this.props.quaternion;
			r = this.props.rotation;
			s = this.props.scale;
			m = this.props.matrix;
			e = this.props.eulerOrder;
			return this.uniforms.transformMatrix.value = this.composer(p, r, q, s, m, e);
		};
	
		Transform3.prototype.vertex = function(shader, pass) {
			if (pass === this.props.pass) {
				shader.pipe('transform3.position', this.uniforms);
			}
			return Transform3.__super__.vertex.call(this, shader, pass);
		};
	
		return Transform3;
	
	})(Transform);
	
	module.exports = Transform3;
	
	
	/***/ }),
	/* 127 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Transform, Transform4,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transform = __webpack_require__(13);
	
	Transform4 = (function(superClass) {
		extend(Transform4, superClass);
	
		function Transform4() {
			return Transform4.__super__.constructor.apply(this, arguments);
		}
	
		Transform4.traits = ['node', 'vertex', 'transform4'];
	
		Transform4.prototype.make = function() {
			this.uniforms = {
				transformMatrix: this._attributes.make(this._types.mat4()),
				transformOffset: this.node.attributes['transform4.position']
			};
			return this.transformMatrix = this.uniforms.transformMatrix.value;
		};
	
		Transform4.prototype.unmake = function() {
			return delete this.uniforms;
		};
	
		Transform4.prototype.change = function(changed, touched, init) {
			var m, s, t;
			if (changed['transform4.pass']) {
				return this.rebuild();
			}
			if (!(touched['transform4'] || init)) {
				return;
			}
			s = this.props.scale;
			m = this.props.matrix;
			t = this.transformMatrix;
			t.copy(m);
			return t.scale(s);
		};
	
		Transform4.prototype.vertex = function(shader, pass) {
			if (pass === this.props.pass) {
				shader.pipe('transform4.position', this.uniforms);
			}
			return Transform4.__super__.vertex.call(this, shader, pass);
		};
	
		return Transform4;
	
	})(Transform);
	
	module.exports = Transform4;
	
	
	/***/ }),
	/* 128 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Transform, Vertex,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transform = __webpack_require__(13);
	
	Vertex = (function(superClass) {
		extend(Vertex, superClass);
	
		function Vertex() {
			return Vertex.__super__.constructor.apply(this, arguments);
		}
	
		Vertex.traits = ['node', 'include', 'vertex', 'bind'];
	
		Vertex.prototype.make = function() {
			return this._helpers.bind.make([
				{
					to: 'include.shader',
					trait: 'shader',
					optional: true
				}
			]);
		};
	
		Vertex.prototype.unmake = function() {
			return this._helpers.bind.unmake();
		};
	
		Vertex.prototype.change = function(changed, touched, init) {
			if (touched['include']) {
				return this.rebuild();
			}
		};
	
		Vertex.prototype.vertex = function(shader, pass) {
			if (this.bind.shader != null) {
				if (pass === this.props.pass) {
					shader.pipe(this.bind.shader.shaderBind());
				}
			}
			return Vertex.__super__.vertex.call(this, shader, pass);
		};
	
		return Vertex;
	
	})(Transform);
	
	module.exports = Vertex;
	
	
	/***/ }),
	/* 129 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Fragment, Transform,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transform = __webpack_require__(13);
	
	Fragment = (function(superClass) {
		extend(Fragment, superClass);
	
		function Fragment() {
			return Fragment.__super__.constructor.apply(this, arguments);
		}
	
		Fragment.traits = ['node', 'include', 'fragment', 'bind'];
	
		Fragment.prototype.make = function() {
			return this._helpers.bind.make([
				{
					to: 'include.shader',
					trait: 'shader',
					optional: true
				}
			]);
		};
	
		Fragment.prototype.unmake = function() {
			return this._helpers.bind.unmake();
		};
	
		Fragment.prototype.change = function(changed, touched, init) {
			if (touched['include'] || changed['fragment.gamma']) {
				return this.rebuild();
			}
		};
	
		Fragment.prototype.fragment = function(shader, pass) {
			if (this.bind.shader != null) {
				if (pass === this.props.pass) {
					if (this.props.gamma) {
						shader.pipe('mesh.gamma.out');
					}
					shader.pipe(this.bind.shader.shaderBind());
					shader.split();
					if (this.props.gamma) {
						shader.pipe('mesh.gamma.in');
					}
					shader.pass();
				}
			}
			return Fragment.__super__.fragment.call(this, shader, pass);
		};
	
		return Fragment;
	
	})(Transform);
	
	module.exports = Fragment;
	
	
	/***/ }),
	/* 130 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Layer, Transform, ,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transform = __webpack_require__(13);
	
	 = Math.PI;
	
	Layer = (function(superClass) {
		extend(Layer, superClass);
	
		function Layer() {
			return Layer.__super__.constructor.apply(this, arguments);
		}
	
		Layer.traits = ['node', 'vertex', 'layer'];
	
		Layer.prototype.make = function() {
			this._listen('root', 'root.resize', this.update);
			return this.uniforms = {
				layerScale: this._attributes.make(this._types.vec4()),
				layerBias: this._attributes.make(this._types.vec4())
			};
		};
	
		Layer.prototype.update = function() {
			var _enum, aspect, camera, depth, fit, fov, pitch, ref, ref1, ref2, scale, size;
			camera = this._inherit('root').getCamera();
			size = this._inherit('root').getSize();
			aspect = (ref = camera.aspect) != null ? ref : 1;
			fov = (ref1 = camera.fov) != null ? ref1 : 1;
			pitch = Math.tan(fov *  / 360);
			_enum = this.node.attributes['layer.fit']["enum"];
			ref2 = this.props, fit = ref2.fit, depth = ref2.depth, scale = ref2.scale;
			switch (fit) {
				case _enum.contain:
					fit = aspect > 1 ? _enum.y : _enum.x;
					break;
				case _enum.cover:
					fit = aspect > 1 ? _enum.x : _enum.y;
			}
			switch (fit) {
				case _enum.x:
					this.uniforms.layerScale.value.set(pitch * aspect, pitch * aspect, 1, 1);
					break;
				case _enum.y:
					this.uniforms.layerScale.value.set(pitch, pitch, 1, 1);
			}
			return this.uniforms.layerBias.value.set(0, 0, -depth, 0);
		};
	
		Layer.prototype.change = function(changed, touched, init) {
			if (changed['layer.fit'] || changed['layer.depth'] || init) {
				return this.update();
			}
		};
	
		Layer.prototype.vertex = function(shader, pass) {
			if (pass === 2) {
				return shader.pipe('layer.position', this.uniforms);
			}
			if (pass === 3) {
				return shader.pipe('root.position');
			}
			return shader;
		};
	
		return Layer;
	
	})(Transform);
	
	module.exports = Layer;
	
	
	/***/ }),
	/* 131 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Mask, Parent,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Mask = (function(superClass) {
		extend(Mask, superClass);
	
		function Mask() {
			return Mask.__super__.constructor.apply(this, arguments);
		}
	
		Mask.traits = ['node', 'include', 'mask', 'bind'];
	
		Mask.prototype.make = function() {
			return this._helpers.bind.make([
				{
					to: 'include.shader',
					trait: 'shader',
					optional: true
				}
			]);
		};
	
		Mask.prototype.unmake = function() {
			return this._helpers.bind.unmake();
		};
	
		Mask.prototype.change = function(changed, touched, init) {
			if (touched['include']) {
				return this.rebuild();
			}
		};
	
		Mask.prototype.mask = function(shader) {
			var ref, ref1, s;
			if (this.bind.shader != null) {
				if (shader) {
					s = this._shaders.shader();
					s.pipe(Util.GLSL.identity('vec4'));
					s.fan();
					s.pipe(shader);
					s.next();
					s.pipe(this.bind.shader.shaderBind());
					s.end();
					s.pipe("float combine(float a, float b) { return min(a, b); }");
				} else {
					s = this._shaders.shader();
					s.pipe(this.bind.shader.shaderBind());
				}
			} else {
				s = shader;
			}
			return (ref = (ref1 = this._inherit('mask')) != null ? ref1.mask(s) : void 0) != null ? ref : s;
		};
	
		return Mask;
	
	})(Parent);
	
	module.exports = Mask;
	
	
	/***/ }),
	/* 132 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Data, Source, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Source = __webpack_require__(20);
	
	Util = __webpack_require__(0);
	
	Data = (function(superClass) {
		extend(Data, superClass);
	
		function Data() {
			return Data.__super__.constructor.apply(this, arguments);
		}
	
		Data.traits = ['node', 'data', 'source', 'index', 'entity', 'active'];
	
		Data.prototype.init = function() {
			this.dataEmitter = null;
			return this.dataSizes = null;
		};
	
		Data.prototype.emitter = function(channels, items) {
			var bind, data, emitter, expr, last, resolve, sizes, thunk;
			data = this.props.data;
			bind = this.props.bind;
			expr = this.props.expr;
			if (data != null) {
				last = this.dataSizes;
				sizes = Util.Data.getSizes(data);
				if (!last || last.length !== sizes.length) {
					thunk = Util.Data.getThunk(data);
					this.dataEmitter = this.callback(Util.Data.makeEmitter(thunk, items, channels));
					this.dataSizes = sizes;
				}
				emitter = this.dataEmitter;
			} else if (typeof resolve !== "undefined" && resolve !== null) {
				resolve = this._inherit('resolve');
				emitter = this.callback(resolve.callback(bind));
			} else if (expr != null) {
				emitter = this.callback(expr);
			} else {
				emitter = this.callback(this.passthrough);
			}
			return emitter;
		};
	
		Data.prototype.callback = function(callback) {
			return callback != null ? callback : function() {};
		};
	
		Data.prototype.update = function() {};
	
		Data.prototype.make = function() {
			this._helpers.active.make();
			this.first = true;
			return this._listen('root', 'root.update', (function(_this) {
				return function() {
					if (_this.isActive || _this.first) {
						_this.update();
					}
					return _this.first = false;
				};
			})(this));
		};
	
		Data.prototype.unmake = function() {
			this._helpers.active.unmake();
			this.dataEmitter = null;
			return this.dataSizes = null;
		};
	
		return Data;
	
	})(Source);
	
	module.exports = Data;
	
	
	/***/ }),
	/* 133 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Interval, Util, _Array,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	_Array = __webpack_require__(48);
	
	Util = __webpack_require__(0);
	
	Interval = (function(superClass) {
		extend(Interval, superClass);
	
		function Interval() {
			return Interval.__super__.constructor.apply(this, arguments);
		}
	
		Interval.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'texture', 'array', 'span', 'interval', 'sampler', 'raw'];
	
		Interval.prototype.updateSpan = function() {
			var centered, dimension, inverse, pad, range, span, width;
			dimension = this.props.axis;
			width = this.props.width;
			centered = this.props.centered;
			pad = this.props.padding;
			range = this._helpers.span.get('', dimension);
			width += pad * 2;
			this.a = range.x;
			span = range.y - range.x;
			if (centered) {
				inverse = 1 / Math.max(1, width);
				this.a += span * inverse / 2;
			} else {
				inverse = 1 / Math.max(1, width - 1);
			}
			this.b = span * inverse;
			return this.a += pad * this.b;
		};
	
		Interval.prototype.callback = function(callback) {
			this.updateSpan();
			if (this.last === callback) {
				return this._callback;
			}
			this.last = callback;
			if (callback.length <= 3) {
				return this._callback = (function(_this) {
					return function(emit, i) {
						var x;
						x = _this.a + _this.b * i;
						return callback(emit, x, i);
					};
				})(this);
			} else {
				return this._callback = (function(_this) {
					return function(emit, i) {
						var x;
						x = _this.a + _this.b * i;
						return callback(emit, x, i, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		Interval.prototype.make = function() {
			Interval.__super__.make.apply(this, arguments);
			this._helpers.span.make();
			return this._listen(this, 'span.range', this.updateSpan);
		};
	
		Interval.prototype.unmake = function() {
			Interval.__super__.unmake.apply(this, arguments);
			return this._helpers.span.unmake();
		};
	
		Interval.prototype.change = function(changed, touched, init) {
			Interval.__super__.change.apply(this, arguments);
			if (touched['span']) {
				return this.updateSpan();
			}
		};
	
		return Interval;
	
	})(_Array);
	
	module.exports = Interval;
	
	
	/***/ }),
	/* 134 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Area, Matrix, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Matrix = __webpack_require__(49);
	
	Util = __webpack_require__(0);
	
	Area = (function(superClass) {
		extend(Area, superClass);
	
		function Area() {
			return Area.__super__.constructor.apply(this, arguments);
		}
	
		Area.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'matrix', 'texture', 'raw', 'span:x', 'span:y', 'area', 'sampler:x', 'sampler:y'];
	
		Area.prototype.updateSpan = function() {
			var centeredX, centeredY, dimensions, height, inverseX, inverseY, padX, padY, rangeX, rangeY, spanX, spanY, width;
			dimensions = this.props.axes;
			width = this.props.width;
			height = this.props.height;
			centeredX = this.props.centeredX;
			centeredY = this.props.centeredY;
			padX = this.props.paddingX;
			padY = this.props.paddingY;
			rangeX = this._helpers.span.get('x.', dimensions[0]);
			rangeY = this._helpers.span.get('y.', dimensions[1]);
			this.aX = rangeX.x;
			this.aY = rangeY.x;
			spanX = rangeX.y - rangeX.x;
			spanY = rangeY.y - rangeY.x;
			width += padX * 2;
			height += padY * 2;
			if (centeredX) {
				inverseX = 1 / Math.max(1, width);
				this.aX += spanX * inverseX / 2;
			} else {
				inverseX = 1 / Math.max(1, width - 1);
			}
			if (centeredY) {
				inverseY = 1 / Math.max(1, height);
				this.aY += spanY * inverseY / 2;
			} else {
				inverseY = 1 / Math.max(1, height - 1);
			}
			this.bX = spanX * inverseX;
			this.bY = spanY * inverseY;
			this.aX += padX * this.bX;
			return this.aY += padY * this.bY;
		};
	
		Area.prototype.callback = function(callback) {
			this.updateSpan();
			if (this.last === callback) {
				return this._callback;
			}
			this.last = callback;
			if (callback.length <= 5) {
				return this._callback = (function(_this) {
					return function(emit, i, j) {
						var x, y;
						x = _this.aX + _this.bX * i;
						y = _this.aY + _this.bY * j;
						return callback(emit, x, y, i, j);
					};
				})(this);
			} else {
				return this._callback = (function(_this) {
					return function(emit, i, j) {
						var x, y;
						x = _this.aX + _this.bX * i;
						y = _this.aY + _this.bY * j;
						return callback(emit, x, y, i, j, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		Area.prototype.make = function() {
			Area.__super__.make.apply(this, arguments);
			this._helpers.span.make();
			return this._listen(this, 'span.range', this.updateSpan);
		};
	
		Area.prototype.unmake = function() {
			Area.__super__.unmake.apply(this, arguments);
			return this._helpers.span.unmake();
		};
	
		Area.prototype.change = function(changed, touched, init) {
			Area.__super__.change.apply(this, arguments);
			if (touched['x'] || touched['y']) {
				return this.updateSpan();
			}
		};
	
		return Area;
	
	})(Matrix);
	
	module.exports = Area;
	
	
	/***/ }),
	/* 135 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Util, Volume, Voxel,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Voxel = __webpack_require__(21);
	
	Util = __webpack_require__(0);
	
	Volume = (function(superClass) {
		extend(Volume, superClass);
	
		function Volume() {
			return Volume.__super__.constructor.apply(this, arguments);
		}
	
		Volume.traits = ['node', 'buffer', 'active', 'data', 'source', 'index', 'texture', 'voxel', 'span:x', 'span:y', 'span:z', 'volume', 'sampler:x', 'sampler:y', 'sampler:z', 'raw'];
	
		Volume.prototype.updateSpan = function() {
			var centeredX, centeredY, centeredZ, depth, dimensions, height, inverseX, inverseY, inverseZ, padX, padY, padZ, rangeX, rangeY, rangeZ, spanX, spanY, spanZ, width;
			dimensions = this.props.axes;
			width = this.props.width;
			height = this.props.height;
			depth = this.props.depth;
			centeredX = this.props.centeredX;
			centeredY = this.props.centeredY;
			centeredZ = this.props.centeredZ;
			padX = this.props.paddingX;
			padY = this.props.paddingY;
			padZ = this.props.paddingZ;
			rangeX = this._helpers.span.get('x.', dimensions[0]);
			rangeY = this._helpers.span.get('y.', dimensions[1]);
			rangeZ = this._helpers.span.get('z.', dimensions[2]);
			this.aX = rangeX.x;
			this.aY = rangeY.x;
			this.aZ = rangeZ.x;
			spanX = rangeX.y - rangeX.x;
			spanY = rangeY.y - rangeY.x;
			spanZ = rangeZ.y - rangeZ.x;
			width += padX * 2;
			height += padY * 2;
			depth += padZ * 2;
			if (centeredX) {
				inverseX = 1 / Math.max(1, width);
				this.aX += spanX * inverseX / 2;
			} else {
				inverseX = 1 / Math.max(1, width - 1);
			}
			if (centeredY) {
				inverseY = 1 / Math.max(1, height);
				this.aY += spanY * inverseY / 2;
			} else {
				inverseY = 1 / Math.max(1, height - 1);
			}
			if (centeredZ) {
				inverseZ = 1 / Math.max(1, depth);
				this.aZ += spanZ * inverseZ / 2;
			} else {
				inverseZ = 1 / Math.max(1, depth - 1);
			}
			this.bX = spanX * inverseX;
			this.bY = spanY * inverseY;
			this.bZ = spanZ * inverseZ;
			this.aX += this.bX * padX;
			this.aY += this.bY * padY;
			return this.aZ += this.bZ * padY;
		};
	
		Volume.prototype.callback = function(callback) {
			this.updateSpan();
			if (this.last === callback) {
				return this._callback;
			}
			this.last = callback;
			if (callback.length <= 7) {
				return this._callback = (function(_this) {
					return function(emit, i, j, k) {
						var x, y, z;
						x = _this.aX + _this.bX * i;
						y = _this.aY + _this.bY * j;
						z = _this.aZ + _this.bZ * k;
						return callback(emit, x, y, z, i, j, k);
					};
				})(this);
			} else {
				return this._callback = (function(_this) {
					return function(emit, i, j, k) {
						var x, y, z;
						x = _this.aX + _this.bX * i;
						y = _this.aY + _this.bY * j;
						z = _this.aZ + _this.bZ * k;
						return callback(emit, x, y, z, i, j, k, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		Volume.prototype.make = function() {
			Volume.__super__.make.apply(this, arguments);
			this._helpers.span.make();
			return this._listen(this, 'span.range', this.updateSpan);
		};
	
		Volume.prototype.unmake = function() {
			Volume.__super__.unmake.apply(this, arguments);
			return this._helpers.span.unmake();
		};
	
		Volume.prototype.change = function(changed, touched, init) {
			Volume.__super__.change.apply(this, arguments);
			if (touched['x'] || touched['y'] || touched['z']) {
				return this.updateSpan();
			}
		};
	
		return Volume;
	
	})(Voxel);
	
	module.exports = Volume;
	
	
	/***/ }),
	/* 136 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Scale, Source, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Source = __webpack_require__(20);
	
	Util = __webpack_require__(0);
	
	Scale = (function(superClass) {
		extend(Scale, superClass);
	
		function Scale() {
			return Scale.__super__.constructor.apply(this, arguments);
		}
	
		Scale.traits = ['node', 'source', 'index', 'interval', 'span', 'scale', 'raw', 'origin'];
	
		Scale.prototype.init = function() {
			return this.used = this.space = this.scaleAxis = this.sampler = null;
		};
	
		Scale.prototype.rawBuffer = function() {
			return this.buffer;
		};
	
		Scale.prototype.sourceShader = function(shader) {
			return shader.pipe(this.sampler);
		};
	
		Scale.prototype.getDimensions = function() {
			return {
				items: 1,
				width: this.space,
				height: 1,
				depth: 1
			};
		};
	
		Scale.prototype.getActiveDimensions = function() {
			return {
				items: 1,
				width: this.used,
				height: this.buffer.getFilled(),
				depth: 1
			};
		};
	
		Scale.prototype.getRawDimensions = function() {
			return this.getDimensions();
		};
	
		Scale.prototype.make = function() {
			var p, positionUniforms, samples;
			this.space = samples = this._helpers.scale.divide('');
			this.buffer = this._renderables.make('dataBuffer', {
				width: samples,
				channels: 1,
				items: 1
			});
			positionUniforms = {
				scaleAxis: this._attributes.make(this._types.vec4()),
				scaleOffset: this._attributes.make(this._types.vec4())
			};
			this.scaleAxis = positionUniforms.scaleAxis.value;
			this.scaleOffset = positionUniforms.scaleOffset.value;
			p = this.sampler = this._shaders.shader();
			p.require(this.buffer.shader(this._shaders.shader(), 1));
			p.pipe('scale.position', positionUniforms);
			this._helpers.span.make();
			return this._listen(this, 'span.range', this.updateRanges);
		};
	
		Scale.prototype.unmake = function() {
			this.scaleAxis = null;
			return this._helpers.span.unmake();
		};
	
		Scale.prototype.change = function(changed, touched, init) {
			if (changed['scale.divide']) {
				return this.rebuild();
			}
			if (touched['view'] || touched['interval'] || touched['span'] || touched['scale'] || touched['origin'] || init) {
				return this.updateRanges();
			}
		};
	
		Scale.prototype.updateRanges = function() {
			var axis, max, min, origin, range, ref, ticks, used;
			used = this.used;
			ref = this.props, axis = ref.axis, origin = ref.origin;
			range = this._helpers.span.get('', axis);
			min = range.x;
			max = range.y;
			ticks = this._helpers.scale.generate('', this.buffer, min, max);
			Util.Axis.setDimension(this.scaleAxis, axis);
			Util.Axis.setOrigin(this.scaleOffset, axis, origin);
			this.used = ticks.length;
			if (this.used !== used) {
				return this.trigger({
					type: 'source.resize'
				});
			}
		};
	
		return Scale;
	
	})(Source);
	
	module.exports = Scale;
	
	
	/***/ }),
	/* 137 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Latch, Parent, clone, deepEq,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	clone = function(x) {
		return x && JSON.parse(JSON.stringify(x));
	};
	
	deepEq = function(a, b) {
		return JSON.stringify(a) === JSON.stringify(b);
	};
	
	Latch = (function(superClass) {
		extend(Latch, superClass);
	
		function Latch() {
			return Latch.__super__.constructor.apply(this, arguments);
		}
	
		Latch.traits = ['node', 'entity', 'active', 'latch'];
	
		Latch.prototype.init = function() {
			this.data = void 0;
			return this.isDirty = true;
		};
	
		Latch.prototype.make = function() {
			this._helpers.active.make();
			return this._listen('root', 'root.update', (function(_this) {
				return function() {
					if (_this.isActive) {
						return _this.update();
					}
				};
			})(this));
		};
	
		Latch.prototype.unmake = function() {
			this._helpers.active.unmake();
			return this.data = void 0;
		};
	
		Latch.prototype.swap = function() {
			var data, deep, dirty, ref;
			ref = this.props, deep = ref.deep, data = ref.data;
			dirty = deep ? !deepEq(data, this.data) : data !== this.data;
			if (dirty) {
				this.data = (deep ? clone(data) : data);
			}
			return dirty;
		};
	
		Latch.prototype.update = function() {
			return this.isDirty = this.swap();
		};
	
		return Latch;
	
	})(Parent);
	
	module.exports = Latch;
	
	
	/***/ }),
	/* 138 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Image, Source, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Source = __webpack_require__(20);
	
	Util = __webpack_require__(0);
	
	Image = (function(superClass) {
		extend(Image, superClass);
	
		function Image() {
			return Image.__super__.constructor.apply(this, arguments);
		}
	
		Image.traits = ['node', 'source', 'index', 'texture', 'image', 'rawtex'];
	
		Image.prototype.init = function() {
			this.width = this.height = this.texture = this.uniforms = null;
			return this.myTexture = false;
		};
	
		Image.prototype.sourceShader = function(shader) {
			shader.pipe;
			shader.pipe(Util.GLSL.truncateVec(4, 2));
			shader.pipe('map.2d.data', this.uniforms);
			return shader.pipe('sample.2d', this.uniforms);
		};
	
		Image.prototype.imageShader = function(shader) {
			return shader.pipe('sample.2d', this.uniforms);
		};
	
		Image.prototype.getDimensions = function() {
			return {
				items: 1,
				width: this.width,
				height: this.height,
				depth: 1
			};
		};
	
		Image.prototype.make = function() {
			var types;
			types = this._attributes.types;
			return this.uniforms = {
				dataTexture: {
					type: 't',
					value: null
				},
				dataResolution: this._attributes.make(types.vec2()),
				dataPointer: this._attributes.make(types.vec2())
			};
		};
	
		Image.prototype.unmake = function() {
			if (this.myTexture) {
				this.texture.dispose();
			}
			this.width = this.height = this.texture = null;
			delete this.uniforms;
			return this.myTexture = false;
		};
	
		Image.prototype.change = function(changed, touched, init) {
			var height, ref, ref1, ref2, ref3, ref4, ref5, width;
			if (init) {
				return this.updateTex();
			}
			width = (ref = (ref1 = this.props.width) != null ? ref1 : (ref2 = this.props.image) != null ? ref2.naturalWidth : void 0) != null ? ref : 1;
			height = (ref3 = (ref4 = this.props.height) != null ? ref4 : (ref5 = this.props.image) != null ? ref5.naturalHeight : void 0) != null ? ref3 : 1;
			if (this.width !== width || this.height !== height) {
				return this.rebuild();
			}
			if (touched['image']) {
				return this.updateTex();
			}
		};
	
		Image.prototype.updateTex = function() {
			var image, magFilter, minFilter, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, texture;
			this.width = (ref = (ref1 = this.props.width) != null ? ref1 : (ref2 = this.props.image) != null ? ref2.naturalWidth : void 0) != null ? ref : 1;
			this.height = (ref3 = (ref4 = this.props.height) != null ? ref4 : (ref5 = this.props.image) != null ? ref5.naturalHeight : void 0) != null ? ref3 : 1;
			image = this.props.image;
			texture = this.props.texture;
			this.needFlip = false;
			minFilter = (ref6 = this.props.minFilter) != null ? ref6 : THREE.LinearFilter;
			magFilter = (ref7 = this.props.magFilter) != null ? ref7 : THREE.LinearFilter;
			if (this.myTexture) {
				this.texture.dispose();
				this.myTexture = false;
			}
			if ((texture == null) && (image == null)) {
				texture = new THREE.DataTexture(new Uint8Array(this.width * this.height * 4), this.width, this.height, THREE.RGBAFormat, THREE.FloatType, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, magFilter, minFilter, 1);
				texture.generateMipmaps = false;
				texture.flipY = false;
				texture.needsUpdate = true;
				this.myTexture = true;
			}
			if (image != null) {
				texture = new THREE.Texture(image, THREE.UVMapping, THREE.ClampToEdgeWrapping, THREE.ClampToEdgeWrapping, magFilter, minFilter, THREE.RGBAFormat, THREE.FloatType);
				texture.generateMipmaps = false;
				texture.unpackAlignment = 1;
				texture.flipY = false;
				texture.needsUpdate = true;
				this.myTexture = true;
				this.needFlip = true;
			}
			this.texture = texture;
			this.uniforms.dataTexture.value = this.texture;
			if (this.needFlip) {
				this.uniforms.dataResolution.value.set(1 / this.width, -1 / this.height);
				return this.uniforms.dataPointer.value.set(0.5, -this.height + 0.5);
			} else {
				this.uniforms.dataResolution.value.set(1 / this.width, 1 / this.height);
				return this.uniforms.dataPointer.value.set(0.5, 0.5);
			}
		};
	
		return Image;
	
	})(Source);
	
	module.exports = Image;
	
	
	/***/ }),
	/* 139 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var HTML, Util, Voxel,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Voxel = __webpack_require__(21);
	
	Util = __webpack_require__(0);
	
	HTML = (function(superClass) {
		extend(HTML, superClass);
	
		function HTML() {
			return HTML.__super__.constructor.apply(this, arguments);
		}
	
		HTML.traits = ['node', 'buffer', 'active', 'data', 'voxel', 'html'];
	
		HTML.finals = {
			channels: 1
		};
	
		HTML.prototype.init = function() {
			HTML.__super__.init.apply(this, arguments);
			return this.storage = 'pushBuffer';
		};
	
		HTML.prototype.make = function() {
			var depth, height, items, ref, width;
			HTML.__super__.make.apply(this, arguments);
			ref = this.getDimensions(), items = ref.items, width = ref.width, height = ref.height, depth = ref.depth;
			this.dom = this._overlays.make('dom');
			return this.dom.hint(items * width * height * depth);
		};
	
		HTML.prototype.unmake = function() {
			HTML.__super__.unmake.apply(this, arguments);
			if (this.dom != null) {
				this.dom.dispose();
				return this.dom = null;
			}
		};
	
		HTML.prototype.update = function() {
			return HTML.__super__.update.apply(this, arguments);
		};
	
		HTML.prototype.change = function(changed, touched, init) {
			if (touched['html']) {
				return this.rebuild();
			}
			return HTML.__super__.change.call(this, changed, touched, init);
		};
	
		HTML.prototype.nodes = function() {
			return this.buffer.read();
		};
	
		HTML.prototype.callback = function(callback) {
			var el;
			el = this.dom.el;
			if (callback.length <= 6) {
				return function(emit, i, j, k, l) {
					return callback(emit, el, i, j, k, l);
				};
			} else {
				return (function(_this) {
					return function(emit, i, j, k, l) {
						return callback(emit, el, i, j, k, l, _this.bufferClock, _this.bufferStep);
					};
				})(this);
			}
		};
	
		return HTML;
	
	})(Voxel);
	
	module.exports = HTML;
	
	
	/***/ }),
	/* 140 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var DOM, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	DOM = (function(superClass) {
		extend(DOM, superClass);
	
		function DOM() {
			return DOM.__super__.constructor.apply(this, arguments);
		}
	
		DOM.traits = ['node', 'bind', 'object', 'visible', 'overlay', 'dom', 'attach', 'position'];
	
		DOM.prototype.init = function() {
			this.emitter = this.root = null;
			return this.active = {};
		};
	
		DOM.prototype.make = function() {
			var depth, height, htmlDims, indexer, items, pointDims, position, projection, width;
			DOM.__super__.make.apply(this, arguments);
			this._helpers.bind.make([
				{
					to: 'dom.html',
					trait: 'html'
				}, {
					to: 'dom.points',
					trait: 'source'
				}
			]);
			if (!((this.bind.points != null) && (this.bind.html != null))) {
				return;
			}
			this.root = this._inherit('root');
			this._listen('root', 'root.update', this.update);
			this._listen('root', 'root.post', this.post);
			pointDims = this.bind.points.getDimensions();
			htmlDims = this.bind.html.getDimensions();
			items = Math.min(pointDims.items, htmlDims.items);
			width = Math.min(pointDims.width, htmlDims.width);
			height = Math.min(pointDims.height, htmlDims.height);
			depth = Math.min(pointDims.depth, htmlDims.depth);
			position = this.bind.points.sourceShader(this._shaders.shader());
			position = this._helpers.position.pipeline(position);
			projection = this._shaders.shader({
				globals: ['projectionMatrix']
			});
			projection.pipe('project.readback');
			position.pipe(projection);
			indexer = this._shaders.shader();
			this.readback = this._renderables.make('readback', {
				map: position,
				indexer: indexer,
				items: items,
				width: width,
				height: height,
				depth: depth,
				channels: 4,
				stpq: true
			});
			this.dom = this._overlays.make('dom');
			this.dom.hint(items * width * height * depth * 2);
			this.readback.setCallback(this.emitter = this.callback(this.bind.html.nodes()));
			return this._helpers.visible.make();
		};
	
		DOM.prototype.unmake = function() {
			if (this.readback != null) {
				this.readback.dispose();
				this.dom.dispose();
				this.readback = this.dom = null;
				this.root = null;
				this.emitter = null;
				this.active = {};
			}
			this._helpers.bind.unmake();
			return this._helpers.visible.unmake();
		};
	
		DOM.prototype.update = function() {
			var ref;
			if (this.readback == null) {
				return;
			}
			if (this.props.visible) {
				this.readback.update((ref = this.root) != null ? ref.getCamera() : void 0);
				this.readback.post();
				return this.readback.iterate();
			}
		};
	
		DOM.prototype.post = function() {
			if (this.readback == null) {
				return;
			}
			return this.dom.render(this.isVisible ? this.emitter.nodes() : []);
		};
	
		DOM.prototype.callback = function(data) {
			var attr, className, color, colorString, depth, el, f, height, nodes, offset, opacity, outline, pointer, size, snap, strideI, strideJ, strideK, styles, uniforms, width, zIndex, zoom;
			uniforms = this._inherit('unit').getUnitUniforms();
			width = uniforms.viewWidth;
			height = uniforms.viewHeight;
			attr = this.node.attributes['dom.attributes'];
			size = this.node.attributes['dom.size'];
			zoom = this.node.attributes['dom.zoom'];
			color = this.node.attributes['dom.color'];
			outline = this.node.attributes['dom.outline'];
			pointer = this.node.attributes['dom.pointerEvents'];
			opacity = this.node.attributes['overlay.opacity'];
			zIndex = this.node.attributes['overlay.zIndex'];
			offset = this.node.attributes['attach.offset'];
			depth = this.node.attributes['attach.depth'];
			snap = this.node.attributes['attach.snap'];
			el = this.dom.el;
			nodes = [];
			styles = null;
			className = null;
			strideI = strideJ = strideK = 0;
			colorString = '';
			f = function(x, y, z, w, i, j, k, l) {
				var a, alpha, children, clip, flatZ, index, iw, ox, oy, props, ref, s, scale, v, xx, yy;
				index = l + strideI * i + strideJ * j + strideK * k;
				children = data[index];
				clip = w < 0;
				iw = 1 / w;
				flatZ = 1 + (iw - 1) * depth.value;
				scale = clip ? 0 : flatZ;
				ox = +offset.value.x * scale;
				oy = +offset.value.y * scale;
				xx = (x + 1) * width.value * .5 + ox;
				yy = (y - 1) * height.value * .5 + oy;
				xx /= zoom.value;
				yy /= zoom.value;
				if (snap.value) {
					xx = Math.round(xx);
					yy = Math.round(yy);
				}
				alpha = Math.min(.999, clip ? 0 : opacity.value);
				props = {
					className: className,
					style: {
						transform: "translate3d(" + xx + "px, " + (-yy) + "px, " + (1 - w) + "px) translate(-50%, -50%) scale(" + scale + "," + scale + ")",
						opacity: alpha
					}
				};
				for (k in styles) {
					v = styles[k];
					props.style[k] = v;
				}
				a = attr.value;
				if (a != null) {
					s = a.style;
					for (k in a) {
						v = a[k];
						if (k !== 'style' && k !== 'className') {
							props[k] = v;
						}
					}
					if (s != null) {
						for (k in s) {
							v = s[k];
							props.style[k] = v;
						}
					}
				}
				props.className += ' ' + ((ref = a != null ? a.className : void 0) != null ? ref : 'mathbox-label');
				return nodes.push(el('div', props, children));
			};
			f.reset = (function(_this) {
				return function() {
					var c, m, ref;
					nodes = [];
					ref = [_this.strideI, _this.strideJ, _this.strideK], strideI = ref[0], strideJ = ref[1], strideK = ref[2];
					c = color.value;
					m = function(x) {
						return Math.floor(x * 255);
					};
					colorString = c ? "rgb(" + [m(c.x), m(c.y), m(c.z)] + ")" : '';
					className = "mathbox-outline-" + (Math.round(outline.value));
					styles = {};
					if (c) {
						styles.color = colorString;
					}
					styles.fontSize = size.value + "px";
					if (zoom.value !== 1) {
						styles.zoom = zoom.value;
					}
					if (zIndex.value > 0) {
						styles.zIndex = zIndex.value;
					}
					if (pointer.value) {
						return styles.pointerEvents = 'auto';
					}
				};
			})(this);
			f.nodes = function() {
				return nodes;
			};
			return f;
		};
	
		DOM.prototype.resize = function() {
			var depth, height, htmlDims, items, pointDims, sI, sJ, sK, width;
			if (this.readback == null) {
				return;
			}
			pointDims = this.bind.points.getActiveDimensions();
			htmlDims = this.bind.html.getActiveDimensions();
			items = Math.min(pointDims.items, htmlDims.items);
			width = Math.min(pointDims.width, htmlDims.width);
			height = Math.min(pointDims.height, htmlDims.height);
			depth = Math.min(pointDims.depth, htmlDims.depth);
			this.readback.setActive(items, width, height, depth);
			this.strideI = sI = htmlDims.items;
			this.strideJ = sJ = sI * htmlDims.width;
			return this.strideK = sK = sJ * htmlDims.height;
		};
	
		DOM.prototype.change = function(changed, touched, init) {
			if (changed['dom.html'] || changed['dom.points']) {
				return this.rebuild();
			}
		};
	
		return DOM;
	
	})(Primitive);
	
	module.exports = DOM;
	
	
	/***/ }),
	/* 141 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, THREE, Text, Util, Voxel,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Buffer = __webpack_require__(19);
	
	Voxel = __webpack_require__(21);
	
	Util = __webpack_require__(0);
	
	Text = (function(superClass) {
		extend(Text, superClass);
	
		function Text() {
			return Text.__super__.constructor.apply(this, arguments);
		}
	
		Text.traits = ['node', 'buffer', 'active', 'data', 'texture', 'voxel', 'text', 'font'];
	
		Text.defaults = {
			minFilter: 'linear',
			magFilter: 'linear'
		};
	
		Text.finals = {
			channels: 1
		};
	
		Text.prototype.init = function() {
			Text.__super__.init.apply(this, arguments);
			return this.atlas = null;
		};
	
		Text.prototype.textShader = function(shader) {
			return this.atlas.shader(shader);
		};
	
		Text.prototype.textIsSDF = function() {
			return this.props.sdf > 0;
		};
	
		Text.prototype.textHeight = function() {
			return this.props.detail;
		};
	
		Text.prototype.make = function() {
			var atlas, channels, data, depth, detail, dims, emit, font, height, items, magFilter, minFilter, ref, ref1, ref2, ref3, ref4, reserveX, reserveY, reserveZ, sdf, space, style, type, variant, weight, width;
			ref = this.props, minFilter = ref.minFilter, magFilter = ref.magFilter, type = ref.type;
			ref1 = this.props, font = ref1.font, style = ref1.style, variant = ref1.variant, weight = ref1.weight, detail = ref1.detail, sdf = ref1.sdf;
			this.atlas = this._renderables.make('textAtlas', {
				font: font,
				size: detail,
				style: style,
				variant: variant,
				weight: weight,
				outline: sdf,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
			this.minFilter = THREE.NearestFilter;
			this.magFilter = THREE.NearestFilter;
			this.type = THREE.FloatType;
			Buffer.prototype.make.call(this);
			minFilter = (ref2 = this.minFilter) != null ? ref2 : this.props.minFilter;
			magFilter = (ref3 = this.magFilter) != null ? ref3 : this.props.magFilter;
			type = (ref4 = this.type) != null ? ref4 : this.props.type;
			width = this.props.width;
			height = this.props.height;
			depth = this.props.depth;
			reserveX = this.props.bufferWidth;
			reserveY = this.props.bufferHeight;
			reserveZ = this.props.bufferDepth;
			channels = this.props.channels;
			items = this.props.items;
			dims = this.spec = {
				channels: channels,
				items: items,
				width: width,
				height: height,
				depth: depth
			};
			this.items = dims.items;
			this.channels = dims.channels;
			data = this.props.data;
			dims = Util.Data.getDimensions(data, dims);
			space = this.space;
			space.width = Math.max(reserveX, dims.width || 1);
			space.height = Math.max(reserveY, dims.height || 1);
			space.depth = Math.max(reserveZ, dims.depth || 1);
			this.buffer = this._renderables.make(this.storage, {
				width: space.width,
				height: space.height,
				depth: space.depth,
				channels: 4,
				items: items,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
			atlas = this.atlas;
			emit = this.buffer.streamer.emit;
			return this.buffer.streamer.emit = function(text) {
				return atlas.map(text, emit);
			};
		};
	
		Text.prototype.unmake = function() {
			Text.__super__.unmake.apply(this, arguments);
			if (this.atlas) {
				this.atlas.dispose();
				return this.atlas = null;
			}
		};
	
		Text.prototype.update = function() {
			this.atlas.begin();
			Text.__super__.update.apply(this, arguments);
			return this.atlas.end();
		};
	
		Text.prototype.change = function(changed, touched, init) {
			if (touched['font']) {
				return this.rebuild();
			}
			return Text.__super__.change.call(this, changed, touched, init);
		};
	
		return Text;
	
	})(Voxel);
	
	module.exports = Text;
	
	
	/***/ }),
	/* 142 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Format, Operator, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Format = (function(superClass) {
		extend(Format, superClass);
	
		function Format() {
			return Format.__super__.constructor.apply(this, arguments);
		}
	
		Format.traits = ['node', 'bind', 'operator', 'texture', 'text', 'format', 'font'];
	
		Format.defaults = {
			minFilter: 'linear',
			magFilter: 'linear'
		};
	
		Format.prototype.init = function() {
			Format.__super__.init.apply(this, arguments);
			this.atlas = this.buffer = this.used = this.time = null;
			return this.filled = false;
		};
	
		Format.prototype.sourceShader = function(shader) {
			return this.buffer.shader(shader);
		};
	
		Format.prototype.textShader = function(shader) {
			return this.atlas.shader(shader);
		};
	
		Format.prototype.textIsSDF = function() {
			return this.props.sdf > 0;
		};
	
		Format.prototype.textHeight = function() {
			return this.props.detail;
		};
	
		Format.prototype.make = function() {
			var atlas, depth, detail, dims, emit, font, height, items, magFilter, minFilter, ref, ref1, sdf, style, type, variant, weight, width;
			this._helpers.bind.make([
				{
					to: 'operator.source',
					trait: 'raw'
				}
			]);
			ref = this.props, minFilter = ref.minFilter, magFilter = ref.magFilter, type = ref.type;
			ref1 = this.props, font = ref1.font, style = ref1.style, variant = ref1.variant, weight = ref1.weight, detail = ref1.detail, sdf = ref1.sdf;
			this.atlas = this._renderables.make('textAtlas', {
				font: font,
				size: detail,
				style: style,
				variant: variant,
				weight: weight,
				outline: sdf,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
			minFilter = THREE.NearestFilter;
			magFilter = THREE.NearestFilter;
			type = THREE.FloatType;
			dims = this.bind.source.getDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			this.buffer = this._renderables.make('voxelBuffer', {
				width: width,
				height: height,
				depth: depth,
				channels: 4,
				items: items,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
			atlas = this.atlas;
			emit = this.buffer.streamer.emit;
			this.buffer.streamer.emit = function(t) {
				return atlas.map(t, emit);
			};
			this.clockParent = this._inherit('clock');
			return this._listen('root', 'root.update', this.update);
		};
	
		Format.prototype.made = function() {
			Format.__super__.made.apply(this, arguments);
			return this.resize();
		};
	
		Format.prototype.unmake = function() {
			Format.__super__.unmake.apply(this, arguments);
			if (this.buffer) {
				this.buffer.dispose();
				this.buffer = null;
			}
			if (this.atlas) {
				this.atlas.dispose();
				return this.atlas = null;
			}
		};
	
		Format.prototype.update = function() {
			var dst, src, used;
			src = this.bind.source.rawBuffer();
			dst = this.buffer;
			if ((this.filled && !this.props.live) || !this.through) {
				return;
			}
			this.time = this.clockParent.getTime();
			used = this.used;
			this.atlas.begin();
			this.used = this.through();
			this.buffer.write(this.used);
			this.atlas.end();
			this.filled = true;
			if (used !== this.used) {
				return this.trigger({
					type: 'source.resize'
				});
			}
		};
	
		Format.prototype.change = function(changed, touched, init) {
			var data, digits, expr, length, map, ref;
			if (touched['font']) {
				return this.rebuild();
			}
			if (changed['format.expr'] || changed['format.digits'] || changed['format.data'] || init) {
				ref = this.props, digits = ref.digits, expr = ref.expr, data = ref.data;
				if (expr == null) {
					if (data != null) {
						expr = function(x, y, z, w, i) {
							return data[i];
						};
					} else {
						expr = function(x) {
							return x;
						};
					}
				}
				length = expr.length;
				if (digits != null) {
					expr = (function(expr) {
						return function(x, y, z, w, i, j, k, l, t, d) {
							return +(expr(x, y, z, w, i, j, k, l, t, d)).toPrecision(digits);
						};
					})(expr);
				}
				if (length > 8) {
					map = (function(_this) {
						return function(emit, x, y, z, w, i, j, k, l, t, d) {
							return emit(expr(x, y, z, w, i, j, k, l, _this.time.clock, _this.time.step));
						};
					})(this);
				} else {
					map = (function(_this) {
						return function(emit, x, y, z, w, i, j, k, l) {
							return emit(expr(x, y, z, w, i, j, k, l));
						};
					})(this);
				}
				return this.through = this.bind.source.rawBuffer().through(map, this.buffer);
			}
		};
	
		return Format;
	
	})(Operator);
	
	module.exports = Format;
	
	
	/***/ }),
	/* 143 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Label, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Label = (function(superClass) {
		extend(Label, superClass);
	
		function Label() {
			return Label.__super__.constructor.apply(this, arguments);
		}
	
		Label.traits = ['node', 'bind', 'object', 'visible', 'style', 'label', 'attach', 'geometry', 'position'];
	
		Label.prototype.make = function() {
			var color, combine, depth, height, items, labelUniforms, map, mask, pointDims, position, snippet, sprite, styleUniforms, textDims, textIsSDF, uniforms, unitUniforms, width;
			Label.__super__.make.apply(this, arguments);
			this._helpers.bind.make([
				{
					to: 'label.text',
					trait: 'text'
				}, {
					to: 'geometry.points',
					trait: 'source'
				}, {
					to: 'geometry.colors',
					trait: 'source'
				}
			]);
			if (this.bind.points == null) {
				return;
			}
			if (this.bind.text == null) {
				return;
			}
			pointDims = this.bind.points.getDimensions();
			textDims = this.bind.text.getDimensions();
			textIsSDF = this.bind.text.textIsSDF();
			items = Math.min(pointDims.items, textDims.items);
			width = Math.min(pointDims.width, textDims.width);
			height = Math.min(pointDims.height, textDims.height);
			depth = Math.min(pointDims.depth, textDims.depth);
			position = this.bind.points.sourceShader(this._shaders.shader());
			position = this._helpers.position.pipeline(position);
			sprite = this.bind.text.sourceShader(this._shaders.shader());
			map = this._shaders.shader().pipe('label.map');
			map.pipe(this.bind.text.textShader(this._shaders.shader()));
			labelUniforms = {
				spriteDepth: this.node.attributes['attach.depth'],
				spriteOffset: this.node.attributes['attach.offset'],
				spriteSnap: this.node.attributes['attach.snap'],
				spriteScale: this._attributes.make(this._types.number()),
				outlineStep: this._attributes.make(this._types.number()),
				outlineExpand: this._attributes.make(this._types.number()),
				outlineColor: this.node.attributes['label.background']
			};
			this.spriteScale = labelUniforms.spriteScale;
			this.outlineStep = labelUniforms.outlineStep;
			this.outlineExpand = labelUniforms.outlineExpand;
			snippet = textIsSDF ? 'label.outline' : 'label.alpha';
			combine = this._shaders.shader().pipe(snippet, labelUniforms);
			if (this.bind.colors) {
				color = this._shaders.shader();
				this.bind.colors.sourceShader(color);
			}
			mask = this._helpers.object.mask();
			styleUniforms = this._helpers.style.uniforms();
			unitUniforms = this._inherit('unit').getUnitUniforms();
			uniforms = Util.JS.merge(unitUniforms, styleUniforms, labelUniforms);
			this.sprite = this._renderables.make('sprite', {
				uniforms: uniforms,
				width: width,
				height: height,
				depth: depth,
				items: items,
				position: position,
				sprite: sprite,
				map: map,
				combine: combine,
				color: color,
				mask: mask,
				linear: true
			});
			this._helpers.visible.make();
			return this._helpers.object.make([this.sprite]);
		};
	
		Label.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			this._helpers.object.unmake();
			return this.sprite = null;
		};
	
		Label.prototype.resize = function() {
			var depth, height, items, pointDims, textDims, width;
			pointDims = this.bind.points.getActiveDimensions();
			textDims = this.bind.text.getActiveDimensions();
			items = Math.min(pointDims.items, textDims.items);
			width = Math.min(pointDims.width, textDims.width);
			height = Math.min(pointDims.height, textDims.height);
			depth = Math.min(pointDims.depth, textDims.depth);
			return this.sprite.geometry.clip(width, height, depth, items);
		};
	
		Label.prototype.change = function(changed, touched, init) {
			var expand, height, outline, scale, size;
			if (touched['geometry'] || changed['label.text']) {
				return this.rebuild();
			}
			if (this.bind.points == null) {
				return;
			}
			size = this.props.size;
			outline = this.props.outline;
			expand = this.props.expand;
			height = this.bind.text.textHeight();
			scale = size / height;
			this.outlineExpand.value = expand / scale * 16 / 255;
			this.outlineStep.value = outline / scale * 16 / 255;
			return this.spriteScale.value = scale;
		};
	
		return Label;
	
	})(Primitive);
	
	module.exports = Label;
	
	
	/***/ }),
	/* 144 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Resample, Retext, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Resample = __webpack_require__(50);
	
	Util = __webpack_require__(0);
	
	Retext = (function(superClass) {
		extend(Retext, superClass);
	
		function Retext() {
			return Retext.__super__.constructor.apply(this, arguments);
		}
	
		Retext.traits = ['node', 'bind', 'operator', 'resample', 'sampler:x', 'sampler:y', 'sampler:z', 'sampler:w', 'include', 'text'];
	
		Retext.prototype.init = function() {
			return this.sourceSpec = [
				{
					to: 'operator.source',
					trait: 'text'
				}
			];
		};
	
		Retext.prototype.textShader = function(shader) {
			return this.bind.source.textShader(shader);
		};
	
		Retext.prototype.textIsSDF = function() {
			var ref;
			return ((ref = this.bind.source) != null ? ref.props.sdf : void 0) > 0;
		};
	
		Retext.prototype.textHeight = function() {
			var ref;
			return (ref = this.bind.source) != null ? ref.props.detail : void 0;
		};
	
		return Retext;
	
	})(Resample);
	
	module.exports = Retext;
	
	
	/***/ }),
	/* 145 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Clamp, Operator,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Clamp = (function(superClass) {
		extend(Clamp, superClass);
	
		function Clamp() {
			return Clamp.__super__.constructor.apply(this, arguments);
		}
	
		Clamp.traits = ['node', 'bind', 'operator', 'source', 'index', 'clamp'];
	
		Clamp.prototype.indexShader = function(shader) {
			shader.pipe(this.operator);
			return Clamp.__super__.indexShader.call(this, shader);
		};
	
		Clamp.prototype.sourceShader = function(shader) {
			shader.pipe(this.operator);
			return Clamp.__super__.sourceShader.call(this, shader);
		};
	
		Clamp.prototype.make = function() {
			var transform, uniforms;
			Clamp.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			uniforms = {
				clampLimit: this._attributes.make(this._types.vec4())
			};
			this.clampLimit = uniforms.clampLimit;
			transform = this._shaders.shader();
			transform.pipe('clamp.position', uniforms);
			return this.operator = transform;
		};
	
		Clamp.prototype.unmake = function() {
			return Clamp.__super__.unmake.apply(this, arguments);
		};
	
		Clamp.prototype.resize = function() {
			var dims;
			if (this.bind.source != null) {
				dims = this.bind.source.getActiveDimensions();
				this.clampLimit.value.set(dims.width - 1, dims.height - 1, dims.depth - 1, dims.items - 1);
			}
			return Clamp.__super__.resize.apply(this, arguments);
		};
	
		Clamp.prototype.change = function(changed, touched, init) {
			if (touched['operator'] || touched['clamp']) {
				return this.rebuild();
			}
		};
	
		return Clamp;
	
	})(Operator);
	
	module.exports = Clamp;
	
	
	/***/ }),
	/* 146 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Grow, Operator,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Grow = (function(superClass) {
		extend(Grow, superClass);
	
		function Grow() {
			return Grow.__super__.constructor.apply(this, arguments);
		}
	
		Grow.traits = ['node', 'bind', 'operator', 'source', 'index', 'grow'];
	
		Grow.prototype.sourceShader = function(shader) {
			return shader.pipe(this.operator);
		};
	
		Grow.prototype.make = function() {
			var transform, uniforms;
			Grow.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			uniforms = {
				growScale: this.node.attributes['grow.scale'],
				growMask: this._attributes.make(this._types.vec4()),
				growAnchor: this._attributes.make(this._types.vec4())
			};
			this.growMask = uniforms.growMask.value;
			this.growAnchor = uniforms.growAnchor.value;
			transform = this._shaders.shader();
			transform.require(this.bind.source.sourceShader(this._shaders.shader()));
			transform.pipe('grow.position', uniforms);
			return this.operator = transform;
		};
	
		Grow.prototype.unmake = function() {
			return Grow.__super__.unmake.apply(this, arguments);
		};
	
		Grow.prototype.resize = function() {
			this.update();
			return Grow.__super__.resize.apply(this, arguments);
		};
	
		Grow.prototype.update = function() {
			var anchor, dims, i, j, key, len, m, order, results;
			dims = this.bind.source.getFutureDimensions();
			order = ['width', 'height', 'depth', 'items'];
			m = function(d, anchor) {
				return ((d || 1) - 1) * (.5 - anchor * .5);
			};
			results = [];
			for (i = j = 0, len = order.length; j < len; i = ++j) {
				key = order[i];
				anchor = this.props[key];
				this.growMask.setComponent(i, +(anchor == null));
				results.push(this.growAnchor.setComponent(i, anchor != null ? m(dims[key], anchor) : 0));
			}
			return results;
		};
	
		Grow.prototype.change = function(changed, touched, init) {
			if (touched['operator']) {
				return this.rebuild();
			}
			if (touched['grow']) {
				return this.update();
			}
		};
	
		return Grow;
	
	})(Operator);
	
	module.exports = Grow;
	
	
	/***/ }),
	/* 147 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Join, Operator, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	
	/*
	split:
		order:       Types.transpose('wxyz')
		axis:        Types.axis()
		overlap:     Types.int(0)
	 */
	
	Join = (function(superClass) {
		extend(Join, superClass);
	
		function Join() {
			return Join.__super__.constructor.apply(this, arguments);
		}
	
		Join.traits = ['node', 'bind', 'operator', 'source', 'index', 'join'];
	
		Join.prototype.indexShader = function(shader) {
			shader.pipe(this.operator);
			return Join.__super__.indexShader.call(this, shader);
		};
	
		Join.prototype.sourceShader = function(shader) {
			shader.pipe(this.operator);
			return Join.__super__.sourceShader.call(this, shader);
		};
	
		Join.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Join.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Join.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Join.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Join.prototype._resample = function(dims) {
			var axis, dim, i, index, j, labels, len, length, mapped, order, out, overlap, product, ref, set, stride;
			order = this.order;
			axis = this.axis;
			overlap = this.overlap;
			length = this.length;
			stride = this.stride;
			labels = ['width', 'height', 'depth', 'items'];
			mapped = order.map(function(x) {
				return labels[x - 1];
			});
			index = order.indexOf(axis);
			set = (function() {
				var j, len, results;
				results = [];
				for (j = 0, len = mapped.length; j < len; j++) {
					dim = mapped[j];
					results.push(dims[dim]);
				}
				return results;
			})();
			product = ((ref = set[index + 1]) != null ? ref : 1) * stride;
			set.splice(index, 2, product);
			set = set.slice(0, 3);
			set.push(1);
			out = {};
			for (i = j = 0, len = mapped.length; j < len; i = ++j) {
				dim = mapped[i];
				out[dim] = set[i];
			}
			return out;
		};
	
		Join.prototype.make = function() {
			var axis, dims, index, labels, length, major, order, overlap, permute, rest, stride, transform, uniforms;
			Join.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			order = this.props.order;
			axis = this.props.axis;
			overlap = this.props.overlap;
	
			/*
			Calculate index transform
			
			order: wxyz
			length: 3
			overlap: 1
			
			axis: w
			index: 0
			rest: 00xy
			
			axis: x
			index: 1
			rest: w00y
			
			axis: y
			index: 2
			rest: wx00
			
			axis: z
			index: 3
			rest: wxy0
			 */
			permute = order.join('');
			if (axis == null) {
				axis = order[0];
			}
			index = permute.indexOf(axis);
			rest = permute.replace(axis, '00').substring(0, 4);
			labels = [null, 'width', 'height', 'depth', 'items'];
			major = labels[axis];
			dims = this.bind.source.getDimensions();
			length = dims[major];
			overlap = Math.min(length - 1, overlap);
			stride = length - overlap;
			uniforms = {
				joinStride: this._attributes.make(this._types.number(stride)),
				joinStrideInv: this._attributes.make(this._types.number(1 / stride))
			};
			transform = this._shaders.shader();
			transform.require(Util.GLSL.swizzleVec4(axis, 1));
			transform.require(Util.GLSL.swizzleVec4(rest, 4));
			transform.require(Util.GLSL.injectVec4([index, index + 1]));
			transform.pipe('join.position', uniforms);
			transform.pipe(Util.GLSL.invertSwizzleVec4(order));
			this.operator = transform;
			this.order = order;
			this.axis = axis;
			this.overlap = overlap;
			this.length = length;
			return this.stride = stride;
		};
	
		Join.prototype.unmake = function() {
			return Join.__super__.unmake.apply(this, arguments);
		};
	
		Join.prototype.change = function(changed, touched, init) {
			if (touched['join'] || touched['operator']) {
				return this.rebuild();
			}
		};
	
		return Join;
	
	})(Operator);
	
	module.exports = Join;
	
	
	/***/ }),
	/* 148 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Lerp, Operator, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Lerp = (function(superClass) {
		extend(Lerp, superClass);
	
		function Lerp() {
			return Lerp.__super__.constructor.apply(this, arguments);
		}
	
		Lerp.traits = ['node', 'bind', 'operator', 'source', 'index', 'lerp', 'sampler:x', 'sampler:y', 'sampler:z', 'sampler:w'];
	
		Lerp.prototype.indexShader = function(shader) {
			shader.pipe(this.indexer);
			return Lerp.__super__.indexShader.call(this, shader);
		};
	
		Lerp.prototype.sourceShader = function(shader) {
			return shader.pipe(this.operator);
		};
	
		Lerp.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Lerp.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Lerp.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Lerp.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Lerp.prototype._resample = function(dims) {
			var c, p, r;
			r = this.resampled;
			c = this.centered;
			p = this.padding;
			if (this.relativeSize) {
				if (!c.items) {
					dims.items--;
				}
				if (!c.width) {
					dims.width--;
				}
				if (!c.height) {
					dims.height--;
				}
				if (!c.depth) {
					dims.depth--;
				}
				if (r.items != null) {
					dims.items *= r.items;
				}
				if (r.width != null) {
					dims.width *= r.width;
				}
				if (r.height != null) {
					dims.height *= r.height;
				}
				if (r.depth != null) {
					dims.depth *= r.depth;
				}
				if (!c.items) {
					dims.items++;
				}
				if (!c.width) {
					dims.width++;
				}
				if (!c.height) {
					dims.height++;
				}
				if (!c.depth) {
					dims.depth++;
				}
				dims.items -= p.items * 2;
				dims.width -= p.width * 2;
				dims.height -= p.height * 2;
				dims.depth -= p.depth * 2;
			} else {
				if (r.items != null) {
					dims.items = r.items;
				}
				if (r.width != null) {
					dims.width = r.width;
				}
				if (r.height != null) {
					dims.height = r.height;
				}
				if (r.depth != null) {
					dims.depth = r.depth;
				}
			}
			dims.items = Math.max(0, Math.floor(dims.items));
			dims.width = Math.max(0, Math.floor(dims.width));
			dims.height = Math.max(0, Math.floor(dims.height));
			dims.depth = Math.max(0, Math.floor(dims.depth));
			return dims;
		};
	
		Lerp.prototype.make = function() {
			var any, centered, depth, height, i, id, indexer, items, j, k, key, len, len1, operator, ref, ref1, ref2, relativeSize, resize, sampler, size, uniforms, vec, width;
			Lerp.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			ref = this.props, size = ref.size, items = ref.items, width = ref.width, height = ref.height, depth = ref.depth;
			relativeSize = size === this.node.attributes['lerp.size']["enum"].relative;
			this.resampled = {};
			if (items != null) {
				this.resampled.items = items;
			}
			if (width != null) {
				this.resampled.width = width;
			}
			if (height != null) {
				this.resampled.height = height;
			}
			if (depth != null) {
				this.resampled.depth = depth;
			}
			this.centered = {};
			this.centered.items = this.props.centeredW;
			this.centered.width = this.props.centeredX;
			this.centered.height = this.props.centeredY;
			this.centered.depth = this.props.centeredZ;
			this.padding = {};
			this.padding.items = this.props.paddingW;
			this.padding.width = this.props.paddingX;
			this.padding.height = this.props.paddingY;
			this.padding.depth = this.props.paddingZ;
			operator = this._shaders.shader();
			indexer = this._shaders.shader();
			uniforms = {
				resampleFactor: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
				resampleBias: this._attributes.make(this._types.vec4(0, 0, 0, 0))
			};
			this.resampleFactor = uniforms.resampleFactor;
			this.resampleBias = uniforms.resampleBias;
			resize = (items != null) || (width != null) || (height != null) || (depth != null);
			operator.pipe('resample.padding', uniforms);
			vec = [];
			any = false;
			ref1 = ['width', 'height', 'depth', 'items'];
			for (i = j = 0, len = ref1.length; j < len; i = ++j) {
				key = ref1[i];
				centered = this.centered[key];
				any || (any = centered);
				vec[i] = centered ? "0.5" : "0.0";
			}
			if (any && resize) {
				vec = "vec4(" + vec + ")";
				operator.pipe(Util.GLSL.binaryOperator(4, '+', vec4));
				indexer.pipe(Util.GLSL.binaryOperator(4, '+', vec4));
			}
			if (resize) {
				operator.pipe('resample.relative', uniforms);
				indexer.pipe('resample.relative', uniforms);
			} else {
				operator.pipe(Util.GLSL.identity('vec4'));
				indexer.pipe(Util.GLSL.identity('vec4'));
			}
			if (any && resize) {
				operator.pipe(Util.GLSL.binaryOperator(4, '-', vec));
				indexer.pipe(Util.GLSL.binaryOperator(4, '-', vec));
			}
			sampler = this.bind.source.sourceShader(this._shaders.shader());
			ref2 = ['width', 'height', 'depth', 'items'];
			for (i = k = 0, len1 = ref2.length; k < len1; i = ++k) {
				key = ref2[i];
				id = "lerp." + key;
				if (this.props[key] != null) {
					sampler = this._shaders.shader().require(sampler);
					sampler.pipe(id, uniforms);
				}
			}
			operator.pipe(sampler);
			this.operator = operator;
			this.indexer = indexer;
			return this.relativeSize = relativeSize;
		};
	
		Lerp.prototype.unmake = function() {
			Lerp.__super__.unmake.apply(this, arguments);
			return this.operator = null;
		};
	
		Lerp.prototype.resize = function() {
			var axis, bd, bh, bi, bw, dims, rd, ref, ref1, ref2, ref3, rh, ri, rw, target;
			if (this.bind.source == null) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			target = this.getActiveDimensions();
			axis = (function(_this) {
				return function(key) {
					var centered, pad, res;
					centered = _this.centered[key];
					pad = _this.padding[key];
					target[key] += pad * 2;
					res = centered ? dims[key] / Math.max(1, target[key]) : Math.max(1, dims[key] - 1) / Math.max(1, target[key] - 1);
					return [res, pad];
				};
			})(this);
			ref = axis('width'), rw = ref[0], bw = ref[1];
			ref1 = axis('height'), rh = ref1[0], bh = ref1[1];
			ref2 = axis('depth'), rd = ref2[0], bd = ref2[1];
			ref3 = axis('items'), ri = ref3[0], bi = ref3[1];
			this.resampleFactor.value.set(rw, rh, rd, ri);
			this.resampleBias.value.set(bw, bh, bd, bi);
			return Lerp.__super__.resize.apply(this, arguments);
		};
	
		Lerp.prototype.change = function(changed, touched, init) {
			if (touched['operator'] || touched['lerp'] || touched['sampler']) {
				return this.rebuild();
			}
		};
	
		return Lerp;
	
	})(Operator);
	
	module.exports = Lerp;
	
	
	/***/ }),
	/* 149 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Memo, Operator, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Memo = (function(superClass) {
		extend(Memo, superClass);
	
		function Memo() {
			return Memo.__super__.constructor.apply(this, arguments);
		}
	
		Memo.traits = ['node', 'bind', 'active', 'operator', 'source', 'index', 'texture', 'memo'];
	
		Memo.prototype.sourceShader = function(shader) {
			return this.memo.shaderAbsolute(shader, 1);
		};
	
		Memo.prototype.make = function() {
			var depth, dims, height, items, magFilter, minFilter, operator, ref, type, width;
			Memo.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			this._helpers.active.make();
			this._listen('root', 'root.update', (function(_this) {
				return function() {
					if (_this.isActive) {
						return _this.update();
					}
				};
			})(this));
			ref = this.props, minFilter = ref.minFilter, magFilter = ref.magFilter, type = ref.type;
			dims = this.bind.source.getDimensions();
			items = dims.items, width = dims.width, height = dims.height, depth = dims.depth;
			this.memo = this._renderables.make('memo', {
				items: items,
				width: width,
				height: height,
				depth: depth,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
			operator = this._shaders.shader();
			this.bind.source.sourceShader(operator);
			this.compose = this._renderables.make('memoScreen', {
				map: operator,
				items: items,
				width: width,
				height: height,
				depth: depth
			});
			this.memo.adopt(this.compose);
			this.objects = [this.compose];
			return this.renders = this.compose.renders;
		};
	
		Memo.prototype.unmake = function() {
			this._helpers.active.unmake();
			if (this.bind.source != null) {
				this.memo.unadopt(this.compose);
				this.memo.dispose();
				this.memo = this.compose = null;
			}
			return Memo.__super__.unmake.apply(this, arguments);
		};
	
		Memo.prototype.update = function() {
			var ref;
			return (ref = this.memo) != null ? ref.render() : void 0;
		};
	
		Memo.prototype.resize = function() {
			var depth, dims, height, width;
			if (this.bind.source == null) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			width = dims.width, height = dims.height, depth = dims.depth;
			this.compose.cover(width, height, depth);
			return Memo.__super__.resize.apply(this, arguments);
		};
	
		Memo.prototype.change = function(changed, touched, init) {
			if (touched['texture'] || touched['operator']) {
				return this.rebuild();
			}
		};
	
		return Memo;
	
	})(Operator);
	
	module.exports = Memo;
	
	
	/***/ }),
	/* 150 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Readback, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Readback = (function(superClass) {
		extend(Readback, superClass);
	
		function Readback() {
			return Readback.__super__.constructor.apply(this, arguments);
		}
	
		Readback.traits = ['node', 'bind', 'operator', 'readback', 'entity', 'active'];
	
		Readback.finals = {
			channels: 4
		};
	
		Readback.prototype.init = function() {
			this.emitter = this.root = null;
			return this.active = {};
		};
	
		Readback.prototype.make = function() {
			var channels, depth, expr, height, items, ref, ref1, sampler, type, width;
			Readback.__super__.make.apply(this, arguments);
			this._compute('readback.data', (function(_this) {
				return function() {
					var ref;
					return (ref = _this.readback) != null ? ref.data : void 0;
				};
			})(this));
			this._compute('readback.items', (function(_this) {
				return function() {
					var ref;
					return (ref = _this.readback) != null ? ref.items : void 0;
				};
			})(this));
			this._compute('readback.width', (function(_this) {
				return function() {
					var ref;
					return (ref = _this.readback) != null ? ref.width : void 0;
				};
			})(this));
			this._compute('readback.height', (function(_this) {
				return function() {
					var ref;
					return (ref = _this.readback) != null ? ref.height : void 0;
				};
			})(this));
			this._compute('readback.depth', (function(_this) {
				return function() {
					var ref;
					return (ref = _this.readback) != null ? ref.depth : void 0;
				};
			})(this));
			this._helpers.bind.make([
				{
					to: 'operator.source',
					trait: 'source'
				}
			]);
			if (this.bind.source == null) {
				return;
			}
			ref = this.props, type = ref.type, channels = ref.channels, expr = ref.expr;
			this.root = this._inherit('root');
			this._listen('root', 'root.update', this.update);
			ref1 = this.bind.source.getDimensions(), items = ref1.items, width = ref1.width, height = ref1.height, depth = ref1.depth;
			sampler = this.bind.source.sourceShader(this._shaders.shader());
			this.readback = this._renderables.make('readback', {
				map: sampler,
				items: items,
				width: width,
				height: height,
				depth: depth,
				channels: channels,
				type: type
			});
			if (expr != null) {
				this.readback.setCallback(expr);
			}
			return this._helpers.active.make();
		};
	
		Readback.prototype.unmake = function() {
			if (this.readback != null) {
				this.readback.dispose();
				this.readback = null;
				this.root = null;
				this.emitter = null;
				this.active = {};
			}
			this._helpers.active.unmake();
			return this._helpers.bind.unmake();
		};
	
		Readback.prototype.update = function() {
			var ref;
			if (this.readback == null) {
				return;
			}
			if (this.isActive) {
				this.readback.update((ref = this.root) != null ? ref.getCamera() : void 0);
				this.readback.post();
				if (this.props.expr != null) {
					return this.readback.iterate();
				}
			}
		};
	
		Readback.prototype.resize = function() {
			var depth, height, items, ref, sI, sJ, sK, width;
			if (this.readback == null) {
				return;
			}
			ref = this.bind.source.getActiveDimensions(), items = ref.items, width = ref.width, height = ref.height, depth = ref.depth;
			this.readback.setActive(items, width, height, depth);
			this.strideI = sI = items;
			this.strideJ = sJ = sI * width;
			return this.strideK = sK = sJ * height;
		};
	
		Readback.prototype.change = function(changed, touched, init) {
			if (changed['readback.type']) {
				return this.rebuild();
			}
			if (changed['readback.expr'] && this.readback) {
				return this.readback.setCallback(this.props.expr);
			}
		};
	
		return Readback;
	
	})(Primitive);
	
	module.exports = Readback;
	
	
	/***/ }),
	/* 151 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Repeat,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Repeat = (function(superClass) {
		extend(Repeat, superClass);
	
		function Repeat() {
			return Repeat.__super__.constructor.apply(this, arguments);
		}
	
		Repeat.traits = ['node', 'bind', 'operator', 'source', 'index', 'repeat'];
	
		Repeat.prototype.indexShader = function(shader) {
			shader.pipe(this.operator);
			return Repeat.__super__.indexShader.call(this, shader);
		};
	
		Repeat.prototype.sourceShader = function(shader) {
			shader.pipe(this.operator);
			return Repeat.__super__.sourceShader.call(this, shader);
		};
	
		Repeat.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Repeat.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Repeat.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Repeat.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Repeat.prototype._resample = function(dims) {
			var r;
			r = this.resample;
			return {
				items: r.items * dims.items,
				width: r.width * dims.width,
				height: r.height * dims.height,
				depth: r.depth * dims.depth
			};
		};
	
		Repeat.prototype.make = function() {
			var transform, uniforms;
			Repeat.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			this.resample = {};
			uniforms = {
				repeatModulus: this._attributes.make(this._types.vec4())
			};
			this.repeatModulus = uniforms.repeatModulus;
			transform = this._shaders.shader();
			transform.pipe('repeat.position', uniforms);
			return this.operator = transform;
		};
	
		Repeat.prototype.unmake = function() {
			return Repeat.__super__.unmake.apply(this, arguments);
		};
	
		Repeat.prototype.resize = function() {
			var dims;
			if (this.bind.source != null) {
				dims = this.bind.source.getActiveDimensions();
				this.repeatModulus.value.set(dims.width, dims.height, dims.depth, dims.items);
			}
			return Repeat.__super__.resize.apply(this, arguments);
		};
	
		Repeat.prototype.change = function(changed, touched, init) {
			var i, key, len, ref, results;
			if (touched['operator'] || touched['repeat']) {
				return this.rebuild();
			}
			if (init) {
				ref = ['items', 'width', 'height', 'depth'];
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					key = ref[i];
					results.push(this.resample[key] = this.props[key]);
				}
				return results;
			}
		};
	
		return Repeat;
	
	})(Operator);
	
	module.exports = Repeat;
	
	
	/***/ }),
	/* 152 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Reverse, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Reverse = (function(superClass) {
		extend(Reverse, superClass);
	
		function Reverse() {
			return Reverse.__super__.constructor.apply(this, arguments);
		}
	
		Reverse.traits = ['node', 'bind', 'operator', 'source', 'index', 'reverse'];
	
		Reverse.prototype.getDimensions = function() {
			return this.bind.source.getDimensions();
		};
	
		Reverse.prototype.getActiveDimensions = function() {
			return this.bind.source.getActiveDimensions();
		};
	
		Reverse.prototype.getFutureDimensions = function() {
			return this.bind.source.getFutureDimensions();
		};
	
		Reverse.prototype.getIndexDimensions = function() {
			return this.bind.source.getIndexDimensions();
		};
	
		Reverse.prototype.sourceShader = function(shader) {
			shader.pipe('reverse.position', this.uniforms);
			return this.bind.source.sourceShader(shader);
		};
	
		Reverse.prototype._resolveScale = function(key, dims) {
			var dim, range;
			range = this.props[key];
			dim = dims[key];
			if (range) {
				return -1;
			} else {
				return 1;
			}
		};
	
		Reverse.prototype._resolveOffset = function(key, dims) {
			var dim, range;
			range = this.props[key];
			dim = dims[key];
			if (range) {
				return dim - 1;
			} else {
				return 0;
			}
		};
	
		Reverse.prototype.make = function() {
			Reverse.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			return this.uniforms = {
				reverseScale: this._attributes.make(this._types.vec4()),
				reverseOffset: this._attributes.make(this._types.vec4())
			};
		};
	
		Reverse.prototype.unmake = function() {
			return Reverse.__super__.unmake.apply(this, arguments);
		};
	
		Reverse.prototype.resize = function() {
			var dims;
			if (this.bind.source == null) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			this.uniforms.reverseScale.value.set(this._resolveScale('width', dims), this._resolveScale('height', dims), this._resolveScale('depth', dims), this._resolveScale('items', dims));
			this.uniforms.reverseOffset.value.set(this._resolveOffset('width', dims), this._resolveOffset('height', dims), this._resolveOffset('depth', dims), this._resolveOffset('items', dims));
			return Reverse.__super__.resize.apply(this, arguments);
		};
	
		Reverse.prototype.change = function(changed, touched, init) {
			if (touched['operator']) {
				return this.rebuild();
			}
			if (touched['reverse']) {
				return this.resize();
			}
		};
	
		return Reverse;
	
	})(Operator);
	
	module.exports = Reverse;
	
	
	/***/ }),
	/* 153 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Swizzle, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Swizzle = (function(superClass) {
		extend(Swizzle, superClass);
	
		function Swizzle() {
			return Swizzle.__super__.constructor.apply(this, arguments);
		}
	
		Swizzle.traits = ['node', 'bind', 'operator', 'source', 'index', 'swizzle'];
	
		Swizzle.prototype.sourceShader = function(shader) {
			shader = Swizzle.__super__.sourceShader.call(this, shader);
			if (this.swizzler) {
				shader.pipe(this.swizzler);
			}
			return shader;
		};
	
		Swizzle.prototype.make = function() {
			var order;
			Swizzle.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			order = this.props.order;
			if (order.join() !== '1234') {
				return this.swizzler = Util.GLSL.swizzleVec4(order, 4);
			}
		};
	
		Swizzle.prototype.unmake = function() {
			Swizzle.__super__.unmake.apply(this, arguments);
			return this.swizzler = null;
		};
	
		Swizzle.prototype.change = function(changed, touched, init) {
			if (touched['swizzle'] || touched['operator']) {
				return this.rebuild();
			}
		};
	
		return Swizzle;
	
	})(Operator);
	
	module.exports = Swizzle;
	
	
	/***/ }),
	/* 154 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Spread,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Spread = (function(superClass) {
		extend(Spread, superClass);
	
		function Spread() {
			return Spread.__super__.constructor.apply(this, arguments);
		}
	
		Spread.traits = ['node', 'bind', 'operator', 'source', 'index', 'spread'];
	
		Spread.prototype.sourceShader = function(shader) {
			return shader.pipe(this.operator);
		};
	
		Spread.prototype.make = function() {
			var transform, uniforms;
			Spread.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			uniforms = {
				spreadMatrix: this._attributes.make(this._types.mat4()),
				spreadOffset: this._attributes.make(this._types.vec4())
			};
			this.spreadMatrix = uniforms.spreadMatrix;
			this.spreadOffset = uniforms.spreadOffset;
			transform = this._shaders.shader();
			transform.require(this.bind.source.sourceShader(this._shaders.shader()));
			transform.pipe('spread.position', uniforms);
			return this.operator = transform;
		};
	
		Spread.prototype.unmake = function() {
			return Spread.__super__.unmake.apply(this, arguments);
		};
	
		Spread.prototype.resize = function() {
			this.update();
			return Spread.__super__.resize.apply(this, arguments);
		};
	
		Spread.prototype.update = function() {
			var align, anchor, d, dims, els, i, j, k, key, len, map, matrix, offset, order, ref, results, spread, unit, unitEnum, v;
			dims = this.bind.source.getFutureDimensions();
			matrix = this.spreadMatrix.value;
			els = matrix.elements;
			order = ['width', 'height', 'depth', 'items'];
			align = ['alignWidth', 'alignHeight', 'alignDepth', 'alignItems'];
			unit = this.props.unit;
			unitEnum = this.node.attributes['spread.unit']["enum"];
			map = (function() {
				switch (unit) {
					case unitEnum.relative:
						return function(key, i, k, v) {
							return els[i * 4 + k] = v / Math.max(1, dims[key] - 1);
						};
					case unitEnum.absolute:
						return function(key, i, k, v) {
							return els[i * 4 + k] = v;
						};
				}
			})();
			results = [];
			for (i = j = 0, len = order.length; j < len; i = ++j) {
				key = order[i];
				spread = this.props[key];
				anchor = this.props[align[i]];
				if (spread != null) {
					d = (ref = dims[key]) != null ? ref : 1;
					offset = -(d - 1) * (.5 - anchor * .5);
				} else {
					offset = 0;
				}
				this.spreadOffset.value.setComponent(i, offset);
				results.push((function() {
					var l, ref1, results1;
					results1 = [];
					for (k = l = 0; l <= 3; k = ++l) {
						v = (ref1 = spread != null ? spread.getComponent(k) : void 0) != null ? ref1 : 0;
						results1.push(els[i * 4 + k] = map(key, i, k, v));
					}
					return results1;
				})());
			}
			return results;
		};
	
		Spread.prototype.change = function(changed, touched, init) {
			if (touched['operator']) {
				return this.rebuild();
			}
			if (touched['spread']) {
				return this.update();
			}
		};
	
		return Spread;
	
	})(Operator);
	
	module.exports = Spread;
	
	
	/***/ }),
	/* 155 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Split, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	
	/*
	split:
		order:       Types.transpose('wxyz')
		axis:        Types.axis()
		length:      Types.int(1)
		overlap:     Types.int(0)
	 */
	
	Split = (function(superClass) {
		extend(Split, superClass);
	
		function Split() {
			return Split.__super__.constructor.apply(this, arguments);
		}
	
		Split.traits = ['node', 'bind', 'operator', 'source', 'index', 'split'];
	
		Split.prototype.indexShader = function(shader) {
			shader.pipe(this.operator);
			return Split.__super__.indexShader.call(this, shader);
		};
	
		Split.prototype.sourceShader = function(shader) {
			shader.pipe(this.operator);
			return Split.__super__.sourceShader.call(this, shader);
		};
	
		Split.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Split.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Split.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Split.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Split.prototype._resample = function(dims) {
			var axis, dim, i, index, j, labels, len, length, mapped, order, out, overlap, remain, set, stride;
			order = this.order;
			axis = this.axis;
			overlap = this.overlap;
			length = this.length;
			stride = this.stride;
			labels = ['width', 'height', 'depth', 'items'];
			mapped = order.map(function(x) {
				return labels[x - 1];
			});
			index = order.indexOf(axis);
			set = (function() {
				var j, len, results;
				results = [];
				for (j = 0, len = mapped.length; j < len; j++) {
					dim = mapped[j];
					results.push(dims[dim]);
				}
				return results;
			})();
			remain = Math.floor((set[index] - overlap) / stride);
			set.splice(index, 1, length, remain);
			set = set.slice(0, 4);
			out = {};
			for (i = j = 0, len = mapped.length; j < len; i = ++j) {
				dim = mapped[i];
				out[dim] = set[i];
			}
			return out;
		};
	
		Split.prototype.make = function() {
			var axis, index, length, order, overlap, permute, ref, rest, split, stride, transform, uniforms;
			Split.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			order = this.props.order;
			axis = this.props.axis;
			overlap = this.props.overlap;
			length = this.props.length;
	
			/*
			Calculate index transform
			
			order: wxyz
			length: 3
			overlap: 1
			
			axis: w
			index: 0
			split: wx
			rest:  0yz0
						 s
			
			axis: x
			index: 1
			split: xy
			rest:  w0z0
							s
			
			axis: y
			index: 2
			split: yz
			rest:  wx00
							 s
			
			axis: z
			index: 3
			split: z0
			rest: wxy0
							 s
			 */
			permute = order.join('');
			if (axis == null) {
				axis = order[0];
			}
			index = permute.indexOf(axis);
			split = permute[index] + ((ref = permute[index + 1]) != null ? ref : 0);
			rest = permute.replace(split[1], '').replace(split[0], '0') + '0';
			overlap = Math.min(length - 1, overlap);
			stride = length - overlap;
			uniforms = {
				splitStride: this._attributes.make(this._types.number(stride))
			};
			transform = this._shaders.shader();
			transform.require(Util.GLSL.swizzleVec4(split, 2));
			transform.require(Util.GLSL.swizzleVec4(rest, 4));
			transform.require(Util.GLSL.injectVec4(index));
			transform.pipe('split.position', uniforms);
			transform.pipe(Util.GLSL.invertSwizzleVec4(order));
			this.operator = transform;
			this.order = order;
			this.axis = axis;
			this.overlap = overlap;
			this.length = length;
			return this.stride = stride;
		};
	
		Split.prototype.unmake = function() {
			return Split.__super__.unmake.apply(this, arguments);
		};
	
		Split.prototype.change = function(changed, touched, init) {
			if (changed['split.axis'] || changed['split.order'] || touched['operator']) {
				return this.rebuild();
			}
		};
	
		return Split;
	
	})(Operator);
	
	module.exports = Split;
	
	
	/***/ }),
	/* 156 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Slice, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Slice = (function(superClass) {
		extend(Slice, superClass);
	
		function Slice() {
			return Slice.__super__.constructor.apply(this, arguments);
		}
	
		Slice.traits = ['node', 'bind', 'operator', 'source', 'index', 'slice'];
	
		Slice.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Slice.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Slice.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Slice.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Slice.prototype.sourceShader = function(shader) {
			shader.pipe('slice.position', this.uniforms);
			return this.bind.source.sourceShader(shader);
		};
	
		Slice.prototype._resolve = function(key, dims) {
			var dim, end, index, range, start;
			range = this.props[key];
			dim = dims[key];
			if (range == null) {
				return [0, dim];
			}
			index = function(i, dim) {
				if (i < 0) {
					return dim + i;
				} else {
					return i;
				}
			};
			start = index(Math.round(range.x), dim);
			end = index(Math.round(range.y), dim);
			end = Math.max(start, end);
			return [start, end - start];
		};
	
		Slice.prototype._resample = function(dims) {
			dims.width = this._resolve('width', dims)[1];
			dims.height = this._resolve('height', dims)[1];
			dims.depth = this._resolve('depth', dims)[1];
			dims.items = this._resolve('items', dims)[1];
			return dims;
		};
	
		Slice.prototype.make = function() {
			Slice.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			return this.uniforms = {
				sliceOffset: this._attributes.make(this._types.vec4())
			};
		};
	
		Slice.prototype.unmake = function() {
			return Slice.__super__.unmake.apply(this, arguments);
		};
	
		Slice.prototype.resize = function() {
			var dims;
			if (this.bind.source == null) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			this.uniforms.sliceOffset.value.set(this._resolve('width', dims)[0], this._resolve('height', dims)[0], this._resolve('depth', dims)[0], this._resolve('items', dims)[0]);
			return Slice.__super__.resize.apply(this, arguments);
		};
	
		Slice.prototype.change = function(changed, touched, init) {
			if (touched['operator']) {
				return this.rebuild();
			}
			if (touched['slice']) {
				return this.resize();
			}
		};
	
		return Slice;
	
	})(Operator);
	
	module.exports = Slice;
	
	
	/***/ }),
	/* 157 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Subdivide, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	Subdivide = (function(superClass) {
		extend(Subdivide, superClass);
	
		function Subdivide() {
			return Subdivide.__super__.constructor.apply(this, arguments);
		}
	
		Subdivide.traits = ['node', 'bind', 'operator', 'source', 'index', 'subdivide'];
	
		Subdivide.prototype.indexShader = function(shader) {
			shader.pipe(this.indexer);
			return Subdivide.__super__.indexShader.call(this, shader);
		};
	
		Subdivide.prototype.sourceShader = function(shader) {
			return shader.pipe(this.operator);
		};
	
		Subdivide.prototype.getDimensions = function() {
			return this._resample(this.bind.source.getDimensions());
		};
	
		Subdivide.prototype.getActiveDimensions = function() {
			return this._resample(this.bind.source.getActiveDimensions());
		};
	
		Subdivide.prototype.getFutureDimensions = function() {
			return this._resample(this.bind.source.getFutureDimensions());
		};
	
		Subdivide.prototype.getIndexDimensions = function() {
			return this._resample(this.bind.source.getIndexDimensions());
		};
	
		Subdivide.prototype._resample = function(dims) {
			var r;
			r = this.resampled;
			dims.items--;
			dims.width--;
			dims.height--;
			dims.depth--;
			if (r.items != null) {
				dims.items *= r.items;
			}
			if (r.width != null) {
				dims.width *= r.width;
			}
			if (r.height != null) {
				dims.height *= r.height;
			}
			if (r.depth != null) {
				dims.depth *= r.depth;
			}
			dims.items++;
			dims.width++;
			dims.height++;
			dims.depth++;
			return dims;
		};
	
		Subdivide.prototype.make = function() {
			var depth, height, i, id, indexer, items, j, key, len, lerp, operator, ref, ref1, resize, sampler, size, uniforms, width;
			Subdivide.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			ref = this.props, size = ref.size, items = ref.items, width = ref.width, height = ref.height, depth = ref.depth, lerp = ref.lerp;
			this.resampled = {};
			if (items != null) {
				this.resampled.items = items;
			}
			if (width != null) {
				this.resampled.width = width;
			}
			if (height != null) {
				this.resampled.height = height;
			}
			if (depth != null) {
				this.resampled.depth = depth;
			}
			operator = this._shaders.shader();
			indexer = this._shaders.shader();
			uniforms = {
				resampleFactor: this._attributes.make(this._types.vec4(0, 0, 0, 0)),
				subdivideBevel: this.node.attributes['subdivide.bevel']
			};
			this.resampleFactor = uniforms.resampleFactor;
			this.resampleBias = uniforms.resampleBias;
			resize = (items != null) || (width != null) || (height != null) || (depth != null);
			if (resize) {
				operator.pipe('resample.relative', uniforms);
				indexer.pipe('resample.relative', uniforms);
			} else {
				operator.pipe(Util.GLSL.identity('vec4'));
				indexer.pipe(Util.GLSL.identity('vec4'));
			}
			sampler = this.bind.source.sourceShader(this._shaders.shader());
			lerp = lerp ? '.lerp' : '';
			ref1 = ['width', 'height', 'depth', 'items'];
			for (i = j = 0, len = ref1.length; j < len; i = ++j) {
				key = ref1[i];
				id = "subdivide." + key + lerp;
				if (this.props[key] != null) {
					sampler = this._shaders.shader().require(sampler);
					sampler.pipe(id, uniforms);
				}
			}
			operator.pipe(sampler);
			this.operator = operator;
			return this.indexer = indexer;
		};
	
		Subdivide.prototype.unmake = function() {
			Subdivide.__super__.unmake.apply(this, arguments);
			return this.operator = null;
		};
	
		Subdivide.prototype.resize = function() {
			var axis, dims, rd, rh, ri, rw, target;
			if (this.bind.source == null) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			target = this.getActiveDimensions();
			axis = function(key) {
				return Math.max(1, dims[key] - 1) / Math.max(1, target[key] - 1);
			};
			rw = axis('width');
			rh = axis('height');
			rd = axis('depth');
			ri = axis('items');
			this.resampleFactor.value.set(rw, rh, rd, ri);
			return Subdivide.__super__.resize.apply(this, arguments);
		};
	
		Subdivide.prototype.change = function(changed, touched, init) {
			if (touched['operator'] || touched['subdivide']) {
				return this.rebuild();
			}
		};
	
		return Subdivide;
	
	})(Operator);
	
	module.exports = Subdivide;
	
	
	/***/ }),
	/* 158 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Operator, Transpose, Util, labels,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Operator = __webpack_require__(3);
	
	Util = __webpack_require__(0);
	
	labels = {
		1: 'width',
		2: 'height',
		3: 'depth',
		4: 'items'
	};
	
	Transpose = (function(superClass) {
		extend(Transpose, superClass);
	
		function Transpose() {
			return Transpose.__super__.constructor.apply(this, arguments);
		}
	
		Transpose.traits = ['node', 'bind', 'operator', 'source', 'index', 'transpose'];
	
		Transpose.prototype.indexShader = function(shader) {
			if (this.swizzler) {
				shader.pipe(this.swizzler);
			}
			return Transpose.__super__.indexShader.call(this, shader);
		};
	
		Transpose.prototype.sourceShader = function(shader) {
			if (this.swizzler) {
				shader.pipe(this.swizzler);
			}
			return Transpose.__super__.sourceShader.call(this, shader);
		};
	
		Transpose.prototype.getDimensions = function() {
			return this._remap(this.transpose, this.bind.source.getDimensions());
		};
	
		Transpose.prototype.getActiveDimensions = function() {
			return this._remap(this.transpose, this.bind.source.getActiveDimensions());
		};
	
		Transpose.prototype.getFutureDimensions = function() {
			return this._remap(this.transpose, this.bind.source.getFutureDimensions());
		};
	
		Transpose.prototype.getIndexDimensions = function() {
			return this._remap(this.transpose, this.bind.source.getIndexDimensions());
		};
	
		Transpose.prototype._remap = function(transpose, dims) {
			var dst, i, j, out, ref, src;
			out = {};
			for (i = j = 0; j <= 3; i = ++j) {
				dst = labels[i + 1];
				src = labels[transpose[i]];
				out[dst] = (ref = dims[src]) != null ? ref : 1;
			}
			return out;
		};
	
		Transpose.prototype.make = function() {
			var order;
			Transpose.__super__.make.apply(this, arguments);
			if (this.bind.source == null) {
				return;
			}
			order = this.props.order;
			if (order.join() !== '1234') {
				this.swizzler = Util.GLSL.invertSwizzleVec4(order);
			}
			this.transpose = order;
			return this.trigger({
				type: 'source.rebuild'
			});
		};
	
		Transpose.prototype.unmake = function() {
			Transpose.__super__.unmake.apply(this, arguments);
			return this.swizzler = null;
		};
	
		Transpose.prototype.change = function(changed, touched, init) {
			if (touched['transpose'] || touched['operator']) {
				return this.rebuild();
			}
		};
	
		return Transpose;
	
	})(Operator);
	
	module.exports = Transpose;
	
	
	/***/ }),
	/* 159 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Group, Parent,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Group = (function(superClass) {
		extend(Group, superClass);
	
		function Group() {
			return Group.__super__.constructor.apply(this, arguments);
		}
	
		Group.traits = ['node', 'object', 'entity', 'visible', 'active'];
	
		Group.prototype.make = function() {
			this._helpers.visible.make();
			return this._helpers.active.make();
		};
	
		Group.prototype.unmake = function() {
			this._helpers.visible.unmake();
			return this._helpers.active.unmake();
		};
	
		return Group;
	
	})(Parent);
	
	module.exports = Group;
	
	
	/***/ }),
	/* 160 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Inherit, Parent,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	Parent = __webpack_require__(4);
	
	Inherit = (function(superClass) {
		extend(Inherit, superClass);
	
		function Inherit() {
			return Inherit.__super__.constructor.apply(this, arguments);
		}
	
		Inherit.traits = ['node', 'bind'];
	
		Inherit.prototype.make = function() {
			return this._helpers.bind.make([
				{
					to: 'inherit.source',
					trait: 'node'
				}
			]);
		};
	
		Inherit.prototype.unmake = function() {
			return this._helpers.bind.unmake();
		};
	
		Inherit.prototype._find = function(trait) {
			if (this.bind.source && (indexOf.call(this.props.traits, trait) >= 0)) {
				return this.bind.source._inherit(trait);
			}
			return Inherit.__super__._find.apply(this, arguments);
		};
	
		return Inherit;
	
	})(Parent);
	
	module.exports = Inherit;
	
	
	/***/ }),
	/* 161 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Root, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Util = __webpack_require__(0);
	
	Root = (function(superClass) {
		extend(Root, superClass);
	
		function Root() {
			return Root.__super__.constructor.apply(this, arguments);
		}
	
		Root.traits = ['node', 'root', 'clock', 'scene', 'vertex', 'unit'];
	
		Root.prototype.init = function() {
			this.size = null;
			this.cameraEvent = {
				type: 'root.camera'
			};
			this.preEvent = {
				type: 'root.pre'
			};
			this.updateEvent = {
				type: 'root.update'
			};
			this.renderEvent = {
				type: 'root.render'
			};
			this.postEvent = {
				type: 'root.post'
			};
			this.clockEvent = {
				type: 'clock.tick'
			};
			return this.camera = null;
		};
	
		Root.prototype.make = function() {
			return this._helpers.unit.make();
		};
	
		Root.prototype.unmake = function() {
			return this._helpers.unit.unmake();
		};
	
		Root.prototype.change = function(changed, touched, init) {
			if (changed['root.camera'] || init) {
				this._unattach();
				this._attach(this.props.camera, 'camera', this.setCamera, this, this, true);
				return this.setCamera();
			}
		};
	
		Root.prototype.adopt = function(renderable) {
			var i, len, object, ref, results;
			ref = renderable.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this._context.scene.add(object));
			}
			return results;
		};
	
		Root.prototype.unadopt = function(renderable) {
			var i, len, object, ref, results;
			ref = renderable.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this._context.scene.remove(object));
			}
			return results;
		};
	
		Root.prototype.select = function(selector) {
			return this.node.model.select(selector);
		};
	
		Root.prototype.watch = function(selector, handler) {
			return this.node.model.watch(selector, handler);
		};
	
		Root.prototype.unwatch = function(handler) {
			return this.node.model.unwatch(handler);
		};
	
		Root.prototype.resize = function(size) {
			this.size = size;
			return this.trigger({
				type: 'root.resize',
				size: size
			});
		};
	
		Root.prototype.getSize = function() {
			return this.size;
		};
	
		Root.prototype.getSpeed = function() {
			return this.props.speed;
		};
	
		Root.prototype.getUnit = function() {
			return this._helpers.unit.get();
		};
	
		Root.prototype.getUnitUniforms = function() {
			return this._helpers.unit.uniforms();
		};
	
		Root.prototype.pre = function() {
			this.getCamera().updateProjectionMatrix();
			this.trigger(this.clockEvent);
			return this.trigger(this.preEvent);
		};
	
		Root.prototype.update = function() {
			return this.trigger(this.updateEvent);
		};
	
		Root.prototype.render = function() {
			return this.trigger(this.renderEvent);
		};
	
		Root.prototype.post = function() {
			return this.trigger(this.postEvent);
		};
	
		Root.prototype.setCamera = function() {
			var camera, ref;
			camera = (ref = this.select(this.props.camera)[0]) != null ? ref.controller : void 0;
			if (this.camera !== camera) {
				this.camera = camera;
				return this.trigger({
					type: 'root.camera'
				});
			}
		};
	
		Root.prototype.getCamera = function() {
			var ref, ref1;
			return (ref = (ref1 = this.camera) != null ? ref1.getCamera() : void 0) != null ? ref : this._context.defaultCamera;
		};
	
		Root.prototype.getTime = function() {
			return this._context.time;
		};
	
		Root.prototype.vertex = function(shader, pass) {
			if (pass === 2) {
				return shader.pipe('view.position');
			}
			if (pass === 3) {
				return shader.pipe('root.position');
			}
			return shader;
		};
	
		return Root;
	
	})(Parent);
	
	module.exports = Root;
	
	
	/***/ }),
	/* 162 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Unit, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Util = __webpack_require__(0);
	
	Unit = (function(superClass) {
		extend(Unit, superClass);
	
		function Unit() {
			return Unit.__super__.constructor.apply(this, arguments);
		}
	
		Unit.traits = ['node', 'unit'];
	
		Unit.prototype.make = function() {
			return this._helpers.unit.make();
		};
	
		Unit.prototype.unmake = function() {
			return this._helpers.unit.unmake();
		};
	
		Unit.prototype.getUnit = function() {
			return this._helpers.unit.get();
		};
	
		Unit.prototype.getUnitUniforms = function() {
			return this._helpers.unit.uniforms();
		};
	
		return Unit;
	
	})(Parent);
	
	module.exports = Unit;
	
	
	/***/ }),
	/* 163 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Primitive, Shader, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Shader = (function(superClass) {
		extend(Shader, superClass);
	
		function Shader() {
			return Shader.__super__.constructor.apply(this, arguments);
		}
	
		Shader.traits = ['node', 'bind', 'shader'];
	
		Shader.freeform = true;
	
		Shader.prototype.init = function() {
			return this.shader = null;
		};
	
		Shader.prototype.make = function() {
			var code, def, i, language, len, make, ref, ref1, snippet, type, types, uniforms;
			ref = this.props, language = ref.language, code = ref.code;
			if (language !== 'glsl') {
				throw new Error("GLSL required");
			}
			this._helpers.bind.make([
				{
					to: 'shader.sources',
					trait: 'source',
					multiple: true
				}
			]);
			snippet = this._shaders.fetch(code);
			types = this._types;
			uniforms = {};
			make = (function(_this) {
				return function(type) {
					var t;
					switch (type) {
						case 'i':
							return types.int();
						case 'f':
							return types.number();
						case 'v2':
							return types.vec2();
						case 'v3':
							return types.vec3();
						case 'v4':
							return types.vec4();
						case 'm3':
							return types.mat3();
						case 'm4':
							return types.mat4();
						case 't':
							return types.object();
						default:
							t = type.split('');
							if (t.pop() === 'v') {
								return types.array(make(t.join('')));
							} else {
								return null;
							}
					}
				};
			})(this);
			ref1 = snippet._signatures.uniform;
			for (i = 0, len = ref1.length; i < len; i++) {
				def = ref1[i];
				if (type = make(def.type)) {
					uniforms[def.name] = type;
				}
			}
			return this.reconfigure({
				props: {
					uniform: uniforms
				}
			});
		};
	
		Shader.prototype.made = function() {
			return this.trigger({
				type: 'source.rebuild'
			});
		};
	
		Shader.prototype.unmake = function() {
			return this.shader = null;
		};
	
		Shader.prototype.change = function(changed, touched, init) {
			if (changed['shader.uniforms'] || changed['shader.code'] || changed['shader.language']) {
				return this.rebuild();
			}
		};
	
		Shader.prototype.shaderBind = function(uniforms) {
			var channels, code, i, indices, k, language, len, name, ref, ref1, ref2, s, source, u, v;
			if (uniforms == null) {
				uniforms = {};
			}
			ref = this.props, language = ref.language, code = ref.code, indices = ref.indices, channels = ref.channels;
			ref1 = this.node.attributes;
			for (k in ref1) {
				v = ref1[k];
				if ((v.type != null) && (v.short != null) && v.ns === 'uniform') {
					if (uniforms[name = v.short] == null) {
						uniforms[name] = v;
					}
				}
			}
			if ((u = this.props.uniforms) != null) {
				for (k in u) {
					v = u[k];
					uniforms[k] = v;
				}
			}
			s = this._shaders.shader();
			if (this.bind.sources != null) {
				ref2 = this.bind.sources;
				for (i = 0, len = ref2.length; i < len; i++) {
					source = ref2[i];
					s.callback();
					if (indices !== 4) {
						s.pipe(Util.GLSL.extendVec(indices, 4));
					}
					s.pipe(source.sourceShader(this._shaders.shader()));
					if (channels !== 4) {
						s.pipe(Util.GLSL.truncateVec(4, channels));
					}
					s.join();
				}
			}
			return s.pipe(code, uniforms);
		};
	
		return Shader;
	
	})(Primitive);
	
	module.exports = Shader;
	
	
	/***/ }),
	/* 164 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Camera, Primitive, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Camera = (function(superClass) {
		extend(Camera, superClass);
	
		function Camera() {
			return Camera.__super__.constructor.apply(this, arguments);
		}
	
		Camera.traits = ['node', 'camera'];
	
		Camera.prototype.init = function() {};
	
		Camera.prototype.make = function() {
			var camera;
			camera = this._context.defaultCamera;
			this.camera = this.props.proxy ? camera : camera.clone();
			this.euler = new THREE.Euler;
			return this.quat = new THREE.Quaternion;
		};
	
		Camera.prototype.unmake = function() {};
	
		Camera.prototype.getCamera = function() {
			return this.camera;
		};
	
		Camera.prototype.change = function(changed, touched, init) {
			var aspect, fov, lookAt, position, quaternion, ref, rotation, up;
			if (changed['camera.position'] || changed['camera.quaternion'] || changed['camera.rotation'] || changed['camera.lookAt'] || changed['camera.up'] || changed['camera.fov'] || init) {
				ref = this.props, position = ref.position, quaternion = ref.quaternion, rotation = ref.rotation, lookAt = ref.lookAt, up = ref.up, fov = ref.fov, aspect = ref.aspect;
				if (position != null) {
					this.camera.position.copy(position);
				}
				if ((quaternion != null) || (rotation != null) || (lookAt != null)) {
					if (lookAt != null) {
						this.camera.lookAt(lookAt);
					} else {
						this.camera.quaternion.set(0, 0, 0, 1);
					}
					if (rotation != null) {
						this.euler.setFromVector3(rotation, Util.Three.swizzleToEulerOrder(this.props.eulerOrder));
						this.quat.setFromEuler(this.euler);
						this.camera.quaternion.multiply(this.quat);
					}
					if (quaternion != null) {
						this.camera.quaternion.multiply(quaternion);
					}
				}
				if ((fov != null) && (this.camera.fov != null)) {
					this.camera.fov = fov;
				}
				if (up != null) {
					this.camera.up.copy(up);
				}
				return this.camera.updateMatrix();
			}
		};
	
		return Camera;
	
	})(Primitive);
	
	module.exports = Camera;
	
	
	/***/ }),
	/* 165 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, RTT, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Util = __webpack_require__(0);
	
	RTT = (function(superClass) {
		extend(RTT, superClass);
	
		function RTT() {
			return RTT.__super__.constructor.apply(this, arguments);
		}
	
		RTT.traits = ['node', 'root', 'scene', 'vertex', 'texture', 'rtt', 'source', 'index', 'image'];
	
		RTT.defaults = {
			minFilter: 'linear',
			magFilter: 'linear',
			type: 'unsignedByte'
		};
	
		RTT.prototype.init = function() {
			return this.rtt = this.scene = this.camera = this.width = this.height = this.history = this.rootSize = this.size = null;
		};
	
		RTT.prototype.indexShader = function(shader) {
			return shader;
		};
	
		RTT.prototype.imageShader = function(shader) {
			return this.rtt.shaderRelative(shader);
		};
	
		RTT.prototype.sourceShader = function(shader) {
			return this.rtt.shaderAbsolute(shader, this.history);
		};
	
		RTT.prototype.getDimensions = function() {
			return {
				items: 1,
				width: this.width,
				height: this.height,
				depth: this.history
			};
		};
	
		RTT.prototype.getActiveDimensions = function() {
			return this.getDimensions();
		};
	
		RTT.prototype.make = function() {
			var aspect, height, heightFactor, history, magFilter, minFilter, ref, ref1, relativeSize, size, type, viewHeight, viewWidth, width, widthFactor;
			this.parentRoot = this._inherit('root');
			this.rootSize = this.parentRoot.getSize();
			this._listen(this.parentRoot, 'root.pre', this.pre);
			this._listen(this.parentRoot, 'root.update', this.update);
			this._listen(this.parentRoot, 'root.render', this.render);
			this._listen(this.parentRoot, 'root.post', this.post);
			this._listen(this.parentRoot, 'root.camera', this.setCamera);
			this._listen(this.parentRoot, 'root.resize', function(event) {
				return this.resize(event.size);
			});
			if (this.rootSize == null) {
				return;
			}
			ref = this.props, minFilter = ref.minFilter, magFilter = ref.magFilter, type = ref.type;
			ref1 = this.props, width = ref1.width, height = ref1.height, history = ref1.history, size = ref1.size;
			relativeSize = size === this.node.attributes['rtt.size']["enum"].relative;
			widthFactor = relativeSize ? this.rootSize.renderWidth : 1;
			heightFactor = relativeSize ? this.rootSize.renderHeight : 1;
			this.width = Math.round(width != null ? width * widthFactor : this.rootSize.renderWidth);
			this.height = Math.round(height != null ? height * heightFactor : this.rootSize.renderHeight);
			this.history = history;
			this.aspect = aspect = this.width / this.height;
			if (this.scene == null) {
				this.scene = this._renderables.make('scene');
			}
			this.rtt = this._renderables.make('renderToTexture', {
				scene: this.scene,
				camera: this._context.defaultCamera,
				width: this.width,
				height: this.height,
				frames: this.history,
				minFilter: minFilter,
				magFilter: magFilter,
				type: type
			});
			aspect = width || height ? aspect : this.rootSize.aspect;
			viewWidth = width != null ? width : this.rootSize.viewWidth;
			viewHeight = height != null ? height : this.rootSize.viewHeight;
			return this.size = {
				renderWidth: this.width,
				renderHeight: this.height,
				aspect: aspect,
				viewWidth: viewWidth,
				viewHeight: viewHeight,
				pixelRatio: this.height / viewHeight
			};
		};
	
		RTT.prototype.made = function() {
			this.trigger({
				type: 'source.rebuild'
			});
			if (this.size) {
				return this.trigger({
					type: 'root.resize',
					size: this.size
				});
			}
		};
	
		RTT.prototype.unmake = function(rebuild) {
			if (this.rtt == null) {
				return;
			}
			this.rtt.dispose();
			if (!rebuild) {
				this.scene.dispose();
			}
			return this.rtt = this.width = this.height = this.history = null;
		};
	
		RTT.prototype.change = function(changed, touched, init) {
			if (touched['texture'] || changed['rtt.width'] || changed['rtt.height']) {
				return this.rebuild();
			}
			if (changed['root.camera'] || init) {
				this._unattach();
				this._attach(this.props.camera, 'camera', this.setCamera, this, this, true);
				return this.setCamera();
			}
		};
	
		RTT.prototype.adopt = function(renderable) {
			var i, len, object, ref, results;
			ref = renderable.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this.scene.add(object));
			}
			return results;
		};
	
		RTT.prototype.unadopt = function(renderable) {
			var i, len, object, ref, results;
			ref = renderable.renders;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				object = ref[i];
				results.push(this.scene.remove(object));
			}
			return results;
		};
	
		RTT.prototype.resize = function(size) {
			var height, ref, relativeSize, width;
			this.rootSize = size;
			ref = this.props, width = ref.width, height = ref.height, size = ref.size;
			relativeSize = size === this.node.attributes['rtt.size']["enum"].relative;
			if (!this.rtt || (width == null) || (height == null) || relativeSize) {
				return this.rebuild();
			}
		};
	
		RTT.prototype.select = function(selector) {
			return this._root.node.model.select(selector, [this.node]);
		};
	
		RTT.prototype.watch = function(selector, handler) {
			return this._root.node.model.watch(selector, handler);
		};
	
		RTT.prototype.unwatch = function(handler) {
			return this._root.node.model.unwatch(handler);
		};
	
		RTT.prototype.pre = function(e) {
			return this.trigger(e);
		};
	
		RTT.prototype.update = function(e) {
			var camera;
			if ((camera = this.getOwnCamera()) != null) {
				camera.aspect = this.aspect || 1;
				camera.updateProjectionMatrix();
			}
			return this.trigger(e);
		};
	
		RTT.prototype.render = function(e) {
			var ref;
			this.trigger(e);
			return (ref = this.rtt) != null ? ref.render(this.getCamera()) : void 0;
		};
	
		RTT.prototype.post = function(e) {
			return this.trigger(e);
		};
	
		RTT.prototype.setCamera = function() {
			var camera, ref;
			camera = (ref = this.select(this.props.camera)[0]) != null ? ref.controller : void 0;
			if (this.camera !== camera) {
				this.camera = camera;
				this.rtt.camera = this.getCamera();
				return this.trigger({
					type: 'root.camera'
				});
			} else if (!this.camera) {
				return this.trigger({
					type: 'root.camera'
				});
			}
		};
	
		RTT.prototype.getOwnCamera = function() {
			var ref;
			return (ref = this.camera) != null ? ref.getCamera() : void 0;
		};
	
		RTT.prototype.getCamera = function() {
			var ref;
			return (ref = this.getOwnCamera()) != null ? ref : this._inherit('root').getCamera();
		};
	
		RTT.prototype.vertex = function(shader, pass) {
			if (pass === 2) {
				return shader.pipe('view.position');
			}
			if (pass === 3) {
				return shader.pipe('root.position');
			}
			return shader;
		};
	
		return RTT;
	
	})(Parent);
	
	module.exports = RTT;
	
	
	/***/ }),
	/* 166 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Compose, Primitive, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Primitive = __webpack_require__(2);
	
	Util = __webpack_require__(0);
	
	Compose = (function(superClass) {
		extend(Compose, superClass);
	
		function Compose() {
			return Compose.__super__.constructor.apply(this, arguments);
		}
	
		Compose.traits = ['node', 'bind', 'object', 'visible', 'operator', 'style', 'compose'];
	
		Compose.defaults = {
			zWrite: false,
			zTest: false,
			color: '#ffffff'
		};
	
		Compose.prototype.init = function() {
			return this.compose = null;
		};
	
		Compose.prototype.resize = function() {
			var depth, dims, height, layers, width;
			if (!(this.compose && this.bind.source)) {
				return;
			}
			dims = this.bind.source.getActiveDimensions();
			width = dims.width;
			height = dims.height;
			depth = dims.depth;
			layers = dims.items;
			return this.remapUVScale.set(width, height);
		};
	
		Compose.prototype.make = function() {
			var alpha, composeUniforms, fragment, resampleUniforms;
			this._helpers.bind.make([
				{
					to: 'operator.source',
					trait: 'source'
				}
			]);
			if (this.bind.source == null) {
				return;
			}
			resampleUniforms = {
				remapUVScale: this._attributes.make(this._types.vec2())
			};
			this.remapUVScale = resampleUniforms.remapUVScale.value;
			fragment = this._shaders.shader();
			alpha = this.props.alpha;
			if (this.bind.source.is('image')) {
				fragment.pipe('screen.pass.uv', resampleUniforms);
				fragment = this.bind.source.imageShader(fragment);
			} else {
				fragment.pipe('screen.map.xy', resampleUniforms);
				fragment = this.bind.source.sourceShader(fragment);
			}
			if (!alpha) {
				fragment.pipe('color.opaque');
			}
			composeUniforms = this._helpers.style.uniforms();
			this.compose = this._renderables.make('screen', {
				map: fragment,
				uniforms: composeUniforms,
				linear: true
			});
			this._helpers.visible.make();
			return this._helpers.object.make([this.compose]);
		};
	
		Compose.prototype.made = function() {
			return this.resize();
		};
	
		Compose.prototype.unmake = function() {
			this._helpers.bind.unmake();
			this._helpers.visible.unmake();
			return this._helpers.object.unmake();
		};
	
		Compose.prototype.change = function(changed, touched, init) {
			if (changed['operator.source'] || changed['compose.alpha']) {
				return this.rebuild();
			}
		};
	
		return Compose;
	
	})(Primitive);
	
	module.exports = Compose;
	
	
	/***/ }),
	/* 167 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Clock, Parent,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Clock = (function(superClass) {
		extend(Clock, superClass);
	
		function Clock() {
			return Clock.__super__.constructor.apply(this, arguments);
		}
	
		Clock.traits = ['node', 'clock', 'seek', 'play'];
	
		Clock.prototype.init = function() {
			this.skew = 0;
			this.last = 0;
			return this.time = {
				now: +new Date() / 1000,
				time: 0,
				delta: 0,
				clock: 0,
				step: 0
			};
		};
	
		Clock.prototype.make = function() {
			return this._listen('clock', 'clock.tick', this.tick);
		};
	
		Clock.prototype.reset = function() {
			return this.skew = 0;
		};
	
		Clock.prototype.tick = function(e) {
			var clock, delay, delta, from, pace, parent, ratio, realtime, ref, seek, speed, time, to;
			ref = this.props, from = ref.from, to = ref.to, speed = ref.speed, seek = ref.seek, pace = ref.pace, delay = ref.delay, realtime = ref.realtime;
			parent = this._inherit('clock').getTime();
			time = realtime ? parent.time : parent.clock;
			delta = realtime ? parent.delta : parent.step;
			ratio = speed / pace;
			this.skew += delta * (ratio - 1);
			if (this.last > time) {
				this.skew = 0;
			}
			this.time.now = parent.now + this.skew;
			this.time.time = parent.time;
			this.time.delta = parent.delta;
			clock = seek != null ? seek : parent.clock + this.skew;
			this.time.clock = Math.min(to, from + Math.max(0, clock - delay * ratio));
			this.time.step = delta * ratio;
			this.last = time;
			return this.trigger(e);
		};
	
		Clock.prototype.getTime = function() {
			return this.time;
		};
	
		return Clock;
	
	})(Parent);
	
	module.exports = Clock;
	
	
	/***/ }),
	/* 168 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Now, Parent,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Now = (function(superClass) {
		extend(Now, superClass);
	
		function Now() {
			return Now.__super__.constructor.apply(this, arguments);
		}
	
		Now.traits = ['node', 'clock', 'now'];
	
		Now.prototype.init = function() {
			var now;
			this.now = now = +new Date() / 1000;
			this.skew = 0;
			return this.time = {
				now: now,
				time: 0,
				delta: 0,
				clock: 0,
				step: 0
			};
		};
	
		Now.prototype.make = function() {
			this.clockParent = this._inherit('clock');
			return this._listen('clock', 'clock.tick', this.tick);
		};
	
		Now.prototype.unmake = function() {
			return this.clockParent = null;
		};
	
		Now.prototype.change = function(changed, touched, init) {
			if (changed['date.now']) {
				return this.skew = 0;
			}
		};
	
		Now.prototype.tick = function(e) {
			var now, pace, parent, ref, ref1, seek, speed;
			ref = this.props, now = ref.now, seek = ref.seek, pace = ref.pace, speed = ref.speed;
			parent = this.clockParent.getTime();
			this.skew += parent.step * pace / speed;
			if (seek != null) {
				this.skew = seek;
			}
			this.time.now = this.time.time = this.time.clock = ((ref1 = this.props.now) != null ? ref1 : this.now) + this.skew;
			this.time.delta = this.time.step = parent.delta;
			return this.trigger(e);
		};
	
		Now.prototype.getTime = function() {
			return this.time;
		};
	
		return Now;
	
	})(Parent);
	
	module.exports = Now;
	
	
	/***/ }),
	/* 169 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Move, Transition,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transition = __webpack_require__(51);
	
	Move = (function(superClass) {
		extend(Move, superClass);
	
		function Move() {
			return Move.__super__.constructor.apply(this, arguments);
		}
	
		Move.traits = ['node', 'transition', 'vertex', 'move', 'visible', 'active'];
	
		Move.prototype.make = function() {
			var k, ref, v;
			Move.__super__.make.apply(this, arguments);
			ref = {
				moveFrom: this.node.attributes['move.from'],
				moveTo: this.node.attributes['move.to']
			};
			for (k in ref) {
				v = ref[k];
				this.uniforms[k] = v;
			}
		};
	
		Move.prototype.vertex = function(shader, pass) {
			var ref, ref1;
			if (pass === this.props.pass) {
				shader.pipe('move.position', this.uniforms);
			}
			return (ref = (ref1 = this._inherit('vertex')) != null ? ref1.vertex(shader, pass) : void 0) != null ? ref : shader;
		};
	
		return Move;
	
	})(Transition);
	
	module.exports = Move;
	
	
	/***/ }),
	/* 170 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Play, Track,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Track = __webpack_require__(52);
	
	Play = (function(superClass) {
		extend(Play, superClass);
	
		function Play() {
			return Play.__super__.constructor.apply(this, arguments);
		}
	
		Play.traits = ['node', 'track', 'trigger', 'play', 'bind'];
	
		Play.prototype.init = function() {
			Play.__super__.init.apply(this, arguments);
			this.skew = null;
			this.start = null;
			return this.done = false;
		};
	
		Play.prototype.reset = function(go) {
			if (go == null) {
				go = true;
			}
			this.skew = go ? 0 : null;
			this.start = null;
			return this.done = false;
		};
	
		Play.prototype.make = function() {
			var parentClock;
			Play.__super__.make.apply(this, arguments);
			this._listen('slide', 'slide.step', (function(_this) {
				return function(e) {
					var trigger;
					trigger = _this.props.trigger;
					if ((trigger != null) && e.index === trigger) {
						return _this.reset();
					}
					if ((trigger != null) && e.index === 0) {
						return _this.reset(false);
					}
				};
			})(this));
			if (!this.props.trigger || (this._inherit('slide') == null)) {
				this.reset();
			}
			this._listen('root', 'root.post', this.post);
			parentClock = this._inherit('clock');
			return this._listen(parentClock, 'clock.tick', (function(_this) {
				return function() {
					var delay, delta, from, now, offset, pace, ratio, realtime, ref, speed, time, to;
					ref = _this.props, from = ref.from, to = ref.to, speed = ref.speed, pace = ref.pace, delay = ref.delay, realtime = ref.realtime;
					time = parentClock.getTime();
					if (_this.skew != null) {
						now = realtime ? time.time : time.clock;
						delta = realtime ? time.delta : time.step;
						ratio = speed / pace;
						if (_this.start == null) {
							_this.start = now;
						}
						_this.skew += delta * (ratio - 1);
						offset = Math.max(0, now - _this.start + _this.skew - delay * ratio);
						if (_this.props.loop) {
							offset = offset % (to - from);
						}
						_this.playhead = Math.min(to, from + offset);
					} else {
						_this.playhead = 0;
					}
					return _this.update();
				};
			})(this));
		};
	
		Play.prototype.update = function() {
			return Play.__super__.update.apply(this, arguments);
		};
	
		Play.prototype.post = function() {
			if ((this.skew != null) && this.playhead === this.props.to && !this.props.loop && !this.done) {
				return this.node.trigger({
					type: "play.done"
				});
			}
		};
	
		Play.prototype.change = function(changed, touched, init) {
			if (changed['trigger.trigger'] || changed['play.realtime']) {
				return this.rebuild();
			}
			return Play.__super__.change.call(this, changed, touched, init);
		};
	
		return Play;
	
	})(Track);
	
	module.exports = Play;
	
	
	/***/ }),
	/* 171 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Present, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Util = __webpack_require__(0);
	
	Present = (function(superClass) {
		extend(Present, superClass);
	
		function Present() {
			return Present.__super__.constructor.apply(this, arguments);
		}
	
		Present.traits = ['node', 'present'];
	
		Present.prototype.init = function() {};
	
		Present.prototype.make = function() {
			this.nodes = [];
			this.steps = [];
			this.length = 0;
			this.last = [];
			this.index = 0;
			this.dirty = [];
			this._listen('root', 'root.update', this.update);
			return this._compute('present.length', (function(_this) {
				return function() {
					return _this.length;
				};
			})(this));
		};
	
		Present.prototype.adopt = function(controller) {
			var node;
			node = controller.node;
			if (this.nodes.indexOf(controller) < 0) {
				this.nodes.push(node);
			}
			return this.dirty.push(controller);
		};
	
		Present.prototype.unadopt = function(controller) {
			var node;
			node = controller.node;
			this.nodes = this.nodes.filter(function(x) {
				return x !== controller;
			});
			return this.dirty.push(controller);
		};
	
		Present.prototype.update = function() {
			var controller, j, len, ref1, ref2;
			if (!this.dirty.length) {
				return;
			}
			ref1 = this.dirty;
			for (j = 0, len = ref1.length; j < len; j++) {
				controller = ref1[j];
				this.slideReset(controller);
			}
			ref2 = this.process(this.nodes), this.steps = ref2[0], this.indices = ref2[1];
			this.length = this.steps.length;
			this.index = null;
			this.go(this.props.index);
			return this.dirty = [];
		};
	
		Present.prototype.slideLatch = function(controller, enabled, step) {
			return controller.slideLatch(enabled, step);
		};
	
		Present.prototype.slideStep = function(controller, index, step) {
			return controller.slideStep(this.mapIndex(controller, index), step);
		};
	
		Present.prototype.slideRelease = function(controller, step) {
			return controller.slideRelease();
		};
	
		Present.prototype.slideReset = function(controller) {
			return controller.slideReset();
		};
	
		Present.prototype.mapIndex = function(controller, index) {
			return index - this.indices[controller.node._id];
		};
	
		Present.prototype.process = function(nodes) {
			var dedupe, expand, finalize, isSibling, isSlide, order, parents, paths, slides, split, steps, traverse;
			slides = function(nodes) {
				var el, j, len, results;
				results = [];
				for (j = 0, len = nodes.length; j < len; j++) {
					el = nodes[j];
					results.push(parents(el).filter(isSlide));
				}
				return results;
			};
			traverse = function(map) {
				return function(el) {
					var ref, ref1, results;
					results = [];
					while (el && (ref1 = [map(el), el], el = ref1[0], ref = ref1[1], ref1)) {
						results.push(ref);
					}
					return results;
				};
			};
			parents = traverse(function(el) {
				if (el.parent.traits.hash.present) {
					return null;
				} else {
					return el.parent;
				}
			});
			isSlide = function(el) {
				return nodes.indexOf(el) >= 0;
			};
			isSibling = function(a, b) {
				var c, d, e, i, j, ref1;
				c = a.length;
				d = b.length;
				e = c - d;
				if (e !== 0) {
					return false;
				}
				e = Math.min(c, d);
				for (i = j = ref1 = e - 1; ref1 <= 0 ? j < 0 : j > 0; i = ref1 <= 0 ? ++j : --j) {
					if (a[i] !== b[i]) {
						return false;
					}
				}
				return true;
			};
			order = function(paths) {
				return paths.sort(function(a, b) {
					var c, d, e, f, g, i, j, nodeA, nodeB, ref1;
					c = a.length;
					d = b.length;
					e = Math.min(c, d);
					for (i = j = 1, ref1 = e; 1 <= ref1 ? j <= ref1 : j >= ref1; i = 1 <= ref1 ? ++j : --j) {
						nodeA = a[c - i];
						nodeB = b[d - i];
						f = nodeA.props.order;
						g = nodeB.props.order;
						if ((f != null) || (g != null)) {
							if ((f != null) && (g != null) && ((e = f - g) !== 0)) {
								return e;
							}
							if (f != null) {
								return -1;
							}
							if (g != null) {
								return 1;
							}
						}
						if (nodeB.order !== nodeA.order) {
							return nodeB.order - nodeA.order;
						}
					}
					e = c - d;
					if (e !== 0) {
						return e;
					}
					return 0;
				});
			};
			split = function(steps) {
				var absolute, j, len, node, relative, step;
				relative = [];
				absolute = [];
				for (j = 0, len = steps.length; j < len; j++) {
					step = steps[j];
					((node = step[0]).props.steps != null ? relative : absolute).push(step);
				}
				return [relative, absolute];
			};
			expand = function(lists) {
				var absolute, i, indices, j, k, len, len1, limit, relative, slide, step, steps;
				relative = lists[0], absolute = lists[1];
				limit = 100;
				indices = {};
				steps = [];
				slide = function(step, index) {
					var childIndex, from, i, j, name, node, parent, parentIndex, props, ref1, ref2, to;
					props = (node = step[0]).props;
					parent = step[1];
					parentIndex = parent != null ? indices[parent._id] : 0;
					childIndex = index;
					from = props.from != null ? parentIndex + props.from : childIndex - props.early;
					to = props.to != null ? parentIndex + props.to : childIndex + props.steps + props.late;
					from = Math.max(0, from);
					to = Math.min(limit, to);
					if (indices[name = node._id] == null) {
						indices[name] = from;
					}
					for (i = j = ref1 = from, ref2 = to; ref1 <= ref2 ? j < ref2 : j > ref2; i = ref1 <= ref2 ? ++j : --j) {
						steps[i] = (steps[i] != null ? steps[i] : steps[i] = []).concat(step);
					}
					return props.steps;
				};
				i = 0;
				for (j = 0, len = relative.length; j < len; j++) {
					step = relative[j];
					i += slide(step, i);
				}
				for (k = 0, len1 = absolute.length; k < len1; k++) {
					step = absolute[k];
					slide(step, 0);
				}
				steps = (function() {
					var l, len2, results;
					results = [];
					for (l = 0, len2 = steps.length; l < len2; l++) {
						step = steps[l];
						results.push(finalize(dedupe(step)));
					}
					return results;
				})();
				return [steps, indices];
			};
			dedupe = function(step) {
				var i, j, len, node, results;
				if (step) {
					results = [];
					for (i = j = 0, len = step.length; j < len; i = ++j) {
						node = step[i];
						if (step.indexOf(node) === i) {
							results.push(node);
						}
					}
					return results;
				} else {
					return [];
				}
			};
			finalize = function(step) {
				return step.sort(function(a, b) {
					return a.order - b.order;
				});
			};
			paths = slides(nodes);
			steps = order(paths);
			return expand(split(steps));
		};
	
		Present.prototype.go = function(index) {
			var active, ascend, descend, enter, exit, j, k, l, last, len, len1, len2, len3, len4, len5, len6, len7, len8, m, n, node, o, p, q, r, ref1, ref2, ref3, ref4, ref5, ref6, ref7, stay, step, toStr;
			index = Math.max(0, Math.min(this.length + 1, +index || 0));
			last = this.last;
			active = (ref1 = this.steps[index - 1]) != null ? ref1 : [];
			step = this.props.directed ? index - this.index : 1;
			this.index = index;
			enter = (function() {
				var j, len, results;
				results = [];
				for (j = 0, len = active.length; j < len; j++) {
					node = active[j];
					if (this.last.indexOf(node) < 0) {
						results.push(node);
					}
				}
				return results;
			}).call(this);
			exit = (function() {
				var j, len, ref2, results;
				ref2 = this.last;
				results = [];
				for (j = 0, len = ref2.length; j < len; j++) {
					node = ref2[j];
					if (active.indexOf(node) < 0) {
						results.push(node);
					}
				}
				return results;
			}).call(this);
			stay = (function() {
				var j, len, results;
				results = [];
				for (j = 0, len = active.length; j < len; j++) {
					node = active[j];
					if (enter.indexOf(node) < 0 && exit.indexOf(node) < 0) {
						results.push(node);
					}
				}
				return results;
			})();
			ascend = function(nodes) {
				return nodes.sort(function(a, b) {
					return a.order - b.order;
				});
			};
			descend = function(nodes) {
				return nodes.sort(function(a, b) {
					return b.order - a.order;
				});
			};
			toStr = function(x) {
				return x.toString();
			};
			ref2 = ascend(enter);
			for (j = 0, len = ref2.length; j < len; j++) {
				node = ref2[j];
				this.slideLatch(node.controller, true, step);
			}
			ref3 = ascend(stay);
			for (k = 0, len1 = ref3.length; k < len1; k++) {
				node = ref3[k];
				this.slideLatch(node.controller, null, step);
			}
			ref4 = ascend(exit);
			for (l = 0, len2 = ref4.length; l < len2; l++) {
				node = ref4[l];
				this.slideLatch(node.controller, false, step);
			}
			for (m = 0, len3 = enter.length; m < len3; m++) {
				node = enter[m];
				this.slideStep(node.controller, index, step);
			}
			for (n = 0, len4 = stay.length; n < len4; n++) {
				node = stay[n];
				this.slideStep(node.controller, index, step);
			}
			for (o = 0, len5 = exit.length; o < len5; o++) {
				node = exit[o];
				this.slideStep(node.controller, index, step);
			}
			ref5 = descend(enter);
			for (p = 0, len6 = ref5.length; p < len6; p++) {
				node = ref5[p];
				this.slideRelease(node.controller);
			}
			ref6 = descend(stay);
			for (q = 0, len7 = ref6.length; q < len7; q++) {
				node = ref6[q];
				this.slideRelease(node.controller);
			}
			ref7 = descend(exit);
			for (r = 0, len8 = ref7.length; r < len8; r++) {
				node = ref7[r];
				this.slideRelease(node.controller);
			}
			this.last = active;
		};
	
		Present.prototype.change = function(changed, touched, init) {
			if (changed['present.index'] || init) {
				return this.go(this.props.index);
			}
		};
	
		return Present;
	
	})(Parent);
	
	module.exports = Present;
	
	
	/***/ }),
	/* 172 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Reveal, Transition, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Transition = __webpack_require__(51);
	
	Util = __webpack_require__(0);
	
	Reveal = (function(superClass) {
		extend(Reveal, superClass);
	
		function Reveal() {
			return Reveal.__super__.constructor.apply(this, arguments);
		}
	
		Reveal.traits = ['node', 'transition', 'mask', 'visible', 'active'];
	
		Reveal.prototype.mask = function(shader) {
			var ref, ref1, s;
			if (shader) {
				s = this._shaders.shader();
				s.pipe(Util.GLSL.identity('vec4'));
				s.fan();
				s.pipe(shader, this.uniforms);
				s.next();
				s.pipe('reveal.mask', this.uniforms);
				s.end();
				s.pipe("float combine(float a, float b) { return min(a, b); }");
			} else {
				s = this._shaders.shader();
				s.pipe('reveal.mask', this.uniforms);
			}
			return (ref = (ref1 = this._inherit('mask')) != null ? ref1.mask(s) : void 0) != null ? ref : s;
		};
	
		return Reveal;
	
	})(Transition);
	
	module.exports = Reveal;
	
	
	/***/ }),
	/* 173 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Parent, Slide,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Parent = __webpack_require__(4);
	
	Slide = (function(superClass) {
		extend(Slide, superClass);
	
		function Slide() {
			return Slide.__super__.constructor.apply(this, arguments);
		}
	
		Slide.traits = ['node', 'slide', 'visible', 'active'];
	
		Slide.prototype.make = function() {
			this._helpers.visible.make();
			this._helpers.active.make();
			if (!this._inherit('present')) {
				throw new Error((this.node.toString()) + " must be placed inside <present></present>");
			}
			return this._inherit('present').adopt(this);
		};
	
		Slide.prototype.unmake = function() {
			this._helpers.visible.unmake();
			this._helpers.active.unmake();
			return this._inherit('present')(unadopt(this));
		};
	
		Slide.prototype.change = function(changed, touched, init) {
			if (changed['slide.early'] || changed['slide.late'] || changed['slide.steps'] || changed['slide.from'] || changed['slide.to']) {
				return this.rebuild();
			}
		};
	
		Slide.prototype.slideLatch = function(enabled, step) {
			this.trigger({
				'type': 'transition.latch',
				'step': step
			});
			if (enabled != null) {
				return this._instant(enabled);
			}
		};
	
		Slide.prototype.slideStep = function(index, step) {
			return this.trigger({
				'type': 'slide.step',
				'index': index,
				'step': step
			});
		};
	
		Slide.prototype.slideRelease = function() {
			return this.trigger({
				'type': 'transition.release'
			});
		};
	
		Slide.prototype.slideReset = function() {
			this._instant(false);
			return this.trigger({
				'type': 'slide.reset'
			});
		};
	
		Slide.prototype._instant = function(enabled) {
			this.setVisible(enabled);
			return this.setActive(enabled);
		};
	
		return Slide;
	
	})(Parent);
	
	module.exports = Slide;
	
	
	/***/ }),
	/* 174 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Step, Track,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Track = __webpack_require__(52);
	
	Step = (function(superClass) {
		extend(Step, superClass);
	
		function Step() {
			return Step.__super__.constructor.apply(this, arguments);
		}
	
		Step.traits = ['node', 'track', 'step', 'trigger', 'bind'];
	
		Step.prototype.make = function() {
			var clock, j, ref, ref1, results;
			Step.__super__.make.apply(this, arguments);
			clock = this._inherit('clock');
			if (this.actualIndex == null) {
				this.actualIndex = null;
			}
			this.animateIndex = this._animator.make(this._types.number(0), {
				clock: clock,
				realtime: this.props.realtime,
				step: (function(_this) {
					return function(value) {
						return _this.actualIndex = value;
					};
				})(this)
			});
			if (this.lastIndex == null) {
				this.lastIndex = null;
			}
			this.animateStep = this._animator.make(this._types.number(0), {
				clock: clock,
				realtime: this.props.realtime,
				step: (function(_this) {
					return function(value) {
						_this.playhead = value;
						return _this.update();
					};
				})(this)
			});
			this.stops = (ref = this.props.stops) != null ? ref : (function() {
				results = [];
				for (var j = 0, ref1 = this.script.length; 0 <= ref1 ? j < ref1 : j > ref1; 0 <= ref1 ? j++ : j--){ results.push(j); }
				return results;
			}).apply(this);
			this._listen('slide', 'slide.reset', (function(_this) {
				return function(e) {
					return _this.lastIndex = null;
				};
			})(this));
			return this._listen('slide', 'slide.step', (function(_this) {
				return function(e) {
					var delay, duration, factor, free, from, i, k, last, len, pace, playback, ref2, ref3, ref4, rewind, skip, skips, speed, step, stop, to, trigger;
					ref2 = _this.props, delay = ref2.delay, duration = ref2.duration, pace = ref2.pace, speed = ref2.speed, playback = ref2.playback, rewind = ref2.rewind, skip = ref2.skip, trigger = ref2.trigger;
					i = Math.max(0, Math.min(_this.stops.length - 1, e.index - trigger));
					from = _this.playhead;
					to = _this.stops[i];
					if ((_this.lastIndex == null) && trigger) {
						_this.lastIndex = i;
						_this.animateStep.set(to);
						_this.animateIndex.set(i);
						return;
					}
					last = (ref3 = (ref4 = _this.actualIndex) != null ? ref4 : _this.lastIndex) != null ? ref3 : 0;
					step = i - last;
					skips = _this.stops.slice(Math.min(last, i), Math.max(last, i));
					free = 0;
					last = skips.shift();
					for (k = 0, len = skips.length; k < len; k++) {
						stop = skips[k];
						if (last === stop) {
							free++;
						}
						last = stop;
					}
					_this.lastIndex = i;
					factor = speed * (e.step >= 0 ? 1 : rewind);
					factor *= skip ? Math.max(1, Math.abs(step) - free) : 1;
					duration += Math.abs(to - from) * pace / factor;
					if (from !== to) {
						_this.animateIndex.immediate(i, {
							delay: delay,
							duration: duration,
							ease: playback
						});
						return _this.animateStep.immediate(to, {
							delay: delay,
							duration: duration,
							ease: playback
						});
					}
				};
			})(this));
		};
	
		Step.prototype.made = function() {
			return this.update();
		};
	
		Step.prototype.unmake = function() {
			this.animateIndex.dispose();
			this.animateStep.dispose();
			this.animateIndex = this.animateStep = null;
			return Step.__super__.unmake.apply(this, arguments);
		};
	
		Step.prototype.change = function(changed, touched, init) {
			if (changed['step.stops'] || changed['step.realtime']) {
				return this.rebuild();
			}
			return Step.__super__.change.call(this, changed, touched, init);
		};
	
		return Step;
	
	})(Track);
	
	module.exports = Step;
	
	
	/***/ }),
	/* 175 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Traits, Types;
	
	Types = __webpack_require__(53);
	
	Traits = {
		node: {
			id: Types.nullable(Types.string()),
			classes: Types.classes()
		},
		entity: {
			active: Types.bool(true)
		},
		object: {
			visible: Types.bool(true)
		},
		latch: {
			data: Types.nullable(Types.object()),
			deep: Types.nullable(Types.bool(true))
		},
		unit: {
			scale: Types.nullable(Types.number()),
			fov: Types.nullable(Types.number()),
			focus: Types.nullable(Types.number(1), true)
		},
		span: {
			range: Types.nullable(Types.vec2(-1, 1))
		},
		view: {
			range: Types.array(Types.vec2(-1, 1), 4)
		},
		view3: {
			position: Types.vec3(),
			quaternion: Types.quat(),
			rotation: Types.vec3(),
			scale: Types.vec3(1, 1, 1),
			eulerOrder: Types.swizzle('xyz')
		},
		view4: {
			position: Types.vec4(),
			scale: Types.vec4(1, 1, 1, 1)
		},
		layer: {
			depth: Types.number(1),
			fit: Types.fit('y')
		},
		vertex: {
			pass: Types.vertexPass()
		},
		fragment: {
			pass: Types.fragmentPass(),
			gamma: Types.bool(false)
		},
		transform3: {
			position: Types.vec3(),
			quaternion: Types.quat(),
			rotation: Types.vec3(),
			eulerOrder: Types.swizzle('xyz'),
			scale: Types.vec3(1, 1, 1),
			matrix: Types.mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
		},
		transform4: {
			position: Types.vec4(),
			scale: Types.vec4(1, 1, 1, 1),
			matrix: Types.mat4(1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 0, 0, 1)
		},
		camera: {
			proxy: Types.bool(false),
			position: Types.nullable(Types.vec3()),
			quaternion: Types.nullable(Types.quat()),
			rotation: Types.nullable(Types.vec3()),
			lookAt: Types.nullable(Types.vec3()),
			up: Types.nullable(Types.vec3()),
			eulerOrder: Types.swizzle('xyz'),
			fov: Types.nullable(Types.number(1))
		},
		polar: {
			bend: Types.number(1),
			helix: Types.number(0)
		},
		spherical: {
			bend: Types.number(1)
		},
		stereographic: {
			bend: Types.number(1)
		},
		interval: {
			axis: Types.axis()
		},
		area: {
			axes: Types.swizzle([1, 2], 2)
		},
		volume: {
			axes: Types.swizzle([1, 2, 3], 3)
		},
		origin: {
			origin: Types.vec4()
		},
		scale: {
			divide: Types.number(10),
			unit: Types.number(1),
			base: Types.number(10),
			mode: Types.scale(),
			start: Types.bool(true),
			end: Types.bool(true),
			zero: Types.bool(true),
			factor: Types.positive(Types.number(1)),
			nice: Types.bool(true)
		},
		grid: {
			lineX: Types.bool(true),
			lineY: Types.bool(true),
			crossed: Types.bool(false),
			closedX: Types.bool(false),
			closedY: Types.bool(false)
		},
		axis: {
			detail: Types.int(1),
			crossed: Types.bool(false)
		},
		rawtex: {
			width: Types.nullable(Types.positive(Types.int(1), true)),
			height: Types.nullable(Types.positive(Types.int(1), true)),
			image: Types.nullable(Types.object()),
			texture: Types.nullable(Types.object())
		},
		data: {
			data: Types.nullable(Types.data()),
			expr: Types.nullable(Types.emitter()),
			bind: Types.nullable(Types.func()),
			live: Types.bool(true)
		},
		buffer: {
			channels: Types["enum"](4, [1, 2, 3, 4]),
			items: Types.int(1),
			fps: Types.nullable(Types.int(60)),
			hurry: Types.int(5),
			limit: Types.int(60),
			realtime: Types.bool(false),
			observe: Types.bool(false),
			aligned: Types.bool(false)
		},
		sampler: {
			centered: Types.bool(false),
			padding: Types.number(0)
		},
		array: {
			width: Types.nullable(Types.positive(Types.int(1), true)),
			bufferWidth: Types.int(1),
			history: Types.int(1)
		},
		matrix: {
			width: Types.nullable(Types.positive(Types.int(1), true)),
			height: Types.nullable(Types.positive(Types.int(1), true)),
			history: Types.int(1),
			bufferWidth: Types.int(1),
			bufferHeight: Types.int(1)
		},
		voxel: {
			width: Types.nullable(Types.positive(Types.int(1), true)),
			height: Types.nullable(Types.positive(Types.int(1), true)),
			depth: Types.nullable(Types.positive(Types.int(1), true)),
			bufferWidth: Types.int(1),
			bufferHeight: Types.int(1),
			bufferDepth: Types.int(1)
		},
		resolve: {
			expr: Types.nullable(Types.func()),
			items: Types.int(1)
		},
		style: {
			opacity: Types.positive(Types.number(1)),
			color: Types.color(),
			blending: Types.blending(),
			zWrite: Types.bool(true),
			zTest: Types.bool(true),
			zIndex: Types.positive(Types.round()),
			zBias: Types.number(0),
			zOrder: Types.nullable(Types.int())
		},
		geometry: {
			points: Types.select(),
			colors: Types.nullable(Types.select())
		},
		point: {
			size: Types.positive(Types.number(4)),
			sizes: Types.nullable(Types.select()),
			shape: Types.shape(),
			optical: Types.bool(true),
			fill: Types.bool(true),
			depth: Types.number(1)
		},
		line: {
			width: Types.positive(Types.number(2)),
			depth: Types.positive(Types.number(1)),
			join: Types.join(),
			stroke: Types.stroke(),
			proximity: Types.nullable(Types.number(2e308)),
			closed: Types.bool(false)
		},
		mesh: {
			fill: Types.bool(true),
			shaded: Types.bool(false),
			normals: Types.nullable(Types.select()),
			map: Types.nullable(Types.select()),
			lineBias: Types.number(5)
		},
		strip: {
			line: Types.bool(false)
		},
		face: {
			line: Types.bool(false)
		},
		arrow: {
			size: Types.number(3),
			start: Types.bool(false),
			end: Types.bool(false)
		},
		ticks: {
			normal: Types.vec3(0, 0, 1),
			size: Types.positive(Types.number(10)),
			epsilon: Types.positive(Types.number(0.001))
		},
		attach: {
			offset: Types.vec2(0, -20),
			snap: Types.bool(false),
			depth: Types.number(0)
		},
		format: {
			digits: Types.nullable(Types.positive(Types.number(3))),
			data: Types.nullable(Types.data()),
			expr: Types.nullable(Types.func()),
			live: Types.bool(true)
		},
		font: {
			font: Types.font('sans-serif'),
			style: Types.string(),
			variant: Types.string(),
			weight: Types.string(),
			detail: Types.number(24),
			sdf: Types.number(5)
		},
		label: {
			text: Types.select(),
			size: Types.number(16),
			outline: Types.number(2),
			expand: Types.number(0),
			background: Types.color(1, 1, 1)
		},
		overlay: {
			opacity: Types.number(1),
			zIndex: Types.positive(Types.round(0))
		},
		dom: {
			points: Types.select(),
			html: Types.select(),
			size: Types.number(16),
			outline: Types.number(2),
			zoom: Types.number(1),
			color: Types.nullable(Types.color()),
			attributes: Types.nullable(Types.object()),
			pointerEvents: Types.bool(false)
		},
		texture: {
			minFilter: Types.filter('nearest'),
			magFilter: Types.filter('nearest'),
			type: Types.type('float')
		},
		shader: {
			sources: Types.nullable(Types.select()),
			indices: Types.number(4),
			channels: Types.number(4),
			language: Types.string('glsl'),
			code: Types.string(),
			uniforms: Types.nullable(Types.object())
		},
		include: {
			shader: Types.select()
		},
		operator: {
			source: Types.select()
		},
		spread: {
			unit: Types.mapping(),
			items: Types.nullable(Types.vec4()),
			width: Types.nullable(Types.vec4()),
			height: Types.nullable(Types.vec4()),
			depth: Types.nullable(Types.vec4()),
			alignItems: Types.anchor(),
			alignWidth: Types.anchor(),
			alignHeight: Types.anchor(),
			alignDepth: Types.anchor()
		},
		grow: {
			scale: Types.number(1),
			items: Types.nullable(Types.anchor()),
			width: Types.nullable(Types.anchor()),
			height: Types.nullable(Types.anchor()),
			depth: Types.nullable(Types.anchor())
		},
		split: {
			order: Types.transpose('wxyz'),
			axis: Types.nullable(Types.axis()),
			length: Types.int(1),
			overlap: Types.int(0)
		},
		join: {
			order: Types.transpose('wxyz'),
			axis: Types.nullable(Types.axis()),
			overlap: Types.int(0)
		},
		swizzle: {
			order: Types.swizzle()
		},
		transpose: {
			order: Types.transpose()
		},
		repeat: {
			items: Types.number(1),
			width: Types.number(1),
			height: Types.number(1),
			depth: Types.number(1)
		},
		slice: {
			items: Types.nullable(Types.vec2()),
			width: Types.nullable(Types.vec2()),
			height: Types.nullable(Types.vec2()),
			depth: Types.nullable(Types.vec2())
		},
		reverse: {
			items: Types.bool(false),
			width: Types.bool(false),
			height: Types.bool(false),
			depth: Types.bool(false)
		},
		lerp: {
			size: Types.mapping('absolute'),
			items: Types.nullable(Types.number()),
			width: Types.nullable(Types.number()),
			height: Types.nullable(Types.number()),
			depth: Types.nullable(Types.number())
		},
		subdivide: {
			items: Types.nullable(Types.positive(Types.int(), true)),
			width: Types.nullable(Types.positive(Types.int(), true)),
			height: Types.nullable(Types.positive(Types.int(), true)),
			depth: Types.nullable(Types.positive(Types.int(), true)),
			bevel: Types.number(1),
			lerp: Types.bool(true)
		},
		resample: {
			indices: Types.number(4),
			channels: Types.number(4),
			sample: Types.mapping(),
			size: Types.mapping('absolute'),
			items: Types.nullable(Types.number()),
			width: Types.nullable(Types.number()),
			height: Types.nullable(Types.number()),
			depth: Types.nullable(Types.number())
		},
		readback: {
			type: Types.type('float'),
			expr: Types.nullable(Types.func()),
			data: Types.data(),
			channels: Types["enum"](4, [1, 2, 3, 4]),
			items: Types.nullable(Types.int()),
			width: Types.nullable(Types.int()),
			height: Types.nullable(Types.int()),
			depth: Types.nullable(Types.int())
		},
		root: {
			speed: Types.number(1),
			camera: Types.select('[camera]')
		},
		inherit: {
			source: Types.select(),
			traits: Types.array(Types.string())
		},
		rtt: {
			size: Types.mapping('absolute'),
			width: Types.nullable(Types.number()),
			height: Types.nullable(Types.number()),
			history: Types.int(1)
		},
		compose: {
			alpha: Types.bool(false)
		},
		present: {
			index: Types.int(1),
			directed: Types.bool(true),
			length: Types.number(0)
		},
		slide: {
			order: Types.nullable(Types.int(0)),
			steps: Types.number(1),
			early: Types.int(0),
			late: Types.int(0),
			from: Types.nullable(Types.int(0)),
			to: Types.nullable(Types.int(1))
		},
		transition: {
			stagger: Types.vec4(),
			enter: Types.nullable(Types.number(1)),
			exit: Types.nullable(Types.number(1)),
			delay: Types.number(0),
			delayEnter: Types.nullable(Types.number(0)),
			delayExit: Types.nullable(Types.number(0)),
			duration: Types.number(.3),
			durationEnter: Types.nullable(Types.number(0)),
			durationExit: Types.nullable(Types.number(0))
		},
		move: {
			from: Types.vec4(),
			to: Types.vec4()
		},
		seek: {
			seek: Types.nullable(Types.number(0))
		},
		track: {
			target: Types.select(),
			script: Types.object({}),
			ease: Types.ease('cosine')
		},
		trigger: {
			trigger: Types.nullable(Types.int(1), true)
		},
		step: {
			playback: Types.ease('linear'),
			stops: Types.nullable(Types.array(Types.number())),
			delay: Types.number(0),
			duration: Types.number(.3),
			pace: Types.number(0),
			speed: Types.number(1),
			rewind: Types.number(2),
			skip: Types.bool(true),
			realtime: Types.bool(false)
		},
		play: {
			delay: Types.number(0),
			pace: Types.number(1),
			speed: Types.number(1),
			from: Types.number(0),
			to: Types.number(2e308),
			realtime: Types.bool(false),
			loop: Types.bool(false)
		},
		now: {
			now: Types.nullable(Types.timestamp()),
			seek: Types.nullable(Types.number(0)),
			pace: Types.number(1),
			speed: Types.number(1)
		}
	};
	
	module.exports = Traits;
	
	
	/***/ }),
	/* 176 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var THREE, Util, View, helpers,
		indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; };
	
	THREE = __webpack_require__(1);
	
	Util = __webpack_require__(0);
	
	View = __webpack_require__(7);
	
	
	/*
	
	This is the general dumping ground for trait behavior.
	
	Helpers are auto-attached to primitives that have the matching trait
	 */
	
	helpers = {
		bind: {
			make: function(slots) {
				var callback, done, i, isUnique, j, len, len1, multiple, name, optional, s, selector, slot, source, start, to, trait, unique;
				if (this.bind == null) {
					this.bind = {};
				}
				if (this.bound == null) {
					this.bound = [];
				}
				for (i = 0, len = slots.length; i < len; i++) {
					slot = slots[i];
					to = slot.to, trait = slot.trait, optional = slot.optional, unique = slot.unique, multiple = slot.multiple, callback = slot.callback;
					if (callback == null) {
						callback = this.rebuild;
					}
					name = to.split(/\./g).pop();
					selector = this._get(to);
					source = null;
					if (selector != null) {
						start = this;
						done = false;
						while (!done) {
							start = source = this._attach(selector, trait, callback, this, start, optional, multiple);
							isUnique = unique && ((source == null) || this.bound.indexOf(source) < 0);
							done = multiple || optional || !unique || isUnique;
						}
					}
					if (source != null) {
						if (this.resize != null) {
							this._listen(source, 'source.resize', this.resize);
						}
						if (callback) {
							this._listen(source, 'source.rebuild', callback);
						}
						if (multiple) {
							for (j = 0, len1 = source.length; j < len1; j++) {
								s = source[j];
								this.bound.push(s);
							}
						} else {
							this.bound.push(source);
						}
					}
					this.bind[name] = source;
				}
				return null;
			},
			unmake: function() {
				if (!this.bind) {
					return;
				}
				delete this.bind;
				return delete this.bound;
			}
		},
		span: {
			make: function() {
				this.spanView = this._inherit('view');
				return this._listen('view', 'view.range', (function(_this) {
					return function() {
						return _this.trigger({
							type: 'span.range'
						});
					};
				})(this));
			},
			unmake: function() {
				return delete this.spanView;
			},
			get: (function() {
				var def;
				def = new THREE.Vector2(-1, 1);
				return function(prefix, dimension) {
					var range, ref, ref1;
					range = this._get(prefix + 'span.range');
					if (range != null) {
						return range;
					}
					return (ref = (ref1 = this.spanView) != null ? ref1.axis(dimension) : void 0) != null ? ref : def;
				};
			})()
		},
		scale: {
			divide: function(prefix) {
				var divide, factor;
				divide = this._get(prefix + 'scale.divide');
				factor = this._get(prefix + 'scale.factor');
				return Math.round(divide * 2.5 / factor);
			},
			generate: function(prefix, buffer, min, max) {
				var base, divide, end, factor, mode, nice, start, ticks, unit, zero;
				mode = this._get(prefix + 'scale.mode');
				divide = this._get(prefix + 'scale.divide');
				unit = this._get(prefix + 'scale.unit');
				base = this._get(prefix + 'scale.base');
				factor = this._get(prefix + 'scale.factor');
				start = this._get(prefix + 'scale.start');
				end = this._get(prefix + 'scale.end');
				zero = this._get(prefix + 'scale.zero');
				nice = this._get(prefix + 'scale.nice');
				ticks = Util.Ticks.make(mode, min, max, divide, unit, base, factor, start, end, zero, nice);
				buffer.copy(ticks);
				return ticks;
			}
		},
		style: {
			uniforms: function() {
				return {
					styleColor: this.node.attributes['style.color'],
					styleOpacity: this.node.attributes['style.opacity'],
					styleZBias: this.node.attributes['style.zBias'],
					styleZIndex: this.node.attributes['style.zIndex']
				};
			}
		},
		arrow: {
			uniforms: function() {
				var end, size, space, start, style;
				start = this.props.start;
				end = this.props.end;
				space = this._attributes.make(this._types.number(1.25 / (start + end)));
				style = this._attributes.make(this._types.vec2(+start, +end));
				size = this.node.attributes['arrow.size'];
				return {
					clipStyle: style,
					clipRange: size,
					clipSpace: space,
					arrowSpace: space,
					arrowSize: size
				};
			}
		},
		point: {
			uniforms: function() {
				return {
					pointSize: this.node.attributes['point.size'],
					pointDepth: this.node.attributes['point.depth']
				};
			}
		},
		line: {
			uniforms: function() {
				return {
					lineWidth: this.node.attributes['line.width'],
					lineDepth: this.node.attributes['line.depth'],
					lineProximity: this.node.attributes['line.proximity']
				};
			}
		},
		surface: {
			uniforms: function() {
				return {};
			}
		},
		shade: {
			pipeline: function(shader) {
				var i, pass, ref;
				if (!this._inherit('fragment')) {
					return shader;
				}
				if (shader == null) {
					shader = this._shaders.shader();
				}
				for (pass = i = 0; i <= 2; pass = ++i) {
					shader = (ref = this._inherit('fragment')) != null ? ref.fragment(shader, pass) : void 0;
				}
				shader.pipe('fragment.map.rgba');
				return shader;
			},
			normal: function(shader) {
				shader.pipe(Util.GLSL.swizzleVec4('xyz'));
				return shader;
			},
			map: function(shader) {
				if (!shader) {
					return shader;
				}
				return shader = this._shaders.shader().pipe('mesh.map.uvwo').pipe(shader);
			}
		},
		position: {
			pipeline: function(shader) {
				var i, pass, ref;
				if (!this._inherit('vertex')) {
					return shader;
				}
				if (shader == null) {
					shader = this._shaders.shader();
				}
				for (pass = i = 0; i <= 3; pass = ++i) {
					shader = (ref = this._inherit('vertex')) != null ? ref.vertex(shader, pass) : void 0;
				}
				return shader;
			},
			swizzle: function(shader, order) {
				if (shader) {
					return this._shaders.shader().pipe(Util.GLSL.swizzleVec4(order)).pipe(shader);
				}
			},
			swizzle2: function(shader, order1, order2) {
				if (shader) {
					return this._shaders.shader().split().pipe(Util.GLSL.swizzleVec4(order1)).next().pipe(Util.GLSL.swizzleVec4(order2)).join().pipe(shader);
				}
			}
		},
		visible: {
			make: function() {
				var e, onVisible, visible, visibleParent;
				e = {
					type: 'visible.change'
				};
				visible = null;
				this.setVisible = function(vis) {
					if (vis != null) {
						visible = vis;
					}
					return onVisible();
				};
				onVisible = (function(_this) {
					return function() {
						var last, ref, self;
						last = _this.isVisible;
						self = (ref = visible != null ? visible : _this._get('object.visible')) != null ? ref : true;
						if (typeof visibleParent !== "undefined" && visibleParent !== null) {
							self && (self = visibleParent.isVisible);
						}
						_this.isVisible = self;
						if (last !== _this.isVisible) {
							return _this.trigger(e);
						}
					};
				})(this);
				visibleParent = this._inherit('visible');
				if (visibleParent) {
					this._listen(visibleParent, 'visible.change', onVisible);
				}
				if (this.is('object')) {
					this._listen(this.node, 'change:object', onVisible);
				}
				return onVisible();
			},
			unmake: function() {
				return delete this.isVisible;
			}
		},
		active: {
			make: function() {
				var active, activeParent, e, onActive;
				e = {
					type: 'active.change'
				};
				active = null;
				this.setActive = function(act) {
					if (act != null) {
						active = act;
					}
					return onActive();
				};
				onActive = (function(_this) {
					return function() {
						var last, ref, self;
						last = _this.isActive;
						self = (ref = active != null ? active : _this._get('entity.active')) != null ? ref : true;
						if (typeof activeParent !== "undefined" && activeParent !== null) {
							self && (self = activeParent.isActive);
						}
						_this.isActive = self;
						if (last !== _this.isActive) {
							return _this.trigger(e);
						}
					};
				})(this);
				activeParent = this._inherit('active');
				if (activeParent) {
					this._listen(activeParent, 'active.change', onActive);
				}
				if (this.is('entity')) {
					this._listen(this.node, 'change:entity', onActive);
				}
				return onActive();
			},
			unmake: function() {
				return delete this.isActive;
			}
		},
		object: {
			make: function(objects) {
				var blending, hasStyle, i, last, len, object, objectScene, onChange, onVisible, opacity, ref, zOrder, zTest, zWrite;
				this.objects = objects != null ? objects : [];
				this.renders = this.objects.reduce((function(a, b) {
					return a.concat(b.renders);
				}), []);
				objectScene = this._inherit('scene');
				opacity = blending = zOrder = null;
				hasStyle = indexOf.call(this.traits, 'style') >= 0;
				opacity = 1;
				blending = THREE.NormalBlending;
				zWrite = true;
				zTest = true;
				if (hasStyle) {
					opacity = this.props.opacity;
					blending = this.props.blending;
					zOrder = this.props.zOrder;
					zWrite = this.props.zWrite;
					zTest = this.props.zTest;
				}
				onChange = (function(_this) {
					return function(event) {
						var changed, refresh;
						changed = event.changed;
						refresh = null;
						if (changed['style.opacity']) {
							refresh = opacity = _this.props.opacity;
						}
						if (changed['style.blending']) {
							refresh = blending = _this.props.blending;
						}
						if (changed['style.zOrder']) {
							refresh = zOrder = _this.props.zOrder;
						}
						if (changed['style.zWrite']) {
							refresh = zWrite = _this.props.zWrite;
						}
						if (changed['style.zTest']) {
							refresh = zTest = _this.props.zTest;
						}
						if (refresh != null) {
							return onVisible();
						}
					};
				})(this);
				last = null;
				onVisible = (function(_this) {
					return function() {
						var i, j, l, len, len1, len2, o, order, ref, ref1, ref2, ref3, results, results1, results2, visible;
						order = zOrder != null ? -zOrder : _this.node.order;
						visible = ((ref = _this.isVisible) != null ? ref : true) && opacity > 0;
						if (visible) {
							if (hasStyle) {
								ref1 = _this.objects;
								results = [];
								for (i = 0, len = ref1.length; i < len; i++) {
									o = ref1[i];
									o.show(opacity < 1, blending, order);
									results.push(o.depth(zWrite, zTest));
								}
								return results;
							} else {
								ref2 = _this.objects;
								results1 = [];
								for (j = 0, len1 = ref2.length; j < len1; j++) {
									o = ref2[j];
									results1.push(o.show(true, blending, order));
								}
								return results1;
							}
						} else {
							ref3 = _this.objects;
							results2 = [];
							for (l = 0, len2 = ref3.length; l < len2; l++) {
								o = ref3[l];
								results2.push(o.hide());
							}
							return results2;
						}
					};
				})(this);
				this._listen(this.node, 'change:style', onChange);
				this._listen(this.node, 'reindex', onVisible);
				this._listen(this, 'visible.change', onVisible);
				ref = this.objects;
				for (i = 0, len = ref.length; i < len; i++) {
					object = ref[i];
					objectScene.adopt(object);
				}
				return onVisible();
			},
			unmake: function(dispose) {
				var i, j, len, len1, object, objectScene, ref, ref1, results;
				if (dispose == null) {
					dispose = true;
				}
				if (!this.objects) {
					return;
				}
				objectScene = this._inherit('scene');
				ref = this.objects;
				for (i = 0, len = ref.length; i < len; i++) {
					object = ref[i];
					objectScene.unadopt(object);
				}
				if (dispose) {
					ref1 = this.objects;
					results = [];
					for (j = 0, len1 = ref1.length; j < len1; j++) {
						object = ref1[j];
						results.push(object.dispose());
					}
					return results;
				}
			},
			mask: function() {
				var mask, shader;
				if (!(mask = this._inherit('mask'))) {
					return;
				}
				return shader = mask.mask(shader);
			}
		},
		unit: {
			make: function() {
				var bottom, focusDepth, handler, pixelRatio, pixelUnit, renderAspect, renderHeight, renderOdd, renderScale, renderScaleInv, renderWidth, root, top, viewHeight, viewWidth, worldUnit, ;
				 = Math.PI;
				this.unitUniforms = {
					renderScaleInv: renderScaleInv = this._attributes.make(this._types.number(1)),
					renderScale: renderScale = this._attributes.make(this._types.number(1)),
					renderAspect: renderAspect = this._attributes.make(this._types.number(1)),
					renderWidth: renderWidth = this._attributes.make(this._types.number(0)),
					renderHeight: renderHeight = this._attributes.make(this._types.number(0)),
					viewWidth: viewWidth = this._attributes.make(this._types.number(0)),
					viewHeight: viewHeight = this._attributes.make(this._types.number(0)),
					pixelRatio: pixelRatio = this._attributes.make(this._types.number(1)),
					pixelUnit: pixelUnit = this._attributes.make(this._types.number(1)),
					worldUnit: worldUnit = this._attributes.make(this._types.number(1)),
					focusDepth: focusDepth = this._attributes.make(this._types.number(1)),
					renderOdd: renderOdd = this._attributes.make(this._types.vec2())
				};
				top = new THREE.Vector3();
				bottom = new THREE.Vector3();
				handler = (function(_this) {
					return function() {
						var camera, dpr, focus, fov, fovtan, isAbsolute, m, measure, pixel, ref, rscale, scale, size, world;
						if ((size = typeof root !== "undefined" && root !== null ? root.getSize() : void 0) == null) {
							return;
						}
						 = Math.PI;
						scale = _this.props.scale;
						fov = _this.props.fov;
						focus = (ref = _this.props.focus) != null ? ref : _this.inherit('unit').props.focus;
						isAbsolute = scale === null;
						measure = 1;
						if ((camera = typeof root !== "undefined" && root !== null ? root.getCamera() : void 0)) {
							m = camera.projectionMatrix;
							top.set(0, -.5, 1).applyMatrix4(m);
							bottom.set(0, .5, 1).applyMatrix4(m);
							top.sub(bottom);
							measure = top.y;
						}
						dpr = size.renderHeight / size.viewHeight;
						fovtan = fov != null ? measure * Math.tan(fov *  / 360) : 1;
						pixel = isAbsolute ? dpr : size.renderHeight / scale * fovtan;
						rscale = size.renderHeight * measure / 2;
						world = pixel / rscale;
						viewWidth.value = size.viewWidth;
						viewHeight.value = size.viewHeight;
						renderWidth.value = size.renderWidth;
						renderHeight.value = size.renderHeight;
						renderAspect.value = size.aspect;
						renderScale.value = rscale;
						renderScaleInv.value = 1 / rscale;
						pixelRatio.value = dpr;
						pixelUnit.value = pixel;
						worldUnit.value = world;
						focusDepth.value = focus;
						return renderOdd.value.set(size.renderWidth % 2, size.renderHeight % 2).multiplyScalar(.5);
					};
				})(this);
				root = this.is('root') ? this : this._inherit('root');
				this._listen(root, 'root.update', handler);
				return handler();
			},
			unmake: function() {
				return delete this.unitUniforms;
			},
			get: function() {
				var k, ref, u, v;
				u = {};
				ref = this.unitUniforms;
				for (k in ref) {
					v = ref[k];
					u[k] = v.value;
				}
				return u;
			},
			uniforms: function() {
				return this.unitUniforms;
			}
		}
	};
	
	module.exports = function(object, traits) {
		var h, i, key, len, method, methods, trait;
		h = {};
		for (i = 0, len = traits.length; i < len; i++) {
			trait = traits[i];
			if (!(methods = helpers[trait])) {
				continue;
			}
			h[trait] = {};
			for (key in methods) {
				method = methods[key];
				h[trait][key] = method.bind(object);
			}
		}
		return h;
	};
	
	
	/***/ }),
	/* 177 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Scene = __webpack_require__(29);
	
	exports.Factory = __webpack_require__(178);
	
	exports.Renderable = __webpack_require__(29);
	
	exports.Classes = __webpack_require__(179);
	
	
	/***/ }),
	/* 178 */
	/***/ (function(module, exports) {
	
	var RenderFactory;
	
	RenderFactory = (function() {
		function RenderFactory(classes, renderer, shaders) {
			this.classes = classes;
			this.renderer = renderer;
			this.shaders = shaders;
		}
	
		RenderFactory.prototype.getTypes = function() {
			return Object.keys(this.classes);
		};
	
		RenderFactory.prototype.make = function(type, options) {
			return new this.classes[type](this.renderer, this.shaders, options);
		};
	
		return RenderFactory;
	
	})();
	
	module.exports = RenderFactory;
	
	
	/***/ }),
	/* 179 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Classes;
	
	Classes = {
		sprite: __webpack_require__(180),
		point: __webpack_require__(187),
		line: __webpack_require__(188),
		surface: __webpack_require__(189),
		face: __webpack_require__(190),
		strip: __webpack_require__(191),
		arrow: __webpack_require__(192),
		screen: __webpack_require__(56),
		memoScreen: __webpack_require__(57),
		debug: __webpack_require__(193),
		dataBuffer: __webpack_require__(22),
		arrayBuffer: __webpack_require__(194),
		matrixBuffer: __webpack_require__(195),
		voxelBuffer: __webpack_require__(196),
		pushBuffer: __webpack_require__(197),
		renderToTexture: __webpack_require__(58),
		memo: __webpack_require__(59),
		readback: __webpack_require__(199),
		atlas: __webpack_require__(60),
		textAtlas: __webpack_require__(201),
		scene: __webpack_require__(29)
	};
	
	module.exports = Classes;
	
	
	/***/ }),
	/* 180 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Sprite, SpriteGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	SpriteGeometry = __webpack_require__(8).SpriteGeometry;
	
	Sprite = (function(superClass) {
		extend(Sprite, superClass);
	
		function Sprite(renderer, shaders, options) {
			var color, combine, edgeFactory, f, factory, fillFactory, hasStyle, linear, map, mask, material, position, sprite, stpq, uniforms, v;
			Sprite.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, sprite = options.sprite, map = options.map, combine = options.combine, linear = options.linear, color = options.color, mask = options.mask, stpq = options.stpq;
			if (uniforms == null) {
				uniforms = {};
			}
			hasStyle = uniforms.styleColor != null;
			this.geometry = new SpriteGeometry({
				items: options.items,
				width: options.width,
				height: options.height,
				depth: options.depth
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			factory = shaders.material();
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			v.require(this._vertexPosition(position, material, map, 2, stpq));
			v.require(sprite);
			v.pipe('sprite.position', this.uniforms);
			v.pipe('project.position', this.uniforms);
			factory.fragment = f = this._fragmentColor(hasStyle, material, color, mask, map, 2, stpq, combine, linear);
			edgeFactory = shaders.material();
			edgeFactory.vertex.pipe(v);
			edgeFactory.fragment.pipe(f);
			edgeFactory.fragment.pipe('fragment.transparent', this.uniforms);
			fillFactory = shaders.material();
			fillFactory.vertex.pipe(v);
			fillFactory.fragment.pipe(f);
			fillFactory.fragment.pipe('fragment.solid', this.uniforms);
			this.fillMaterial = this._material(fillFactory.link({
				side: THREE.DoubleSide
			}));
			this.edgeMaterial = this._material(edgeFactory.link({
				side: THREE.DoubleSide
			}));
			this.fillObject = new THREE.Mesh(this.geometry, this.fillMaterial);
			this.edgeObject = new THREE.Mesh(this.geometry, this.edgeMaterial);
			this._raw(this.fillObject);
			this._raw(this.edgeObject);
			this.renders = [this.fillObject, this.edgeObject];
		}
	
		Sprite.prototype.show = function(transparent, blending, order, depth) {
			this._show(this.edgeObject, true, blending, order, depth);
			return this._show(this.fillObject, transparent, blending, order, depth);
		};
	
		Sprite.prototype.dispose = function() {
			this.geometry.dispose();
			this.edgeMaterial.dispose();
			this.fillMaterial.dispose();
			this.renders = this.geometry = this.edgeMaterial = this.fillMaterial = this.edgeObject = this.fillObject = null;
			return Sprite.__super__.dispose.apply(this, arguments);
		};
	
		return Sprite;
	
	})(Base);
	
	module.exports = Sprite;
	
	
	/***/ }),
	/* 181 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ArrowGeometry, ClipGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	ClipGeometry = __webpack_require__(14);
	
	
	/*
	Cones to attach as arrowheads on line strips
	
	.....> .....> .....> .....>
	
	.....> .....> .....> .....>
	
	.....> .....> .....> .....>
	 */
	
	ArrowGeometry = (function(superClass) {
		extend(ArrowGeometry, superClass);
	
		function ArrowGeometry(options) {
			var a, anchor, angle, arrow, arrows, attach, b, back, base, c, circle, closed, far, flip, i, index, j, k, l, layers, m, n, near, o, p, points, position, q, r, ref, ref1, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, ribbons, samples, sides, strips, tip, triangles, x, y, z;
			ArrowGeometry.__super__.constructor.call(this, options);
			this._clipUniforms();
			this.sides = sides = +options.sides || 12;
			this.samples = samples = +options.samples || 2;
			this.strips = strips = +options.strips || 1;
			this.ribbons = ribbons = +options.ribbons || 1;
			this.layers = layers = +options.layers || 1;
			this.flip = flip = (ref = options.flip) != null ? ref : false;
			this.closed = closed = (ref1 = options.closed) != null ? ref1 : false;
			this.anchor = anchor = (ref2 = options.anchor) != null ? ref2 : flip || closed ? 0 : samples - 1;
			arrows = strips * ribbons * layers;
			points = (sides + 2) * arrows;
			triangles = (sides * 2) * arrows;
			this.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles * 3), 1));
			this.addAttribute('position4', new THREE.BufferAttribute(new Float32Array(points * 4), 4));
			this.addAttribute('arrow', new THREE.BufferAttribute(new Float32Array(points * 3), 3));
			this.addAttribute('attach', new THREE.BufferAttribute(new Float32Array(points * 2), 2));
			index = this._emitter('index');
			position = this._emitter('position4');
			arrow = this._emitter('arrow');
			attach = this._emitter('attach');
			circle = [];
			for (k = j = 0, ref3 = sides; 0 <= ref3 ? j < ref3 : j > ref3; k = 0 <= ref3 ? ++j : --j) {
				angle = k / sides * (2 * Math.PI);
				circle.push([Math.cos(angle), Math.sin(angle), 1]);
			}
			base = 0;
			for (i = m = 0, ref4 = arrows; 0 <= ref4 ? m < ref4 : m > ref4; i = 0 <= ref4 ? ++m : --m) {
				tip = base++;
				back = tip + sides + 1;
				for (k = n = 0, ref5 = sides; 0 <= ref5 ? n < ref5 : n > ref5; k = 0 <= ref5 ? ++n : --n) {
					a = base + k % sides;
					b = base + (k + 1) % sides;
					index(tip);
					index(a);
					index(b);
					index(b);
					index(a);
					index(back);
				}
				base += sides + 1;
			}
			near = flip ? 1 : closed ? samples - 1 : -1;
			far = flip && !closed ? samples - 1 : 0;
			x = anchor;
			for (l = o = 0, ref6 = layers; 0 <= ref6 ? o < ref6 : o > ref6; l = 0 <= ref6 ? ++o : --o) {
				for (z = p = 0, ref7 = ribbons; 0 <= ref7 ? p < ref7 : p > ref7; z = 0 <= ref7 ? ++p : --p) {
					for (y = q = 0, ref8 = strips; 0 <= ref8 ? q < ref8 : q > ref8; y = 0 <= ref8 ? ++q : --q) {
						position(x, y, z, l);
						arrow(0, 0, 0);
						attach(near, far);
						for (k = r = 0, ref9 = sides; 0 <= ref9 ? r < ref9 : r > ref9; k = 0 <= ref9 ? ++r : --r) {
							position(x, y, z, l);
							c = circle[k];
							arrow(c[0], c[1], c[2]);
							attach(near, far);
						}
						position(x, y, z, l);
						arrow(0, 0, 1);
						attach(near, far);
					}
				}
			}
			this._finalize();
			this.clip();
			return;
		}
	
		ArrowGeometry.prototype.clip = function(samples, strips, ribbons, layers) {
			var dims, maxs, quads, segments;
			if (samples == null) {
				samples = this.samples;
			}
			if (strips == null) {
				strips = this.strips;
			}
			if (ribbons == null) {
				ribbons = this.ribbons;
			}
			if (layers == null) {
				layers = this.layers;
			}
			segments = Math.max(0, samples - 1);
			this._clipGeometry(samples, strips, ribbons, layers);
			if (samples > 0) {
				dims = [layers, ribbons, strips];
				maxs = [this.layers, this.ribbons, this.strips];
				quads = this.sides * this._reduce(dims, maxs);
			} else {
				quads = 0;
			}
			return this._offsets([
				{
					start: 0,
					count: quads * 6
				}
			]);
		};
	
		return ArrowGeometry;
	
	})(ClipGeometry);
	
	module.exports = ArrowGeometry;
	
	
	/***/ }),
	/* 182 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ClipGeometry, FaceGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	ClipGeometry = __webpack_require__(14);
	
	
	/*
	(flat) Triangle fans arranged in items, columns and rows
	
	+-+     +-+     +-+     +-+     
	|\\\    |\\\    |\\\    |\\\    
	+-+-+   +-+-+   +-+-+   +-+-+   
	
	+-+     +-+     +-+     +-+     
	|\\\    |\\\    |\\\    |\\\    
	+-+-+   +-+-+   +-+-+   +-+-+   
	
	+-+     +-+     +-+     +-+     
	|\\\    |\\\    |\\\    |\\\    
	+-+-+   +-+-+   +-+-+   +-+-+
	 */
	
	FaceGeometry = (function(superClass) {
		extend(FaceGeometry, superClass);
	
		function FaceGeometry(options) {
			var base, depth, height, i, index, items, j, k, l, m, n, o, p, points, position, q, ref, ref1, ref2, ref3, ref4, ref5, samples, sides, triangles, width, x, y, z;
			FaceGeometry.__super__.constructor.call(this, options);
			this._clipUniforms();
			this.items = items = +options.items || 2;
			this.width = width = +options.width || 1;
			this.height = height = +options.height || 1;
			this.depth = depth = +options.depth || 1;
			this.sides = sides = Math.max(0, items - 2);
			samples = width * height * depth;
			points = items * samples;
			triangles = sides * samples;
			this.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles * 3), 1));
			this.addAttribute('position4', new THREE.BufferAttribute(new Float32Array(points * 4), 4));
			index = this._emitter('index');
			position = this._emitter('position4');
			base = 0;
			for (i = k = 0, ref = samples; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
				for (j = m = 0, ref1 = sides; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
					index(base);
					index(base + j + 1);
					index(base + j + 2);
				}
				base += items;
			}
			for (z = n = 0, ref2 = depth; 0 <= ref2 ? n < ref2 : n > ref2; z = 0 <= ref2 ? ++n : --n) {
				for (y = o = 0, ref3 = height; 0 <= ref3 ? o < ref3 : o > ref3; y = 0 <= ref3 ? ++o : --o) {
					for (x = p = 0, ref4 = width; 0 <= ref4 ? p < ref4 : p > ref4; x = 0 <= ref4 ? ++p : --p) {
						for (l = q = 0, ref5 = items; 0 <= ref5 ? q < ref5 : q > ref5; l = 0 <= ref5 ? ++q : --q) {
							position(x, y, z, l);
						}
					}
				}
			}
			this._finalize();
			this.clip();
			return;
		}
	
		FaceGeometry.prototype.clip = function(width, height, depth, items) {
			var sides;
			if (width == null) {
				width = this.width;
			}
			if (height == null) {
				height = this.height;
			}
			if (depth == null) {
				depth = this.depth;
			}
			if (items == null) {
				items = this.items;
			}
			sides = Math.max(0, items - 2);
			this._clipGeometry(width, height, depth, items);
			return this._clipOffsets(3, width, height, depth, sides, this.width, this.height, this.depth, this.sides);
		};
	
		return FaceGeometry;
	
	})(ClipGeometry);
	
	module.exports = FaceGeometry;
	
	
	/***/ }),
	/* 183 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ClipGeometry, LineGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	ClipGeometry = __webpack_require__(14);
	
	
	/*
	Line strips arranged in columns and rows
	
	+----+ +----+ +----+ +----+
	
	+----+ +----+ +----+ +----+
	
	+----+ +----+ +----+ +----+
	 */
	
	LineGeometry = (function(superClass) {
		extend(LineGeometry, superClass);
	
		function LineGeometry(options) {
			var base, closed, detail, edge, edger, i, i1, index, j, j1, joint, joints, k, l, layers, line, lines, m, n, o, p, points, position, q, quads, r, ref, ref1, ref10, ref11, ref2, ref3, ref4, ref5, ref6, ref7, ref8, ref9, ribbons, s, samples, segments, strips, t, triangles, u, v, vertices, w, x, y, z;
			LineGeometry.__super__.constructor.call(this, options);
			this._clipUniforms();
			this.closed = closed = options.closed || false;
			this.samples = samples = (+options.samples || 2) + (closed ? 1 : 0);
			this.strips = strips = +options.strips || 1;
			this.ribbons = ribbons = +options.ribbons || 1;
			this.layers = layers = +options.layers || 1;
			this.detail = detail = +options.detail || 1;
			lines = samples - 1;
			this.joints = joints = detail - 1;
			this.vertices = vertices = (lines - (closed ? 0 : 1)) * joints + samples;
			this.segments = segments = vertices - 1;
			points = vertices * strips * ribbons * layers * 2;
			quads = segments * strips * ribbons * layers;
			triangles = quads * 2;
			this.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles * 3), 1));
			this.addAttribute('position4', new THREE.BufferAttribute(new Float32Array(points * 4), 4));
			this.addAttribute('line', new THREE.BufferAttribute(new Float32Array(points * 1), 1));
			if (detail > 1) {
				this.addAttribute('joint', new THREE.BufferAttribute(new Float32Array(points), 1));
			}
			index = this._emitter('index');
			position = this._emitter('position4');
			line = this._emitter('line');
			if (detail > 1) {
				joint = this._emitter('joint');
			}
			base = 0;
			for (i = n = 0, ref = ribbons * layers; 0 <= ref ? n < ref : n > ref; i = 0 <= ref ? ++n : --n) {
				for (j = o = 0, ref1 = strips; 0 <= ref1 ? o < ref1 : o > ref1; j = 0 <= ref1 ? ++o : --o) {
					for (k = p = 0, ref2 = segments; 0 <= ref2 ? p < ref2 : p > ref2; k = 0 <= ref2 ? ++p : --p) {
						index(base);
						index(base + 1);
						index(base + 2);
						index(base + 2);
						index(base + 1);
						index(base + 3);
						base += 2;
					}
					base += 2;
				}
			}
			edger = closed ? function() {
				return 0;
			} : function(x) {
				if (x === 0) {
					return -1;
				} else if (x === samples - 1) {
					return 1;
				} else {
					return 0;
				}
			};
			if (detail > 1) {
				for (l = q = 0, ref3 = layers; 0 <= ref3 ? q < ref3 : q > ref3; l = 0 <= ref3 ? ++q : --q) {
					for (z = r = 0, ref4 = ribbons; 0 <= ref4 ? r < ref4 : r > ref4; z = 0 <= ref4 ? ++r : --r) {
						for (y = s = 0, ref5 = strips; 0 <= ref5 ? s < ref5 : s > ref5; y = 0 <= ref5 ? ++s : --s) {
							for (x = t = 0, ref6 = samples; 0 <= ref6 ? t < ref6 : t > ref6; x = 0 <= ref6 ? ++t : --t) {
								edge = edger(x);
								if (edge !== 0) {
									position(x, y, z, l);
									position(x, y, z, l);
									line(1);
									line(-1);
									joint(0.5);
									joint(0.5);
								} else {
									for (m = u = 0, ref7 = detail; 0 <= ref7 ? u < ref7 : u > ref7; m = 0 <= ref7 ? ++u : --u) {
										position(x, y, z, l);
										position(x, y, z, l);
										line(1);
										line(-1);
										joint(m / joints);
										joint(m / joints);
									}
								}
							}
						}
					}
				}
			} else {
				for (l = v = 0, ref8 = layers; 0 <= ref8 ? v < ref8 : v > ref8; l = 0 <= ref8 ? ++v : --v) {
					for (z = w = 0, ref9 = ribbons; 0 <= ref9 ? w < ref9 : w > ref9; z = 0 <= ref9 ? ++w : --w) {
						for (y = i1 = 0, ref10 = strips; 0 <= ref10 ? i1 < ref10 : i1 > ref10; y = 0 <= ref10 ? ++i1 : --i1) {
							for (x = j1 = 0, ref11 = samples; 0 <= ref11 ? j1 < ref11 : j1 > ref11; x = 0 <= ref11 ? ++j1 : --j1) {
								position(x, y, z, l);
								position(x, y, z, l);
								line(1);
								line(-1);
							}
						}
					}
				}
			}
			this._finalize();
			this.clip();
			return;
		}
	
		LineGeometry.prototype.clip = function(samples, strips, ribbons, layers) {
			var segments, vertices;
			if (samples == null) {
				samples = this.samples - this.closed;
			}
			if (strips == null) {
				strips = this.strips;
			}
			if (ribbons == null) {
				ribbons = this.ribbons;
			}
			if (layers == null) {
				layers = this.layers;
			}
			vertices = samples + (samples - (this.closed ? 0 : 2)) * this.joints;
			segments = vertices - (this.closed ? 0 : 1);
			samples += this.closed;
			this._clipGeometry(samples, strips, ribbons, layers);
			return this._clipOffsets(6, segments, strips, ribbons, layers, this.segments, this.strips, this.ribbons, this.layers);
		};
	
		return LineGeometry;
	
	})(ClipGeometry);
	
	module.exports = LineGeometry;
	
	
	/***/ }),
	/* 184 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ScreenGeometry, SurfaceGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	SurfaceGeometry = __webpack_require__(55);
	
	
	/*
	Grid Surface in normalized screen space
	
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	|    |    |    |    |
	+----+----+----+----+
	 */
	
	ScreenGeometry = (function(superClass) {
		extend(ScreenGeometry, superClass);
	
		function ScreenGeometry(options) {
			var ref, ref1;
			if (this.uniforms == null) {
				this.uniforms = {};
			}
			this.uniforms.geometryScale = {
				type: 'v4',
				value: new THREE.Vector4
			};
			options.width = Math.max(2, (ref = +options.width) != null ? ref : 2);
			options.height = Math.max(2, (ref1 = +options.height) != null ? ref1 : 2);
			this.cover();
			ScreenGeometry.__super__.constructor.call(this, options);
		}
	
		ScreenGeometry.prototype.cover = function(scaleX, scaleY, scaleZ, scaleW) {
			this.scaleX = scaleX != null ? scaleX : 1;
			this.scaleY = scaleY != null ? scaleY : 1;
			this.scaleZ = scaleZ != null ? scaleZ : 1;
			this.scaleW = scaleW != null ? scaleW : 1;
		};
	
		ScreenGeometry.prototype.clip = function(width, height, surfaces, layers) {
			var invert;
			if (width == null) {
				width = this.width;
			}
			if (height == null) {
				height = this.height;
			}
			if (surfaces == null) {
				surfaces = this.surfaces;
			}
			if (layers == null) {
				layers = this.layers;
			}
			ScreenGeometry.__super__.clip.call(this, width, height, surfaces, layers);
			invert = function(x) {
				return 1 / Math.max(1, x - 1);
			};
			return this.uniforms.geometryScale.value.set(invert(width) * this.scaleX, invert(height) * this.scaleY, invert(surfaces) * this.scaleZ, invert(layers) * this.scaleW);
		};
	
		return ScreenGeometry;
	
	})(SurfaceGeometry);
	
	module.exports = ScreenGeometry;
	
	
	/***/ }),
	/* 185 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ClipGeometry, SpriteGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	ClipGeometry = __webpack_require__(14);
	
	
	/*
	Render points as quads
	
	+----+  +----+  +----+  +----+
	|    |  |    |  |    |  |    |
	+----+  +----+  +----+  +----+
	
	+----+  +----+  +----+  +----+
	|    |  |    |  |    |  |    |
	+----+  +----+  +----+  +----+
	
	+----+  +----+  +----+  +----+
	|    |  |    |  |    |  |    |
	+----+  +----+  +----+  +----+
	 */
	
	SpriteGeometry = (function(superClass) {
		extend(SpriteGeometry, superClass);
	
		function SpriteGeometry(options) {
			var base, depth, height, i, index, items, j, k, l, len, m, n, o, p, points, position, quad, ref, ref1, ref2, ref3, ref4, samples, sprite, triangles, v, width, x, y, z;
			SpriteGeometry.__super__.constructor.call(this, options);
			this._clipUniforms();
			this.items = items = +options.items || 2;
			this.width = width = +options.width || 1;
			this.height = height = +options.height || 1;
			this.depth = depth = +options.depth || 1;
			samples = items * width * height * depth;
			points = samples * 4;
			triangles = samples * 2;
			this.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles * 3), 1));
			this.addAttribute('position4', new THREE.BufferAttribute(new Float32Array(points * 4), 4));
			this.addAttribute('sprite', new THREE.BufferAttribute(new Float32Array(points * 2), 2));
			index = this._emitter('index');
			position = this._emitter('position4');
			sprite = this._emitter('sprite');
			quad = [[-1, -1], [-1, 1], [1, -1], [1, 1]];
			base = 0;
			for (i = j = 0, ref = samples; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
				index(base);
				index(base + 1);
				index(base + 2);
				index(base + 1);
				index(base + 2);
				index(base + 3);
				base += 4;
			}
			for (z = k = 0, ref1 = depth; 0 <= ref1 ? k < ref1 : k > ref1; z = 0 <= ref1 ? ++k : --k) {
				for (y = m = 0, ref2 = height; 0 <= ref2 ? m < ref2 : m > ref2; y = 0 <= ref2 ? ++m : --m) {
					for (x = n = 0, ref3 = width; 0 <= ref3 ? n < ref3 : n > ref3; x = 0 <= ref3 ? ++n : --n) {
						for (l = o = 0, ref4 = items; 0 <= ref4 ? o < ref4 : o > ref4; l = 0 <= ref4 ? ++o : --o) {
							for (p = 0, len = quad.length; p < len; p++) {
								v = quad[p];
								position(x, y, z, l);
								sprite(v[0], v[1]);
							}
						}
					}
				}
			}
			this._finalize();
			this.clip();
			return;
		}
	
		SpriteGeometry.prototype.clip = function(width, height, depth, items) {
			if (width == null) {
				width = this.width;
			}
			if (height == null) {
				height = this.height;
			}
			if (depth == null) {
				depth = this.depth;
			}
			if (items == null) {
				items = this.items;
			}
			this._clipGeometry(width, height, depth, items);
			return this._clipOffsets(6, width, height, depth, items, this.width, this.height, this.depth, this.items);
		};
	
		return SpriteGeometry;
	
	})(ClipGeometry);
	
	module.exports = SpriteGeometry;
	
	
	/***/ }),
	/* 186 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ClipGeometry, StripGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	ClipGeometry = __webpack_require__(14);
	
	
	/*
	Triangle strips arranged in items, columns and rows
	
	+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+  
	| /| /| /   | /| /| /   | /| /| /   | /| /| / 
	+--+--+/    +--+--+/    +--+--+/    +--+--+/  
	
	+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+  
	| /| /| /   | /| /| /   | /| /| /   | /| /| / 
	+--+--+/    +--+--+/    +--+--+/    +--+--+/  
	
	+--+--+--+  +--+--+--+  +--+--+--+  +--+--+--+  
	| /| /| /   | /| /| /   | /| /| /   | /| /| / 
	+--+--+/    +--+--+/    +--+--+/    +--+--+/
	 */
	
	StripGeometry = (function(superClass) {
		extend(StripGeometry, superClass);
	
		function StripGeometry(options) {
			var base, depth, f, height, i, index, items, j, k, l, last, m, n, o, p, points, position, q, r, ref, ref1, ref2, ref3, ref4, ref5, samples, sides, strip, triangles, width, x, y, z;
			StripGeometry.__super__.constructor.call(this, options);
			this._clipUniforms();
			this.items = items = +options.items || 2;
			this.width = width = +options.width || 1;
			this.height = height = +options.height || 1;
			this.depth = depth = +options.depth || 1;
			this.sides = sides = Math.max(0, items - 2);
			samples = width * height * depth;
			points = items * samples;
			triangles = sides * samples;
			this.setIndex(new THREE.BufferAttribute(new Uint32Array(triangles * 3), 1));
			this.addAttribute('position4', new THREE.BufferAttribute(new Float32Array(points * 4), 4));
			this.addAttribute('strip', new THREE.BufferAttribute(new Float32Array(points * 3), 3));
			index = this._emitter('index');
			position = this._emitter('position4');
			strip = this._emitter('strip');
			base = 0;
			for (i = k = 0, ref = samples; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
				o = base;
				for (j = m = 0, ref1 = sides; 0 <= ref1 ? m < ref1 : m > ref1; j = 0 <= ref1 ? ++m : --m) {
					if (j & 1) {
						index(o + 1);
						index(o);
						index(o + 2);
					} else {
						index(o);
						index(o + 1);
						index(o + 2);
					}
					o++;
				}
				base += items;
			}
			last = items - 1;
			for (z = n = 0, ref2 = depth; 0 <= ref2 ? n < ref2 : n > ref2; z = 0 <= ref2 ? ++n : --n) {
				for (y = p = 0, ref3 = height; 0 <= ref3 ? p < ref3 : p > ref3; y = 0 <= ref3 ? ++p : --p) {
					for (x = q = 0, ref4 = width; 0 <= ref4 ? q < ref4 : q > ref4; x = 0 <= ref4 ? ++q : --q) {
						f = 1;
						position(x, y, z, 0);
						strip(1, 2, f);
						for (l = r = 1, ref5 = last; 1 <= ref5 ? r < ref5 : r > ref5; l = 1 <= ref5 ? ++r : --r) {
							position(x, y, z, l);
							strip(l - 1, l + 1, f = -f);
						}
						position(x, y, z, last);
						strip(last - 2, last - 1, -f);
					}
				}
			}
			this._finalize();
			this.clip();
			return;
		}
	
		StripGeometry.prototype.clip = function(width, height, depth, items) {
			var sides;
			if (width == null) {
				width = this.width;
			}
			if (height == null) {
				height = this.height;
			}
			if (depth == null) {
				depth = this.depth;
			}
			if (items == null) {
				items = this.items;
			}
			sides = Math.max(0, items - 2);
			this._clipGeometry(width, height, depth, items);
			return this._clipOffsets(3, width, height, depth, sides, this.width, this.height, this.depth, this.sides);
		};
	
		return StripGeometry;
	
	})(ClipGeometry);
	
	module.exports = StripGeometry;
	
	
	/***/ }),
	/* 187 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Point, SpriteGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	SpriteGeometry = __webpack_require__(8).SpriteGeometry;
	
	Point = (function(superClass) {
		extend(Point, superClass);
	
		function Point(renderer, shaders, options) {
			var _scale, _shape, alpha, color, combine, defines, edgeFactory, f, factory, fill, fillFactory, hasStyle, linear, map, mask, material, optical, pass, passes, position, ref, ref1, ref2, ref3, scales, shape, shapes, size, stpq, uniforms, v;
			Point.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, color = options.color, size = options.size, mask = options.mask, map = options.map, combine = options.combine, linear = options.linear, shape = options.shape, optical = options.optical, fill = options.fill, stpq = options.stpq;
			if (uniforms == null) {
				uniforms = {};
			}
			shape = (ref = +shape) != null ? ref : 0;
			if (fill == null) {
				fill = true;
			}
			hasStyle = uniforms.styleColor != null;
			shapes = ['circle', 'square', 'diamond', 'up', 'down', 'left', 'right'];
			passes = ['circle', 'generic', 'generic', 'generic', 'generic', 'generic', 'generic'];
			scales = [1.2, 1, 1.414, 1.16, 1.16, 1.16, 1.16];
			pass = (ref1 = passes[shape]) != null ? ref1 : passes[0];
			_shape = (ref2 = shapes[shape]) != null ? ref2 : shapes[0];
			_scale = (ref3 = optical && scales[shape]) != null ? ref3 : 1;
			alpha = fill ? pass : pass + ".hollow";
			this.geometry = new SpriteGeometry({
				items: options.items,
				width: options.width,
				height: options.height,
				depth: options.depth
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			defines = {
				POINT_SHAPE_SCALE: +(_scale + .00001)
			};
			factory = shaders.material();
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			if (size) {
				v.isolate();
				v.require(size);
				v.require('point.size.varying', this.uniforms);
				v.end();
			} else {
				v.require('point.size.uniform', this.uniforms);
			}
			v.require(this._vertexPosition(position, material, map, 2, stpq));
			v.pipe('point.position', this.uniforms, defines);
			v.pipe('project.position', this.uniforms);
			factory.fragment = f = this._fragmentColor(hasStyle, material, color, mask, map, 2, stpq, combine, linear);
			edgeFactory = shaders.material();
			edgeFactory.vertex.pipe(v);
			f = edgeFactory.fragment.pipe(factory.fragment);
			f.require("point.mask." + _shape, this.uniforms);
			f.require("point.alpha." + alpha, this.uniforms);
			f.pipe('point.edge', this.uniforms);
			fillFactory = shaders.material();
			fillFactory.vertex.pipe(v);
			f = fillFactory.fragment.pipe(factory.fragment);
			f.require("point.mask." + _shape, this.uniforms);
			f.require("point.alpha." + alpha, this.uniforms);
			f.pipe('point.fill', this.uniforms);
			this.fillMaterial = this._material(fillFactory.link({
				side: THREE.DoubleSide
			}));
			this.edgeMaterial = this._material(edgeFactory.link({
				side: THREE.DoubleSide
			}));
			this.fillObject = new THREE.Mesh(this.geometry, this.fillMaterial);
			this.edgeObject = new THREE.Mesh(this.geometry, this.edgeMaterial);
			this._raw(this.fillObject);
			this._raw(this.edgeObject);
			this.renders = [this.fillObject, this.edgeObject];
		}
	
		Point.prototype.show = function(transparent, blending, order, depth) {
			this._show(this.edgeObject, true, blending, order, depth);
			return this._show(this.fillObject, transparent, blending, order, depth);
		};
	
		Point.prototype.dispose = function() {
			this.geometry.dispose();
			this.edgeMaterial.dispose();
			this.fillMaterial.dispose();
			this.renders = this.edgeObject = this.fillObject = this.geometry = this.edgeMaterial = this.fillMaterial = null;
			return Point.__super__.dispose.apply(this, arguments);
		};
	
		return Point;
	
	})(Base);
	
	module.exports = Point;
	
	
	/***/ }),
	/* 188 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Line, LineGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	LineGeometry = __webpack_require__(8).LineGeometry;
	
	Line = (function(superClass) {
		extend(Line, superClass);
	
		function Line(renderer, shaders, options) {
			var clip, closed, color, combine, defs, detail, f, factory, hasStyle, join, linear, map, mask, material, object, position, proximity, ref, stpq, stroke, uniforms, v;
			Line.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, color = options.color, mask = options.mask, map = options.map, combine = options.combine, stpq = options.stpq, linear = options.linear, clip = options.clip, stroke = options.stroke, join = options.join, proximity = options.proximity, closed = options.closed;
			if (uniforms == null) {
				uniforms = {};
			}
			stroke = [null, 'dotted', 'dashed'][stroke];
			hasStyle = uniforms.styleColor != null;
			join = (ref = ['miter', 'round', 'bevel'][join]) != null ? ref : 'miter';
			detail = {
				miter: 1,
				round: 4,
				bevel: 2
			}[join];
			this.geometry = new LineGeometry({
				samples: options.samples,
				strips: options.strips,
				ribbons: options.ribbons,
				layers: options.layers,
				anchor: options.anchor,
				closed: options.closed,
				detail: detail
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			factory = shaders.material();
			defs = {};
			if (stroke) {
				defs.LINE_STROKE = '';
			}
			if (clip) {
				defs.LINE_CLIP = '';
			}
			if (proximity != null) {
				defs.LINE_PROXIMITY = '';
			}
			defs['LINE_JOIN_' + join.toUpperCase()] = '';
			if (detail > 1) {
				defs['LINE_JOIN_DETAIL'] = detail;
			}
			if (closed) {
				defs['LINE_CLOSED'] = '';
			}
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			v.require(this._vertexPosition(position, material, map, 2, stpq));
			v.pipe('line.position', this.uniforms, defs);
			v.pipe('project.position', this.uniforms);
			f = factory.fragment;
			if (stroke) {
				f.pipe("fragment.clip." + stroke, this.uniforms);
			}
			if (clip) {
				f.pipe('fragment.clip.ends', this.uniforms);
			}
			if (proximity != null) {
				f.pipe('fragment.clip.proximity', this.uniforms);
			}
			f.pipe(this._fragmentColor(hasStyle, material, color, mask, map, 2, stpq, combine, linear));
			f.pipe('fragment.color', this.uniforms);
			this.material = this._material(factory.link({
				side: THREE.DoubleSide
			}));
			object = new THREE.Mesh(this.geometry, this.material);
			this._raw(object);
			this.renders = [object];
		}
	
		Line.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.renders = this.geometry = this.material = null;
			return Line.__super__.dispose.apply(this, arguments);
		};
	
		return Line;
	
	})(Base);
	
	module.exports = Line;
	
	
	/***/ }),
	/* 189 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Surface, SurfaceGeometry, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	SurfaceGeometry = __webpack_require__(8).SurfaceGeometry;
	
	Util = __webpack_require__(0);
	
	Surface = (function(superClass) {
		extend(Surface, superClass);
	
		function Surface(renderer, shaders, options) {
			var color, combine, defs, f, factory, hasHollow, hasStyle, intUV, linear, map, mask, material, normal, object, position, stpq, uniforms, v;
			Surface.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, color = options.color, normal = options.normal, mask = options.mask, map = options.map, combine = options.combine, linear = options.linear, stpq = options.stpq, intUV = options.intUV;
			if (uniforms == null) {
				uniforms = {};
			}
			if (material == null) {
				material = true;
			}
			hasStyle = uniforms.styleColor != null;
			hasHollow = uniforms.surfaceHollow != null;
			this.geometry = new SurfaceGeometry({
				width: options.width,
				height: options.height,
				surfaces: options.surfaces,
				layers: options.layers,
				closedX: options.closedX,
				closedY: options.closedY
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			defs = {};
			if (options.closedX) {
				defs.SURFACE_CLOSED_X = '';
			}
			if (options.closedY) {
				defs.SURFACE_CLOSED_Y = '';
			}
			if (intUV) {
				defs.POSITION_UV_INT = '';
			}
			factory = shaders.material();
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			v.require(this._vertexPosition(position, material, map, 2, stpq));
			if (normal) {
				v.require(normal);
				v.pipe('surface.position.normal', this.uniforms, defs);
			} else {
				if (!material) {
					v.pipe('surface.position', this.uniforms, defs);
				}
				if (material) {
					v.pipe('surface.position.shaded', this.uniforms, defs);
				}
			}
			v.pipe('project.position', this.uniforms);
			factory.fragment = f = this._fragmentColor(hasStyle, material, color, mask, map, 2, stpq, combine, linear);
			f.pipe('fragment.color', this.uniforms);
			this.material = this._material(factory.link({
				side: THREE.DoubleSide
			}));
			object = new THREE.Mesh(this.geometry, this.material);
			this._raw(object);
			this.renders = [object];
		}
	
		Surface.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.renders = this.geometry = this.material = null;
			return Surface.__super__.dispose.apply(this, arguments);
		};
	
		return Surface;
	
	})(Base);
	
	module.exports = Surface;
	
	
	/***/ }),
	/* 190 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Face, FaceGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	FaceGeometry = __webpack_require__(8).FaceGeometry;
	
	Face = (function(superClass) {
		extend(Face, superClass);
	
		function Face(renderer, shaders, options) {
			var color, combine, f, factory, hasStyle, linear, map, mask, material, object, position, stpq, uniforms, v;
			Face.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, color = options.color, mask = options.mask, map = options.map, combine = options.combine, stpq = options.stpq, linear = options.linear;
			if (uniforms == null) {
				uniforms = {};
			}
			if (material == null) {
				material = true;
			}
			hasStyle = uniforms.styleColor != null;
			this.geometry = new FaceGeometry({
				items: options.items,
				width: options.width,
				height: options.height,
				depth: options.depth
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			factory = shaders.material();
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			v.require(this._vertexPosition(position, material, map, 2, stpq));
			if (!material) {
				v.pipe('face.position', this.uniforms);
			}
			if (material) {
				v.pipe('face.position.normal', this.uniforms);
			}
			v.pipe('project.position', this.uniforms);
			factory.fragment = f = this._fragmentColor(hasStyle, material, color, mask, map, 2, stpq, combine, linear);
			f.pipe('fragment.color', this.uniforms);
			this.material = this._material(factory.link({
				side: THREE.DoubleSide
			}));
			object = new THREE.Mesh(this.geometry, this.material);
			this._raw(object);
			this.renders = [object];
		}
	
		Face.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.renders = this.geometry = this.material = null;
			return Face.__super__.dispose.apply(this, arguments);
		};
	
		return Face;
	
	})(Base);
	
	module.exports = Face;
	
	
	/***/ }),
	/* 191 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Strip, StripGeometry, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	StripGeometry = __webpack_require__(8).StripGeometry;
	
	Strip = (function(superClass) {
		extend(Strip, superClass);
	
		function Strip(renderer, shaders, options) {
			var color, combine, f, factory, hasStyle, linear, map, mask, material, object, position, stpq, uniforms, v;
			Strip.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, color = options.color, mask = options.mask, map = options.map, combine = options.combine, linear = options.linear, stpq = options.stpq;
			if (uniforms == null) {
				uniforms = {};
			}
			if (material == null) {
				material = true;
			}
			hasStyle = uniforms.styleColor != null;
			this.geometry = new StripGeometry({
				items: options.items,
				width: options.width,
				height: options.height,
				depth: options.depth
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			factory = shaders.material();
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			v.require(this._vertexPosition(position, material, map, 2, stpq));
			if (!material) {
				v.pipe('mesh.position', this.uniforms);
			}
			if (material) {
				v.pipe('strip.position.normal', this.uniforms);
			}
			v.pipe('project.position', this.uniforms);
			factory.fragment = f = this._fragmentColor(hasStyle, material, color, mask, map, 2, stpq, combine, linear);
			f.pipe('fragment.color', this.uniforms);
			this.material = this._material(factory.link({
				side: THREE.DoubleSide
			}));
			object = new THREE.Mesh(this.geometry, this.material);
			this._raw(object);
			this.renders = [object];
		}
	
		Strip.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.renders = this.geometry = this.material = null;
			return Strip.__super__.dispose.apply(this, arguments);
		};
	
		return Strip;
	
	})(Base);
	
	module.exports = Strip;
	
	
	/***/ }),
	/* 192 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Arrow, ArrowGeometry, Base, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	ArrowGeometry = __webpack_require__(8).ArrowGeometry;
	
	Arrow = (function(superClass) {
		extend(Arrow, superClass);
	
		function Arrow(renderer, shaders, options) {
			var color, combine, defs, f, factory, hasStyle, linear, map, mask, material, object, position, stpq, uniforms, v;
			Arrow.__super__.constructor.call(this, renderer, shaders, options);
			uniforms = options.uniforms, material = options.material, position = options.position, color = options.color, mask = options.mask, map = options.map, combine = options.combine, stpq = options.stpq, linear = options.linear;
			if (uniforms == null) {
				uniforms = {};
			}
			hasStyle = uniforms.styleColor != null;
			this.geometry = new ArrowGeometry({
				sides: options.sides,
				samples: options.samples,
				strips: options.strips,
				ribbons: options.ribbons,
				layers: options.layers,
				anchor: options.anchor,
				flip: options.flip,
				closed: options.closed
			});
			this._adopt(uniforms);
			this._adopt(this.geometry.uniforms);
			defs = {};
			if (closed) {
				defs['ARROW_CLOSED'] = '';
			}
			factory = shaders.material();
			v = factory.vertex;
			v.pipe(this._vertexColor(color, mask));
			v.require(this._vertexPosition(position, material, map, 1, stpq));
			v.pipe('arrow.position', this.uniforms, defs);
			v.pipe('project.position', this.uniforms);
			factory.fragment = f = this._fragmentColor(hasStyle, material, color, mask, map, 1, stpq, combine, linear);
			f.pipe('fragment.color', this.uniforms);
			this.material = this._material(factory.link({}));
			object = new THREE.Mesh(this.geometry, this.material);
			object.frustumCulled = false;
			object.matrixAutoUpdate = false;
			this._raw(object);
			this.renders = [object];
		}
	
		Arrow.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.renders = this.geometry = this.material = null;
			return Arrow.__super__.dispose.apply(this, arguments);
		};
	
		return Arrow;
	
	})(Base);
	
	module.exports = Arrow;
	
	
	/***/ }),
	/* 193 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Base, Debug, THREE,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Base = __webpack_require__(5);
	
	Debug = (function(superClass) {
		extend(Debug, superClass);
	
		function Debug(renderer, shaders, options) {
			var object;
			Debug.__super__.constructor.call(this, renderer, shaders, options);
			this.geometry = new THREE.PlaneGeometry(1, 1);
			this.material = new THREE.MeshBasicMaterial({
				map: options.map
			});
			this.material.side = THREE.DoubleSide;
			object = new THREE.Mesh(this.geometry, this.material);
			object.position.x += options.x || 0;
			object.position.y += options.y || 0;
			object.frustumCulled = false;
			object.scale.set(2, 2, 2);
			object.__debug = true;
			this.objects = [object];
		}
	
		Debug.prototype.dispose = function() {
			this.geometry.dispose();
			this.material.dispose();
			this.objects = this.geometry = this.material = null;
			return Debug.__super__.dispose.apply(this, arguments);
		};
	
		return Debug;
	
	})(Base);
	
	module.exports = Debug;
	
	
	/***/ }),
	/* 194 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var ArrayBuffer_, DataBuffer, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	DataBuffer = __webpack_require__(22);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * 1D + history array
	 */
	
	ArrayBuffer_ = (function(superClass) {
		extend(ArrayBuffer_, superClass);
	
		function ArrayBuffer_(renderer, shaders, options) {
			this.width = options.width || 1;
			this.history = options.history || 1;
			this.samples = this.width;
			this.wrap = this.history > 1;
			options.width = this.width;
			options.height = this.history;
			options.depth = 1;
			ArrayBuffer_.__super__.constructor.call(this, renderer, shaders, options);
		}
	
		ArrayBuffer_.prototype.build = function(options) {
			ArrayBuffer_.__super__.build.apply(this, arguments);
			this.index = 0;
			this.pad = 0;
			return this.streamer = this.generate(this.data);
		};
	
		ArrayBuffer_.prototype.setActive = function(i) {
			return this.pad = Math.max(0, this.width - i);
		};
	
		ArrayBuffer_.prototype.fill = function() {
			var callback, count, done, emit, i, limit, ref, reset, skip;
			callback = this.callback;
			if (typeof callback.reset === "function") {
				callback.reset();
			}
			ref = this.streamer, emit = ref.emit, skip = ref.skip, count = ref.count, done = ref.done, reset = ref.reset;
			reset();
			limit = this.samples - this.pad;
			i = 0;
			while (!done() && i < limit && callback(emit, i++) !== false) {
				true;
			}
			return Math.floor(count() / this.items);
		};
	
		ArrayBuffer_.prototype.write = function(n) {
			if (n == null) {
				n = this.samples;
			}
			n *= this.items;
			this.texture.write(this.data, 0, this.index, n, 1);
			this.dataPointer.set(.5, this.index + .5);
			this.index = (this.index + this.history - 1) % this.history;
			return this.filled = Math.min(this.history, this.filled + 1);
		};
	
		ArrayBuffer_.prototype.through = function(callback, target) {
			var consume, done, dst, emit, i, pipe, ref, src;
			ref = src = this.streamer, consume = ref.consume, done = ref.done;
			emit = (dst = target.streamer).emit;
			i = 0;
			pipe = function() {
				return consume(function(x, y, z, w) {
					return callback(emit, x, y, z, w, i);
				});
			};
			pipe = Util.Data.repeatCall(pipe, this.items);
			return (function(_this) {
				return function() {
					var limit;
					src.reset();
					dst.reset();
					limit = _this.samples - _this.pad;
					i = 0;
					while (!done() && i < limit) {
						pipe();
						i++;
					}
					return src.count();
				};
			})(this);
		};
	
		return ArrayBuffer_;
	
	})(DataBuffer);
	
	module.exports = ArrayBuffer_;
	
	
	/***/ }),
	/* 195 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var DataBuffer, MatrixBuffer, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	DataBuffer = __webpack_require__(22);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * 2D + history array
	 */
	
	MatrixBuffer = (function(superClass) {
		extend(MatrixBuffer, superClass);
	
		function MatrixBuffer(renderer, shaders, options) {
			this.width = options.width || 1;
			this.height = options.height || 1;
			this.history = options.history || 1;
			this.samples = this.width * this.height;
			this.wrap = this.history > 1;
			options.depth = this.history;
			MatrixBuffer.__super__.constructor.call(this, renderer, shaders, options);
		}
	
		MatrixBuffer.prototype.build = function(options) {
			MatrixBuffer.__super__.build.apply(this, arguments);
			this.index = 0;
			this.pad = {
				x: 0,
				y: 0
			};
			return this.streamer = this.generate(this.data);
		};
	
		MatrixBuffer.prototype.getFilled = function() {
			return this.filled;
		};
	
		MatrixBuffer.prototype.setActive = function(i, j) {
			var ref;
			return ref = [Math.max(0, this.width - i), Math.max(0, this.height - j)], this.pad.x = ref[0], this.pad.y = ref[1], ref;
		};
	
		MatrixBuffer.prototype.fill = function() {
			var callback, count, done, emit, i, j, k, limit, n, pad, ref, repeat, reset, skip;
			callback = this.callback;
			if (typeof callback.reset === "function") {
				callback.reset();
			}
			ref = this.streamer, emit = ref.emit, skip = ref.skip, count = ref.count, done = ref.done, reset = ref.reset;
			reset();
			n = this.width;
			pad = this.pad.x;
			limit = this.samples - this.pad.y * n;
			i = j = k = 0;
			if (pad) {
				while (!done() && k < limit) {
					k++;
					repeat = callback(emit, i, j);
					if (++i === n - pad) {
						skip(pad);
						k += pad;
						i = 0;
						j++;
					}
					if (repeat === false) {
						break;
					}
				}
			} else {
				while (!done() && k < limit) {
					k++;
					repeat = callback(emit, i, j);
					if (++i === n) {
						i = 0;
						j++;
					}
					if (repeat === false) {
						break;
					}
				}
			}
			return Math.floor(count() / this.items);
		};
	
		MatrixBuffer.prototype.write = function(n) {
			var height, width;
			if (n == null) {
				n = this.samples;
			}
			n *= this.items;
			width = this.width * this.items;
			height = Math.ceil(n / width);
			this.texture.write(this.data, 0, this.index * this.height, width, height);
			this.dataPointer.set(.5, this.index * this.height + .5);
			this.index = (this.index + this.history - 1) % this.history;
			return this.filled = Math.min(this.history, this.filled + 1);
		};
	
		MatrixBuffer.prototype.through = function(callback, target) {
			var consume, done, dst, emit, i, j, pipe, ref, src;
			ref = src = this.streamer, consume = ref.consume, done = ref.done;
			emit = (dst = target.streamer).emit;
			i = j = 0;
			pipe = function() {
				return consume(function(x, y, z, w) {
					return callback(emit, x, y, z, w, i, j);
				});
			};
			pipe = Util.Data.repeatCall(pipe, this.items);
			return (function(_this) {
				return function() {
					var k, limit, n, pad;
					src.reset();
					dst.reset();
					n = _this.width;
					pad = _this.pad.x;
					limit = _this.samples - _this.pad.y * n;
					i = j = k = 0;
					if (pad) {
						while (!done() && k < limit) {
							k++;
							pipe();
							if (++i === n - pad) {
								skip(pad);
								i = 0;
								j++;
							}
						}
					} else {
						while (!done() && k < limit) {
							k++;
							pipe();
							if (++i === n) {
								i = 0;
								j++;
							}
						}
					}
					return src.count();
				};
			})(this);
		};
	
		return MatrixBuffer;
	
	})(DataBuffer);
	
	module.exports = MatrixBuffer;
	
	
	/***/ }),
	/* 196 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var DataBuffer, Util, VoxelBuffer,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	DataBuffer = __webpack_require__(22);
	
	Util = __webpack_require__(0);
	
	VoxelBuffer = (function(superClass) {
		extend(VoxelBuffer, superClass);
	
		function VoxelBuffer() {
			return VoxelBuffer.__super__.constructor.apply(this, arguments);
		}
	
		VoxelBuffer.prototype.build = function(options) {
			VoxelBuffer.__super__.build.apply(this, arguments);
			this.pad = {
				x: 0,
				y: 0,
				z: 0
			};
			return this.streamer = this.generate(this.data);
		};
	
		VoxelBuffer.prototype.setActive = function(i, j, k) {
			var ref;
			return ref = [Math.max(0, this.width - i), Math.max(0, this.height - j), Math.max(0, this.depth - k)], this.pad.x = ref[0], this.pad.y = ref[1], this.pad.z = ref[2], ref;
		};
	
		VoxelBuffer.prototype.fill = function() {
			var callback, count, done, emit, i, j, k, l, limit, m, n, o, padX, padY, ref, repeat, reset, skip;
			callback = this.callback;
			if (typeof callback.reset === "function") {
				callback.reset();
			}
			ref = this.streamer, emit = ref.emit, skip = ref.skip, count = ref.count, done = ref.done, reset = ref.reset;
			reset();
			n = this.width;
			m = this.height;
			o = this.depth;
			padX = this.pad.x;
			padY = this.pad.y;
			limit = this.samples - this.pad.z * n * m;
			i = j = k = l = 0;
			if (padX > 0 || padY > 0) {
				while (!done() && l < limit) {
					l++;
					repeat = callback(emit, i, j, k);
					if (++i === n - padX) {
						skip(padX);
						l += padX;
						i = 0;
						if (++j === m - padY) {
							skip(n * padY);
							l += n * padY;
							j = 0;
							k++;
						}
					}
					if (repeat === false) {
						break;
					}
				}
			} else {
				while (!done() && l < limit) {
					l++;
					repeat = callback(emit, i, j, k);
					if (++i === n) {
						i = 0;
						if (++j === m) {
							j = 0;
							k++;
						}
					}
					if (repeat === false) {
						break;
					}
				}
			}
			return Math.floor(count() / this.items);
		};
	
		VoxelBuffer.prototype.through = function(callback, target) {
			var consume, done, dst, emit, i, j, k, pipe, ref, src;
			ref = src = this.streamer, consume = ref.consume, done = ref.done;
			emit = (dst = target.streamer).emit;
			i = j = k = 0;
			pipe = function() {
				return consume(function(x, y, z, w) {
					return callback(emit, x, y, z, w, i, j, k);
				});
			};
			pipe = Util.Data.repeatCall(pipe, this.items);
			return (function(_this) {
				return function() {
					var l, limit, m, n, o, padX, padY;
					src.reset();
					dst.reset();
					n = _this.width;
					m = _this.height;
					o = _this.depth;
					padX = _this.pad.x;
					padY = _this.pad.y;
					limit = _this.samples - _this.pad.z * n * m;
					i = j = k = l = 0;
					if (padX > 0 || padY > 0) {
						while (!done() && l < limit) {
							l++;
							pipe();
							if (++i === n - padX) {
								skip(padX);
								i = 0;
								if (++j === m - padY) {
									skip(n * padY);
									j = 0;
									k++;
								}
							}
						}
					} else {
						while (!done() && l < limit) {
							l++;
							pipe();
							if (++i === n) {
								i = 0;
								if (++j === m) {
									j = 0;
									k++;
								}
							}
						}
					}
					return src.count();
				};
			})(this);
		};
	
		return VoxelBuffer;
	
	})(DataBuffer);
	
	module.exports = VoxelBuffer;
	
	
	/***/ }),
	/* 197 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, PushBuffer, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Buffer = __webpack_require__(30);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * Buffer for CPU-side use
	 */
	
	PushBuffer = (function(superClass) {
		extend(PushBuffer, superClass);
	
		function PushBuffer(renderer, shaders, options) {
			this.width = options.width || 1;
			this.height = options.height || 1;
			this.depth = options.depth || 1;
			if (this.samples == null) {
				this.samples = this.width * this.height * this.depth;
			}
			PushBuffer.__super__.constructor.call(this, renderer, shaders, options);
			this.build(options);
		}
	
		PushBuffer.prototype.build = function(options) {
			this.data = [];
			this.data.length = this.samples;
			this.filled = 0;
			this.pad = {
				x: 0,
				y: 0,
				z: 0
			};
			return this.streamer = this.generate(this.data);
		};
	
		PushBuffer.prototype.dispose = function() {
			this.data = null;
			return PushBuffer.__super__.dispose.apply(this, arguments);
		};
	
		PushBuffer.prototype.getFilled = function() {
			return this.filled;
		};
	
		PushBuffer.prototype.setActive = function(i, j, k) {
			var ref;
			return ref = [this.width - i, this.height - j, this.depth - k], this.pad.x = ref[0], this.pad.y = ref[1], this.pad.z = ref[2], ref;
		};
	
		PushBuffer.prototype.read = function() {
			return this.data;
		};
	
		PushBuffer.prototype.copy = function(data) {
			var d, i, n, p, ref, results;
			n = Math.min(data.length, this.samples);
			d = this.data;
			results = [];
			for (i = p = 0, ref = n; 0 <= ref ? p < ref : p > ref; i = 0 <= ref ? ++p : --p) {
				results.push(d[i] = data[i]);
			}
			return results;
		};
	
		PushBuffer.prototype.fill = function() {
			var callback, count, done, emit, i, j, k, l, limit, m, n, o, padX, padY, ref, repeat, reset, skip;
			callback = this.callback;
			if (typeof callback.reset === "function") {
				callback.reset();
			}
			ref = this.streamer, emit = ref.emit, skip = ref.skip, count = ref.count, done = ref.done, reset = ref.reset;
			reset();
			n = this.width;
			m = this.height;
			o = this.depth;
			padX = this.pad.x;
			padY = this.pad.y;
			limit = this.samples - this.pad.z * n * m;
			i = j = k = l = 0;
			if (padX > 0 || padY > 0) {
				while (!done() && l < limit) {
					l++;
					repeat = callback(emit, i, j, k);
					if (++i === n - padX) {
						skip(padX);
						i = 0;
						if (++j === m - padY) {
							skip(n * padY);
							j = 0;
							k++;
						}
					}
					if (repeat === false) {
						break;
					}
				}
			} else {
				while (!done() && l < limit) {
					l++;
					repeat = callback(emit, i, j, k);
					if (++i === n) {
						i = 0;
						if (++j === m) {
							j = 0;
							k++;
						}
					}
					if (repeat === false) {
						break;
					}
				}
			}
			this.filled = 1;
			return count();
		};
	
		return PushBuffer;
	
	})(Buffer);
	
	module.exports = PushBuffer;
	
	
	/***/ }),
	/* 198 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var RenderTarget, THREE;
	
	THREE = __webpack_require__(1);
	
	
	/*
	Virtual RenderTarget that cycles through multiple frames
	Provides easy access to past rendered frames
	@reads[] and @write contain WebGLRenderTargets whose internal pointers are rotated automatically
	 */
	
	RenderTarget = (function() {
		function RenderTarget(gl, width, height, frames, options) {
			this.gl = gl;
			if (options == null) {
				options = {};
			}
			if (options.minFilter == null) {
				options.minFilter = THREE.NearestFilter;
			}
			if (options.magFilter == null) {
				options.magFilter = THREE.NearestFilter;
			}
			if (options.format == null) {
				options.format = THREE.RGBAFormat;
			}
			if (options.type == null) {
				options.type = THREE.UnsignedByteType;
			}
			this.options = options;
			this.width = width || 1;
			this.height = height || 1;
			this.frames = frames || 1;
			this.buffers = this.frames + 1;
			this.build();
		}
	
		RenderTarget.prototype.build = function() {
			var i, make, target;
			make = (function(_this) {
				return function() {
					return new THREE.WebGLRenderTarget(_this.width, _this.height, _this.options);
				};
			})(this);
			this.targets = (function() {
				var j, ref, results;
				results = [];
				for (i = j = 0, ref = this.buffers; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
					results.push(make());
				}
				return results;
			}).call(this);
			this.reads = (function() {
				var j, len, ref, results;
				ref = this.targets;
				results = [];
				for (j = 0, len = ref.length; j < len; j++) {
					target = ref[j];
					results.push(target.texture);
				}
				return results;
			}).call(this);
			this.write = this.targets[this.buffers - 1];
			return this.uniforms = {
				dataResolution: {
					type: 'v2',
					value: new THREE.Vector2(1 / this.width, 1 / this.height)
				},
				dataTexture: {
					type: 't',
					value: this.reads[0]
				},
				dataTextures: {
					type: 'tv',
					value: this.reads
				}
			};
		};
	
		RenderTarget.prototype.cycle = function() {
			this.targets.unshift(this.targets.pop());
			this.write = this.targets[this.buffers - 1];
			this.reads.unshift(this.reads.pop());
			return this.uniforms.dataTexture.value = this.reads[0];
		};
	
		RenderTarget.prototype.warmup = function(callback) {
			var i, j, ref, results;
			results = [];
			for (i = j = 0, ref = this.buffers; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
				callback(this.write);
				results.push(this.cycle());
			}
			return results;
		};
	
		RenderTarget.prototype.dispose = function() {
			var j, len, ref, target;
			ref = this.targets;
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				target.dispose();
			}
			return this.targets = this.reads = this.write = null;
		};
	
		return RenderTarget;
	
	})();
	
	module.exports = RenderTarget;
	
	
	/***/ }),
	/* 199 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Buffer, Memo, MemoScreen, Readback, Renderable, THREE, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Renderable = __webpack_require__(10);
	
	Buffer = __webpack_require__(30);
	
	Memo = __webpack_require__(59);
	
	MemoScreen = __webpack_require__(57);
	
	Util = __webpack_require__(0);
	
	
	/*
	 * Readback up to 4D array of up to 4D data from GL
	 */
	
	Readback = (function(superClass) {
		extend(Readback, superClass);
	
		function Readback(renderer, shaders, options) {
			if (this.items == null) {
				this.items = options.items || 1;
			}
			if (this.channels == null) {
				this.channels = options.channels || 4;
			}
			if (this.width == null) {
				this.width = options.width || 1;
			}
			if (this.height == null) {
				this.height = options.height || 1;
			}
			if (this.depth == null) {
				this.depth = options.depth || 1;
			}
			if (this.type == null) {
				this.type = options.type || THREE.FloatType;
			}
			if (this.stpq == null) {
				this.stpq = options.stpq || false;
			}
			this.isFloat = this.type === THREE.FloatType;
			this.active = this.sampled = this.rect = this.pad = null;
			Readback.__super__.constructor.call(this, renderer, shaders);
			this.build(options);
	
			/*
			 * log precision
			gl = @gl
			for name, pass of {Vertex: gl.VERTEX_SHADER, Fragment: gl.FRAGMENT_SHADER}
				bits = for prec in [gl.LOW_FLOAT, gl.MEDIUM_FLOAT, gl.HIGH_FLOAT]
					gl.getShaderPrecisionFormat(pass, prec).precision
				console.log name, 'shader precision',  bits
			 */
		}
	
		Readback.prototype.build = function(options) {
			var channels, depth, encoder, h, height, indexer, isIndexed, items, map, ref, sampler, stpq, stretch, w, width;
			map = options.map;
			indexer = options.indexer;
			isIndexed = (indexer != null) && !indexer.empty();
			ref = this, items = ref.items, width = ref.width, height = ref.height, depth = ref.depth, stpq = ref.stpq;
			sampler = map;
			if (isIndexed) {
				this._adopt({
					indexModulus: {
						type: 'v4',
						value: new THREE.Vector4(items, items * width, items * width * height, 1)
					}
				});
				sampler = this.shaders.shader();
				sampler.require(map);
				sampler.require(indexer);
				sampler.pipe('float.index.pack', this.uniforms);
			}
			if (this.isFloat && this.channels > 1) {
				this.floatMemo = new Memo(this.renderer, this.shaders, {
					items: items,
					channels: 4,
					width: width,
					height: height,
					depth: depth,
					history: 0,
					type: THREE.FloatType
				});
				this.floatCompose = new MemoScreen(this.renderer, this.shaders, {
					map: sampler,
					items: items,
					width: width,
					height: height,
					depth: depth,
					stpq: stpq
				});
				this.floatMemo.adopt(this.floatCompose);
				stpq = false;
				sampler = this.shaders.shader();
				this.floatMemo.shaderAbsolute(sampler);
			}
			if (this.isFloat) {
				stretch = this.channels;
				channels = 4;
			} else {
				stretch = 1;
				channels = this.channels;
			}
			if (stretch > 1) {
				encoder = this.shaders.shader();
				encoder.pipe(Util.GLSL.mapByte2FloatOffset(stretch));
				encoder.require(sampler);
				encoder.pipe('float.stretch');
				encoder.pipe('float.encode');
				sampler = encoder;
			} else if (this.isFloat) {
				encoder = this.shaders.shader();
				encoder.pipe(sampler);
				encoder.pipe(Util.GLSL.truncateVec4(4, 1));
				encoder.pipe('float.encode');
				sampler = encoder;
			}
			this.byteMemo = new Memo(this.renderer, this.shaders, {
				items: items * stretch,
				channels: 4,
				width: width,
				height: height,
				depth: depth,
				history: 0,
				type: THREE.UnsignedByteType
			});
			this.byteCompose = new MemoScreen(this.renderer, this.shaders, {
				map: sampler,
				items: items * stretch,
				width: width,
				height: height,
				depth: depth,
				stpq: stpq
			});
			this.byteMemo.adopt(this.byteCompose);
			w = items * width * stretch;
			h = height * depth;
			this.samples = this.width * this.height * this.depth;
			this.bytes = new Uint8Array(w * h * 4);
			if (this.isFloat) {
				this.floats = new Float32Array(this.bytes.buffer);
			}
			this.data = this.isFloat ? this.floats : this.bytes;
			this.streamer = this.generate(this.data);
			this.active = {
				items: 0,
				width: 0,
				height: 0,
				depth: 0
			};
			this.sampled = {
				items: 0,
				width: 0,
				height: 0,
				depth: 0
			};
			this.rect = {
				w: 0,
				h: 0
			};
			this.pad = {
				x: 0,
				y: 0,
				z: 0,
				w: 0
			};
			this.stretch = stretch;
			this.isIndexed = isIndexed;
			return this.setActive(items, width, height, depth);
		};
	
		Readback.prototype.generate = function(data) {
			return Util.Data.getStreamer(data, this.samples, 4, this.items);
		};
	
		Readback.prototype.setActive = function(items, width, height, depth) {
			var h, ref, ref1, ref2, ref3, ref4, ref5, w;
			if (!(items !== this.active.items || width !== this.active.width || height !== this.active.height || depth !== this.active.depth)) {
				return;
			}
			ref = [items, width, height, depth], this.active.items = ref[0], this.active.width = ref[1], this.active.height = ref[2], this.active.depth = ref[3];
			if ((ref1 = this.floatCompose) != null) {
				ref1.cover(width, height, depth);
			}
			if ((ref2 = this.byteCompose) != null) {
				ref2.cover(width * this.stretch, height, depth);
			}
			items = this.items;
			width = this.active.width;
			height = this.depth === 1 ? this.active.height : this.height;
			depth = this.active.depth;
			w = items * width * this.stretch;
			h = height * depth;
			ref3 = [items, width, height, depth], this.sampled.items = ref3[0], this.sampled.width = ref3[1], this.sampled.height = ref3[2], this.sampled.depth = ref3[3];
			ref4 = [w, h], this.rect.w = ref4[0], this.rect.h = ref4[1];
			return ref5 = [this.sampled.width - this.active.width, this.sampled.height - this.active.height, this.sampled.depth - this.active.depth, this.sampled.items - this.active.items], this.pad.x = ref5[0], this.pad.y = ref5[1], this.pad.z = ref5[2], this.pad.w = ref5[3], ref5;
		};
	
		Readback.prototype.update = function(camera) {
			var ref, ref1;
			if ((ref = this.floatMemo) != null) {
				ref.render(camera);
			}
			return (ref1 = this.byteMemo) != null ? ref1.render(camera) : void 0;
		};
	
		Readback.prototype.post = function() {
			this.renderer.setRenderTarget(this.byteMemo.target.reads[0]);
			return this.gl.readPixels(0, 0, this.rect.w, this.rect.h, gl.RGBA, gl.UNSIGNED_BYTE, this.bytes);
		};
	
		Readback.prototype.readFloat = function(n) {
			var ref;
			return (ref = this.floatMemo) != null ? ref.read(n) : void 0;
		};
	
		Readback.prototype.readByte = function(n) {
			var ref;
			return (ref = this.byteMemo) != null ? ref.read(n) : void 0;
		};
	
		Readback.prototype.setCallback = function(callback) {
			return this.emitter = this.callback(callback);
		};
	
		Readback.prototype.callback = function(callback) {
			var f, m, n, o, p;
			if (!this.isIndexed) {
				return callback;
			}
			n = this.width;
			m = this.height;
			o = this.depth;
			p = this.items;
			f = function(x, y, z, w) {
				var idx, ii, jj, kk, ll;
				idx = w;
				ll = idx % p;
				idx = (idx - ll) / p;
				ii = idx % n;
				idx = (idx - ii) / n;
				jj = idx % m;
				idx = (idx - jj) / m;
				kk = idx;
				return callback(x, y, z, w, ii, jj, kk, ll);
			};
			f.reset = function() {
				return typeof callback.reset === "function" ? callback.reset() : void 0;
			};
			return f;
		};
	
		Readback.prototype.iterate = function() {
			var callback, consume, count, done, emit, i, j, k, l, limit, m, n, o, p, padW, padX, padY, padZ, ref, repeat, reset, skip;
			emit = this.emitter;
			if (typeof emit.reset === "function") {
				emit.reset();
			}
			ref = this.streamer, consume = ref.consume, skip = ref.skip, count = ref.count, done = ref.done, reset = ref.reset;
			reset();
			n = this.sampled.width | 0;
			m = this.sampled.height | 0;
			o = this.sampled.depth | 0;
			p = this.sampled.items | 0;
			padX = this.pad.x | 0;
			padY = this.pad.y | 0;
			padZ = this.pad.z | 0;
			padW = this.pad.w | 0;
			limit = n * m * p * (o - padZ);
			if (!this.isIndexed) {
				callback = emit;
				emit = function(x, y, z, w) {
					return callback(x, y, z, w, i, j, k, l);
				};
			}
			i = j = k = l = m = 0;
			while (!done() && m < limit) {
				m++;
				repeat = consume(emit);
				if (++l === p - padW) {
					skip(padX);
					l = 0;
					if (++i === n - padX) {
						skip(p * padX);
						i = 0;
						if (++j === m - padY) {
							skip(p * n * padY);
							j = 0;
							k++;
						}
					}
				}
				if (repeat === false) {
					break;
				}
			}
			return Math.floor(count() / p);
		};
	
		Readback.prototype.dispose = function() {
			var ref, ref1, ref2, ref3, ref4, ref5;
			if ((ref = this.floatMemo) != null) {
				ref.unadopt(this.floatCompose);
			}
			if ((ref1 = this.floatMemo) != null) {
				ref1.dispose();
			}
			if ((ref2 = this.floatCompose) != null) {
				ref2.dispose();
			}
			if ((ref3 = this.byteMemo) != null) {
				ref3.unadopt(this.byteCompose);
			}
			if ((ref4 = this.byteMemo) != null) {
				ref4.dispose();
			}
			if ((ref5 = this.byteCompose) != null) {
				ref5.dispose();
			}
			return this.floatMemo = this.byteMemo = this.floatCompose = this.byteCompose = null;
		};
	
		return Readback;
	
	})(Renderable);
	
	module.exports = Readback;
	
	
	/***/ }),
	/* 200 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var BackedTexture, DataTexture, Util,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Util = __webpack_require__(0);
	
	DataTexture = __webpack_require__(31);
	
	
	/*
	Manually allocated GL texture for data streaming, locally backed.
	
	Allows partial updates via subImage.
	Contains local copy of its data to allow quick resizing without gl.copyTexImage2d
	(which requires render-to-framebuffer)
	 */
	
	BackedTexture = (function(superClass) {
		extend(BackedTexture, superClass);
	
		function BackedTexture(renderer, width, height, channels, options) {
			BackedTexture.__super__.constructor.call(this, renderer, width, height, channels, options);
			this.data = new this.ctor(this.n);
		}
	
		BackedTexture.prototype.resize = function(width, height) {
			var gl, old, oldHeight, oldWidth, state;
			old = this.data;
			oldWidth = this.width;
			oldHeight = this.height;
			this.width = width;
			this.height = height;
			this.n = width * height * this.channels;
			this.data = new this.ctor(this.n);
			gl = this.gl;
			state = this.renderer.state;
			state.bindTexture(gl.TEXTURE_2D, this.texture);
			gl.pixelStorei(gl.UNPACK_ALIGNMENT, 1);
			gl.texImage2D(gl.TEXTURE_2D, 0, this.format, width, height, 0, this.format, this.type, this.data);
			this.uniforms.dataResolution.value.set(1 / width, 1 / height);
			return this.write(old, 0, 0, oldWidth, oldHeight);
		};
	
		BackedTexture.prototype.write = function(src, x, y, w, h) {
			var channels, dst, i, j, k, n, stride, width, ww, xx, yh, yy;
			width = this.width;
			dst = this.data;
			channels = this.channels;
			i = 0;
			if (width === w && x === 0) {
				j = y * w * channels;
				n = w * h * channels;
				while (i < n) {
					dst[j++] = src[i++];
				}
			} else {
				stride = width * channels;
				ww = w * channels;
				xx = x * channels;
				yy = y;
				yh = y + h;
				while (yy < yh) {
					k = 0;
					j = xx + yy * stride;
					while (k++ < ww) {
						dst[j++] = src[i++];
					}
					yy++;
				}
			}
			return BackedTexture.__super__.write.call(this, src, x, y, w, h);
		};
	
		BackedTexture.prototype.dispose = function() {
			this.data = null;
			return BackedTexture.__super__.dispose.apply(this, arguments);
		};
	
		return BackedTexture;
	
	})(DataTexture);
	
	module.exports = BackedTexture;
	
	
	/***/ }),
	/* 201 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Atlas, SCRATCH_SIZE, THREE, TextAtlas,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	THREE = __webpack_require__(1);
	
	Atlas = __webpack_require__(60);
	
	SCRATCH_SIZE = 512 / 16;
	
	
	/*
	 * Dynamic text atlas
	 * - Stores entire strings as sprites
	 * - Renders alpha mask (fast) or signed distance field (slow)
	 * - Emits (x,y,width,height) pointers into the atlas
	 */
	
	TextAtlas = (function(superClass) {
		extend(TextAtlas, superClass);
	
		function TextAtlas(renderer, shaders, options) {
			var ref, ref1, ref2, ref3, ref4, ref5, ua;
			this.font = (ref = options.font) != null ? ref : ['sans-serif'];
			this.size = options.size || 24;
			this.style = (ref1 = options.style) != null ? ref1 : 'normal';
			this.variant = (ref2 = options.variant) != null ? ref2 : 'normal';
			this.weight = (ref3 = options.weight) != null ? ref3 : 'normal';
			this.outline = (ref4 = +((ref5 = options.outline) != null ? ref5 : 5)) != null ? ref4 : 0;
			options.width || (options.width = 256);
			options.height || (options.height = 256);
			options.type = THREE.UnsignedByteType;
			options.channels = 1;
			options.backed = true;
			this.gamma = 1;
			if (typeof navigator !== 'undefined') {
				ua = navigator.userAgent;
				if (ua.match(/Chrome/) && ua.match(/OS X/)) {
					this.gamma = .5;
				}
			}
			this.scratchW = this.scratchH = 0;
			TextAtlas.__super__.constructor.call(this, renderer, shaders, options);
		}
	
		TextAtlas.prototype.build = function(options) {
			var canvas, colors, context, dilate, font, hex, i, k, lineHeight, maxWidth, quote, ref, scratch;
			TextAtlas.__super__.build.call(this, options);
			lineHeight = 16;
			lineHeight = this.size;
			lineHeight += 4 + 2 * Math.min(1, this.outline);
			maxWidth = SCRATCH_SIZE * lineHeight;
			canvas = document.createElement('canvas');
			canvas.width = maxWidth;
			canvas.height = lineHeight;
			quote = function(str) {
				return "\"" + (str.replace(/(['"\\])/g, '\\$1')) + "\"";
			};
			font = this.font.map(quote).join(", ");
			context = canvas.getContext('2d');
			context.font = this.style + " " + this.variant + " " + this.weight + " " + this.size + "px " + this.font;
			context.fillStyle = '#FF0000';
			context.textAlign = 'left';
			context.textBaseline = 'bottom';
			context.lineJoin = 'round';
	
			/*
			document.body.appendChild canvas
			canvas.setAttribute('style', "position: absolute; top: 0; left: 0; z-index: 100; border: 1px solid red; background: rgba(255,0,255,.25);")
			 */
			colors = [];
			dilate = this.outline * 3;
			for (i = k = 0, ref = dilate; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
				hex = ('00' + Math.max(0, -i * 8 + 128 - (!i) * 8).toString(16)).slice(-2);
				colors.push('#' + hex + hex + hex);
			}
			scratch = new Uint8Array(maxWidth * lineHeight * 2);
			this.canvas = canvas;
			this.context = context;
			this.lineHeight = lineHeight;
			this.maxWidth = maxWidth;
			this.colors = colors;
			this.scratch = scratch;
			this._allocate = this.allocate.bind(this);
			return this._write = this.write.bind(this);
		};
	
		TextAtlas.prototype.reset = function() {
			TextAtlas.__super__.reset.apply(this, arguments);
			return this.mapped = {};
		};
	
		TextAtlas.prototype.begin = function() {
			var k, len, ref, results, row;
			ref = this.rows;
			results = [];
			for (k = 0, len = ref.length; k < len; k++) {
				row = ref[k];
				results.push(row.alive = 0);
			}
			return results;
		};
	
		TextAtlas.prototype.end = function() {
			var k, key, l, len, len1, mapped, ref, ref1, row;
			mapped = this.mapped;
			ref = this.rows.slice();
			for (k = 0, len = ref.length; k < len; k++) {
				row = ref[k];
				if (!(row.alive === 0)) {
					continue;
				}
				ref1 = row.keys;
				for (l = 0, len1 = ref1.length; l < len1; l++) {
					key = ref1[l];
					delete mapped[key];
				}
				this.collapse(row);
			}
		};
	
		TextAtlas.prototype.map = function(text, emit) {
			var allocate, c, data, h, mapped, w, write;
			mapped = this.mapped;
			c = mapped[text];
			if (c != null) {
				c.row.alive++;
				return emit(c.x, c.y, c.w, c.h);
			}
			this.draw(text);
			data = this.scratch;
			w = this.scratchW;
			h = this.scratchH;
			allocate = this._allocate;
			write = this._write;
			return allocate(text, w, h, function(row, x, y) {
				mapped[text] = {
					x: x,
					y: y,
					w: w,
					h: h,
					row: row
				};
				write(data, x, y, w, h);
				return emit(x, y, w, h);
			});
		};
	
		TextAtlas.prototype.draw = function(text) {
			var a, b, c, colors, ctx, data, dst, gamma, h, i, imageData, j, k, l, m, mask, max, n, o, ref, ref1, ref2, w, x, y;
			w = this.width;
			h = this.lineHeight;
			o = this.outline;
			ctx = this.context;
			dst = this.scratch;
			max = this.maxWidth;
			colors = this.colors;
			x = o + 1;
			y = Math.round(h * 1.05 - 1);
			m = ctx.measureText(text);
			w = Math.min(max, Math.ceil(m.width + 2 * x + 1));
			ctx.clearRect(0, 0, w, h);
			if (this.outline === 0) {
				ctx.fillText(text, x, y);
				data = (imageData = ctx.getImageData(0, 0, w, h)).data;
				j = 3;
				for (i = k = 0, ref = data.length / 4; 0 <= ref ? k < ref : k > ref; i = 0 <= ref ? ++k : --k) {
					dst[i] = data[j];
					j += 4;
				}
				this.scratchW = w;
				return this.scratchH = h;
			} else {
				ctx.globalCompositeOperation = 'source-over';
				for (i = l = ref1 = o + 1; ref1 <= 1 ? l <= 1 : l >= 1; i = ref1 <= 1 ? ++l : --l) {
					j = i > 1 ? i * 2 - 2 : i;
					ctx.strokeStyle = colors[j - 1];
					ctx.lineWidth = j;
					ctx.strokeText(text, x, y);
				}
				ctx.globalCompositeOperation = 'multiply';
				ctx.fillText(text, x, y);
				data = (imageData = ctx.getImageData(0, 0, w, h)).data;
				j = 0;
				gamma = this.gamma;
				for (i = n = 0, ref2 = data.length / 4; 0 <= ref2 ? n < ref2 : n > ref2; i = 0 <= ref2 ? ++n : --n) {
					a = data[j];
					mask = a ? data[j + 1] / a : 1;
					if (gamma === .5) {
						mask = Math.sqrt(mask);
					}
					mask = Math.min(1, Math.max(0, mask));
					b = 256 - a;
					c = b + (a - b) * mask;
					dst[i] = Math.max(0, Math.min(255, c + 2));
					j += 4;
				}
	
				/*
				j = 0
				for i in [0...data.length / 4]
					v = dst[i]
					#data[j] = v
					#data[j+1] = v
					data[j+2] = v
					data[j+3] = 255
					j += 4
				ctx.putImageData imageData, 0, 0
				 */
				this.scratchW = w;
				return this.scratchH = h;
			}
		};
	
		return TextAtlas;
	
	})(Atlas);
	
	module.exports = TextAtlas;
	
	
	/***/ }),
	/* 202 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Factory = __webpack_require__(203);
	
	exports.Snippets = __webpack_require__(232);
	
	
	/***/ }),
	/* 203 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Factory, ShaderGraph;
	
	ShaderGraph = __webpack_require__(204);
	
	Factory = function(snippets) {
		var fetch;
		fetch = function(name) {
			var element, ref, ref1, s, sel;
			s = snippets[name];
			if (s != null) {
				return s;
			}
			ref = (ref1 = name[0]) === '#' || ref1 === '.' || ref1 === ':' || ref1 === '[';
			sel = ref ? name : "#" + name;
			element = document.querySelector(sel);
			if ((element != null) && element.tagName === 'SCRIPT') {
				return element.textContent || element.innerText;
			}
			throw new Error("Unknown shader `" + name + "`");
		};
		return new ShaderGraph(fetch, {
			autoInspect: true
		});
	};
	
	module.exports = Factory;
	
	
	/***/ }),
	/* 204 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Factory, GLSL, Graph, Linker, ShaderGraph, Snippet, Visualize, cache, inspect, library, merge, visualize;
	
	Block = __webpack_require__(32);
	
	Factory = __webpack_require__(212);
	
	GLSL = __webpack_require__(219);
	
	Graph = __webpack_require__(6);
	
	Linker = __webpack_require__(34);
	
	Visualize = __webpack_require__(37);
	
	library = Factory.library;
	
	cache = Factory.cache;
	
	visualize = Visualize.visualize;
	
	inspect = Visualize.inspect;
	
	Snippet = Linker.Snippet;
	
	merge = function(a, b) {
		var key, out, ref, value;
		if (b == null) {
			b = {};
		}
		out = {};
		for (key in a) {
			value = a[key];
			out[key] = (ref = b[key]) != null ? ref : a[key];
		}
		return out;
	};
	
	ShaderGraph = (function() {
		function ShaderGraph(snippets, config) {
			var defaults;
			if (!(this instanceof ShaderGraph)) {
				return new ShaderGraph(snippets, config);
			}
			defaults = {
				globalUniforms: false,
				globalVaryings: true,
				globalAttributes: true,
				globals: [],
				autoInspect: false
			};
			this.config = merge(defaults, config);
			this.fetch = cache(library(GLSL, snippets, Snippet.load));
		}
	
		ShaderGraph.prototype.shader = function(config) {
			var _config;
			if (config == null) {
				config = {};
			}
			_config = merge(this.config, config);
			return new Factory.Factory(GLSL, this.fetch, _config);
		};
	
		ShaderGraph.prototype.material = function(config) {
			return new Factory.Material(this.shader(config), this.shader(config));
		};
	
		ShaderGraph.prototype.inspect = function(shader) {
			return ShaderGraph.inspect(shader);
		};
	
		ShaderGraph.prototype.visualize = function(shader) {
			return ShaderGraph.visualize(shader);
		};
	
		ShaderGraph.Block = Block;
	
		ShaderGraph.Factory = Factory;
	
		ShaderGraph.GLSL = GLSL;
	
		ShaderGraph.Graph = Graph;
	
		ShaderGraph.Linker = Linker;
	
		ShaderGraph.Visualize = Visualize;
	
		ShaderGraph.inspect = function(shader) {
			return inspect(shader);
		};
	
		ShaderGraph.visualize = function(shader) {
			return visualize(shader);
		};
	
		return ShaderGraph;
	
	})();
	
	module.exports = ShaderGraph;
	
	if (typeof window !== 'undefined') {
		window.ShaderGraph = ShaderGraph;
	}
	
	
	/***/ }),
	/* 205 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Graph, Node, Outlet;
	
	Graph = __webpack_require__(33);
	
	Outlet = __webpack_require__(61);
	
	
	/*
	 Node in graph.
	 */
	
	Node = (function() {
		Node.index = 0;
	
		Node.id = function(name) {
			return ++Node.index;
		};
	
		function Node(owner, outlets) {
			this.owner = owner;
			this.graph = null;
			this.inputs = [];
			this.outputs = [];
			this.all = [];
			this.outlets = null;
			this.id = Node.id();
			this.setOutlets(outlets);
		}
	
		Node.prototype.getIn = function(name) {
			var outlet;
			return ((function() {
				var i, len, ref, results;
				ref = this.inputs;
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					outlet = ref[i];
					if (outlet.name === name) {
						results.push(outlet);
					}
				}
				return results;
			}).call(this))[0];
		};
	
		Node.prototype.getOut = function(name) {
			var outlet;
			return ((function() {
				var i, len, ref, results;
				ref = this.outputs;
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					outlet = ref[i];
					if (outlet.name === name) {
						results.push(outlet);
					}
				}
				return results;
			}).call(this))[0];
		};
	
		Node.prototype.get = function(name) {
			return this.getIn(name) || this.getOut(name);
		};
	
		Node.prototype.setOutlets = function(outlets) {
			var existing, hash, i, j, k, key, len, len1, len2, match, outlet, ref;
			if (outlets != null) {
				if (this.outlets == null) {
					this.outlets = {};
					for (i = 0, len = outlets.length; i < len; i++) {
						outlet = outlets[i];
						if (!(outlet instanceof Outlet)) {
							outlet = Outlet.make(outlet);
						}
						this._add(outlet);
					}
					return;
				}
				hash = function(outlet) {
					return [outlet.name, outlet.inout, outlet.type].join('-');
				};
				match = {};
				for (j = 0, len1 = outlets.length; j < len1; j++) {
					outlet = outlets[j];
					match[hash(outlet)] = true;
				}
				ref = this.outlets;
				for (key in ref) {
					outlet = ref[key];
					key = hash(outlet);
					if (match[key]) {
						match[key] = outlet;
					} else {
						this._remove(outlet);
					}
				}
				for (k = 0, len2 = outlets.length; k < len2; k++) {
					outlet = outlets[k];
					existing = match[hash(outlet)];
					if (existing instanceof Outlet) {
						this._morph(existing, outlet);
					} else {
						if (!(outlet instanceof Outlet)) {
							outlet = Outlet.make(outlet);
						}
						this._add(outlet);
					}
				}
				this;
			}
			return this.outlets;
		};
	
		Node.prototype.connect = function(node, empty, force) {
			var dest, dests, hint, hints, i, j, k, len, len1, len2, list, outlets, ref, ref1, ref2, source, sources, type, typeHint;
			outlets = {};
			hints = {};
			typeHint = function(outlet) {
				return type + '/' + outlet.hint;
			};
			ref = node.inputs;
			for (i = 0, len = ref.length; i < len; i++) {
				dest = ref[i];
				if (!force && dest.input) {
					continue;
				}
				type = dest.type;
				hint = typeHint(dest);
				if (!hints[hint]) {
					hints[hint] = dest;
				}
				outlets[type] = list = outlets[type] || [];
				list.push(dest);
			}
			sources = this.outputs;
			sources = sources.filter(function(outlet) {
				return !(empty && outlet.output.length);
			});
			ref1 = sources.slice();
			for (j = 0, len1 = ref1.length; j < len1; j++) {
				source = ref1[j];
				type = source.type;
				hint = typeHint(source);
				dests = outlets[type];
				if (dest = hints[hint]) {
					source.connect(dest);
					delete hints[hint];
					dests.splice(dests.indexOf(dest), 1);
					sources.splice(sources.indexOf(source), 1);
				}
			}
			if (!sources.length) {
				return this;
			}
			ref2 = sources.slice();
			for (k = 0, len2 = ref2.length; k < len2; k++) {
				source = ref2[k];
				type = source.type;
				dests = outlets[type];
				if (dests && dests.length) {
					source.connect(dests.shift());
				}
			}
			return this;
		};
	
		Node.prototype.disconnect = function(node) {
			var i, j, len, len1, outlet, ref, ref1;
			ref = this.inputs;
			for (i = 0, len = ref.length; i < len; i++) {
				outlet = ref[i];
				outlet.disconnect();
			}
			ref1 = this.outputs;
			for (j = 0, len1 = ref1.length; j < len1; j++) {
				outlet = ref1[j];
				outlet.disconnect();
			}
			return this;
		};
	
		Node.prototype._key = function(outlet) {
			return [outlet.name, outlet.inout].join('-');
		};
	
		Node.prototype._add = function(outlet) {
			var key;
			key = this._key(outlet);
			if (outlet.node) {
				throw new Error("Adding outlet to two nodes at once.");
			}
			if (this.outlets[key]) {
				throw new Error("Adding two identical outlets to same node. (" + key + ")");
			}
			outlet.node = this;
			if (outlet.inout === Graph.IN) {
				this.inputs.push(outlet);
			}
			if (outlet.inout === Graph.OUT) {
				this.outputs.push(outlet);
			}
			this.all.push(outlet);
			return this.outlets[key] = outlet;
		};
	
		Node.prototype._morph = function(existing, outlet) {
			var key;
			key = this._key(outlet);
			delete this.outlets[key];
			existing.morph(outlet);
			key = this._key(outlet);
			return this.outlets[key] = outlet;
		};
	
		Node.prototype._remove = function(outlet) {
			var inout, key;
			key = this._key(outlet);
			inout = outlet.inout;
			if (outlet.node !== this) {
				throw new Error("Removing outlet from wrong node.");
			}
			outlet.disconnect();
			outlet.node = null;
			delete this.outlets[key];
			if (outlet.inout === Graph.IN) {
				this.inputs.splice(this.inputs.indexOf(outlet), 1);
			}
			if (outlet.inout === Graph.OUT) {
				this.outputs.splice(this.outputs.indexOf(outlet), 1);
			}
			this.all.splice(this.all.indexOf(outlet), 1);
			return this;
		};
	
		return Node;
	
	})();
	
	module.exports = Node;
	
	
	/***/ }),
	/* 206 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Program, Snippet, assemble;
	
	Snippet = __webpack_require__(35);
	
	assemble = __webpack_require__(62);
	
	
	/*
		Program assembly model
		
		Snippets are added to its queue, registering calls and code includes.
		Calls are de-duped and scheduled at the earliest point required for correct data flow.
		
		When assemble() is called, it builds a main() function to
		execute all calls in final order.
		
		The result is a new instance of Snippet that acts as if it
		was parsed from the combined source of the component
		nodes.
	 */
	
	Program = (function() {
		Program.index = 0;
	
		Program.entry = function() {
			return "_pg_" + (++Program.index) + "_";
		};
	
		function Program(language, namespace, graph) {
			this.language = language;
			this.namespace = namespace;
			this.graph = graph;
			this.calls = {};
			this.requires = {};
		}
	
		Program.prototype.call = function(node, module, priority) {
			var exists, ns;
			ns = module.namespace;
			if (exists = this.calls[ns]) {
				exists.priority = Math.max(exists.priority, priority);
			} else {
				this.calls[ns] = {
					node: node,
					module: module,
					priority: priority
				};
			}
			return this;
		};
	
		Program.prototype.require = function(node, module) {
			var ns;
			ns = module.namespace;
			return this.requires[ns] = {
				node: node,
				module: module
			};
		};
	
		Program.prototype.assemble = function() {
			var data, key, ref, snippet;
			data = assemble(this.language, (ref = this.namespace) != null ? ref : Program.entry, this.calls, this.requires);
			snippet = new Snippet;
			for (key in data) {
				snippet[key] = data[key];
			}
			snippet.graph = this.graph;
			return snippet;
		};
	
		return Program;
	
	})();
	
	module.exports = Program;
	
	
	/***/ }),
	/* 207 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Layout, Snippet, debug, link;
	
	Snippet = __webpack_require__(35);
	
	link = __webpack_require__(63);
	
	debug = false;
	
	
	/*
		Program linkage layout
		
		Entry points are added to its dependency graph
		Callbacks are linked either with a go-between function
		or a #define if the signatures are identical.
	 */
	
	Layout = (function() {
		function Layout(language, graph) {
			this.language = language;
			this.graph = graph;
			this.links = [];
			this.includes = [];
			this.modules = {};
			this.visits = {};
		}
	
		Layout.prototype.callback = function(node, module, priority, name, external) {
			return this.links.push({
				node: node,
				module: module,
				priority: priority,
				name: name,
				external: external
			});
		};
	
		Layout.prototype.include = function(node, module, priority) {
			var m;
			if ((m = this.modules[module.namespace]) != null) {
				return m.priority = Math.max(priority, m.priority);
			} else {
				this.modules[module.namespace] = true;
				return this.includes.push({
					node: node,
					module: module,
					priority: priority
				});
			}
		};
	
		Layout.prototype.visit = function(namespace) {
			debug && console.log('Visit', namespace, !this.visits[namespace]);
			if (this.visits[namespace]) {
				return false;
			}
			return this.visits[namespace] = true;
		};
	
		Layout.prototype.link = function(module) {
			var data, key, snippet;
			data = link(this.language, this.links, this.includes, module);
			snippet = new Snippet;
			for (key in data) {
				snippet[key] = data[key];
			}
			snippet.graph = this.graph;
			return snippet;
		};
	
		return Layout;
	
	})();
	
	module.exports = Layout;
	
	
	/***/ }),
	/* 208 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Call,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Block = __webpack_require__(17);
	
	Call = (function(superClass) {
		extend(Call, superClass);
	
		function Call(snippet) {
			this.snippet = snippet;
			this.namespace = this.snippet.namespace;
			Call.__super__.constructor.apply(this, arguments);
		}
	
		Call.prototype.clone = function() {
			return new Call(this.snippet);
		};
	
		Call.prototype.makeOutlets = function() {
			var callbacks, externals, key, main, outlet, params, symbols;
			main = this.snippet.main.signature;
			externals = this.snippet.externals;
			symbols = this.snippet.symbols;
			params = (function() {
				var i, len, results;
				results = [];
				for (i = 0, len = main.length; i < len; i++) {
					outlet = main[i];
					results.push(this._outlet(outlet, {
						callback: false
					}));
				}
				return results;
			}).call(this);
			callbacks = (function() {
				var i, len, results;
				results = [];
				for (i = 0, len = symbols.length; i < len; i++) {
					key = symbols[i];
					results.push(this._outlet(externals[key], {
						callback: true
					}));
				}
				return results;
			}).call(this);
			return params.concat(callbacks);
		};
	
		Call.prototype.call = function(program, depth) {
			this._call(this.snippet, program, depth);
			return this._inputs(this.snippet, program, depth);
		};
	
		Call.prototype["export"] = function(layout, depth) {
			if (!layout.visit(this.namespace, depth)) {
				return;
			}
			this._link(this.snippet, layout, depth);
			return this._trace(this.snippet, layout, depth);
		};
	
		return Call;
	
	})(Block);
	
	module.exports = Call;
	
	
	/***/ }),
	/* 209 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Callback, Graph,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Graph = __webpack_require__(6);
	
	Block = __webpack_require__(17);
	
	
	/*
		Re-use a subgraph as a callback
	 */
	
	Callback = (function(superClass) {
		extend(Callback, superClass);
	
		function Callback(graph) {
			this.graph = graph;
			Callback.__super__.constructor.apply(this, arguments);
		}
	
		Callback.prototype.refresh = function() {
			Callback.__super__.refresh.apply(this, arguments);
			return delete this.subroutine;
		};
	
		Callback.prototype.clone = function() {
			return new Callback(this.graph);
		};
	
		Callback.prototype.makeOutlets = function() {
			var handle, i, ins, j, len, len1, outlet, outlets, outs, ref, ref1, type;
			this.make();
			outlets = [];
			ins = [];
			outs = [];
			handle = (function(_this) {
				return function(outlet, list) {
					var base, dupe;
					if (outlet.meta.callback) {
						if (outlet.inout === Graph.IN) {
							dupe = outlet.dupe();
							if ((base = dupe.meta).child == null) {
								base.child = outlet;
							}
							outlet.meta.parent = dupe;
							return outlets.push(dupe);
						}
					} else {
						return list.push(outlet.type);
					}
				};
			})(this);
			ref = this.graph.inputs();
			for (i = 0, len = ref.length; i < len; i++) {
				outlet = ref[i];
				handle(outlet, ins);
			}
			ref1 = this.graph.outputs();
			for (j = 0, len1 = ref1.length; j < len1; j++) {
				outlet = ref1[j];
				handle(outlet, outs);
			}
			ins = ins.join(',');
			outs = outs.join(',');
			type = "(" + ins + ")(" + outs + ")";
			outlets.push({
				name: 'callback',
				type: type,
				inout: Graph.OUT,
				meta: {
					callback: true,
					def: this.subroutine.main
				}
			});
			return outlets;
		};
	
		Callback.prototype.make = function() {
			return this.subroutine = this.graph.compile(this.namespace);
		};
	
		Callback.prototype["export"] = function(layout, depth) {
			if (!layout.visit(this.namespace, depth)) {
				return;
			}
			this._link(this.subroutine, layout, depth);
			return this.graph["export"](layout, depth);
		};
	
		Callback.prototype.call = function(program, depth) {
			return this._require(this.subroutine, program, depth);
		};
	
		Callback.prototype.callback = function(layout, depth, name, external, outlet) {
			this._include(this.subroutine, layout, depth);
			return this._callback(this.subroutine, layout, depth, name, external, outlet);
		};
	
		return Callback;
	
	})(Block);
	
	module.exports = Callback;
	
	
	/***/ }),
	/* 210 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Graph, Isolate,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Graph = __webpack_require__(6);
	
	Block = __webpack_require__(17);
	
	
	/*
		Isolate a subgraph as a single node
	 */
	
	Isolate = (function(superClass) {
		extend(Isolate, superClass);
	
		function Isolate(graph) {
			this.graph = graph;
			Isolate.__super__.constructor.apply(this, arguments);
		}
	
		Isolate.prototype.refresh = function() {
			Isolate.__super__.refresh.apply(this, arguments);
			return delete this.subroutine;
		};
	
		Isolate.prototype.clone = function() {
			return new Isolate(this.graph);
		};
	
		Isolate.prototype.makeOutlets = function() {
			var base, done, dupe, i, j, len, len1, name, outlet, outlets, ref, ref1, ref2, seen, set;
			this.make();
			outlets = [];
			seen = {};
			done = {};
			ref = ['inputs', 'outputs'];
			for (i = 0, len = ref.length; i < len; i++) {
				set = ref[i];
				ref1 = this.graph[set]();
				for (j = 0, len1 = ref1.length; j < len1; j++) {
					outlet = ref1[j];
					name = void 0;
					if (((ref2 = outlet.hint) === 'return' || ref2 === 'callback') && outlet.inout === Graph.OUT) {
						name = outlet.hint;
					}
					if (seen[name] != null) {
						name = void 0;
					}
					dupe = outlet.dupe(name);
					if ((base = dupe.meta).child == null) {
						base.child = outlet;
					}
					outlet.meta.parent = dupe;
					if (name != null) {
						seen[name] = true;
					}
					done[outlet.name] = dupe;
					outlets.push(dupe);
				}
			}
			return outlets;
		};
	
		Isolate.prototype.make = function() {
			return this.subroutine = this.graph.compile(this.namespace);
		};
	
		Isolate.prototype.call = function(program, depth) {
			this._call(this.subroutine, program, depth);
			return this._inputs(this.subroutine, program, depth);
		};
	
		Isolate.prototype["export"] = function(layout, depth) {
			if (!layout.visit(this.namespace, depth)) {
				return;
			}
			this._link(this.subroutine, layout, depth);
			this._trace(this.subroutine, layout, depth);
			return this.graph["export"](layout, depth);
		};
	
		Isolate.prototype.callback = function(layout, depth, name, external, outlet) {
			outlet = outlet.meta.child;
			return outlet.node.owner.callback(layout, depth, name, external, outlet);
		};
	
		return Isolate;
	
	})(Block);
	
	module.exports = Isolate;
	
	
	/***/ }),
	/* 211 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Join,
		extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
		hasProp = {}.hasOwnProperty;
	
	Block = __webpack_require__(17);
	
	
	/*
		Join multiple disconnected nodes
	 */
	
	Join = (function(superClass) {
		extend(Join, superClass);
	
		function Join(nodes) {
			this.nodes = nodes;
			Join.__super__.constructor.apply(this, arguments);
		}
	
		Join.prototype.clone = function() {
			return new Join(this.nodes);
		};
	
		Join.prototype.makeOutlets = function() {
			return [];
		};
	
		Join.prototype.call = function(program, depth) {
			var block, i, len, node, ref, results;
			ref = this.nodes;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				node = ref[i];
				block = node.owner;
				results.push(block.call(program, depth));
			}
			return results;
		};
	
		Join.prototype["export"] = function(layout, depth) {
			var block, i, len, node, ref, results;
			ref = this.nodes;
			results = [];
			for (i = 0, len = ref.length; i < len; i++) {
				node = ref[i];
				block = node.owner;
				results.push(block["export"](layout, depth));
			}
			return results;
		};
	
		return Join;
	
	})(Block);
	
	module.exports = Join;
	
	
	/***/ }),
	/* 212 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Factory = __webpack_require__(213);
	
	exports.Material = __webpack_require__(216);
	
	exports.library = __webpack_require__(217);
	
	exports.cache = __webpack_require__(218);
	
	exports.queue = __webpack_require__(64);
	
	exports.hash = __webpack_require__(38);
	
	
	/***/ }),
	/* 213 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, Factory, Graph, State, Visualize;
	
	Graph = __webpack_require__(6).Graph;
	
	Block = __webpack_require__(32);
	
	Visualize = __webpack_require__(37);
	
	
	/*
		Chainable factory
		
		Exposes methods to build a graph incrementally
	 */
	
	Factory = (function() {
		function Factory(language, fetch, config) {
			this.language = language;
			this.fetch = fetch;
			this.config = config;
			this.graph();
		}
	
		Factory.prototype.pipe = function(name, uniforms, namespace, defines) {
			if (name instanceof Factory) {
				this._concat(name);
			} else if (name != null) {
				this._call(name, uniforms, namespace, defines);
			}
			return this;
		};
	
		Factory.prototype.call = function(name, uniforms, namespace, defines) {
			return this.pipe(name, uniforms, namespace, defines);
		};
	
		Factory.prototype.require = function(name, uniforms, namespace, defines) {
			if (name instanceof Factory) {
				this._import(name);
			} else if (name != null) {
				this.callback();
				this._call(name, uniforms, namespace, defines);
				this.end();
			}
			return this;
		};
	
		Factory.prototype["import"] = function(name, uniforms, namespace, defines) {
			return this.require(name, uniforms, namespace, defines);
		};
	
		Factory.prototype.split = function() {
			this._group('_combine', true);
			return this;
		};
	
		Factory.prototype.fan = function() {
			this._group('_combine', false);
			return this;
		};
	
		Factory.prototype.isolate = function() {
			this._group('_isolate');
			return this;
		};
	
		Factory.prototype.callback = function() {
			this._group('_callback');
			return this;
		};
	
		Factory.prototype.next = function() {
			this._next();
			return this;
		};
	
		Factory.prototype.pass = function() {
			var pass;
			pass = this._stack[2].end;
			this.end();
			this._state.end = this._state.end.concat(pass);
			return this;
		};
	
		Factory.prototype.end = function() {
			var main, op, ref, sub;
			ref = this._exit(), sub = ref[0], main = ref[1];
			op = sub.op;
			if (this[op]) {
				this[op](sub, main);
			}
			return this;
		};
	
		Factory.prototype.join = function() {
			return this.end();
		};
	
		Factory.prototype.graph = function() {
			var graph, ref;
			while (((ref = this._stack) != null ? ref.length : void 0) > 1) {
				this.end();
			}
			if (this._graph) {
				this._tail(this._state, this._graph);
			}
			graph = this._graph;
			this._graph = new Graph;
			this._state = new State;
			this._stack = [this._state];
			return graph;
		};
	
		Factory.prototype.compile = function(namespace) {
			if (namespace == null) {
				namespace = 'main';
			}
			return this.graph().compile(namespace);
		};
	
		Factory.prototype.link = function(namespace) {
			if (namespace == null) {
				namespace = 'main';
			}
			return this.graph().link(namespace);
		};
	
		Factory.prototype.serialize = function() {
			return Visualize.serialize(this._graph);
		};
	
		Factory.prototype.empty = function() {
			return this._graph.nodes.length === 0;
		};
	
		Factory.prototype._concat = function(factory) {
			var block, error;
			if (factory._state.nodes.length === 0) {
				return this;
			}
			this._tail(factory._state, factory._graph);
			try {
				block = new Block.Isolate(factory._graph);
			} catch (error1) {
				error = error1;
				if (this.config.autoInspect) {
					Visualize.inspect(error, this._graph, factory);
				}
				throw error;
			}
			this._auto(block);
			return this;
		};
	
		Factory.prototype._import = function(factory) {
			var block, error;
			if (factory._state.nodes.length === 0) {
				throw "Can't import empty callback";
			}
			this._tail(factory._state, factory._graph);
			try {
				block = new Block.Callback(factory._graph);
			} catch (error1) {
				error = error1;
				if (this.config.autoInspect) {
					Visualize.inspect(error, this._graph, factory);
				}
				throw error;
			}
			this._auto(block);
			return this;
		};
	
		Factory.prototype._combine = function(sub, main) {
			var from, j, k, len, len1, ref, ref1, to;
			ref = sub.start;
			for (j = 0, len = ref.length; j < len; j++) {
				to = ref[j];
				ref1 = main.end;
				for (k = 0, len1 = ref1.length; k < len1; k++) {
					from = ref1[k];
					from.connect(to, sub.multi);
				}
			}
			main.end = sub.end;
			return main.nodes = main.nodes.concat(sub.nodes);
		};
	
		Factory.prototype._isolate = function(sub, main) {
			var block, error, subgraph;
			if (sub.nodes.length) {
				subgraph = this._subgraph(sub);
				this._tail(sub, subgraph);
				try {
					block = new Block.Isolate(subgraph);
				} catch (error1) {
					error = error1;
					if (this.config.autoInspect) {
						Visualize.inspect(error, this._graph, subgraph);
					}
					throw error;
				}
				return this._auto(block);
			}
		};
	
		Factory.prototype._callback = function(sub, main) {
			var block, error, subgraph;
			if (sub.nodes.length) {
				subgraph = this._subgraph(sub);
				this._tail(sub, subgraph);
				try {
					block = new Block.Callback(subgraph);
				} catch (error1) {
					error = error1;
					if (this.config.autoInspect) {
						Visualize.inspect(error, this._graph, subgraph);
					}
					throw error;
				}
				return this._auto(block);
			}
		};
	
		Factory.prototype._call = function(name, uniforms, namespace, defines) {
			var block, snippet;
			snippet = this.fetch(name);
			snippet.bind(this.config, uniforms, namespace, defines);
			block = new Block.Call(snippet);
			return this._auto(block);
		};
	
		Factory.prototype._subgraph = function(sub) {
			var subgraph;
			subgraph = new Graph(null, this._graph);
			subgraph.adopt(sub.nodes);
			return subgraph;
		};
	
		Factory.prototype._tail = function(state, graph) {
			var tail;
			tail = state.end.concat(state.tail);
			tail = tail.filter(function(node, i) {
				return tail.indexOf(node) === i;
			});
			if (tail.length > 1) {
				tail = new Block.Join(tail);
				tail = [tail.node];
				this._graph.add(tail);
			}
			graph.tail = tail[0];
			state.end = tail;
			state.tail = [];
			if (!graph.tail) {
				throw new Error("Cannot finalize empty graph");
			}
			graph.compile = (function(_this) {
				return function(namespace) {
					var error;
					if (namespace == null) {
						namespace = 'main';
					}
					try {
						return graph.tail.owner.compile(_this.language, namespace);
					} catch (error1) {
						error = error1;
						if (_this.config.autoInspect) {
							graph.inspect(error);
						}
						throw error;
					}
				};
			})(this);
			graph.link = (function(_this) {
				return function(namespace) {
					var error;
					if (namespace == null) {
						namespace = 'main';
					}
					try {
						return graph.tail.owner.link(_this.language, namespace);
					} catch (error1) {
						error = error1;
						if (_this.config.autoInspect) {
							graph.inspect(error);
						}
						throw error;
					}
				};
			})(this);
			graph["export"] = (function(_this) {
				return function(layout, depth) {
					return graph.tail.owner["export"](layout, depth);
				};
			})(this);
			return graph.inspect = function(message) {
				if (message == null) {
					message = null;
				}
				return Visualize.inspect(message, graph);
			};
		};
	
		Factory.prototype._group = function(op, multi) {
			this._push(op, multi);
			this._push();
			return this;
		};
	
		Factory.prototype._next = function() {
			var sub;
			sub = this._pop();
			this._state.start = this._state.start.concat(sub.start);
			this._state.end = this._state.end.concat(sub.end);
			this._state.nodes = this._state.nodes.concat(sub.nodes);
			this._state.tail = this._state.tail.concat(sub.tail);
			return this._push();
		};
	
		Factory.prototype._exit = function() {
			this._next();
			this._pop();
			return [this._pop(), this._state];
		};
	
		Factory.prototype._push = function(op, multi) {
			this._stack.unshift(new State(op, multi));
			return this._state = this._stack[0];
		};
	
		Factory.prototype._pop = function() {
			var ref;
			this._state = this._stack[1];
			if (this._state == null) {
				this._state = new State;
			}
			return (ref = this._stack.shift()) != null ? ref : new State;
		};
	
		Factory.prototype._auto = function(block) {
			if (block.node.inputs.length) {
				return this._append(block);
			} else {
				return this._insert(block);
			}
		};
	
		Factory.prototype._append = function(block) {
			var end, j, len, node, ref;
			node = block.node;
			this._graph.add(node);
			ref = this._state.end;
			for (j = 0, len = ref.length; j < len; j++) {
				end = ref[j];
				end.connect(node);
			}
			if (!this._state.start.length) {
				this._state.start = [node];
			}
			this._state.end = [node];
			this._state.nodes.push(node);
			if (!node.outputs.length) {
				return this._state.tail.push(node);
			}
		};
	
		Factory.prototype._prepend = function(block) {
			var j, len, node, ref, start;
			node = block.node;
			this._graph.add(node);
			ref = this._state.start;
			for (j = 0, len = ref.length; j < len; j++) {
				start = ref[j];
				node.connect(start);
			}
			if (!this._state.end.length) {
				this._state.end = [node];
			}
			this._state.start = [node];
			this._state.nodes.push(node);
			if (!node.outputs.length) {
				return this._state.tail.push(node);
			}
		};
	
		Factory.prototype._insert = function(block) {
			var node;
			node = block.node;
			this._graph.add(node);
			this._state.start.push(node);
			this._state.end.push(node);
			this._state.nodes.push(node);
			if (!node.outputs.length) {
				return this._state.tail.push(node);
			}
		};
	
		return Factory;
	
	})();
	
	State = (function() {
		function State(op1, multi1, start1, end1, nodes, tail1) {
			this.op = op1 != null ? op1 : null;
			this.multi = multi1 != null ? multi1 : false;
			this.start = start1 != null ? start1 : [];
			this.end = end1 != null ? end1 : [];
			this.nodes = nodes != null ? nodes : [];
			this.tail = tail1 != null ? tail1 : [];
		}
	
		return State;
	
	})();
	
	module.exports = Factory;
	
	
	/***/ }),
	/* 214 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Block, isCallback, serialize;
	
	Block = __webpack_require__(32);
	
	isCallback = function(outlet) {
		return outlet.type[0] === '(';
	};
	
	serialize = function(graph) {
		var block, format, i, inputs, j, k, l, len, len1, len2, len3, links, node, nodes, other, outlet, outputs, record, ref, ref1, ref2, ref3, ref4;
		nodes = [];
		links = [];
		ref = graph.nodes;
		for (i = 0, len = ref.length; i < len; i++) {
			node = ref[i];
			record = {
				id: node.id,
				name: null,
				type: null,
				depth: null,
				graph: null,
				inputs: [],
				outputs: []
			};
			nodes.push(record);
			inputs = record.inputs;
			outputs = record.outputs;
			block = node.owner;
			if (block instanceof Block.Call) {
				record.name = block.snippet._name;
				record.type = 'call';
				record.code = block.snippet._original;
			} else if (block instanceof Block.Callback) {
				record.name = "Callback";
				record.type = 'callback';
				record.graph = serialize(block.graph);
			} else if (block instanceof Block.Isolate) {
				record.name = 'Isolate';
				record.type = 'isolate';
				record.graph = serialize(block.graph);
			} else if (block instanceof Block.Join) {
				record.name = 'Join';
				record.type = 'join';
			} else if (block != null) {
				if (record.name == null) {
					record.name = (ref1 = block.name) != null ? ref1 : block.type;
				}
				if (record.type == null) {
					record.type = block.type;
				}
				if (record.code == null) {
					record.code = block.code;
				}
				if (block.graph != null) {
					record.graph = serialize(block.graph);
				}
			}
			format = function(type) {
				type = type.replace(")(", ")(");
				return type = type.replace("()", "");
			};
			ref2 = node.inputs;
			for (j = 0, len1 = ref2.length; j < len1; j++) {
				outlet = ref2[j];
				inputs.push({
					id: outlet.id,
					name: outlet.name,
					type: format(outlet.type),
					open: outlet.input == null
				});
			}
			ref3 = node.outputs;
			for (k = 0, len2 = ref3.length; k < len2; k++) {
				outlet = ref3[k];
				outputs.push({
					id: outlet.id,
					name: outlet.name,
					type: format(outlet.type),
					open: !outlet.output.length
				});
				ref4 = outlet.output;
				for (l = 0, len3 = ref4.length; l < len3; l++) {
					other = ref4[l];
					links.push({
						from: node.id,
						out: outlet.id,
						to: other.node.id,
						"in": other.id,
						type: format(outlet.type)
					});
				}
			}
		}
		return {
			nodes: nodes,
			links: links
		};
	};
	
	module.exports = serialize;
	
	
	/***/ }),
	/* 215 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var _activate, _markup, _order, connect, cssColor, escapeText, hash, hashColor, makeSVG, merge, overlay, path, process, sqr, trim, wrap;
	
	hash = __webpack_require__(38);
	
	trim = function(string) {
		return ("" + string).replace(/^\s+|\s+$/g, '');
	};
	
	cssColor = function(r, g, b, alpha) {
		return 'rgba(' + [r, g, b, alpha].join(', ') + ')';
	};
	
	hashColor = function(string, alpha) {
		var b, color, g, max, min, norm, r;
		if (alpha == null) {
			alpha = 1;
		}
		color = hash(string) ^ 0x123456;
		r = color & 0xFF;
		g = (color >>> 8) & 0xFF;
		b = (color >>> 16) & 0xFF;
		max = Math.max(r, g, b);
		norm = 140 / max;
		min = Math.round(max / 3);
		r = Math.min(255, Math.round(norm * Math.max(r, min)));
		g = Math.min(255, Math.round(norm * Math.max(g, min)));
		b = Math.min(255, Math.round(norm * Math.max(b, min)));
		return cssColor(r, g, b, alpha);
	};
	
	escapeText = function(string) {
		string = string != null ? string : "";
		return string.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/'/g, '&#39;').replace(/"/g, '&quot;');
	};
	
	process = function(data) {
		var el, links;
		links = [];
		el = _markup(data, links);
		el.update = function() {
			return connect(el, links);
		};
		_activate(el);
		return el;
	};
	
	_activate = function(el) {
		var code, codes, i, len, results;
		codes = el.querySelectorAll('.shadergraph-code');
		results = [];
		for (i = 0, len = codes.length; i < len; i++) {
			code = codes[i];
			results.push((function() {
				var popup;
				popup = code;
				popup.parentNode.classList.add('shadergraph-has-code');
				return popup.parentNode.addEventListener('click', function(event) {
					return popup.style.display = {
						block: 'none',
						none: 'block'
					}[popup.style.display || 'none'];
				});
			})());
		}
		return results;
	};
	
	_order = function(data) {
		var i, j, k, len, len1, len2, link, linkMap, name, node, nodeMap, recurse, ref1, ref2, ref3;
		nodeMap = {};
		linkMap = {};
		ref1 = data.nodes;
		for (i = 0, len = ref1.length; i < len; i++) {
			node = ref1[i];
			nodeMap[node.id] = node;
		}
		ref2 = data.links;
		for (j = 0, len1 = ref2.length; j < len1; j++) {
			link = ref2[j];
			if (linkMap[name = link.from] == null) {
				linkMap[name] = [];
			}
			linkMap[link.from].push(link);
		}
		recurse = function(node, depth) {
			var k, len2, next, ref3;
			if (depth == null) {
				depth = 0;
			}
			node.depth = Math.max((ref3 = node.depth) != null ? ref3 : 0, depth);
			if (next = linkMap[node.id]) {
				for (k = 0, len2 = next.length; k < len2; k++) {
					link = next[k];
					recurse(nodeMap[link.to], depth + 1);
				}
			}
			return null;
		};
		ref3 = data.nodes;
		for (k = 0, len2 = ref3.length; k < len2; k++) {
			node = ref3[k];
			if (node.depth == null) {
				recurse(node);
			}
		}
		return null;
	};
	
	_markup = function(data, links) {
		var addOutlet, block, clear, color, column, columns, div, i, j, k, l, len, len1, len2, len3, len4, link, m, node, outlet, outlets, ref1, ref2, ref3, ref4, wrapper;
		_order(data);
		wrapper = document.createElement('div');
		wrapper.classList.add('shadergraph-graph');
		columns = [];
		outlets = {};
		ref1 = data.nodes;
		for (i = 0, len = ref1.length; i < len; i++) {
			node = ref1[i];
			block = document.createElement('div');
			block.classList.add("shadergraph-node");
			block.classList.add("shadergraph-node-" + node.type);
			block.innerHTML = "<div class=\"shadergraph-header\">" + (escapeText(node.name)) + "</div>";
			addOutlet = function(outlet, inout) {
				var color, div;
				color = hashColor(outlet.type);
				div = document.createElement('div');
				div.classList.add('shadergraph-outlet');
				div.classList.add("shadergraph-outlet-" + inout);
				div.innerHTML = "<div class=\"shadergraph-point\" style=\"background: " + color + "\"></div>\n<div class=\"shadergraph-type\" style=\"color: " + color + "\">" + (escapeText(outlet.type)) + "</div>\n<div class=\"shadergraph-name\">" + (escapeText(outlet.name)) + "</div>";
				block.appendChild(div);
				return outlets[outlet.id] = div.querySelector('.shadergraph-point');
			};
			ref2 = node.inputs;
			for (j = 0, len1 = ref2.length; j < len1; j++) {
				outlet = ref2[j];
				addOutlet(outlet, 'in');
			}
			ref3 = node.outputs;
			for (k = 0, len2 = ref3.length; k < len2; k++) {
				outlet = ref3[k];
				addOutlet(outlet, 'out');
			}
			if (node.graph != null) {
				block.appendChild(_markup(node.graph, links));
			} else {
				clear = document.createElement('div');
				clear.classList.add('shadergraph-clear');
				block.appendChild(clear);
			}
			if (node.code != null) {
				div = document.createElement('div');
				div.classList.add('shadergraph-code');
				div.innerHTML = escapeText(trim(node.code));
				block.appendChild(div);
			}
			column = columns[node.depth];
			if (column == null) {
				column = document.createElement('div');
				column.classList.add('shadergraph-column');
				columns[node.depth] = column;
			}
			column.appendChild(block);
		}
		for (l = 0, len3 = columns.length; l < len3; l++) {
			column = columns[l];
			if (column != null) {
				wrapper.appendChild(column);
			}
		}
		ref4 = data.links;
		for (m = 0, len4 = ref4.length; m < len4; m++) {
			link = ref4[m];
			color = hashColor(link.type);
			links.push({
				color: color,
				out: outlets[link.out],
				"in": outlets[link["in"]]
			});
		}
		return wrapper;
	};
	
	sqr = function(x) {
		return x * x;
	};
	
	path = function(x1, y1, x2, y2) {
		var d, dx, dy, f, h, mx, my, vert;
		dx = x2 - x1;
		dy = y2 - y1;
		d = Math.sqrt(sqr(dx) + sqr(dy));
		vert = Math.abs(dy) > Math.abs(dx);
		if (vert) {
			mx = (x1 + x2) / 2;
			my = (y1 + y2) / 2;
			f = dy > 0 ? .3 : -.3;
			h = Math.min(Math.abs(dx) / 2, 20 + d / 8);
			return ['M', x1, y1, 'C', x1 + h, y1 + ',', mx, my - d * f, mx, my, 'C', mx, my + d * f, x2 - h, y2 + ',', x2, y2].join(' ');
		} else {
			h = Math.min(Math.abs(dx) / 2.5, 20 + d / 4);
			return ['M', x1, y1, 'C', x1 + h, y1 + ',', x2 - h, y2 + ',', x2, y2].join(' ');
		}
	};
	
	makeSVG = function(tag) {
		if (tag == null) {
			tag = 'svg';
		}
		return document.createElementNS('http://www.w3.org/2000/svg', tag);
	};
	
	connect = function(element, links) {
		var a, b, box, c, i, j, len, len1, line, link, ref, svg;
		if (element.parentNode == null) {
			return;
		}
		ref = element.getBoundingClientRect();
		for (i = 0, len = links.length; i < len; i++) {
			link = links[i];
			a = link.out.getBoundingClientRect();
			b = link["in"].getBoundingClientRect();
			link.coords = {
				x1: (a.left + a.right) / 2 - ref.left,
				y1: (a.top + a.bottom) / 2 - ref.top,
				x2: (b.left + b.right) / 2 - ref.left,
				y2: (b.top + b.bottom) / 2 - ref.top
			};
		}
		svg = element.querySelector('svg');
		if (svg != null) {
			element.removeChild(svg);
		}
		box = element;
		while (box.parentNode && box.offsetHeight === 0) {
			box = box.parentNode;
		}
		svg = makeSVG();
		svg.setAttribute('width', box.offsetWidth);
		svg.setAttribute('height', box.offsetHeight);
		for (j = 0, len1 = links.length; j < len1; j++) {
			link = links[j];
			c = link.coords;
			line = makeSVG('path');
			line.setAttribute('d', path(c.x1, c.y1, c.x2, c.y2));
			line.setAttribute('stroke', link.color);
			line.setAttribute('stroke-width', 3);
			line.setAttribute('fill', 'transparent');
			svg.appendChild(line);
		}
		return element.appendChild(svg);
	};
	
	overlay = function(contents) {
		var close, div, inside, view;
		div = document.createElement('div');
		div.setAttribute('class', 'shadergraph-overlay');
		close = document.createElement('div');
		close.setAttribute('class', 'shadergraph-close');
		close.innerHTML = '&times;';
		view = document.createElement('div');
		view.setAttribute('class', 'shadergraph-view');
		inside = document.createElement('div');
		inside.setAttribute('class', 'shadergraph-inside');
		inside.appendChild(contents);
		view.appendChild(inside);
		div.appendChild(view);
		div.appendChild(close);
		close.addEventListener('click', function() {
			return div.parentNode.removeChild(div);
		});
		return div;
	};
	
	wrap = function(markup) {
		var p;
		if (markup instanceof Node) {
			return markup;
		}
		p = document.createElement('span');
		p.innerText = markup != null ? markup : '';
		return p;
	};
	
	merge = function(markup) {
		var div, el, i, len;
		if (markup.length !== 1) {
			div = document.createElement('div');
			for (i = 0, len = markup.length; i < len; i++) {
				el = markup[i];
				div.appendChild(wrap(el));
			}
			div.update = function() {
				var j, len1, results;
				results = [];
				for (j = 0, len1 = markup.length; j < len1; j++) {
					el = markup[j];
					results.push(typeof el.update === "function" ? el.update() : void 0);
				}
				return results;
			};
			return div;
		} else {
			return wrap(markup[0]);
		}
	};
	
	module.exports = {
		process: process,
		merge: merge,
		overlay: overlay
	};
	
	
	/***/ }),
	/* 216 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Material, Visualize, debug, tick;
	
	debug = false;
	
	Visualize = __webpack_require__(37);
	
	tick = function() {
		var now;
		now = +(new Date);
		return function(label) {
			var delta;
			delta = +new Date() - now;
			console.log(label, delta + " ms");
			return delta;
		};
	};
	
	Material = (function() {
		function Material(vertex1, fragment1) {
			this.vertex = vertex1;
			this.fragment = fragment1;
			if (debug) {
				this.tock = tick();
			}
		}
	
		Material.prototype.build = function(options) {
			return this.link(options);
		};
	
		Material.prototype.link = function(options) {
			var attributes, fragment, i, key, len, ref, ref1, ref2, ref3, shader, uniforms, value, varyings, vertex;
			if (options == null) {
				options = {};
			}
			uniforms = {};
			varyings = {};
			attributes = {};
			vertex = this.vertex.link('main');
			fragment = this.fragment.link('main');
			ref = [vertex, fragment];
			for (i = 0, len = ref.length; i < len; i++) {
				shader = ref[i];
				ref1 = shader.uniforms;
				for (key in ref1) {
					value = ref1[key];
					uniforms[key] = value;
				}
				ref2 = shader.varyings;
				for (key in ref2) {
					value = ref2[key];
					varyings[key] = value;
				}
				ref3 = shader.attributes;
				for (key in ref3) {
					value = ref3[key];
					attributes[key] = value;
				}
			}
			options.vertexShader = vertex.code;
			options.vertexGraph = vertex.graph;
			options.fragmentShader = fragment.code;
			options.fragmentGraph = fragment.graph;
			options.attributes = attributes;
			options.uniforms = uniforms;
			options.varyings = varyings;
			options.inspect = function() {
				return Visualize.inspect('Vertex Shader', vertex, 'Fragment Shader', fragment.graph);
			};
			if (debug) {
				this.tock('Material build');
			}
			return options;
		};
	
		Material.prototype.inspect = function() {
			return Visualize.inspect('Vertex Shader', this.vertex, 'Fragment Shader', this.fragment.graph);
		};
	
		return Material;
	
	})();
	
	module.exports = Material;
	
	
	/***/ }),
	/* 217 */
	/***/ (function(module, exports) {
	
	
	/*
		Snippet library
		
		Takes:
			- Hash of snippets: named library
			- (name) -> getter: dynamic lookup
			- nothing:          no library, only pass in inline source code
		
		If 'name' contains any of "{;(#" it is assumed to be direct GLSL code.
	 */
	var library;
	
	library = function(language, snippets, load) {
		var callback, fetch, inline, used;
		callback = null;
		used = {};
		if (snippets != null) {
			if (typeof snippets === 'function') {
				callback = function(name) {
					return load(language, name, snippets(name));
				};
			} else if (typeof snippets === 'object') {
				callback = function(name) {
					if (snippets[name] == null) {
						throw new Error("Unknown snippet `" + name + "`");
					}
					return load(language, name, snippets[name]);
				};
			}
		}
		inline = function(code) {
			return load(language, '', code);
		};
		if (callback == null) {
			return inline;
		}
		fetch = function(name) {
			if (name.match(/[{;]/)) {
				return inline(name);
			}
			used[name] = true;
			return callback(name);
		};
		fetch.used = function(_used) {
			if (_used == null) {
				_used = used;
			}
			return used = _used;
		};
		return fetch;
	};
	
	module.exports = library;
	
	
	/***/ }),
	/* 218 */
	/***/ (function(module, exports, __webpack_require__) {
	
	
	/*
		Cache decorator  
		Fetches snippets once, clones for reuse
		Inline code is hashed to avoid bloat
	 */
	var cache, hash, queue;
	
	queue = __webpack_require__(64);
	
	hash = __webpack_require__(38);
	
	cache = function(fetch) {
		var cached, push;
		cached = {};
		push = queue(100);
		return function(name) {
			var expire, key;
			key = name.length > 32 ? '##' + hash(name).toString(16) : name;
			expire = push(key);
			if (expire != null) {
				delete cached[expire];
			}
			if (cached[key] == null) {
				cached[key] = fetch(name);
			}
			return cached[key].clone();
		};
	};
	
	module.exports = cache;
	
	
	/***/ }),
	/* 219 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var i, k, len, ref, v;
	
	exports.compile = __webpack_require__(220);
	
	exports.parse = __webpack_require__(221);
	
	exports.generate = __webpack_require__(231);
	
	ref = __webpack_require__(39);
	for (v = i = 0, len = ref.length; i < len; v = ++i) {
		k = ref[v];
		exports[k] = v;
	}
	
	
	/***/ }),
	/* 220 */
	/***/ (function(module, exports) {
	
	
	/*
		Compile snippet back into GLSL, but with certain symbols replaced by prefixes / placeholders
	 */
	var compile, replaced, string_compiler, tick;
	
	compile = function(program) {
		var assembler, ast, code, placeholders, signatures;
		ast = program.ast, code = program.code, signatures = program.signatures;
		placeholders = replaced(signatures);
		assembler = string_compiler(code, placeholders);
		return [signatures, assembler];
	};
	
	tick = function() {
		var now;
		now = +(new Date);
		return function(label) {
			var delta;
			delta = +new Date() - now;
			console.log(label, delta + " ms");
			return delta;
		};
	};
	
	replaced = function(signatures) {
		var i, j, key, len, len1, out, ref, ref1, s, sig;
		out = {};
		s = function(sig) {
			return out[sig.name] = true;
		};
		s(signatures.main);
		ref = ['external', 'internal', 'varying', 'uniform', 'attribute'];
		for (i = 0, len = ref.length; i < len; i++) {
			key = ref[i];
			ref1 = signatures[key];
			for (j = 0, len1 = ref1.length; j < len1; j++) {
				sig = ref1[j];
				s(sig);
			}
		}
		return out;
	};
	
	
	/*
	String-replacement based compiler
	 */
	
	string_compiler = function(code, placeholders) {
		var key, re;
		re = new RegExp('\\b(' + ((function() {
			var results;
			results = [];
			for (key in placeholders) {
				results.push(key);
			}
			return results;
		})()).join('|') + ')\\b', 'g');
		code = code.replace(/\/\/[^\n]*/g, '');
		code = code.replace(/\/\*([^*]|\*[^\/])*\*\//g, '');
		return function(prefix, exceptions, defines) {
			var compiled, defs, replace, value;
			if (prefix == null) {
				prefix = '';
			}
			if (exceptions == null) {
				exceptions = {};
			}
			if (defines == null) {
				defines = {};
			}
			replace = {};
			for (key in placeholders) {
				replace[key] = exceptions[key] != null ? key : prefix + key;
			}
			compiled = code.replace(re, function(key) {
				return replace[key];
			});
			defs = (function() {
				var results;
				results = [];
				for (key in defines) {
					value = defines[key];
					results.push("#define " + key + " " + value);
				}
				return results;
			})();
			if (defs.length) {
				defs.push('');
			}
			return defs.join("\n") + compiled;
		};
	};
	
	module.exports = compile;
	
	
	/***/ }),
	/* 221 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var $, collect, debug, decl, extractSignatures, mapSymbols, parse, parseGLSL, parser, processAST, sortSymbols, tick, tokenizer, walk;
	
	tokenizer = __webpack_require__(222);
	
	parser = __webpack_require__(226);
	
	decl = __webpack_require__(230);
	
	$ = __webpack_require__(39);
	
	debug = false;
	
	
	/*
	parse GLSL into AST
	extract all global symbols and make type signatures
	 */
	
	parse = function(name, code) {
		var ast, program;
		ast = parseGLSL(name, code);
		return program = processAST(ast, code);
	};
	
	parseGLSL = function(name, code) {
		var ast, e, error, errors, fmt, j, len, ref, ref1, tock;
		if (debug) {
			tock = tick();
		}
		try {
			ref = tokenizer().process(parser(), code), (ref1 = ref[0], ast = ref1[0]), errors = ref[1];
		} catch (error1) {
			e = error1;
			errors = [
				{
					message: e
				}
			];
		}
		if (debug) {
			tock('GLSL Tokenize & Parse');
		}
		fmt = function(code) {
			var max, pad;
			code = code.split("\n");
			max = ("" + code.length).length;
			pad = function(v) {
				if ((v = "" + v).length < max) {
					return ("       " + v).slice(-max);
				} else {
					return v;
				}
			};
			return code.map(function(line, i) {
				return (pad(i + 1)) + ": " + line;
			}).join("\n");
		};
		if (!ast || errors.length) {
			if (!name) {
				name = '(inline code)';
			}
			console.warn(fmt(code));
			for (j = 0, len = errors.length; j < len; j++) {
				error = errors[j];
				console.error(name + " -", error.message);
			}
			throw new Error("GLSL parse error");
		}
		return ast;
	};
	
	processAST = function(ast, code) {
		var externals, internals, main, ref, signatures, symbols, tock;
		if (debug) {
			tock = tick();
		}
		symbols = [];
		walk(mapSymbols, collect(symbols), ast, '');
		ref = sortSymbols(symbols), main = ref[0], internals = ref[1], externals = ref[2];
		signatures = extractSignatures(main, internals, externals);
		if (debug) {
			tock('GLSL AST');
		}
		return {
			ast: ast,
			code: code,
			signatures: signatures
		};
	};
	
	mapSymbols = function(node, collect) {
		switch (node.type) {
			case 'decl':
				collect(decl.node(node));
				return false;
		}
		return true;
	};
	
	collect = function(out) {
		return function(value) {
			var j, len, obj, results;
			if (value != null) {
				results = [];
				for (j = 0, len = value.length; j < len; j++) {
					obj = value[j];
					results.push(out.push(obj));
				}
				return results;
			}
		};
	};
	
	sortSymbols = function(symbols) {
		var e, externals, found, internals, j, len, main, maybe, s;
		main = null;
		internals = [];
		externals = [];
		maybe = {};
		found = false;
		for (j = 0, len = symbols.length; j < len; j++) {
			s = symbols[j];
			if (!s.body) {
				if (s.storage === 'global') {
					internals.push(s);
				} else {
					externals.push(s);
					maybe[s.ident] = true;
				}
			} else {
				if (maybe[s.ident]) {
					externals = (function() {
						var k, len1, results;
						results = [];
						for (k = 0, len1 = externals.length; k < len1; k++) {
							e = externals[k];
							if (e.ident !== s.ident) {
								results.push(e);
							}
						}
						return results;
					})();
					delete maybe[s.ident];
				}
				internals.push(s);
				if (s.ident === 'main') {
					main = s;
					found = true;
				} else if (!found) {
					main = s;
				}
			}
		}
		return [main, internals, externals];
	};
	
	extractSignatures = function(main, internals, externals) {
		var def, defn, func, j, k, len, len1, sigs, symbol;
		sigs = {
			uniform: [],
			attribute: [],
			varying: [],
			external: [],
			internal: [],
			global: [],
			main: null
		};
		defn = function(symbol) {
			return decl.type(symbol.ident, symbol.type, symbol.quant, symbol.count, symbol.inout, symbol.storage);
		};
		func = function(symbol, inout) {
			var a, arg, b, d, def, inTypes, j, len, outTypes, signature, type;
			signature = (function() {
				var j, len, ref, results;
				ref = symbol.args;
				results = [];
				for (j = 0, len = ref.length; j < len; j++) {
					arg = ref[j];
					results.push(defn(arg));
				}
				return results;
			})();
			for (j = 0, len = signature.length; j < len; j++) {
				d = signature[j];
				if (!(d.inout === decl.inout)) {
					continue;
				}
				a = d;
				b = d.copy();
				a.inout = decl["in"];
				b.inout = decl.out;
				b.meta = {
					shadow: a.name
				};
				b.name += $.SHADOW_ARG;
				a.meta = {
					shadowed: b.name
				};
				signature.push(b);
			}
			if (symbol.type !== 'void') {
				signature.unshift(decl.type($.RETURN_ARG, symbol.type, false, '', 'out'));
			}
			inTypes = ((function() {
				var k, len1, results;
				results = [];
				for (k = 0, len1 = signature.length; k < len1; k++) {
					d = signature[k];
					if (d.inout === decl["in"]) {
						results.push(d.type);
					}
				}
				return results;
			})()).join(',');
			outTypes = ((function() {
				var k, len1, results;
				results = [];
				for (k = 0, len1 = signature.length; k < len1; k++) {
					d = signature[k];
					if (d.inout === decl.out) {
						results.push(d.type);
					}
				}
				return results;
			})()).join(',');
			type = "(" + inTypes + ")(" + outTypes + ")";
			return def = {
				name: symbol.ident,
				type: type,
				signature: signature,
				inout: inout,
				spec: symbol.type
			};
		};
		sigs.main = func(main, decl.out);
		for (j = 0, len = internals.length; j < len; j++) {
			symbol = internals[j];
			sigs.internal.push({
				name: symbol.ident
			});
		}
		for (k = 0, len1 = externals.length; k < len1; k++) {
			symbol = externals[k];
			switch (symbol.decl) {
				case 'external':
					def = defn(symbol);
					sigs[symbol.storage].push(def);
					break;
				case 'function':
					def = func(symbol, decl["in"]);
					sigs.external.push(def);
			}
		}
		return sigs;
	};
	
	debug = false;
	
	walk = function(map, collect, node, indent) {
		var child, i, j, len, recurse, ref, ref1, ref2;
		debug && console.log(indent, node.type, (ref = node.token) != null ? ref.data : void 0, (ref1 = node.token) != null ? ref1.type : void 0);
		recurse = map(node, collect);
		if (recurse) {
			ref2 = node.children;
			for (i = j = 0, len = ref2.length; j < len; i = ++j) {
				child = ref2[i];
				walk(map, collect, child, indent + '  ', debug);
			}
		}
		return null;
	};
	
	tick = function() {
		var now;
		now = +(new Date);
		return function(label) {
			var delta;
			delta = +new Date() - now;
			console.log(label, delta + " ms");
			return delta;
		};
	};
	
	module.exports = walk;
	
	module.exports = parse;
	
	
	/***/ }),
	/* 222 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = tokenize
	
	var through = __webpack_require__(65)
	
	var literals = __webpack_require__(223)
		, operators = __webpack_require__(224)
		, builtins = __webpack_require__(225)
	
	var NORMAL = 999          // <-- never emitted
		, TOKEN = 9999          // <-- never emitted 
		, BLOCK_COMMENT = 0 
		, LINE_COMMENT = 1
		, PREPROCESSOR = 2
		, OPERATOR = 3
		, INTEGER = 4
		, FLOAT = 5
		, IDENT = 6
		, BUILTIN = 7
		, KEYWORD = 8
		, WHITESPACE = 9
		, EOF = 10 
		, HEX = 11
	
	var map = [
			'block-comment'
		, 'line-comment'
		, 'preprocessor'
		, 'operator'
		, 'integer'
		, 'float'
		, 'ident'
		, 'builtin'
		, 'keyword'
		, 'whitespace'
		, 'eof'
		, 'integer'
	]
	
	function tokenize() {
		var stream = through(write, end)
	
		var i = 0
			, total = 0
			, mode = NORMAL 
			, c
			, last
			, content = []
			, token_idx = 0
			, token_offs = 0
			, line = 1
			, start = 0
			, isnum = false
			, isoperator = false
			, input = ''
			, len
	
		return stream
	
		function token(data) {
			if(data.length) {
				stream.queue({
					type: map[mode]
				, data: data
				, position: start
				, line: line
				})
			}
		}
	
		function write(chunk) {
			i = 0
			input += chunk.toString()
			len = input.length
	
			while(c = input[i], i < len) switch(mode) {
				case BLOCK_COMMENT: i = block_comment(); break
				case LINE_COMMENT: i = line_comment(); break
				case PREPROCESSOR: i = preprocessor(); break 
				case OPERATOR: i = operator(); break
				case INTEGER: i = integer(); break
				case HEX: i = hex(); break
				case FLOAT: i = decimal(); break
				case TOKEN: i = readtoken(); break
				case WHITESPACE: i = whitespace(); break
				case NORMAL: i = normal(); break
			}
	
			total += i
			input = input.slice(i)
		} 
	
		function end(chunk) {
			if(content.length) {
				token(content.join(''))
			}
	
			mode = EOF
			token('(eof)')
	
			stream.queue(null)
		}
	
		function normal() {
			content = content.length ? [] : content
	
			if(last === '/' && c === '*') {
				start = total + i - 1
				mode = BLOCK_COMMENT
				last = c
				return i + 1
			}
	
			if(last === '/' && c === '/') {
				start = total + i - 1
				mode = LINE_COMMENT
				last = c
				return i + 1
			}
	
			if(c === '#') {
				mode = PREPROCESSOR
				start = total + i
				return i
			}
	
			if(/\s/.test(c)) {
				mode = WHITESPACE
				start = total + i
				return i
			}
	
			isnum = /\d/.test(c)
			isoperator = /[^\w_]/.test(c)
	
			start = total + i
			mode = isnum ? INTEGER : isoperator ? OPERATOR : TOKEN
			return i
		}
	
		function whitespace() {
			if(c === '\n') ++line
	
			if(/[^\s]/g.test(c)) {
				token(content.join(''))
				mode = NORMAL
				return i
			}
			content.push(c)
			last = c
			return i + 1
		}
	
		function preprocessor() {
			if(c === '\n') ++line
	
			if(c === '\n' && last !== '\\') {
				token(content.join(''))
				mode = NORMAL
				return i
			}
			content.push(c)
			last = c
			return i + 1
		}
	
		function line_comment() {
			return preprocessor()
		}
	
		function block_comment() {
			if(c === '/' && last === '*') {
				content.push(c)
				token(content.join(''))
				mode = NORMAL
				return i + 1
			}
	
			if(c === '\n') ++line
	
			content.push(c)
			last = c
			return i + 1
		}
	
		function operator() {
			if(last === '.' && /\d/.test(c)) {
				mode = FLOAT
				return i
			}
	
			if(last === '/' && c === '*') {
				mode = BLOCK_COMMENT
				return i
			}
	
			if(last === '/' && c === '/') {
				mode = LINE_COMMENT
				return i
			}
	
			if(c === '.' && content.length) {
				while(determine_operator(content));
				
				mode = FLOAT
				return i
			}
	
			if(c === ';') {
				if(content.length) while(determine_operator(content));
				token(c)
				mode = NORMAL
				return i + 1
			}
	
			var is_composite_operator = content.length === 2 && c !== '='
			if(/[\w_\d\s]/.test(c) || is_composite_operator) {
				while(determine_operator(content));
				mode = NORMAL
				return i
			}
	
			content.push(c)
			last = c
			return i + 1
		}
	
		function determine_operator(buf) {
			var j = 0
				, k = buf.length
				, idx
	
			do {
				idx = operators.indexOf(buf.slice(0, buf.length + j).join(''))
				if(idx === -1) { 
					j -= 1
					k -= 1
					if (k < 0) return 0
					continue
				}
				
				token(operators[idx])
	
				start += operators[idx].length
				content = content.slice(operators[idx].length)
				return content.length
			} while(1)
		}
	
		function hex() {
			if(/[^a-fA-F0-9]/.test(c)) {
				token(content.join(''))
				mode = NORMAL
				return i
			}
	
			content.push(c)
			last = c
			return i + 1    
		}
	
		function integer() {
			if(c === '.') {
				content.push(c)
				mode = FLOAT
				last = c
				return i + 1
			}
	
			if(/[eE]/.test(c)) {
				content.push(c)
				mode = FLOAT
				last = c
				return i + 1
			}
	
			if(c === 'x' && content.length === 1 && content[0] === '0') {
				mode = HEX
				content.push(c)
				last = c
				return i + 1
			}
	
			if(/[^\d]/.test(c)) {
				token(content.join(''))
				mode = NORMAL
				return i
			}
	
			content.push(c)
			last = c
			return i + 1
		}
	
		function decimal() {
			if(c === 'f') {
				content.push(c)
				last = c
				i += 1
			}
	
			if(/[eE]/.test(c)) {
				content.push(c)
				last = c
				return i + 1
			}
	
			if(/[^\d]/.test(c)) {
				token(content.join(''))
				mode = NORMAL
				return i
			}
			content.push(c)
			last = c
			return i + 1
		}
	
		function readtoken() {
			if(/[^\d\w_]/.test(c)) {
				var contentstr = content.join('')
				if(literals.indexOf(contentstr) > -1) {
					mode = KEYWORD
				} else if(builtins.indexOf(contentstr) > -1) {
					mode = BUILTIN
				} else {
					mode = IDENT
				}
				token(content.join(''))
				mode = NORMAL
				return i
			}
			content.push(c)
			last = c
			return i + 1
		}
	}
	
	
	/***/ }),
	/* 223 */
	/***/ (function(module, exports) {
	
	module.exports = [
		// current
			'precision'
		, 'highp'
		, 'mediump'
		, 'lowp'
		, 'attribute'
		, 'const'
		, 'uniform'
		, 'varying'
		, 'break'
		, 'continue'
		, 'do'
		, 'fo'+'r'
		, 'whi'+'le'
		, 'i'+'f'
		, 'else'
		, 'in'
		, 'out'
		, 'inout'
		, 'float'
		, 'int'
		, 'void'
		, 'bool'
		, 'true'
		, 'false'
		, 'discard'
		, 'return'
		, 'mat2'
		, 'mat3'
		, 'mat4'
		, 'vec2'
		, 'vec3'
		, 'vec4'
		, 'ivec2'
		, 'ivec3'
		, 'ivec4'
		, 'bvec2'
		, 'bvec3'
		, 'bvec4'
		, 'sampler1D'
		, 'sampler2D'
		, 'sampler3D'
		, 'samplerCube'
		, 'sampler1DShadow'
		, 'sampler2DShadow'
		, 'struct'
	
		// future
		, 'asm'
		, 'class'
		, 'union'
		, 'enum'
		, 'typedef'
		, 'template'
		, 'this'
		, 'packed'
		, 'goto'
		, 'switch'
		, 'default'
		, 'inline'
		, 'noinline'
		, 'volatile'
		, 'public'
		, 'static'
		, 'extern'
		, 'external'
		, 'interface'
		, 'long'
		, 'short'
		, 'double'
		, 'half'
		, 'fixed'
		, 'unsigned'
		, 'input'
		, 'output'
		, 'hvec2'
		, 'hvec3'
		, 'hvec4'
		, 'dvec2'
		, 'dvec3'
		, 'dvec4'
		, 'fvec2'
		, 'fvec3'
		, 'fvec4'
		, 'sampler2DRect'
		, 'sampler3DRect'
		, 'sampler2DRectShadow'
		, 'sizeof'
		, 'cast'
		, 'namespace'
		, 'using'
	]
	
	
	/***/ }),
	/* 224 */
	/***/ (function(module, exports) {
	
	module.exports = [
			'<<='
		, '>>='
		, '++'
		, '--'
		, '<<'
		, '>>'
		, '<='
		, '>='
		, '=='
		, '!='
		, '&&'
		, '||'
		, '+='
		, '-='
		, '*='
		, '/='
		, '%='
		, '&='
		, '^='
		, '|='
		, '('
		, ')'
		, '['
		, ']'
		, '.'
		, '!'
		, '~'
		, '*'
		, '/'
		, '%'
		, '+'
		, '-'
		, '<'
		, '>'
		, '&'
		, '^'
		, '|'
		, '?'
		, ':'
		, '='
		, ','
		, ';'
		, '{'
		, '}'
	]
	
	
	/***/ }),
	/* 225 */
	/***/ (function(module, exports) {
	
	module.exports = [
			'gl_Position'
		, 'gl_PointSize'
		, 'gl_ClipVertex'
		, 'gl_FragCoord'
		, 'gl_FrontFacing'
		, 'gl_FragColor'
		, 'gl_FragData'
		, 'gl_FragDepth'
		, 'gl_Color'
		, 'gl_SecondaryColor'
		, 'gl_Normal'
		, 'gl_Vertex'
		, 'gl_MultiTexCoord0'
		, 'gl_MultiTexCoord1'
		, 'gl_MultiTexCoord2'
		, 'gl_MultiTexCoord3'
		, 'gl_MultiTexCoord4'
		, 'gl_MultiTexCoord5'
		, 'gl_MultiTexCoord6'
		, 'gl_MultiTexCoord7'
		, 'gl_FogCoord'
		, 'gl_MaxLights'
		, 'gl_MaxClipPlanes'
		, 'gl_MaxTextureUnits'
		, 'gl_MaxTextureCoords'
		, 'gl_MaxVertexAttribs'
		, 'gl_MaxVertexUniformComponents'
		, 'gl_MaxVaryingFloats'
		, 'gl_MaxVertexTextureImageUnits'
		, 'gl_MaxCombinedTextureImageUnits'
		, 'gl_MaxTextureImageUnits'
		, 'gl_MaxFragmentUniformComponents'
		, 'gl_MaxDrawBuffers'
		, 'gl_ModelViewMatrix'
		, 'gl_ProjectionMatrix'
		, 'gl_ModelViewProjectionMatrix'
		, 'gl_TextureMatrix'
		, 'gl_NormalMatrix'
		, 'gl_ModelViewMatrixInverse'
		, 'gl_ProjectionMatrixInverse'
		, 'gl_ModelViewProjectionMatrixInverse'
		, 'gl_TextureMatrixInverse'
		, 'gl_ModelViewMatrixTranspose'
		, 'gl_ProjectionMatrixTranspose'
		, 'gl_ModelViewProjectionMatrixTranspose'
		, 'gl_TextureMatrixTranspose'
		, 'gl_ModelViewMatrixInverseTranspose'
		, 'gl_ProjectionMatrixInverseTranspose'
		, 'gl_ModelViewProjectionMatrixInverseTranspose'
		, 'gl_TextureMatrixInverseTranspose'
		, 'gl_NormalScale'
		, 'gl_DepthRangeParameters'
		, 'gl_DepthRange'
		, 'gl_ClipPlane'
		, 'gl_PointParameters'
		, 'gl_Point'
		, 'gl_MaterialParameters'
		, 'gl_FrontMaterial'
		, 'gl_BackMaterial'
		, 'gl_LightSourceParameters'
		, 'gl_LightSource'
		, 'gl_LightModelParameters'
		, 'gl_LightModel'
		, 'gl_LightModelProducts'
		, 'gl_FrontLightModelProduct'
		, 'gl_BackLightModelProduct'
		, 'gl_LightProducts'
		, 'gl_FrontLightProduct'
		, 'gl_BackLightProduct'
		, 'gl_FogParameters'
		, 'gl_Fog'
		, 'gl_TextureEnvColor'
		, 'gl_EyePlaneS'
		, 'gl_EyePlaneT'
		, 'gl_EyePlaneR'
		, 'gl_EyePlaneQ'
		, 'gl_ObjectPlaneS'
		, 'gl_ObjectPlaneT'
		, 'gl_ObjectPlaneR'
		, 'gl_ObjectPlaneQ'
		, 'gl_FrontColor'
		, 'gl_BackColor'
		, 'gl_FrontSecondaryColor'
		, 'gl_BackSecondaryColor'
		, 'gl_TexCoord'
		, 'gl_FogFragCoord'
		, 'gl_Color'
		, 'gl_SecondaryColor'
		, 'gl_TexCoord'
		, 'gl_FogFragCoord'
		, 'gl_PointCoord'
		, 'radians'
		, 'degrees'
		, 'sin'
		, 'cos'
		, 'tan'
		, 'asin'
		, 'acos'
		, 'atan'
		, 'pow'
		, 'exp'
		, 'log'
		, 'exp2'
		, 'log2'
		, 'sqrt'
		, 'inversesqrt'
		, 'abs'
		, 'sign'
		, 'floor'
		, 'ceil'
		, 'fract'
		, 'mod'
		, 'min'
		, 'max'
		, 'clamp'
		, 'mix'
		, 'step'
		, 'smoothstep'
		, 'length'
		, 'distance'
		, 'dot'
		, 'cross'
		, 'normalize'
		, 'faceforward'
		, 'reflect'
		, 'refract'
		, 'matrixCompMult'
		, 'lessThan'
		, 'lessThanEqual'
		, 'greaterThan'
		, 'greaterThanEqual'
		, 'equal'
		, 'notEqual'
		, 'any'
		, 'all'
		, 'not'
		, 'texture2D'
		, 'texture2DProj'
		, 'texture2DLod'
		, 'texture2DProjLod'
		, 'textureCube'
		, 'textureCubeLod'
	]
	
	
	/***/ }),
	/* 226 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = __webpack_require__(227)
	
	
	/***/ }),
	/* 227 */
	/***/ (function(module, exports, __webpack_require__) {
	
	module.exports = parser
	
	var through = __webpack_require__(65)
		, full_parse_expr = __webpack_require__(228)
		, Scope = __webpack_require__(229)
	
	// singleton!
	var Advance = new Object
	
	var DEBUG = false
	
	var _ = 0
		, IDENT = _++
		, STMT = _++
		, STMTLIST = _++
		, STRUCT = _++
		, FUNCTION = _++
		, FUNCTIONARGS = _++
		, DECL = _++
		, DECLLIST = _++
		, FORLOOP = _++
		, WHILELOOP = _++
		, IF = _++
		, EXPR = _++
		, PRECISION = _++
		, COMMENT = _++
		, PREPROCESSOR = _++
		, KEYWORD = _++
		, KEYWORD_OR_IDENT = _++
		, RETURN = _++
		, BREAK = _++
		, CONTINUE = _++
		, DISCARD = _++
		, DOWHILELOOP = _++
		, PLACEHOLDER = _++
		, QUANTIFIER = _++
	
	var DECL_ALLOW_ASSIGN = 0x1
		, DECL_ALLOW_COMMA = 0x2
		, DECL_REQUIRE_NAME = 0x4
		, DECL_ALLOW_INVARIANT = 0x8
		, DECL_ALLOW_STORAGE = 0x10
		, DECL_NO_INOUT = 0x20
		, DECL_ALLOW_STRUCT = 0x40
		, DECL_STATEMENT = 0xFF
		, DECL_FUNCTION = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_COMMA | DECL_NO_INOUT | DECL_ALLOW_INVARIANT | DECL_REQUIRE_NAME)
		, DECL_STRUCT = DECL_STATEMENT & ~(DECL_ALLOW_ASSIGN | DECL_ALLOW_INVARIANT | DECL_ALLOW_STORAGE | DECL_ALLOW_STRUCT)
	
	var QUALIFIERS = ['const', 'attribute', 'uniform', 'varying']
	
	var NO_ASSIGN_ALLOWED = false
		, NO_COMMA_ALLOWED = false
	
	// map of tokens to stmt types
	var token_map = {
			'block-comment': COMMENT
		, 'line-comment': COMMENT
		, 'preprocessor': PREPROCESSOR
	}
	
	// map of stmt types to human
	var stmt_type = _ = [ 
			'ident'
		, 'stmt'
		, 'stmtlist'
		, 'struct'
		, 'function'
		, 'functionargs'
		, 'decl'
		, 'decllist'
		, 'forloop'
		, 'whileloop'
		, 'i'+'f'
		, 'expr'
		, 'precision'
		, 'comment'
		, 'preprocessor'
		, 'keyword'
		, 'keyword_or_ident'
		, 'return'
		, 'break'
		, 'continue'
		, 'discard'
		, 'do-while'
		, 'placeholder'
		, 'quantifier'
	]
	
	function parser() {
		var stmtlist = n(STMTLIST)
			, stmt = n(STMT)
			, decllist = n(DECLLIST)
			, precision = n(PRECISION)
			, ident = n(IDENT)
			, keyword_or_ident = n(KEYWORD_OR_IDENT)
			, fn = n(FUNCTION)
			, fnargs = n(FUNCTIONARGS)
			, forstmt = n(FORLOOP)
			, ifstmt = n(IF)
			, whilestmt = n(WHILELOOP)
			, returnstmt = n(RETURN)
			, dowhilestmt = n(DOWHILELOOP)
			, quantifier = n(QUANTIFIER)
	
		var parse_struct
			, parse_precision
			, parse_quantifier
			, parse_forloop
			, parse_if
			, parse_return
			, parse_whileloop
			, parse_dowhileloop
			, parse_function
			, parse_function_args
	
		var stream = through(write, end)
			, check = arguments.length ? [].slice.call(arguments) : []
			, depth = 0
			, state = []
			, tokens = []
			, whitespace = []
			, errored = false
			, program
			, token
			, node
	
		// setup state
		state.shift = special_shift
		state.unshift = special_unshift
		state.fake = special_fake
		state.unexpected = unexpected
		state.scope = new Scope(state)
		state.create_node = function() {
			var n = mknode(IDENT, token)
			n.parent = stream.program
			return n
		}
	
		setup_stative_parsers()
	
		// setup root node
		node = stmtlist()
		node.expecting = '(eof)'
		node.mode = STMTLIST
		node.token = {type: '(program)', data: '(program)'}
		program = node
	
		stream.program = program
		stream.scope = function(scope) {
			if(arguments.length === 1) {
				state.scope = scope
			}
			return state.scope
		}
	
		state.unshift(node)
		return stream
	
		// stream functions ---------------------------------------------
	
		function write(input) {
			if(input.type === 'whitespace' || input.type === 'line-comment' || input.type === 'block-comment') {
	
				whitespace.push(input)
				return
			}
			tokens.push(input)
			token = token || tokens[0]
	
			if(token && whitespace.length) {
				token.preceding = token.preceding || []
				token.preceding = token.preceding.concat(whitespace)
				whitespace = []
			}
	
			while(take()) switch(state[0].mode) {
				case STMT: parse_stmt(); break
				case STMTLIST: parse_stmtlist(); break
				case DECL: parse_decl(); break
				case DECLLIST: parse_decllist(); break
				case EXPR: parse_expr(); break
				case STRUCT: parse_struct(true, true); break
				case PRECISION: parse_precision(); break
				case IDENT: parse_ident(); break
				case KEYWORD: parse_keyword(); break
				case KEYWORD_OR_IDENT: parse_keyword_or_ident(); break
				case FUNCTION: parse_function(); break
				case FUNCTIONARGS: parse_function_args(); break
				case FORLOOP: parse_forloop(); break
				case WHILELOOP: parse_whileloop(); break
				case DOWHILELOOP: parse_dowhileloop(); break
				case RETURN: parse_return(); break
				case IF: parse_if(); break
				case QUANTIFIER: parse_quantifier(); break
			}
		}
		
		function end(tokens) {
			if(arguments.length) {
				write(tokens)
			}
	
			if(state.length > 1) {
				unexpected('unexpected EOF')
				return
			}
	
			stream.emit('end')
		}
	
		function take() {
			if(errored || !state.length)
				return false
	
			return (token = tokens[0]) && !stream.paused
		}
	
		// ----- state manipulation --------
	
		function special_fake(x) {
			state.unshift(x)
			state.shift()
		}
	
		function special_unshift(_node, add_child) {
			_node.parent = state[0]
	
			var ret = [].unshift.call(this, _node)
	
			add_child = add_child === undefined ? true : add_child
	
			if(DEBUG) {
				var pad = ''
				for(var i = 0, len = this.length - 1; i < len; ++i) {
					pad += ' |'
				}
				console.log(pad, '\\'+_node.type, _node.token.data)
			}
	
			if(add_child && node !== _node) node.children.push(_node)
			node = _node
	
			return ret
		}
	
		function special_shift() {
			var _node = [].shift.call(this)
				, okay = check[this.length]
				, emit = false
	
			if(DEBUG) {
				var pad = ''
				for(var i = 0, len = this.length; i < len; ++i) {
					pad += ' |'
				}
				console.log(pad, '/'+_node.type)
			}
	
			if(check.length) { 
				if(typeof check[0] === 'function') {
					emit = check[0](_node)
				} else if(okay !== undefined) {
					emit = okay.test ? okay.test(_node.type) : okay === _node.type
				}
			} else {
				emit = true
			}
	
			if(emit) stream.emit('data', _node) 
		
			node = _node.parent
			return _node
		}
	
		// parse states ---------------
	
		function parse_stmtlist() {
			// determine the type of the statement
			// and then start parsing
			return stative(
				function() { state.scope.enter(); return Advance }
			, normal_mode
			)()
	
			function normal_mode() {
				if(token.data === state[0].expecting) {
					return state.scope.exit(), state.shift()
				}
				switch(token.type) {
					case 'preprocessor':
						state.fake(adhoc())
						tokens.shift()
					return
					default:
						state.unshift(stmt())
					return 
				}
			}
		}
	
		function parse_stmt() {
			if(state[0].brace) {
				if(token.data !== '}') {
					return unexpected('expected `}`, got '+token.data)
				}
				state[0].brace = false
				return tokens.shift(), state.shift()
			}
			switch(token.type) {
				case 'eof': return state.shift()
				case 'keyword': 
					switch(token.data) {
						case 'for': return state.unshift(forstmt());
						case 'if': return state.unshift(ifstmt());
						case 'while': return state.unshift(whilestmt());
						case 'do': return state.unshift(dowhilestmt());
						case 'break': return state.fake(mknode(BREAK, token)), tokens.shift()
						case 'continue': return state.fake(mknode(CONTINUE, token)), tokens.shift()
						case 'discard': return state.fake(mknode(DISCARD, token)), tokens.shift()
						case 'return': return state.unshift(returnstmt());
						case 'precision': return state.unshift(precision());
					}
					return state.unshift(decl(DECL_STATEMENT))
				case 'ident':
					var lookup
					if(lookup = state.scope.find(token.data)) {
						if(lookup.parent.type === 'struct') {
							// this is strictly untrue, you could have an
							// expr that starts with a struct constructor.
							//      ... sigh
							return state.unshift(decl(DECL_STATEMENT))
						}
						return state.unshift(expr(';'))
					}
				case 'operator':
					if(token.data === '{') {
						state[0].brace = true
						var n = stmtlist()
						n.expecting = '}'
						return tokens.shift(), state.unshift(n)
					}
					if(token.data === ';') {
						return tokens.shift(), state.shift()
					}
				default: return state.unshift(expr(';'))
			}
		}
	
		function parse_decl() {
			var stmt = state[0]
	
			return stative(
				invariant_or_not,
				storage_or_not,
				parameter_or_not,
				precision_or_not,
				struct_or_type,
				maybe_name,
				maybe_lparen,     // lparen means we're a function
				is_decllist,
				done
			)()
	
			function invariant_or_not() {
				if(token.data === 'invariant') {
					if(stmt.flags & DECL_ALLOW_INVARIANT) {
						state.unshift(keyword())
						return Advance
					} else {
						return unexpected('`invariant` is not allowed here') 
					}
				} else {
					state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))
					return Advance
				}
			}
	
			function storage_or_not() {
				if(is_storage(token)) {
					if(stmt.flags & DECL_ALLOW_STORAGE) {
						state.unshift(keyword()) 
						return Advance
					} else {
						return unexpected('storage is not allowed here') 
					}
				} else {
					state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))
					return Advance
				}
			}
	
			function parameter_or_not() {
				if(is_parameter(token)) {
					if(!(stmt.flags & DECL_NO_INOUT)) {
						state.unshift(keyword()) 
						return Advance
					} else {
						return unexpected('parameter is not allowed here') 
					}
				} else {
					state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))
					return Advance
				}
			}
	
			function precision_or_not() {
				if(is_precision(token)) {
					state.unshift(keyword())
					return Advance
				} else {
					state.fake(mknode(PLACEHOLDER, {data: '', position: token.position}))
					return Advance
				}
			}
	
			function struct_or_type() {
				if(token.data === 'struct') {
					if(!(stmt.flags & DECL_ALLOW_STRUCT)) {
						return unexpected('cannot nest structs')
					}
					state.unshift(struct())
					return Advance
				}
	
				if(token.type === 'keyword') {
					state.unshift(keyword())
					return Advance
				}
	
				var lookup = state.scope.find(token.data)
	
				if(lookup) {
					state.fake(Object.create(lookup))
					tokens.shift()
					return Advance  
				}
				return unexpected('expected user defined type, struct or keyword, got '+token.data)
			}
	
			function maybe_name() {
				if(token.data === ',' && !(stmt.flags & DECL_ALLOW_COMMA)) {
					return state.shift()
				}
	
				if(token.data === '[') {
					// oh lord.
					state.unshift(quantifier())
					return
				}
	
				if(token.data === ')') return state.shift()
	
				if(token.data === ';') {
					return stmt.stage + 3
				}
	
				if(token.type !== 'ident') {
					console.log(token);
					return unexpected('expected identifier, got '+token.data)
				}
	
				stmt.collected_name = tokens.shift()
				return Advance      
			}
	
			function maybe_lparen() {
				if(token.data === '(') {
					tokens.unshift(stmt.collected_name)
					delete stmt.collected_name
					state.unshift(fn())
					return stmt.stage + 2 
				}
				return Advance
			}
	
			function is_decllist() {
				tokens.unshift(stmt.collected_name)
				delete stmt.collected_name
				state.unshift(decllist())
				return Advance
			}
	
			function done() {
				return state.shift()
			}
		}
		
		function parse_decllist() {
			// grab ident
	
			if(token.type === 'ident') {
				var name = token.data
				state.unshift(ident())
				state.scope.define(name)
				return
			}
	
			if(token.type === 'operator') {
	
				if(token.data === ',') {
					// multi-decl!
					if(!(state[1].flags & DECL_ALLOW_COMMA)) {
						return state.shift()
					}
	
					return tokens.shift()
				} else if(token.data === '=') {
					if(!(state[1].flags & DECL_ALLOW_ASSIGN)) return unexpected('`=` is not allowed here.')
	
					tokens.shift()
	
					state.unshift(expr(',', ';'))
					return
				} else if(token.data === '[') {
					state.unshift(quantifier())
					return
				}
			}
			return state.shift()
		}
	
		function parse_keyword_or_ident() {
			if(token.type === 'keyword') {
				state[0].type = 'keyword'
				state[0].mode = KEYWORD
				return
			}
	
			if(token.type === 'ident') {
				state[0].type = 'ident'
				state[0].mode = IDENT
				return
			}
	
			return unexpected('expected keyword or user-defined name, got '+token.data)
		}
	
		function parse_keyword() {
			if(token.type !== 'keyword') {
				return unexpected('expected keyword, got '+token.data)
			}
	
			return state.shift(), tokens.shift()
		}
	
		function parse_ident() {
			if(token.type !== 'ident') {
				return unexpected('expected user-defined name, got '+token.data)
			}
	
			state[0].data = token.data
			return state.shift(), tokens.shift()
		}
	
	
		function parse_expr() {
			var expecting = state[0].expecting
	
			state[0].tokens = state[0].tokens || []
	
			if(state[0].parenlevel === undefined) {
				state[0].parenlevel = 0
				state[0].bracelevel = 0
			}
			if(state[0].parenlevel < 1 && expecting.indexOf(token.data) > -1) {
				return parseexpr(state[0].tokens)
			}
			if(token.data === '(') {
				++state[0].parenlevel
			} else if(token.data === ')') {
				--state[0].parenlevel
			}
	
			switch(token.data) {
				case '{': ++state[0].bracelevel; break
				case '}': --state[0].bracelevel; break
				case '(': ++state[0].parenlevel; break
				case ')': --state[0].parenlevel; break
			}
	
			if(state[0].parenlevel < 0) return unexpected('unexpected `)`')
			if(state[0].bracelevel < 0) return unexpected('unexpected `}`')
	
			state[0].tokens.push(tokens.shift())
			return
	
			function parseexpr(tokens) {
				return full_parse_expr(state, tokens), state.shift()
			}
		}
	
		// node types ---------------
	
		function n(type) {
			// this is a function factory that suffices for most kinds of expressions and statements
			return function() {
				return mknode(type, token)
			}
		}
	
		function adhoc() {
			return mknode(token_map[token.type], token, node)
		}
	
		function decl(flags) {
			var _ = mknode(DECL, token, node)
			_.flags = flags
	
			return _
		}
	
		function struct(allow_assign, allow_comma) {
			var _ = mknode(STRUCT, token, node)
			_.allow_assign = allow_assign === undefined ? true : allow_assign
			_.allow_comma = allow_comma === undefined ? true : allow_comma
			return _
		}
	
		function expr() {
			var n = mknode(EXPR, token, node)
	
			n.expecting = [].slice.call(arguments)
			return n
		}
		
		function keyword(default_value) {
			var t = token
			if(default_value) {
				t = {'type': '(implied)', data: '(default)', position: t.position} 
			}
			return mknode(KEYWORD, t, node)
		}
	
		// utils ----------------------------
	
		function unexpected(str) {
			errored = true
			stream.emit('error', new Error(
				(str || 'unexpected '+state) +
				' at line '+state[0].token.line
			))
		}
	
		function assert(type, data) {
			return 1,
				assert_null_string_or_array(type, token.type) && 
				assert_null_string_or_array(data, token.data)
		}
	
		function assert_null_string_or_array(x, y) {
			switch(typeof x) {
				case 'string': if(y !== x) {
					unexpected('expected `'+x+'`, got '+y+'\n'+token.data);
				} return !errored
	
				case 'object': if(x && x.indexOf(y) === -1) {
					unexpected('expected one of `'+x.join('`, `')+'`, got '+y);
				} return !errored
			}
			return true
		}
	
		// stative ----------------------------
	
		function stative() {
			var steps = [].slice.call(arguments)
				, step
				, result
	
			return function() {
				var current = state[0]
	
				current.stage || (current.stage = 0)
	
				step = steps[current.stage]
				if(!step) return unexpected('parser in undefined state!')
	
				result = step()
	
				if(result === Advance) return ++current.stage
				if(result === undefined) return
				current.stage = result
			} 
		}
	
		function advance(op, t) {
			t = t || 'operator'
			return function() {
				if(!assert(t, op)) return
	
				var last = tokens.shift()
					, children = state[0].children
					, last_node = children[children.length - 1]
	
				if(last_node && last_node.token && last.preceding) {
					last_node.token.succeeding = last_node.token.succeeding || []
					last_node.token.succeeding = last_node.token.succeeding.concat(last.preceding)
				}
				return Advance
			}
		}
	
		function advance_expr(until) {
			return function() { return state.unshift(expr(until)), Advance }
		}
	
		function advance_ident(declare) {
			return declare ? function() {
				var name = token.data
				return assert('ident') && (state.unshift(ident()), state.scope.define(name), Advance)
			} :  function() {
				if(!assert('ident')) return
	
				var s = Object.create(state.scope.find(token.data))
				s.token = token
	
				return (tokens.shift(), Advance)
			}
		}
	
		function advance_stmtlist() {
			return function() {
				var n = stmtlist()
				n.expecting = '}'
				return state.unshift(n), Advance
			}
		}
	
		function maybe_stmtlist(skip) {
			return function() {
				var current = state[0].stage
				if(token.data !== '{') { return state.unshift(stmt()), current + skip }
				return tokens.shift(), Advance
			}
		}
	
		function popstmt() {
			return function() { return state.shift(), state.shift() }
		}
	
	
		function setup_stative_parsers() {
	
			// could also be
			// struct { } decllist
			parse_struct =
					stative(
						advance('struct', 'keyword')
					, function() {
							if(token.data === '{') {
								state.fake(mknode(IDENT, {data:'', position: token.position, type:'ident'}))
								return Advance
							}
	
							return advance_ident(true)()
						}
					, function() { state.scope.enter(); return Advance }
					, advance('{')
					, function() {
							if(token.data === '}') {
								state.scope.exit()
								tokens.shift()
								return state.shift()
							}
							if(token.data === ';') { tokens.shift(); return }
							state.unshift(decl(DECL_STRUCT))
						}
					)
	
			parse_precision =
					stative(
						function() { return tokens.shift(), Advance }
					, function() { 
							return assert(
							'keyword', ['lowp', 'mediump', 'highp']
							) && (state.unshift(keyword()), Advance) 
						}
					, function() { return (state.unshift(keyword()), Advance) }
					, function() { return state.shift() } 
					)
	
			parse_quantifier =
					stative(
						advance('[')
					, advance_expr(']')
					, advance(']')
					, function() { return state.shift() }
					)
	
			parse_forloop = 
					stative(
						advance('for', 'keyword')
					, advance('(')
					, function() {
							var lookup
							if(token.type === 'ident') {
								if(!(lookup = state.scope.find(token.data))) {
									lookup = state.create_node()
								}
							 
								if(lookup.parent.type === 'struct') {
									return state.unshift(decl(DECL_STATEMENT)), Advance
								}
							} else if(token.type === 'builtin' || token.type === 'keyword') {
								return state.unshift(decl(DECL_STATEMENT)), Advance
							}
							return advance_expr(';')()
						}
					, advance(';')
					, advance_expr(';')
					, advance(';')
					, advance_expr(')')
					, advance(')')
					, maybe_stmtlist(3)
					, advance_stmtlist()
					, advance('}')
					, popstmt()
					)
	
			parse_if = 
					stative(
						advance('if', 'keyword')
					, advance('(')
					, advance_expr(')')
					, advance(')')
					, maybe_stmtlist(3)
					, advance_stmtlist()
					, advance('}')
					, function() {
							if(token.data === 'else') {
								return tokens.shift(), state.unshift(stmt()), Advance
							}
							return popstmt()()
						}
					, popstmt()
					)
	
			parse_return =
					stative(
						advance('return', 'keyword')
					, function() {
							if(token.data === ';') return Advance
							return state.unshift(expr(';')), Advance
						}
					, function() { tokens.shift(), popstmt()() } 
					)
	
			parse_whileloop =
					stative(
						advance('while', 'keyword')
					, advance('(')
					, advance_expr(')')
					, advance(')')
					, maybe_stmtlist(3)
					, advance_stmtlist()
					, advance('}')
					, popstmt()
					)
	
			parse_dowhileloop = 
				stative(
					advance('do', 'keyword')
				, maybe_stmtlist(3)
				, advance_stmtlist()
				, advance('}')
				, advance('while', 'keyword')
				, advance('(')
				, advance_expr(')')
				, advance(')')
				, popstmt()
				)
	
			parse_function =
				stative(
					function() {
						for(var i = 1, len = state.length; i < len; ++i) if(state[i].mode === FUNCTION) {
							return unexpected('function definition is not allowed within another function')
						}
	
						return Advance
					}
				, function() {
						if(!assert("ident")) return
	
						var name = token.data
							, lookup = state.scope.find(name)
	
						state.unshift(ident())
						state.scope.define(name)
	
						state.scope.enter(lookup ? lookup.scope : null)
						return Advance
					}
				, advance('(')
				, function() { return state.unshift(fnargs()), Advance }
				, advance(')')
				, function() { 
						// forward decl
						if(token.data === ';') {
							return state.scope.exit(), state.shift(), state.shift()
						}
						return Advance
					}
				, advance('{')
				, advance_stmtlist()
				, advance('}')
				, function() { state.scope.exit(); return Advance } 
				, function() { return state.shift(), state.shift(), state.shift() }
				)
	
			parse_function_args =
				stative(
					function() {
						if(token.data === 'void') { state.fake(keyword()); tokens.shift(); return Advance }
						if(token.data === ')') { state.shift(); return }
						if(token.data === 'struct') {
							state.unshift(struct(NO_ASSIGN_ALLOWED, NO_COMMA_ALLOWED))
							return Advance
						}
						state.unshift(decl(DECL_FUNCTION))
						return Advance
					}
				, function() {
						if(token.data === ',') { tokens.shift(); return 0 }
						if(token.data === ')') { state.shift(); return }
						unexpected('expected one of `,` or `)`, got '+token.data)
					}
				)
		}
	}
	
	function mknode(mode, sourcetoken) {
		return {
				mode: mode
			, token: sourcetoken
			, children: []
			, type: stmt_type[mode]
	//    , id: (Math.random() * 0xFFFFFFFF).toString(16)
		}
	}
	
	function is_storage(token) {
		return token.data === 'const' ||
					 token.data === 'attribute' ||
					 token.data === 'uniform' ||
					 token.data === 'varying'
	}
	
	function is_parameter(token) {
		return token.data === 'in' ||
					 token.data === 'inout' ||
					 token.data === 'out'
	}
	
	function is_precision(token) {
		return token.data === 'highp' ||
					 token.data === 'mediump' ||
					 token.data === 'lowp'
	}
	
	
	/***/ }),
	/* 228 */
	/***/ (function(module, exports) {
	
	var state
		, token
		, tokens
		, idx
	
	var original_symbol = {
			nud: function() { return this.children && this.children.length ? this : fail('unexpected')() }
		, led: fail('missing operator')
	}
	
	var symbol_table = {}
	
	function itself() {
		return this
	}
	
	symbol('(ident)').nud = itself
	symbol('(keyword)').nud = itself
	symbol('(builtin)').nud = itself
	symbol('(literal)').nud = itself
	symbol('(end)')
	
	symbol(':')
	symbol(';')
	symbol(',')
	symbol(')')
	symbol(']')
	symbol('}')
	
	infixr('&&', 30)
	infixr('||', 30)
	infix('|', 43)
	infix('^', 44)
	infix('&', 45)
	infix('==', 46)
	infix('!=', 46)
	infix('<', 47)
	infix('<=', 47)
	infix('>', 47)
	infix('>=', 47)
	infix('>>', 48)
	infix('<<', 48)
	infix('+', 50)
	infix('-', 50)
	infix('*', 60)
	infix('/', 60)
	infix('%', 60)
	infix('?', 20, function(left) {
		this.children = [left, expression(0), (advance(':'), expression(0))]
		this.type = 'ternary'
		return this
	})
	infix('.', 80, function(left) {
		token.type = 'literal'
		state.fake(token)
		this.children = [left, token]
		advance()
		return this
	})
	infix('[', 80, function(left) {
		this.children = [left, expression(0)]
		this.type = 'binary'
		advance(']')
		return this
	})
	infix('(', 80, function(left) {
		this.children = [left]
		this.type = 'call'
	
		if(token.data !== ')') while(1) {
			this.children.push(expression(0))
			if(token.data !== ',') break
			advance(',')
		}
		advance(')')
		return this
	})
	
	prefix('-')
	prefix('+')
	prefix('!')
	prefix('~')
	prefix('defined')
	prefix('(', function() {
		this.type = 'group'
		this.children = [expression(0)]
		advance(')')
		return this 
	})
	prefix('++')
	prefix('--')
	suffix('++')
	suffix('--')
	
	assignment('=')
	assignment('+=')
	assignment('-=')
	assignment('*=')
	assignment('/=')
	assignment('%=')
	assignment('&=')
	assignment('|=')
	assignment('^=')
	assignment('>>=')
	assignment('<<=')
	
	module.exports = function(incoming_state, incoming_tokens) {
		state = incoming_state
		tokens = incoming_tokens
		idx = 0
		var result
	
		if(!tokens.length) return
	
		advance()
		result = expression(0)
		result.parent = state[0]
		emit(result)
	
		if(idx < tokens.length) {
			throw new Error('did not use all tokens')
		}
	
		result.parent.children = [result]
	
		function emit(node) {
			state.unshift(node, false)
			for(var i = 0, len = node.children.length; i < len; ++i) {
				emit(node.children[i])
			}
			state.shift()
		}
	
	}
	
	function symbol(id, binding_power) {
		var sym = symbol_table[id]
		binding_power = binding_power || 0
		if(sym) {
			if(binding_power > sym.lbp) {
				sym.lbp = binding_power
			}
		} else {
			sym = Object.create(original_symbol)
			sym.id = id 
			sym.lbp = binding_power
			symbol_table[id] = sym
		}
		return sym
	}
	
	function expression(rbp) {
		var left, t = token
		advance()
	
		left = t.nud()
		while(rbp < token.lbp) {
			t = token
			advance()
			left = t.led(left)
		}
		return left
	}
	
	function infix(id, bp, led) {
		var sym = symbol(id, bp)
		sym.led = led || function(left) {
			this.children = [left, expression(bp)]
			this.type = 'binary'
			return this
		}
	}
	
	function infixr(id, bp, led) {
		var sym = symbol(id, bp)
		sym.led = led || function(left) {
			this.children = [left, expression(bp - 1)]
			this.type = 'binary'
			return this
		}
		return sym
	}
	
	function prefix(id, nud) {
		var sym = symbol(id)
		sym.nud = nud || function() {
			this.children = [expression(70)]
			this.type = 'unary'
			return this
		}
		return sym
	}
	
	function suffix(id) {
		var sym = symbol(id, 150)
		sym.led = function(left) {
			this.children = [left]
			this.type = 'suffix'
			return this
		}
	}
	
	function assignment(id) {
		return infixr(id, 10, function(left) {
			this.children = [left, expression(9)]
			this.assignment = true
			this.type = 'assign'
			return this
		})
	}
	
	function advance(id) {
		var next
			, value
			, type
			, output
	
		if(id && token.data !== id) {
			return state.unexpected('expected `'+ id + '`, got `'+token.data+'`')
		}
	
		if(idx >= tokens.length) {
			token = symbol_table['(end)']
			return
		}
	
		next = tokens[idx++]
		value = next.data
		type = next.type
	
		if(type === 'ident') {
			output = state.scope.find(value) || state.create_node()
			type = output.type
		} else if(type === 'builtin') {
			output = symbol_table['(builtin)']
		} else if(type === 'keyword') {
			output = symbol_table['(keyword)']
		} else if(type === 'operator') {
			output = symbol_table[value]
			if(!output) {
				return state.unexpected('unknown operator `'+value+'`')
			}
		} else if(type === 'float' || type === 'integer') {
			type = 'literal'
			output = symbol_table['(literal)']
		} else {
			return state.unexpected('unexpected token.')
		}
	
		if(output) {
			if(!output.nud) { output.nud = itself }
			if(!output.children) { output.children = [] }
		}
	
		output = Object.create(output)
		output.token = next
		output.type = type
		if(!output.data) output.data = value
	
		return token = output
	}
	
	function fail(message) {
		return function() { return state.unexpected(message) }
	}
	
	
	/***/ }),
	/* 229 */
	/***/ (function(module, exports) {
	
	module.exports = scope
	
	function scope(state) {
		if(this.constructor !== scope)
			return new scope(state)
	
		this.state = state
		this.scopes = []
		this.current = null
	}
	
	var cons = scope
		, proto = cons.prototype
	
	proto.enter = function(s) {
		this.scopes.push(
			this.current = this.state[0].scope = s || {}
		)
	}
	
	proto.exit = function() {
		this.scopes.pop()
		this.current = this.scopes[this.scopes.length - 1]
	}
	
	proto.define = function(str) {
		this.current[str] = this.state[0]
	}
	
	proto.find = function(name, fail) {
		for(var i = this.scopes.length - 1; i > -1; --i) {
			if(this.scopes[i].hasOwnProperty(name)) {
				return this.scopes[i][name]
			}
		}
	
		return null
	}
	
	
	/***/ }),
	/* 230 */
	/***/ (function(module, exports) {
	
	var Definition, decl, defaults, get, three, threejs, win;
	
	module.exports = decl = {};
	
	decl["in"] = 0;
	
	decl.out = 1;
	
	decl.inout = 2;
	
	get = function(n) {
		return n.token.data;
	};
	
	decl.node = function(node) {
		var ref, ref1;
		if (((ref = node.children[5]) != null ? ref.type : void 0) === 'function') {
			return decl["function"](node);
		} else if (((ref1 = node.token) != null ? ref1.type : void 0) === 'keyword') {
			return decl.external(node);
		}
	};
	
	decl.external = function(node) {
		var c, i, ident, j, len, list, next, out, quant, ref, storage, struct, type;
		c = node.children;
		storage = get(c[1]);
		struct = get(c[3]);
		type = get(c[4]);
		list = c[5];
		if (storage !== 'attribute' && storage !== 'uniform' && storage !== 'varying') {
			storage = 'global';
		}
		out = [];
		ref = list.children;
		for (i = j = 0, len = ref.length; j < len; i = ++j) {
			c = ref[i];
			if (c.type === 'ident') {
				ident = get(c);
				next = list.children[i + 1];
				quant = (next != null ? next.type : void 0) === 'quantifier';
				out.push({
					decl: 'external',
					storage: storage,
					type: type,
					ident: ident,
					quant: !!quant,
					count: quant
				});
			}
		}
		return out;
	};
	
	decl["function"] = function(node) {
		var args, body, c, child, decls, func, ident, storage, struct, type;
		c = node.children;
		storage = get(c[1]);
		struct = get(c[3]);
		type = get(c[4]);
		func = c[5];
		ident = get(func.children[0]);
		args = func.children[1];
		body = func.children[2];
		decls = (function() {
			var j, len, ref, results;
			ref = args.children;
			results = [];
			for (j = 0, len = ref.length; j < len; j++) {
				child = ref[j];
				results.push(decl.argument(child));
			}
			return results;
		})();
		return [
			{
				decl: 'function',
				storage: storage,
				type: type,
				ident: ident,
				body: !!body,
				args: decls
			}
		];
	};
	
	decl.argument = function(node) {
		var c, count, ident, inout, list, quant, storage, type;
		c = node.children;
		storage = get(c[1]);
		inout = get(c[2]);
		type = get(c[4]);
		list = c[5];
		ident = get(list.children[0]);
		quant = list.children[1];
		count = quant ? quant.children[0].token.data : void 0;
		return {
			decl: 'argument',
			storage: storage,
			inout: inout,
			type: type,
			ident: ident,
			quant: !!quant,
			count: count
		};
	};
	
	decl.param = function(dir, storage, spec, quant, count) {
		var f, prefix, suffix;
		prefix = [];
		if (storage != null) {
			prefix.push(storage);
		}
		if (spec != null) {
			prefix.push(spec);
		}
		prefix.push('');
		prefix = prefix.join(' ');
		suffix = quant ? '[' + count + ']' : '';
		if (dir !== '') {
			dir += ' ';
		}
		f = function(name, long) {
			return (long ? dir : '') + ("" + prefix + name + suffix);
		};
		f.split = function(dir) {
			return decl.param(dir, storage, spec, quant, count);
		};
		return f;
	};
	
	win = typeof window !== 'undefined';
	
	threejs = win && !!window.THREE;
	
	defaults = {
		int: 0,
		float: 0,
		vec2: threejs ? THREE.Vector2 : null,
		vec3: threejs ? THREE.Vector3 : null,
		vec4: threejs ? THREE.Vector4 : null,
		mat2: null,
		mat3: threejs ? THREE.Matrix3 : null,
		mat4: threejs ? THREE.Matrix4 : null,
		sampler2D: 0,
		samplerCube: 0
	};
	
	three = {
		int: 'i',
		float: 'f',
		vec2: 'v2',
		vec3: 'v3',
		vec4: 'v4',
		mat2: 'm2',
		mat3: 'm3',
		mat4: 'm4',
		sampler2D: 't',
		samplerCube: 't'
	};
	
	decl.type = function(name, spec, quant, count, dir, storage) {
		var dirs, inout, param, ref, storages, type, value;
		dirs = {
			"in": decl["in"],
			out: decl.out,
			inout: decl.inout
		};
		storages = {
			"const": 'const'
		};
		type = three[spec];
		if (quant) {
			type += 'v';
		}
		value = defaults[spec];
		if (value != null ? value.call : void 0) {
			value = new value;
		}
		if (quant) {
			value = [value];
		}
		inout = (ref = dirs[dir]) != null ? ref : dirs["in"];
		storage = storages[storage];
		param = decl.param(dir, storage, spec, quant, count);
		return new Definition(name, type, spec, param, value, inout);
	};
	
	Definition = (function() {
		function Definition(name1, type1, spec1, param1, value1, inout1, meta1) {
			this.name = name1;
			this.type = type1;
			this.spec = spec1;
			this.param = param1;
			this.value = value1;
			this.inout = inout1;
			this.meta = meta1;
		}
	
		Definition.prototype.split = function() {
			var dir, inout, isIn, param;
			isIn = this.meta.shadowed != null;
			dir = isIn ? 'in' : 'out';
			inout = isIn ? decl["in"] : decl.out;
			param = this.param.split(dir);
			return new Definition(this.name, this.type, this.spec, param, this.value, inout);
		};
	
		Definition.prototype.copy = function(name, meta) {
			var def;
			return def = new Definition(name != null ? name : this.name, this.type, this.spec, this.param, this.value, this.inout, meta);
		};
	
		return Definition;
	
	})();
	
	
	/***/ }),
	/* 231 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var $, Graph, _;
	
	Graph = __webpack_require__(6);
	
	$ = __webpack_require__(39);
	
	
	/*
	 GLSL code generator for compiler and linker stubs
	 */
	
	module.exports = _ = {
		unshadow: function(name) {
			var real;
			real = name.replace($.SHADOW_ARG, '');
			if (real !== name) {
				return real;
			} else {
				return null;
			}
		},
		lines: function(lines) {
			return lines.join('\n');
		},
		list: function(lines) {
			return lines.join(', ');
		},
		statements: function(lines) {
			return lines.join(';\n');
		},
		body: function(entry) {
			return {
				entry: entry,
				type: 'void',
				params: [],
				signature: [],
				"return": '',
				vars: {},
				calls: [],
				post: [],
				chain: {}
			};
		},
		define: function(a, b) {
			return "#define " + a + " " + b;
		},
		"function": function(type, entry, params, vars, calls) {
			return type + " " + entry + "(" + params + ") {\n" + vars + calls + "}";
		},
		invoke: function(ret, entry, args) {
			ret = ret ? ret + " = " : '';
			args = _.list(args);
			return "  " + ret + entry + "(" + args + ")";
		},
		same: function(a, b) {
			var A, B, i, k, len;
			for (i = k = 0, len = a.length; k < len; i = ++k) {
				A = a[i];
				B = b[i];
				if (!B) {
					return false;
				}
				if (A.type !== B.type) {
					return false;
				}
				if ((A.name === $.RETURN_ARG) !== (B.name === $.RETURN_ARG)) {
					return false;
				}
			}
			return true;
		},
		call: function(lookup, dangling, entry, signature, body) {
			var arg, args, copy, id, inout, isReturn, k, len, meta, name, omit, op, other, ref, ref1, ret, rets, shadow;
			args = [];
			ret = '';
			rets = 1;
			for (k = 0, len = signature.length; k < len; k++) {
				arg = signature[k];
				name = arg.name;
				copy = id = lookup(name);
				other = null;
				meta = null;
				omit = false;
				inout = arg.inout;
				isReturn = name === $.RETURN_ARG;
				if (shadow = (ref = arg.meta) != null ? ref.shadowed : void 0) {
					other = lookup(shadow);
					if (other) {
						body.vars[other] = "  " + arg.param(other);
						body.calls.push("  " + other + " = " + id);
						if (!dangling(shadow)) {
							arg = arg.split();
						} else {
							meta = {
								shadowed: other
							};
						}
					}
				}
				if (shadow = (ref1 = arg.meta) != null ? ref1.shadow : void 0) {
					other = lookup(shadow);
					if (other) {
						if (!dangling(shadow)) {
							arg = arg.split();
							omit = true;
						} else {
							meta = {
								shadow: other
							};
							continue;
						}
					}
				}
				if (isReturn) {
					ret = id;
				} else if (!omit) {
					args.push(other != null ? other : id);
				}
				if (dangling(name)) {
					op = 'push';
					if (isReturn) {
						if (body["return"] === '') {
							op = 'unshift';
							copy = name;
							body.type = arg.spec;
							body["return"] = "  return " + id;
							body.vars[id] = "  " + arg.param(id);
						} else {
							body.vars[id] = "  " + arg.param(id);
							body.params.push(arg.param(id, true));
						}
					} else {
						body.params.push(arg.param(id, true));
					}
					arg = arg.copy(copy, meta);
					body.signature[op](arg);
				} else {
					body.vars[id] = "  " + arg.param(id);
				}
			}
			return body.calls.push(_.invoke(ret, entry, args));
		},
		build: function(body, calls) {
			var a, b, code, decl, entry, params, post, ret, type, v, vars;
			entry = body.entry;
			code = null;
			if (calls && calls.length === 1 && entry !== 'main') {
				a = body;
				b = calls[0].module;
				if (_.same(body.signature, b.main.signature)) {
					code = _.define(entry, b.entry);
				}
			}
			if (code == null) {
				vars = (function() {
					var ref, results;
					ref = body.vars;
					results = [];
					for (v in ref) {
						decl = ref[v];
						results.push(decl);
					}
					return results;
				})();
				calls = body.calls;
				post = body.post;
				params = body.params;
				type = body.type;
				ret = body["return"];
				calls = calls.concat(post);
				if (ret !== '') {
					calls.push(ret);
				}
				calls.push('');
				if (vars.length) {
					vars.push('');
					vars = _.statements(vars) + '\n';
				} else {
					vars = '';
				}
				calls = _.statements(calls);
				params = _.list(params);
				code = _["function"](type, entry, params, vars, calls);
			}
			return {
				signature: body.signature,
				code: code,
				name: entry
			};
		},
		links: function(links) {
			var k, l, len, out;
			out = {
				defs: [],
				bodies: []
			};
			for (k = 0, len = links.length; k < len; k++) {
				l = links[k];
				_.link(l, out);
			}
			out.defs = _.lines(out.defs);
			out.bodies = _.statements(out.bodies);
			if (out.defs === '') {
				delete out.defs;
			}
			if (out.bodies === '') {
				delete out.bodies;
			}
			return out;
		},
		link: (function(_this) {
			return function(link, out) {
				var _dangling, _lookup, _name, arg, entry, external, inner, ins, k, len, len1, list, main, map, module, n, name, other, outer, outs, ref, ref1, returnVar, wrapper;
				module = link.module, name = link.name, external = link.external;
				main = module.main;
				entry = module.entry;
				if (_.same(main.signature, external.signature)) {
					return out.defs.push(_.define(name, entry));
				}
				ins = [];
				outs = [];
				map = {};
				returnVar = [module.namespace, $.RETURN_ARG].join('');
				ref = external.signature;
				for (k = 0, len = ref.length; k < len; k++) {
					arg = ref[k];
					list = arg.inout === Graph.IN ? ins : outs;
					list.push(arg);
				}
				ref1 = main.signature;
				for (n = 0, len1 = ref1.length; n < len1; n++) {
					arg = ref1[n];
					list = arg.inout === Graph.IN ? ins : outs;
					other = list.shift();
					_name = other.name;
					if (_name === $.RETURN_ARG) {
						_name = returnVar;
					}
					map[arg.name] = _name;
				}
				_lookup = function(name) {
					return map[name];
				};
				_dangling = function() {
					return true;
				};
				inner = _.body();
				_.call(_lookup, _dangling, entry, main.signature, inner);
				inner.entry = entry;
				map = {
					"return": returnVar
				};
				_lookup = function(name) {
					var ref2;
					return (ref2 = map[name]) != null ? ref2 : name;
				};
				outer = _.body();
				wrapper = _.call(_lookup, _dangling, entry, external.signature, outer);
				outer.calls = inner.calls;
				outer.entry = name;
				out.bodies.push(_.build(inner).code.split(' {')[0]);
				return out.bodies.push(_.build(outer).code);
			};
		})(this),
		defuse: function(code) {
			var b, blocks, hash, head, i, j, k, len, len1, level, line, n, re, rest, strip;
			re = /([A-Za-z0-9_]+\s+)?[A-Za-z0-9_]+\s+[A-Za-z0-9_]+\s*\([^)]*\)\s*;\s*/mg;
			strip = function(code) {
				return code.replace(re, function(m) {
					return '';
				});
			};
			blocks = code.split(/(?=[{}])/g);
			level = 0;
			for (i = k = 0, len = blocks.length; k < len; i = ++k) {
				b = blocks[i];
				switch (b[0]) {
					case '{':
						level++;
						break;
					case '}':
						level--;
				}
				if (level === 0) {
					hash = b.split(/^[ \t]*#/m);
					for (j = n = 0, len1 = hash.length; n < len1; j = ++n) {
						line = hash[j];
						if (j > 0) {
							line = line.split(/\n/);
							head = line.shift();
							rest = line.join("\n");
							hash[j] = [head, strip(rest)].join('\n');
						} else {
							hash[j] = strip(line);
						}
					}
					blocks[i] = hash.join('#');
				}
			}
			return code = blocks.join('');
		},
		dedupe: function(code) {
			var map, re;
			map = {};
			re = /((attribute|uniform|varying)\s+)[A-Za-z0-9_]+\s+([A-Za-z0-9_]+)\s*(\[[^\]]*\]\s*)?;\s*/mg;
			return code.replace(re, function(m, qual, type, name, struct) {
				if (map[name]) {
					return '';
				}
				map[name] = true;
				return m;
			});
		},
		hoist: function(code) {
			var filter, lines;
			filter = function(lines, re) {
				var defs, k, len, line, list, out;
				defs = [];
				out = [];
				for (k = 0, len = lines.length; k < len; k++) {
					line = lines[k];
					list = line.match(re) ? defs : out;
					list.push(line);
				}
				return defs.concat(out);
			};
			lines = code.split("\n");
			lines = filter(lines, /^#define ([^ ]+ _pg_[0-9]+_|_pg_[0-9]+_ [^ ]+)$/);
			lines = filter(lines, /^#extension/);
			return lines.join("\n");
		}
	};
	
	
	/***/ }),
	/* 232 */
	/***/ (function(module) {
	
	module.exports = JSON.parse("{\"arrow.position\":\"uniform float worldUnit;\\r\\nuniform float lineDepth;\\r\\nuniform float lineWidth;\\r\\nuniform float focusDepth;\\r\\n\\r\\nuniform vec4 geometryClip;\\r\\nuniform float arrowSize;\\r\\nuniform float arrowSpace;\\r\\n\\r\\nattribute vec4 position4;\\r\\nattribute vec3 arrow;\\r\\nattribute vec2 attach;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvoid getArrowGeometry(vec4 xyzw, float near, float mid, float far, out vec3 left, out vec3 right, out vec3 middle, out vec3 start) {\\r\\n  right  = getPosition(xyzw, 1.0);\\r\\n  left   = getPosition(vec4(near, xyzw.yzw), 0.0);\\r\\n  middle = getPosition(vec4(mid,  xyzw.yzw), 0.0);\\r\\n  start  = getPosition(vec4(far,  xyzw.yzw), 0.0);\\r\\n}\\r\\n\\r\\nmat4 getArrowMatrix(vec3 left, vec3 right, vec3 middle, vec3 start) {\\r\\n\\r\\n  float depth = focusDepth;\\r\\n  if (lineDepth < 1.0) {\\r\\n    // Depth blending\\r\\n    float z = max(0.00001, -right.z);\\r\\n    depth = mix(z, focusDepth, lineDepth);\\r\\n  }\\r\\n\\r\\n  vec3 diff = left - right;\\r\\n  float l = length(diff);\\r\\n  if (l == 0.0) {\\r\\n    return mat4(1.0, 0.0, 0.0, 0.0,\\r\\n                0.0, 1.0, 0.0, 0.0,\\r\\n                0.0, 0.0, 1.0, 0.0,\\r\\n                0.0, 0.0, 0.0, 1.0);\\r\\n  }\\r\\n\\r\\n  // Construct TBN matrix around shaft\\r\\n  vec3 t = normalize(diff);\\r\\n  vec3 n = normalize(cross(t, t.yzx + vec3(.1, .2, .3)));\\r\\n  vec3 b = cross(n, t);\\r\\n  \\r\\n  // Shrink arrows when vector gets too small\\r\\n  // Approach linear scaling with cubic ease the smaller we get\\r\\n  float size = arrowSize * lineWidth * worldUnit * depth * 1.25;\\r\\n  l = max(length(right - middle), length(middle - start)) * 2.0 * arrowSpace;\\r\\n  float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);\\r\\n  float scale = 1.0 - mini * mini * mini;\\r\\n  float range = size * scale;\\r\\n\\r\\n  // Size to 2.5:1 ratio\\r\\n  float rangeNB = range / 2.5;\\r\\n\\r\\n  // Anchor at end position\\r\\n  return mat4(vec4(n * rangeNB,  0),\\r\\n              vec4(b * rangeNB,  0),\\r\\n              vec4(t * range, 0),\\r\\n              vec4(right,  1.0));\\r\\n}\\r\\n\\r\\nvec3 getArrowPosition() {\\r\\n  vec3 left, right, middle, start;\\r\\n  \\r\\n  // Clip arrow position and attachment anchors to data\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  vec3 a = vec3(min(geometryClip.x, p.x + attach.x), geometryClip.x / 2.0, min(geometryClip.x, attach.y));\\r\\n\\r\\n  getArrowGeometry(p, a.x, a.y, a.z, left, right, middle, start);\\r\\n  mat4 matrix = getArrowMatrix(left, right, middle, start);\\r\\n  return (matrix * vec4(arrow.xyz, 1.0)).xyz;\\r\\n\\r\\n}\\r\\n\",\"axis.position\":\"uniform vec4 axisStep;\\r\\nuniform vec4 axisPosition;\\r\\n\\r\\nvec4 getAxisPosition(vec4 xyzw, inout vec4 stpq) {\\r\\n  return axisStep * xyzw.x + axisPosition;\\r\\n}\\r\\n\",\"cartesian.position\":\"uniform mat4 viewMatrix;\\r\\n\\r\\nvec4 getCartesianPosition(vec4 position, inout vec4 stpq) {\\r\\n  return viewMatrix * vec4(position.xyz, 1.0);\\r\\n}\\r\\n\",\"cartesian4.position\":\"uniform vec4 basisScale;\\r\\nuniform vec4 basisOffset;\\r\\nuniform vec4 viewScale;\\r\\nuniform vec4 viewOffset;\\r\\n\\r\\nvec4 getCartesian4Position(vec4 position, inout vec4 stpq) {\\r\\n  return position * basisScale + basisOffset;\\r\\n}\\r\\n\",\"clamp.position\":\"uniform vec4 clampLimit;\\r\\n\\r\\nvec4 getClampXYZW(vec4 xyzw) {\\r\\n  return clamp(xyzw, vec4(0.0), clampLimit);\\r\\n}\\r\\n\",\"color.opaque\":\"vec4 opaqueColor(vec4 color) {\\r\\n  return vec4(color.rgb, 1.0);\\r\\n}\\r\\n\",\"face.position\":\"uniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvec3 getFacePosition() {\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  return getPosition(p, 1.0);\\r\\n}\\r\\n\",\"face.position.normal\":\"attribute vec4 position4;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vLight;\\r\\nvarying vec3 vPosition;\\r\\n\\r\\nvoid getFaceGeometry(vec4 xyzw, out vec3 pos, out vec3 normal) {\\r\\n  vec3 a, b, c;\\r\\n\\r\\n  a   = getPosition(vec4(xyzw.xyz, 0.0), 0.0);\\r\\n  b   = getPosition(vec4(xyzw.xyz, 1.0), 0.0);\\r\\n  c   = getPosition(vec4(xyzw.xyz, 2.0), 0.0);\\r\\n\\r\\n  pos = getPosition(xyzw, 1.0);\\r\\n  normal = normalize(cross(c - a, b - a));\\r\\n}\\r\\n\\r\\nvec3 getFacePositionNormal() {\\r\\n  vec3 center, normal;\\r\\n\\r\\n  getFaceGeometry(position4, center, normal);\\r\\n  vNormal   = normal;\\r\\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);\\r\\n  vPosition = -center;\\r\\n\\r\\n  return center;\\r\\n}\\r\\n\",\"float.encode\":\"/*\\r\\nFloat encoding technique by\\r\\nCarlos Scheidegger\\r\\nhttps://github.com/cscheid/lux/blob/master/src/shade/bits/encode_float.js\\r\\n\\r\\nConversion to GLSL by:\\r\\nhttp://concord-consortium.github.io/lab/experiments/webgl-gpgpu/script.js\\r\\n*/\\r\\n\\r\\nfloat shift_right(float v, float amt) { \\r\\n  v = floor(v) + 0.5; \\r\\n  return floor(v / exp2(amt)); \\r\\n}\\r\\n\\r\\nfloat shift_left(float v, float amt) { \\r\\n  return floor(v * exp2(amt) + 0.5); \\r\\n}\\r\\n\\r\\nfloat mask_last(float v, float bits) { \\r\\n  return mod(v, shift_left(1.0, bits)); \\r\\n}\\r\\n\\r\\nfloat extract_bits(float num, float from, float to) { \\r\\n  from = floor(from + 0.5); to = floor(to + 0.5); \\r\\n  return mask_last(shift_right(num, from), to - from); \\r\\n}\\r\\n\\r\\nvec4 encode_float(float val) { \\r\\n  if (val == 0.0) return vec4(0, 0, 0, 0); \\r\\n  float valuesign = val > 0.0 ? 0.0 : 1.0; \\r\\n  val = abs(val); \\r\\n  float exponent = floor(log2(val)); \\r\\n  float biased_exponent = exponent + 127.0; \\r\\n  float fraction = ((val / exp2(exponent)) - 1.0) * 8388608.0; \\r\\n  float t = biased_exponent / 2.0; \\r\\n  float last_bit_of_biased_exponent = fract(t) * 2.0; \\r\\n  float remaining_bits_of_biased_exponent = floor(t); \\r\\n  float byte4 = extract_bits(fraction, 0.0, 8.0) / 255.0; \\r\\n  float byte3 = extract_bits(fraction, 8.0, 16.0) / 255.0; \\r\\n  float byte2 = (last_bit_of_biased_exponent * 128.0 + extract_bits(fraction, 16.0, 23.0)) / 255.0; \\r\\n  float byte1 = (valuesign * 128.0 + remaining_bits_of_biased_exponent) / 255.0; \\r\\n  return vec4(byte4, byte3, byte2, byte1); \\r\\n}\\r\\n\",\"float.index.pack\":\"uniform vec4 indexModulus;\\r\\n\\r\\nvec4 getSample(vec4 xyzw);\\r\\nvec4 getIndex(vec4 xyzw);\\r\\n\\r\\nvec4 floatPackIndex(vec4 xyzw) {\\r\\n  vec4 value = getSample(xyzw);\\r\\n  vec4 index = getIndex(xyzw);\\r\\n\\r\\n  vec4 offset = floor(index + .5) * indexModulus;\\r\\n  vec2 sum2 = offset.xy + offset.zw;\\r\\n  float sum = sum2.x + sum2.y;\\r\\n  return vec4(value.xyz, sum);\\r\\n}\",\"float.stretch\":\"vec4 getSample(vec4 xyzw);\\r\\n\\r\\nfloat floatStretch(vec4 xyzw, float channelIndex) {\\r\\n  vec4 sample = getSample(xyzw);\\r\\n  vec2 xy = channelIndex > 1.5 ? sample.zw : sample.xy;\\r\\n  return mod(channelIndex, 2.0) > .5 ? xy.y : xy.x;\\r\\n}\",\"fragment.clip.dashed\":\"varying float vClipStrokeWidth;\\r\\nvarying float vClipStrokeIndex;\\r\\nvarying vec3  vClipStrokeEven;\\r\\nvarying vec3  vClipStrokeOdd;\\r\\nvarying vec3  vClipStrokePosition;\\r\\n\\r\\nvoid clipStrokeFragment() {\\r\\n  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;\\r\\n\\r\\n  vec3 tangent;\\r\\n  if (odd) {\\r\\n    tangent = vClipStrokeOdd;\\r\\n  }\\r\\n  else {\\r\\n    tangent = vClipStrokeEven;\\r\\n  }\\r\\n\\r\\n  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;\\r\\n  if (mod(travel, 16.0) > 8.0) {\\r\\n    discard;\\r\\n  }\\r\\n}\\r\\n\",\"fragment.clip.dotted\":\"varying float vClipStrokeWidth;\\r\\nvarying float vClipStrokeIndex;\\r\\nvarying vec3  vClipStrokeEven;\\r\\nvarying vec3  vClipStrokeOdd;\\r\\nvarying vec3  vClipStrokePosition;\\r\\n\\r\\nvoid clipStrokeFragment() {\\r\\n  bool odd = mod(vClipStrokeIndex, 2.0) >= 1.0;\\r\\n\\r\\n  vec3 tangent;\\r\\n  if (odd) {\\r\\n    tangent = vClipStrokeOdd;\\r\\n  }\\r\\n  else {\\r\\n    tangent = vClipStrokeEven;\\r\\n  }\\r\\n\\r\\n  float travel = dot(vClipStrokePosition, normalize(tangent)) / vClipStrokeWidth;\\r\\n  if (mod(travel, 4.0) > 2.0) {\\r\\n    discard;\\r\\n  }\\r\\n}\\r\\n\",\"fragment.clip.ends\":\"varying vec2 vClipEnds;\\r\\n\\r\\nvoid clipEndsFragment() {\\r\\n  if (vClipEnds.x < 0.0 || vClipEnds.y < 0.0) discard;\\r\\n}\\r\\n\",\"fragment.clip.proximity\":\"varying float vClipProximity;\\r\\n\\r\\nvoid clipProximityFragment() {\\r\\n  if (vClipProximity >= 0.5) discard;\\r\\n}\",\"fragment.color\":\"void setFragmentColor(vec4 color) {\\r\\n  gl_FragColor = color;\\r\\n}\",\"fragment.map.rgba\":\"vec4 fragmentRGBA(vec4 rgba, vec4 stpq) {\\r\\n  return rgba;\\r\\n}\",\"fragment.solid\":\"void setFragmentColor(vec4 color) {\\r\\n  if (color.a < 1.0) discard;\\r\\n  gl_FragColor = color;\\r\\n}\",\"fragment.transparent\":\"void setFragmentColor(vec4 color) {\\r\\n  if (color.a >= 1.0) discard;\\r\\n  gl_FragColor = color;\\r\\n}\",\"grid.position\":\"uniform vec4 gridPosition;\\r\\nuniform vec4 gridStep;\\r\\nuniform vec4 gridAxis;\\r\\n\\r\\nvec4 sampleData(vec2 xy);\\r\\n\\r\\nvec4 getGridPosition(vec4 xyzw) {\\r\\n  vec4 onAxis  = gridAxis * sampleData(vec2(xyzw.y, 0.0)).x;\\r\\n  vec4 offAxis = gridStep * xyzw.x + gridPosition;\\r\\n  return onAxis + offAxis;\\r\\n}\\r\\n\",\"grow.position\":\"uniform float growScale;\\r\\nuniform vec4  growMask;\\r\\nuniform vec4  growAnchor;\\r\\n\\r\\nvec4 getSample(vec4 xyzw);\\r\\n\\r\\nvec4 getGrowSample(vec4 xyzw) {\\r\\n  vec4 anchor = xyzw * growMask + growAnchor;\\r\\n\\r\\n  vec4 position = getSample(xyzw);\\r\\n  vec4 center = getSample(anchor);\\r\\n\\r\\n  return mix(center, position, growScale);\\r\\n}\",\"join.position\":\"uniform float joinStride;\\r\\nuniform float joinStrideInv;\\r\\n\\r\\nfloat getIndex(vec4 xyzw);\\r\\nvec4 getRest(vec4 xyzw);\\r\\nvec4 injectIndices(float a, float b);\\r\\n\\r\\nvec4 getJoinXYZW(vec4 xyzw) {\\r\\n\\r\\n  float a = getIndex(xyzw);\\r\\n  float b = a * joinStrideInv;\\r\\n\\r\\n  float integer  = floor(b);\\r\\n  float fraction = b - integer;\\r\\n  \\r\\n  return injectIndices(fraction * joinStride, integer) + getRest(xyzw);\\r\\n}\\r\\n\",\"label.alpha\":\"varying float vPixelSize;\\r\\n\\r\\nvec4 getLabelAlphaColor(vec4 color, vec4 sample) {\\r\\n  float mask = clamp(sample.r * 1000.0, 0.0, 1.0);\\r\\n  float alpha = (sample.r - .5) * vPixelSize + .5;\\r\\n  float a = mask * alpha * color.a;\\r\\n  if (a <= 0.0) discard;\\r\\n  return vec4(color.xyz, a);\\r\\n}\\r\\n\",\"label.map\":\"vec2 mapUV(vec4 uvwo, vec4 stpq) {\\r\\n  return uvwo.xy;\\r\\n}\\r\\n\",\"label.outline\":\"uniform float outlineExpand;\\r\\nuniform float outlineStep;\\r\\nuniform vec3  outlineColor;\\r\\n\\r\\nvarying float vPixelSize;\\r\\n\\r\\nconst float PIXEL_STEP = 255.0 / 16.0;\\r\\n\\r\\nvec4 getLabelOutlineColor(vec4 color, vec4 sample) {\\r\\n  float ps = vPixelSize * PIXEL_STEP;\\r\\n  float os = outlineStep;\\r\\n\\r\\n  float sdf = sample.r - .5 + outlineExpand;\\r\\n  vec2  sdfs = vec2(sdf, sdf + os);\\r\\n  vec2  alpha = clamp(sdfs * ps + .5, 0.0, 1.0);\\r\\n\\r\\n  if (alpha.y <= 0.0) {\\r\\n    discard;\\r\\n  }\\r\\n\\r\\n  vec3 blend = color.xyz;\\r\\n  if (alpha.y > alpha.x) {\\r\\n    blend = sqrt(mix(outlineColor * outlineColor, blend * blend, alpha.x));\\r\\n  }\\r\\n  \\r\\n  return vec4(blend, alpha.y * color.a);\\r\\n}\\r\\n\",\"layer.position\":\"uniform vec4 layerScale;\\r\\nuniform vec4 layerBias;\\r\\n\\r\\n#define PROJECT_ORTHOGONAL\\r\\n\\r\\nvec4 layerPosition(vec4 position, inout vec4 stpq) {\\r\\n  return layerScale * position + layerBias;\\r\\n}\\r\\n\",\"lerp.depth\":\"// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 lerpDepth(vec4 xyzw) {\\r\\n  float x = xyzw.z;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n    \\r\\n  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);\\r\\n  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, f);\\r\\n}\\r\\n\",\"lerp.height\":\"// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 lerpHeight(vec4 xyzw) {\\r\\n  float x = xyzw.y;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n    \\r\\n  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);\\r\\n  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, f);\\r\\n}\\r\\n\",\"lerp.items\":\"// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 lerpItems(vec4 xyzw) {\\r\\n  float x = xyzw.w;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n    \\r\\n  vec4 xyzw1 = vec4(xyzw.xyz, i);\\r\\n  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, f);\\r\\n}\\r\\n\",\"lerp.width\":\"// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 lerpWidth(vec4 xyzw) {\\r\\n  float x = xyzw.x;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n    \\r\\n  vec4 xyzw1 = vec4(i, xyzw.yzw);\\r\\n  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, f);\\r\\n}\\r\\n\",\"line.position\":\"// Units and calibration\\r\\nuniform float worldUnit;\\r\\nuniform float lineWidth;\\r\\nuniform float lineDepth;\\r\\nuniform float focusDepth;\\r\\n\\r\\n// General data index\\r\\nuniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\n\\r\\n// (Top/bottom -1,1) \\r\\nattribute float line;\\r\\n\\r\\n// 0...1 for round or bevel joins\\r\\n#ifdef LINE_JOIN_DETAIL\\r\\nattribute float joint;\\r\\n#else\\r\\nconst float joint = 0.0;\\r\\n#endif\\r\\n\\r\\n// Knock out excessively long line segments (e.g. for asymtpotes)\\r\\n#ifdef LINE_PROXIMITY\\r\\nuniform float lineProximity;\\r\\nvarying float vClipProximity;\\r\\n#endif\\r\\n\\r\\n// Ghetto line stroking (local only, not global)\\r\\n#ifdef LINE_STROKE\\r\\nvarying float vClipStrokeWidth;\\r\\nvarying float vClipStrokeIndex;\\r\\nvarying vec3  vClipStrokeEven;\\r\\nvarying vec3  vClipStrokeOdd;\\r\\nvarying vec3  vClipStrokePosition;\\r\\n#endif\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\n// Clip line ends for arrows / decoration\\r\\n#ifdef LINE_CLIP\\r\\nuniform float clipRange;\\r\\nuniform vec2  clipStyle;\\r\\nuniform float clipSpace;\\r\\n\\r\\nattribute vec2 strip;\\r\\n\\r\\nvarying vec2 vClipEnds;\\r\\n\\r\\nvoid clipEnds(vec4 xyzw, vec3 center, vec3 pos) {\\r\\n  // Sample start of line strip\\r\\n  vec4 xyzwS = vec4(0.0, xyzw.yzw);\\r\\n  vec3 start = getPosition(xyzwS, 0.0);\\r\\n\\r\\n  // Sample middle of line strip\\r\\n  vec4 xyzwM = vec4(geometryClip.x / 2.0, xyzw.yzw);\\r\\n  vec3 middle = getPosition(xyzwM, 0.0);\\r\\n\\r\\n#ifdef LINE_CLOSED\\r\\n  vec3 end = start;\\r\\n#else\\r\\n  // Sample other end of line strip\\r\\n  vec4 xyzwE = vec4(geometryClip.x, xyzw.yzw);\\r\\n  vec3 end   = getPosition(xyzwE, 0.0);\\r\\n#endif\\r\\n\\r\\n  // Measure length\\r\\n  float l = max(length(end - middle), length(middle - start)) * clipSpace * 2.0;\\r\\n\\r\\n  // Arrow length (=2.5x radius)\\r\\n  float arrowSize = 1.25 * clipRange * lineWidth * worldUnit;\\r\\n\\r\\n#ifdef LINE_CLOSED\\r\\n  // Clip around start/end\\r\\n  end = start;\\r\\n#endif\\r\\n\\r\\n  vClipEnds = vec2(1.0);\\r\\n\\r\\n  if (clipStyle.y > 0.0) {\\r\\n    // Depth blend end\\r\\n    float depth = focusDepth;\\r\\n    if (lineDepth < 1.0) {\\r\\n      float z = max(0.00001, -end.z);\\r\\n      depth = mix(z, focusDepth, lineDepth);\\r\\n    }\\r\\n    \\r\\n    // Absolute arrow length\\r\\n    float size = arrowSize * depth;\\r\\n\\r\\n    // Adjust clip range\\r\\n    // Approach linear scaling with cubic ease the smaller we get\\r\\n    float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);\\r\\n    float scale = 1.0 - mini * mini * mini; \\r\\n    float invrange = 1.0 / (size * scale);\\r\\n  \\r\\n    // Clip end\\r\\n    vec3 diff = end - center;\\r\\n    if(diff == vec3(0.0))\\r\\n      vClipEnds.x = -1.0;\\r\\n    else {\\r\\n      diff = normalize(end - center);\\r\\n      float d = dot(end - pos, diff);\\r\\n      vClipEnds.x = d * invrange - 1.0;\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (clipStyle.x > 0.0) {\\r\\n    // Depth blend start\\r\\n    float depth = focusDepth;\\r\\n    if (lineDepth < 1.0) {\\r\\n      float z = max(0.00001, -start.z);\\r\\n      depth = mix(z, focusDepth, lineDepth);\\r\\n    }\\r\\n    \\r\\n    // Absolute arrow length\\r\\n    float size = arrowSize * depth;\\r\\n\\r\\n    // Adjust clip range\\r\\n    // Approach linear scaling with cubic ease the smaller we get\\r\\n    float mini = clamp(1.0 - l / size * .333, 0.0, 1.0);\\r\\n    float scale = 1.0 - mini * mini * mini; \\r\\n    float invrange = 1.0 / (size * scale);\\r\\n  \\r\\n    // Clip start \\r\\n    vec3 diff = center - start;\\r\\n    if(diff == vec3(0.0))\\r\\n      vClipEnds.y = -1.0;\\r\\n    else {\\r\\n      diff = normalize(center - start);\\r\\n      float d = dot(pos - start, diff);\\r\\n      vClipEnds.y = d * invrange - 1.0;\\r\\n    }\\r\\n  }\\r\\n}\\r\\n#endif\\r\\n\\r\\n// Adjust left/center/right to be inside near/far z range\\r\\nconst float epsilon = 1e-5;\\r\\nvoid fixCenter(inout vec3 left, inout vec3 center, inout vec3 right) {\\r\\n  if (center.z >= 0.0) {\\r\\n    if (left.z < 0.0) {\\r\\n      float d = (center.z + epsilon) / (center.z - left.z);\\r\\n      center = mix(center, left, d);\\r\\n    }\\r\\n    else if (right.z < 0.0) {\\r\\n      float d = (center.z + epsilon) / (center.z - right.z);\\r\\n      center = mix(center, right, d);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (left.z >= 0.0) {\\r\\n    if (center.z < 0.0) {\\r\\n      float d = (left.z + epsilon) / (left.z - center.z);\\r\\n      left = mix(left, center, d);\\r\\n    }\\r\\n  }\\r\\n\\r\\n  if (right.z >= 0.0) {\\r\\n    if (center.z < 0.0) {\\r\\n      float d = (right.z + epsilon) / (right.z - center.z);\\r\\n      right = mix(right, center, d);\\r\\n    }\\r\\n  }\\r\\n}\\r\\n\\r\\nvec4 wrapAround(vec4 xyzw) {\\r\\n#ifdef LINE_CLOSED\\r\\n  float gx = geometryClip.x;\\r\\n  if (xyzw.x < 0.0) xyzw.x += gx;\\r\\n  if (xyzw.x >= gx) xyzw.x -= gx;\\r\\n#endif\\r\\n  return xyzw;\\r\\n}\\r\\n\\r\\n// Sample the source data in an edge-aware manner\\r\\nvoid getLineGeometry(vec4 xyzw, float edge, out vec3 left, out vec3 center, out vec3 right) {\\r\\n  vec4 delta = vec4(1.0, 0.0, 0.0, 0.0);\\r\\n\\r\\n  center = getPosition(xyzw, 1.0);\\r\\n  left   = (edge > -0.5) ? getPosition(wrapAround(xyzw - delta), 0.0) : center;\\r\\n  right  = (edge < 0.5)  ? getPosition(wrapAround(xyzw + delta), 0.0) : center;\\r\\n}\\r\\n\\r\\n// Calculate the position for a vertex along the line, including joins\\r\\nvec3 getLineJoin(float edge, bool odd, vec3 left, vec3 center, vec3 right, float width, float offset, float joint) {\\r\\n  vec2 join = vec2(1.0, 0.0);\\r\\n\\r\\n  fixCenter(left, center, right);\\r\\n\\r\\n  vec4 a = vec4(left.xy, right.xy);\\r\\n  vec4 b = a / vec4(left.zz, right.zz);\\r\\n\\r\\n  vec2 l = b.xy;\\r\\n  vec2 r = b.zw;\\r\\n  vec2 c = center.xy / center.z;\\r\\n\\r\\n  vec4 d = vec4(l, c) - vec4(c, r);\\r\\n  float l1 = dot(d.xy, d.xy);\\r\\n  float l2 = dot(d.zw, d.zw);\\r\\n\\r\\n  if (l1 + l2 > 0.0) {\\r\\n    \\r\\n    if (edge > 0.5 || l2 == 0.0) {\\r\\n      vec2 nl = normalize(d.xy);\\r\\n      vec2 tl = vec2(nl.y, -nl.x);\\r\\n\\r\\n#ifdef LINE_PROXIMITY\\r\\n      vClipProximity = 1.0;\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_STROKE\\r\\n      vClipStrokeEven = vClipStrokeOdd = normalize(left - center);\\r\\n#endif\\r\\n      join = tl;\\r\\n    }\\r\\n    else if (edge < -0.5 || l1 == 0.0) {\\r\\n      vec2 nr = normalize(d.zw);\\r\\n      vec2 tr = vec2(nr.y, -nr.x);\\r\\n\\r\\n#ifdef LINE_PROXIMITY\\r\\n      vClipProximity = 1.0;\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_STROKE\\r\\n      vClipStrokeEven = vClipStrokeOdd = normalize(center - right);\\r\\n#endif\\r\\n      join = tr;\\r\\n    }\\r\\n    else {\\r\\n      // Limit join stretch for tiny segments\\r\\n      float lmin2 = min(l1, l2) / (width * width);\\r\\n\\r\\n      // Hide line segment if ratio of leg lengths exceeds promixity threshold\\r\\n#ifdef LINE_PROXIMITY\\r\\n      float lr     = l1 / l2;\\r\\n      float rl     = l2 / l1;\\r\\n      float ratio  = max(lr, rl);\\r\\n      float thresh = lineProximity + 1.0;\\r\\n      vClipProximity = (ratio > thresh * thresh) ? 1.0 : 0.0;\\r\\n#endif\\r\\n\\r\\n      // Calculate normals/tangents\\r\\n      vec2 nl = normalize(d.xy);\\r\\n      vec2 nr = normalize(d.zw);\\r\\n\\r\\n      // Calculate tangents\\r\\n      vec2 tl = vec2(nl.y, -nl.x);\\r\\n      vec2 tr = vec2(nr.y, -nr.x);\\r\\n\\r\\n#ifdef LINE_PROXIMITY\\r\\n      // Mix tangents according to leg lengths\\r\\n      vec2 tc = normalize(mix(tl, tr, l1/(l1+l2)));\\r\\n#else\\r\\n      // Average tangent\\r\\n      vec2 tc = normalize(tl + tr);\\r\\n#endif\\r\\n    \\r\\n      // Miter join\\r\\n      float cosA   = dot(nl, tc);\\r\\n      float sinA   = max(0.1, abs(dot(tl, tc)));\\r\\n      float factor = cosA / sinA;\\r\\n      float scale  = sqrt(1.0 + min(lmin2, factor * factor));\\r\\n\\r\\n      // Stroke normals\\r\\n#ifdef LINE_STROKE\\r\\n      vec3 stroke1 = normalize(left - center);\\r\\n      vec3 stroke2 = normalize(center - right);\\r\\n\\r\\n      if (odd) {\\r\\n        vClipStrokeEven = stroke1;\\r\\n        vClipStrokeOdd  = stroke2;\\r\\n      }\\r\\n      else {\\r\\n        vClipStrokeEven = stroke2;\\r\\n        vClipStrokeOdd  = stroke1;\\r\\n      }\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_JOIN_MITER\\r\\n      // Apply straight up miter\\r\\n      join = tc * scale;\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_JOIN_ROUND\\r\\n      // Slerp bevel join into circular arc\\r\\n      float dotProduct = dot(nl, nr);\\r\\n      float angle = acos(dotProduct);\\r\\n      float sinT  = sin(angle);\\r\\n      join = (sin((1.0 - joint) * angle) * tl + sin(joint * angle) * tr) / sinT;\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_JOIN_BEVEL\\r\\n      // Direct bevel join between two flat ends\\r\\n      float dotProduct = dot(nl, nr);\\r\\n      join = mix(tl, tr, joint);\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_JOIN_DETAIL\\r\\n      // Check if on inside or outside of joint\\r\\n      float crossProduct = nl.x * nr.y - nl.y * nr.x;\\r\\n      if (offset * crossProduct < 0.0) {\\r\\n        // For near-180-degree bends, correct back to a miter to avoid discontinuities\\r\\n        float ratio = clamp(-dotProduct * 2.0 - 1.0, 0.0, 1.0);\\r\\n        // Otherwise collapse the inside vertices into one.\\r\\n        join = mix(tc * scale, join, ratio * ratio * ratio);\\r\\n      }\\r\\n#endif\\r\\n\\r\\n    }\\r\\n    return vec3(join, 0.0);\\r\\n  }\\r\\n  else {\\r\\n    return vec3(0.0);\\r\\n  }\\r\\n\\r\\n}\\r\\n\\r\\n// Calculate final line position\\r\\nvec3 getLinePosition() {\\r\\n  vec3 left, center, right, join;\\r\\n\\r\\n  // Up/down along segment\\r\\n  float offset = line;\\r\\n\\r\\n  // Clip data\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n\\r\\n  // Left/center/right\\r\\n  float edge = 0.0;\\r\\n#ifdef LINE_CLOSED\\r\\n  if (p.x == geometryClip.x) p.x = 0.0;\\r\\n#else\\r\\n  if (p.x == geometryClip.x) edge = 1.0;\\r\\n  if (p.x == 0.0) edge = -1.0;\\r\\n#endif\\r\\n\\r\\n  // Get position + adjacent neighbours\\r\\n  getLineGeometry(p, edge, left, center, right);\\r\\n\\r\\n#ifdef LINE_STROKE\\r\\n  // Set parameters for line stroke fragment shader\\r\\n  vClipStrokePosition = center;\\r\\n  vClipStrokeIndex = p.x;\\r\\n  bool odd = mod(p.x, 2.0) >= 1.0;\\r\\n#else\\r\\n  bool odd = true;\\r\\n#endif\\r\\n\\r\\n  // Divide line width up/down\\r\\n  float width = lineWidth * 0.5;\\r\\n\\r\\n  float depth = focusDepth;\\r\\n  if (lineDepth < 1.0) {\\r\\n    // Depth blending\\r\\n    float z = max(0.00001, -center.z);\\r\\n    depth = mix(z, focusDepth, lineDepth);\\r\\n  }\\r\\n  width *= depth;\\r\\n\\r\\n  // Convert to world units\\r\\n  width *= worldUnit;\\r\\n\\r\\n  // Calculate line join\\r\\n#ifdef LINE_CLOSED\\r\\n  join = getLineJoin(0.0, odd, left, center, right, width, offset, joint);\\r\\n#else\\r\\n  join = getLineJoin(edge, odd, left, center, right, width, offset, joint);\\r\\n#endif\\r\\n  vec3 pos = center + join * offset * width;\\r\\n\\r\\n#ifdef LINE_STROKE\\r\\n  vClipStrokeWidth = width;\\r\\n#endif\\r\\n\\r\\n#ifdef LINE_CLIP\\r\\n  clipEnds(p, center, pos);\\r\\n#endif\\r\\n\\r\\n  return pos;\\r\\n}\\r\\n\",\"map.2d.data\":\"uniform vec2 dataResolution;\\r\\nuniform vec2 dataPointer;\\r\\n\\r\\nvec2 map2DData(vec2 xy) {\\r\\n  return fract((xy + dataPointer) * dataResolution);\\r\\n}\\r\\n\",\"map.2d.data.wrap\":\"uniform vec2 dataResolution;\\r\\nuniform vec2 dataPointer;\\r\\n\\r\\nvec2 map2DData(vec2 xy) {\\r\\n  return fract((xy + dataPointer) * dataResolution);\\r\\n}\\r\\n\",\"map.xyzw.2dv\":\"void mapXyzw2DV(vec4 xyzw, out vec2 xy, out float z) {\\r\\n  xy = xyzw.xy;\\r\\n  z  = xyzw.z;\\r\\n}\\r\\n\\r\\n\",\"map.xyzw.align\":\"vec4 alignXYZW(vec4 xyzw) {\\r\\n  return floor(xyzw + .5);\\r\\n}\\r\\n\\r\\n\",\"map.xyzw.texture\":\"uniform float textureItems;\\r\\nuniform float textureHeight;\\r\\n\\r\\nvec2 mapXyzwTexture(vec4 xyzw) {\\r\\n  \\r\\n  float x = xyzw.x;\\r\\n  float y = xyzw.y;\\r\\n  float z = xyzw.z;\\r\\n  float i = xyzw.w;\\r\\n  \\r\\n  return vec2(i, y) + vec2(x, z) * vec2(textureItems, textureHeight);\\r\\n}\\r\\n\\r\\n\",\"mesh.fragment.color\":\"varying vec4 vColor;\\r\\n\\r\\nvec4 getColor() {\\r\\n  if (vColor.a <= 0.0) discard;\\r\\n  return vColor;\\r\\n}\\r\\n\",\"mesh.fragment.map\":\"#ifdef POSITION_STPQ\\r\\nvarying vec4 vSTPQ;\\r\\n#endif\\r\\n#ifdef POSITION_U\\r\\nvarying float vU;\\r\\n#endif\\r\\n#ifdef POSITION_UV\\r\\nvarying vec2 vUV;\\r\\n#endif\\r\\n#ifdef POSITION_UVW\\r\\nvarying vec3 vUVW;\\r\\n#endif\\r\\n#ifdef POSITION_UVWO\\r\\nvarying vec4 vUVWO;\\r\\n#endif\\r\\n\\r\\nvec4 getSample(vec4 uvwo, vec4 stpq);\\r\\n\\r\\nvec4 getMapColor() {\\r\\n  #ifdef POSITION_STPQ\\r\\n  vec4 stpq = vSTPQ;\\r\\n  #else\\r\\n  vec4 stpq = vec4(0.0);\\r\\n  #endif\\r\\n\\r\\n  #ifdef POSITION_U\\r\\n  vec4 uvwo = vec4(vU, 0.0, 0.0, 0.0);\\r\\n  #endif\\r\\n  #ifdef POSITION_UV\\r\\n  vec4 uvwo = vec4(vUV, 0.0, 0.0);\\r\\n  #endif\\r\\n  #ifdef POSITION_UVW\\r\\n  vec4 uvwo = vec4(vUVW, 0.0);\\r\\n  #endif\\r\\n  #ifdef POSITION_UVWO\\r\\n  vec4 uvwo = vec4(vUVWO);\\r\\n  #endif\\r\\n\\r\\n  return getSample(uvwo, stpq);\\r\\n}\\r\\n\",\"mesh.fragment.mask\":\"varying float vMask;\\r\\n\\r\\nfloat ease(float t) {\\r\\n  t = clamp(t, 0.0, 1.0);\\r\\n  return t * t * (3.0 - 2.0 * t);\\r\\n}\\r\\n\\r\\nvec4 maskColor() {\\r\\n  if (vMask <= 0.0) discard;\\r\\n  return vec4(vec3(1.0), ease(vMask));\\r\\n}\\r\\n\",\"mesh.fragment.material\":\"#ifdef POSITION_STPQ\\r\\nvarying vec4 vSTPQ;\\r\\n#endif\\r\\n#ifdef POSITION_U\\r\\nvarying float vU;\\r\\n#endif\\r\\n#ifdef POSITION_UV\\r\\nvarying vec2 vUV;\\r\\n#endif\\r\\n#ifdef POSITION_UVW\\r\\nvarying vec3 vUVW;\\r\\n#endif\\r\\n#ifdef POSITION_UVWO\\r\\nvarying vec4 vUVWO;\\r\\n#endif\\r\\n\\r\\nvec4 getSample(vec4 rgba, vec4 stpq);\\r\\n\\r\\nvec4 getMaterialColor(vec4 rgba) {\\r\\n  vec4 stpq = vec4(0.0);\\r\\n\\r\\n  #ifdef POSITION_U\\r\\n  stpq.x = vU;\\r\\n  #endif\\r\\n  #ifdef POSITION_UV\\r\\n  stpq.xy = vUV;\\r\\n  #endif\\r\\n  #ifdef POSITION_UVW\\r\\n  stpq.xyz = vUVW;\\r\\n  #endif\\r\\n  #ifdef POSITION_UVWO\\r\\n  stpq = vUVWO;\\r\\n  #endif\\r\\n\\r\\n  #ifdef POSITION_STPQ\\r\\n  stpq = vSTPQ;\\r\\n  #endif\\r\\n\\r\\n  return getSample(rgba, stpq);\\r\\n}\\r\\n\",\"mesh.fragment.shaded\":\"varying vec3 vNormal;\\r\\nvarying vec3 vLight;\\r\\nvarying vec3 vPosition;\\r\\n\\r\\nvec3 offSpecular(vec3 color) {\\r\\n  vec3 c = 1.0 - color;\\r\\n  return 1.0 - c * c;\\r\\n}\\r\\n\\r\\nvec4 getShadedColor(vec4 rgba) {\\r\\n  \\r\\n  vec3 color = rgba.xyz;\\r\\n  vec3 color2 = offSpecular(rgba.xyz);\\r\\n\\r\\n  vec3 normal = normalize(vNormal);\\r\\n  vec3 light = normalize(vLight);\\r\\n  vec3 position = normalize(vPosition);\\r\\n  \\r\\n  float side    = gl_FrontFacing ? -1.0 : 1.0;\\r\\n  float cosine  = side * dot(normal, light);\\r\\n  float diffuse = mix(max(0.0, cosine), .5 + .5 * cosine, .1);\\r\\n  \\r\\n  vec3  halfLight = normalize(light + position);\\r\\n\\tfloat cosineHalf = max(0.0, side * dot(normal, halfLight));\\r\\n\\tfloat specular = pow(cosineHalf, 16.0);\\r\\n\\t\\r\\n\\treturn vec4(color * (diffuse * .9 + .05) + .25 * color2 * specular, rgba.a);\\r\\n}\\r\\n\",\"mesh.fragment.texture\":\"\",\"mesh.gamma.in\":\"vec4 getGammaInColor(vec4 rgba) {\\r\\n  return vec4(rgba.rgb * rgba.rgb, rgba.a);\\r\\n}\\r\\n\",\"mesh.gamma.out\":\"vec4 getGammaOutColor(vec4 rgba) {\\r\\n  return vec4(sqrt(rgba.rgb), rgba.a);\\r\\n}\\r\\n\",\"mesh.map.uvwo\":\"vec4 mapUVWO(vec4 uvwo, vec4 stpq) {\\r\\n  return uvwo;\\r\\n}\\r\\n\",\"mesh.position\":\"uniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvec3 getMeshPosition() {\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  return getPosition(p, 1.0);\\r\\n}\\r\\n\",\"mesh.vertex.color\":\"attribute vec4 position4;\\r\\nuniform vec4 geometryClip;\\r\\nvarying vec4 vColor;\\r\\n\\r\\n// External\\r\\nvec4 getSample(vec4 xyzw);\\r\\n\\r\\nvoid vertexColor() {\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  vColor = getSample(p);\\r\\n}\\r\\n\",\"mesh.vertex.mask\":\"attribute vec4 position4;\\r\\nuniform vec4 geometryResolution;\\r\\nuniform vec4 geometryClip;\\r\\nvarying float vMask;\\r\\n\\r\\n// External\\r\\nfloat getSample(vec4 xyzw);\\r\\n\\r\\nvoid maskLevel() {\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  vMask = getSample(p * geometryResolution);\\r\\n}\\r\\n\",\"mesh.vertex.position\":\"uniform vec4 geometryResolution;\\r\\n\\r\\n#ifdef POSITION_STPQ\\r\\nvarying vec4 vSTPQ;\\r\\n#endif\\r\\n#ifdef POSITION_U\\r\\nvarying float vU;\\r\\n#endif\\r\\n#ifdef POSITION_UV\\r\\nvarying vec2 vUV;\\r\\n#endif\\r\\n#ifdef POSITION_UVW\\r\\nvarying vec3 vUVW;\\r\\n#endif\\r\\n#ifdef POSITION_UVWO\\r\\nvarying vec4 vUVWO;\\r\\n#endif\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut);\\r\\n\\r\\nvec3 getMeshPosition(vec4 xyzw, float canonical) {\\r\\n  vec4 stpqOut, stpqIn = xyzw * geometryResolution;\\r\\n  vec3 xyz = getPosition(xyzw, stpqIn, stpqOut);\\r\\n\\r\\n  #ifdef POSITION_MAP\\r\\n  if (canonical > 0.5) {\\r\\n    #ifdef POSITION_STPQ\\r\\n    vSTPQ = stpqOut;\\r\\n    #endif\\r\\n    #ifdef POSITION_U\\r\\n    vU = stpqOut.x;\\r\\n    #endif\\r\\n    #ifdef POSITION_UV\\r\\n    vUV = stpqOut.xy;\\r\\n    #endif\\r\\n    #ifdef POSITION_UVW\\r\\n    vUVW = stpqOut.xyz;\\r\\n    #endif\\r\\n    #ifdef POSITION_UVWO\\r\\n    vUVWO = stpqOut;\\r\\n    #endif\\r\\n  }\\r\\n  #endif\\r\\n  return xyz;\\r\\n}\\r\\n\",\"move.position\":\"uniform float transitionEnter;\\r\\nuniform float transitionExit;\\r\\nuniform vec4  transitionScale;\\r\\nuniform vec4  transitionBias;\\r\\nuniform float transitionSkew;\\r\\nuniform float transitionActive;\\r\\n\\r\\nuniform vec4  moveFrom;\\r\\nuniform vec4  moveTo;\\r\\n\\r\\nfloat ease(float t) {\\r\\n  t = clamp(t, 0.0, 1.0);\\r\\n  return 1.0 - (2.0 - t) * t;\\r\\n}\\r\\n\\r\\nvec4 getTransitionPosition(vec4 xyzw, inout vec4 stpq) {\\r\\n  if (transitionActive < 0.5) return xyzw;\\r\\n\\r\\n  float enter   = transitionEnter;\\r\\n  float exit    = transitionExit;\\r\\n  float skew    = transitionSkew;\\r\\n  vec4  scale   = transitionScale;\\r\\n  vec4  bias    = transitionBias;\\r\\n\\r\\n  float factor  = 1.0 + skew;\\r\\n  float offset  = dot(vec4(1.0), stpq * scale + bias);\\r\\n\\r\\n  float a1 = ease(enter * factor - offset);\\r\\n  float a2 = ease(exit  * factor + offset - skew);\\r\\n\\r\\n  return xyzw + a1 * moveFrom + a2 * moveTo;\\r\\n}\",\"object.mask.default\":\"vec4 getMask(vec4 xyzw) {\\r\\n  return vec4(1.0);\\r\\n}\",\"point.alpha.circle\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getDiscAlpha(float mask) {\\r\\n  // Approximation: 1 - x*x is approximately linear around x = 1 with slope 2\\r\\n  return vPixelSize * (1.0 - mask);\\r\\n  //  return vPixelSize * 2.0 * (1.0 - sqrt(mask));\\r\\n}\\r\\n\",\"point.alpha.circle.hollow\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getDiscHollowAlpha(float mask) {\\r\\n  return vPixelSize * (0.5 - 2.0 * abs(sqrt(mask) - .75));\\r\\n}\\r\\n\",\"point.alpha.generic\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getGenericAlpha(float mask) {\\r\\n  return vPixelSize * 2.0 * (1.0 - mask);\\r\\n}\\r\\n\",\"point.alpha.generic.hollow\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getGenericHollowAlpha(float mask) {\\r\\n  return vPixelSize * (0.5 - 2.0 * abs(mask - .75));\\r\\n}\\r\\n\",\"point.edge\":\"varying vec2 vSprite;\\r\\n\\r\\nfloat getSpriteMask(vec2 xy);\\r\\nfloat getSpriteAlpha(float mask);\\r\\n\\r\\nvoid setFragmentColorFill(vec4 color) {\\r\\n  float mask = getSpriteMask(vSprite);\\r\\n  if (mask > 1.0) {\\r\\n    discard;\\r\\n  }\\r\\n  float alpha = getSpriteAlpha(mask);\\r\\n  if (alpha >= 1.0) {\\r\\n    discard;\\r\\n  }\\r\\n  gl_FragColor = vec4(color.rgb, alpha * color.a);\\r\\n}\\r\\n\",\"point.fill\":\"varying vec2 vSprite;\\r\\n\\r\\nfloat getSpriteMask(vec2 xy);\\r\\nfloat getSpriteAlpha(float mask);\\r\\n\\r\\nvoid setFragmentColorFill(vec4 color) {\\r\\n  float mask = getSpriteMask(vSprite);\\r\\n  if (mask > 1.0) {\\r\\n    discard;\\r\\n  }\\r\\n  float alpha = getSpriteAlpha(mask);\\r\\n  if (alpha < 1.0) {\\r\\n    discard;\\r\\n  }\\r\\n  gl_FragColor = color;\\r\\n}\\r\\n\\r\\n\",\"point.mask.circle\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getCircleMask(vec2 uv) {\\r\\n  return dot(uv, uv);\\r\\n}\\r\\n\",\"point.mask.diamond\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getDiamondMask(vec2 uv) {\\r\\n  vec2 a = abs(uv);\\r\\n  return a.x + a.y;\\r\\n}\\r\\n\",\"point.mask.down\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getTriangleDownMask(vec2 uv) {\\r\\n  uv.y += .25;\\r\\n  return max(uv.y, abs(uv.x) * .866 - uv.y * .5 + .6);\\r\\n}\\r\\n\",\"point.mask.left\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getTriangleLeftMask(vec2 uv) {\\r\\n  uv.x += .25;\\r\\n  return max(uv.x, abs(uv.y) * .866 - uv.x * .5 + .6);\\r\\n}\\r\\n\",\"point.mask.right\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getTriangleRightMask(vec2 uv) {\\r\\n  uv.x -= .25;\\r\\n  return max(-uv.x, abs(uv.y) * .866 + uv.x * .5 + .6);\\r\\n}\\r\\n\",\"point.mask.square\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getSquareMask(vec2 uv) {\\r\\n  vec2 a = abs(uv);\\r\\n  return max(a.x, a.y);\\r\\n}\\r\\n\",\"point.mask.up\":\"varying float vPixelSize;\\r\\n\\r\\nfloat getTriangleUpMask(vec2 uv) {\\r\\n  uv.y -= .25;\\r\\n  return max(-uv.y, abs(uv.x) * .866 + uv.y * .5 + .6);\\r\\n}\\r\\n\",\"point.position\":\"uniform float pointDepth;\\r\\n\\r\\nuniform float pixelUnit;\\r\\nuniform float renderScale;\\r\\nuniform float renderScaleInv;\\r\\nuniform float focusDepth;\\r\\n\\r\\nuniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\nattribute vec2 sprite;\\r\\n\\r\\nvarying vec2 vSprite;\\r\\nvarying float vPixelSize;\\r\\n\\r\\nconst float pointScale = POINT_SHAPE_SCALE;\\r\\n\\r\\n// External\\r\\nfloat getPointSize(vec4 xyzw);\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvec3 getPointPosition() {\\r\\n  // Discard out-of-range points by generating degenerate face\\r\\n  if (\\r\\n    position4.x > geometryClip.x ||\\r\\n    position4.y > geometryClip.y ||\\r\\n    position4.z > geometryClip.z ||\\r\\n    position4.w > geometryClip.w\\r\\n  ) return vec3(0.0, 0.0, 0.0);\\r\\n  vec4 p = position4;\\r\\n\\r\\n  vec3 center = getPosition(p, 1.0);\\r\\n\\r\\n  // Depth blending\\r\\n  // TODO: orthographic camera\\r\\n  // Workaround: set depth = 0\\r\\n  float z = -center.z;\\r\\n  float depth = mix(z, focusDepth, pointDepth);\\r\\n  \\r\\n  // Match device/unit mapping \\r\\n  // Sprite goes from -1..1, width = 2.\\r\\n  float pointSize = getPointSize(p);\\r\\n  float size = pointScale * pointSize * pixelUnit * .5;\\r\\n  float depthSize = depth * size;\\r\\n  \\r\\n  // Pad sprite by half a pixel to make the anti-aliasing straddle the pixel edge\\r\\n  // Note: pixelsize measures radius\\r\\n  float pixelSize = .5 * (pointDepth > 0.0 ? depthSize / z : size);\\r\\n  float paddedSize = pixelSize + 0.5;\\r\\n  float padFactor = paddedSize / pixelSize;\\r\\n\\r\\n  vPixelSize = paddedSize;\\r\\n  vSprite    = sprite;\\r\\n\\r\\n  return center + vec3(sprite * depthSize * renderScaleInv * padFactor, 0.0);\\r\\n}\\r\\n\",\"point.size.uniform\":\"uniform float pointSize;\\r\\n\\r\\nfloat getPointSize(vec4 xyzw) {\\r\\n  return pointSize;\\r\\n}\",\"point.size.varying\":\"uniform float pointSize;\\r\\n\\r\\nvec4 getSample(vec4 xyzw);\\r\\n\\r\\nfloat getPointSize(vec4 xyzw) {\\r\\n  return pointSize * getSample(xyzw).x;\\r\\n}\",\"polar.position\":\"uniform float polarBend;\\r\\nuniform float polarFocus;\\r\\nuniform float polarAspect;\\r\\nuniform float polarHelix;\\r\\n\\r\\nuniform mat4 viewMatrix;\\r\\n\\r\\nvec4 getPolarPosition(vec4 position, inout vec4 stpq) {\\r\\n  if (polarBend > 0.0) {\\r\\n\\r\\n    if (polarBend < 0.001) {\\r\\n      // Factor out large addition/subtraction of polarFocus\\r\\n      // to avoid numerical error\\r\\n      // sin(x) ~ x\\r\\n      // cos(x) ~ 1 - x * x / 2\\r\\n      vec2 pb = position.xy * polarBend;\\r\\n      float ppbbx = pb.x * pb.x;\\r\\n      return viewMatrix * vec4(\\r\\n        position.x * (1.0 - polarBend + (pb.y * polarAspect)),\\r\\n        position.y * (1.0 - .5 * ppbbx) - (.5 * ppbbx) * polarFocus / polarAspect,\\r\\n        position.z + position.x * polarHelix * polarBend,\\r\\n        1.0\\r\\n      );\\r\\n    }\\r\\n    else {\\r\\n      vec2 xy = position.xy * vec2(polarBend, polarAspect);\\r\\n      float radius = polarFocus + xy.y;\\r\\n      return viewMatrix * vec4(\\r\\n        sin(xy.x) * radius,\\r\\n        (cos(xy.x) * radius - polarFocus) / polarAspect,\\r\\n        position.z + position.x * polarHelix * polarBend,\\r\\n        1.0\\r\\n      );\\r\\n    }\\r\\n  }\\r\\n  else {\\r\\n    return viewMatrix * vec4(position.xyz, 1.0);\\r\\n  }\\r\\n}\",\"project.position\":\"uniform float styleZBias;\\r\\nuniform float styleZIndex;\\r\\n\\r\\nvoid setPosition(vec3 position) {\\r\\n\\r\\n  #ifdef PROJECT_ORTHOGONAL\\r\\n  // Orthogonal projection with depth preservation around z = 1\\r\\n  vec4 pos = projectionMatrix * vec4(position, 1.0);\\r\\n  pos.xy *= -position.z;\\r\\n  #else\\r\\n  // Normal perspective projection\\r\\n  vec4 pos = projectionMatrix * vec4(position, 1.0);\\r\\n  #endif\\r\\n\\r\\n  // Apply relative Z bias\\r\\n  float bias  = (1.0 - styleZBias / 32768.0);\\r\\n  pos.z *= bias;\\r\\n  \\r\\n  // Apply large scale Z index changes\\r\\n  if (styleZIndex > 0.0) {\\r\\n    float z = pos.z / pos.w;\\r\\n    pos.z = ((z + 1.0) / (styleZIndex + 1.0) - 1.0) * pos.w;\\r\\n  }\\r\\n  \\r\\n  gl_Position = pos;\\r\\n}\",\"project.readback\":\"// This is three.js' global uniform, missing from fragment shaders.\\r\\nuniform mat4 projectionMatrix;\\r\\n\\r\\nvec4 readbackPosition(vec3 position, vec4 stpq) {\\r\\n  vec4 pos = projectionMatrix * vec4(position, 1.0);\\r\\n  vec3 final = pos.xyz / pos.w;\\r\\n  if (final.z < -1.0) {\\r\\n    return vec4(0.0, 0.0, 0.0, -1.0);\\r\\n  }\\r\\n  else {\\r\\n    return vec4(final, -position.z);\\r\\n  }\\r\\n}\\r\\n\",\"raw.position.scale\":\"uniform vec4 geometryScale;\\r\\nattribute vec4 position4;\\r\\n\\r\\nvec4 getRawPositionScale() {\\r\\n  return geometryScale * position4;\\r\\n}\\r\\n\",\"repeat.position\":\"uniform vec4 repeatModulus;\\r\\n\\r\\nvec4 getRepeatXYZW(vec4 xyzw) {\\r\\n  return mod(xyzw + .5, repeatModulus) - .5;\\r\\n}\\r\\n\",\"resample.padding\":\"uniform vec4 resampleBias;\\r\\n\\r\\nvec4 resamplePadding(vec4 xyzw) {\\r\\n  return xyzw + resampleBias;\\r\\n}\",\"resample.relative\":\"uniform vec4 resampleFactor;\\r\\n\\r\\nvec4 resampleRelative(vec4 xyzw) {\\r\\n  return xyzw * resampleFactor;\\r\\n}\",\"reveal.mask\":\"uniform float transitionEnter;\\r\\nuniform float transitionExit;\\r\\nuniform vec4  transitionScale;\\r\\nuniform vec4  transitionBias;\\r\\nuniform float transitionSkew;\\r\\nuniform float transitionActive;\\r\\n\\r\\nfloat getTransitionSDFMask(vec4 stpq) {\\r\\n  if (transitionActive < 0.5) return 1.0;\\r\\n\\r\\n  float enter   = transitionEnter;\\r\\n  float exit    = transitionExit;\\r\\n  float skew    = transitionSkew;\\r\\n  vec4  scale   = transitionScale;\\r\\n  vec4  bias    = transitionBias;\\r\\n\\r\\n  float factor  = 1.0 + skew;\\r\\n  float offset  = dot(vec4(1.0), stpq * scale + bias);\\r\\n\\r\\n  vec2 d = vec2(enter, exit) * factor + vec2(-offset, offset - skew);\\r\\n  if (exit  == 1.0) return d.x;\\r\\n  if (enter == 1.0) return d.y;\\r\\n  return min(d.x, d.y);\\r\\n}\",\"reverse.position\":\"uniform vec4 reverseScale;\\r\\nuniform vec4 reverseOffset;\\r\\n\\r\\nvec4 getReverseOffset(vec4 xyzw) {\\r\\n  return xyzw * reverseScale + reverseOffset;\\r\\n}\\r\\n\",\"root.position\":\"vec3 getRootPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut) {\\r\\n  stpqOut = stpqIn; // avoid inout confusion\\r\\n  return position.xyz;\\r\\n}\",\"sample.2d\":\"uniform sampler2D dataTexture;\\r\\n\\r\\nvec4 sample2D(vec2 uv) {\\r\\n  return texture2D(dataTexture, uv);\\r\\n}\\r\\n\",\"scale.position\":\"uniform vec4 scaleAxis;\\r\\nuniform vec4 scaleOffset;\\r\\n\\r\\nvec4 sampleData(float x);\\r\\n\\r\\nvec4 getScalePosition(vec4 xyzw) {\\r\\n  return scaleAxis * sampleData(xyzw.x).x + scaleOffset;\\r\\n}\\r\\n\",\"screen.map.stpq\":\"uniform vec4 remapSTPQScale;\\r\\n\\r\\nvec4 screenMapSTPQ(vec4 xyzw, out vec4 stpq) {\\r\\n  stpq = xyzw * remapSTPQScale;\\r\\n  return xyzw;\\r\\n}\\r\\n\",\"screen.map.xy\":\"uniform vec2 remapUVScale;\\r\\n\\r\\nvec4 screenMapXY(vec4 uvwo, vec4 stpq) {\\r\\n  return vec4(floor(remapUVScale * uvwo.xy), 0.0, 0.0);\\r\\n}\\r\\n\",\"screen.map.xyzw\":\"uniform vec2 remapUVScale;\\r\\nuniform vec2 remapModulus;\\r\\nuniform vec2 remapModulusInv;\\r\\n\\r\\nvec4 screenMapXYZW(vec4 uvwo, vec4 stpq) {\\r\\n  vec2 st = floor(remapUVScale * uvwo.xy);\\r\\n  vec2 xy = st * remapModulusInv;\\r\\n  vec2 ixy = floor(xy);\\r\\n  vec2 fxy = xy - ixy;\\r\\n  vec2 zw = fxy * remapModulus;\\r\\n  return vec4(ixy.x, zw.y, ixy.y, zw.x);\\r\\n}\\r\\n\",\"screen.pass.uv\":\"vec2 screenPassUV(vec4 uvwo, vec4 stpq) {\\r\\n  return uvwo.xy;\\r\\n}\\r\\n\",\"screen.position\":\"void setScreenPosition(vec4 position) {\\r\\n  gl_Position = vec4(position.xy * 2.0 - 1.0, 0.5, 1.0);\\r\\n}\\r\\n\",\"slice.position\":\"uniform vec4 sliceOffset;\\r\\n\\r\\nvec4 getSliceOffset(vec4 xyzw) {\\r\\n  return xyzw + sliceOffset;\\r\\n}\\r\\n\",\"spherical.position\":\"uniform float sphericalBend;\\r\\nuniform float sphericalFocus;\\r\\nuniform float sphericalAspectX;\\r\\nuniform float sphericalAspectY;\\r\\nuniform float sphericalScaleY;\\r\\n\\r\\nuniform mat4 viewMatrix;\\r\\n\\r\\nvec4 getSphericalPosition(vec4 position, inout vec4 stpq) {\\r\\n  if (sphericalBend > 0.0001) {\\r\\n\\r\\n    vec3 xyz = position.xyz * vec3(sphericalBend, sphericalBend / sphericalAspectY * sphericalScaleY, sphericalAspectX);\\r\\n    float radius = sphericalFocus + xyz.z;\\r\\n    float cosine = cos(xyz.y) * radius;\\r\\n\\r\\n    return viewMatrix * vec4(\\r\\n      sin(xyz.x) * cosine,\\r\\n      sin(xyz.y) * radius * sphericalAspectY,\\r\\n      (cos(xyz.x) * cosine - sphericalFocus) / sphericalAspectX,\\r\\n      1.0\\r\\n    );\\r\\n  }\\r\\n  else {\\r\\n    return viewMatrix * vec4(position.xyz, 1.0);\\r\\n  }\\r\\n}\",\"split.position\":\"uniform float splitStride;\\r\\n\\r\\nvec2 getIndices(vec4 xyzw);\\r\\nvec4 getRest(vec4 xyzw);\\r\\nvec4 injectIndex(float v);\\r\\n\\r\\nvec4 getSplitXYZW(vec4 xyzw) {\\r\\n  vec2 uv = getIndices(xyzw);\\r\\n  float offset = uv.x + uv.y * splitStride;\\r\\n  return injectIndex(offset) + getRest(xyzw);\\r\\n}\\r\\n\",\"spread.position\":\"uniform vec4 spreadOffset;\\r\\nuniform mat4 spreadMatrix;\\r\\n\\r\\n// External\\r\\nvec4 getSample(vec4 xyzw);\\r\\n\\r\\nvec4 getSpreadSample(vec4 xyzw) {\\r\\n  vec4 sample = getSample(xyzw);\\r\\n  return sample + spreadMatrix * (spreadOffset + xyzw);\\r\\n}\\r\\n\",\"sprite.fragment\":\"varying vec2 vSprite;\\r\\n\\r\\nvec4 getSample(vec2 xy);\\r\\n\\r\\nvec4 getSpriteColor() {\\r\\n  return getSample(vSprite);\\r\\n}\",\"sprite.position\":\"uniform vec2 spriteOffset;\\r\\nuniform float spriteScale;\\r\\nuniform float spriteDepth;\\r\\nuniform float spriteSnap;\\r\\n\\r\\nuniform vec2 renderOdd;\\r\\nuniform float renderScale;\\r\\nuniform float renderScaleInv;\\r\\nuniform float pixelUnit;\\r\\nuniform float focusDepth;\\r\\n\\r\\nuniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\nattribute vec2 sprite;\\r\\n\\r\\nvarying float vPixelSize;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\nvec4 getSprite(vec4 xyzw);\\r\\n\\r\\nvec3 getSpritePosition() {\\r\\n  // Clip points\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  float diff = length(position4 - p);\\r\\n  if (diff > 0.0) {\\r\\n    return vec3(0.0, 0.0, 1000.0);\\r\\n  }\\r\\n\\r\\n  // Make sprites\\r\\n  vec3 center = getPosition(p, 1.0);\\r\\n  vec4 atlas = getSprite(p);\\r\\n\\r\\n  // Sprite goes from -1..1, width = 2.\\r\\n  // -1..1 -> -0.5..0.5\\r\\n  vec2 halfSprite = sprite * .5;\\r\\n  vec2 halfFlipSprite = vec2(halfSprite.x, -halfSprite.y);\\r\\n\\r\\n#ifdef POSITION_UV\\r\\n  // Assign UVs\\r\\n  vUV = atlas.xy + atlas.zw * (halfFlipSprite + .5);\\r\\n#endif\\r\\n\\r\\n  // Depth blending\\r\\n  // TODO: orthographic camera\\r\\n  // Workaround: set depth = 0\\r\\n  float depth = focusDepth, z;\\r\\n  z = -center.z;\\r\\n  if (spriteDepth < 1.0) {\\r\\n    depth = mix(z, focusDepth, spriteDepth);\\r\\n  }\\r\\n  \\r\\n  // Match device/unit mapping \\r\\n  float size = pixelUnit * spriteScale;\\r\\n  float depthSize = depth * size;\\r\\n\\r\\n  // Calculate pixelSize for anti-aliasing\\r\\n  float pixelSize = (spriteDepth > 0.0 ? depthSize / z : size);\\r\\n  vPixelSize = pixelSize;\\r\\n\\r\\n  // Position sprite\\r\\n  vec2 atlasOdd = fract(atlas.zw / 2.0);\\r\\n  vec2 offset = (spriteOffset + halfSprite * atlas.zw) * depthSize;\\r\\n  if (spriteSnap > 0.5) {\\r\\n    // Snap to pixel (w/ epsilon shift to avoid jitter)\\r\\n    return vec3(((floor(center.xy / center.z * renderScale + 0.001) + renderOdd + atlasOdd) * center.z + offset) * renderScaleInv, center.z);\\r\\n  }\\r\\n  else {\\r\\n    // Place directly\\r\\n    return center + vec3(offset * renderScaleInv, 0.0);\\r\\n  }\\r\\n\\r\\n}\\r\\n\",\"stereographic.position\":\"uniform float stereoBend;\\r\\n\\r\\nuniform mat4 viewMatrix;\\r\\n\\r\\nvec4 getStereoPosition(vec4 position, inout vec4 stpq) {\\r\\n  if (stereoBend > 0.0001) {\\r\\n\\r\\n    vec3 pos = position.xyz;\\r\\n    float r = length(pos);\\r\\n    float z = r + pos.z;\\r\\n    vec3 project = vec3(pos.xy / z, r);\\r\\n    \\r\\n    vec3 lerped = mix(pos, project, stereoBend);\\r\\n\\r\\n    return viewMatrix * vec4(lerped, 1.0);\\r\\n  }\\r\\n  else {\\r\\n    return viewMatrix * vec4(position.xyz, 1.0);\\r\\n  }\\r\\n}\",\"stereographic4.position\":\"uniform float stereoBend;\\r\\nuniform vec4 basisScale;\\r\\nuniform vec4 basisOffset;\\r\\nuniform mat4 viewMatrix;\\r\\nuniform vec2 view4D;\\r\\n\\r\\nvec4 getStereographic4Position(vec4 position, inout vec4 stpq) {\\r\\n  \\r\\n  vec4 transformed;\\r\\n  if (stereoBend > 0.0001) {\\r\\n\\r\\n    float r = length(position);\\r\\n    float w = r + position.w;\\r\\n    vec4 project = vec4(position.xyz / w, r);\\r\\n    \\r\\n    transformed = mix(position, project, stereoBend);\\r\\n  }\\r\\n  else {\\r\\n    transformed = position;\\r\\n  }\\r\\n\\r\\n  vec4 pos4 = transformed * basisScale - basisOffset;\\r\\n  vec3 xyz = (viewMatrix * vec4(pos4.xyz, 1.0)).xyz;\\r\\n  return vec4(xyz, pos4.w * view4D.y + view4D.x);\\r\\n}\\r\\n\",\"stpq.sample.2d\":\"varying vec2 vST;\\r\\n\\r\\nvec4 getSample(vec2 st);\\r\\n\\r\\nvec4 getSTSample() {\\r\\n  return getSample(vST);\\r\\n}\\r\\n\",\"stpq.xyzw.2d\":\"varying vec2 vUV;\\r\\n\\r\\nvoid setRawUV(vec4 xyzw) {\\r\\n  vUV = xyzw.xy;\\r\\n}\\r\\n\",\"strip.position.normal\":\"uniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\nattribute vec3 strip;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vLight;\\r\\nvarying vec3 vPosition;\\r\\n\\r\\nvoid getStripGeometry(vec4 xyzw, vec3 strip, out vec3 pos, out vec3 normal) {\\r\\n  vec3 a, b, c;\\r\\n\\r\\n  a   = getPosition(xyzw, 1.0);\\r\\n  b   = getPosition(vec4(xyzw.xyz, strip.x), 0.0);\\r\\n  c   = getPosition(vec4(xyzw.xyz, strip.y), 0.0);\\r\\n\\r\\n  normal = normalize(cross(c - a, b - a)) * strip.z;\\r\\n  \\r\\n  pos = a;\\r\\n}\\r\\n\\r\\nvec3 getStripPositionNormal() {\\r\\n  vec3 center, normal;\\r\\n\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n\\r\\n  getStripGeometry(p, strip, center, normal);\\r\\n  vNormal   = normal;\\r\\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz);\\r\\n  vPosition = -center;\\r\\n\\r\\n  return center;\\r\\n}\\r\\n\",\"style.color\":\"uniform vec3 styleColor;\\r\\nuniform float styleOpacity;\\r\\n\\r\\nvec4 getStyleColor() {\\r\\n  return vec4(styleColor, styleOpacity);\\r\\n}\\r\\n\",\"subdivide.depth\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideDepth(vec4 xyzw) {\\r\\n  float x = xyzw.z;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  return sampleData(vec4(xyzw.xy, i + g, xyzw.w));\\r\\n}\\r\\n\",\"subdivide.depth.lerp\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideDepthLerp(vec4 xyzw) {\\r\\n  float x = xyzw.z;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  vec4 xyzw1 = vec4(xyzw.xy, i, xyzw.w);\\r\\n  vec4 xyzw2 = vec4(xyzw.xy, i + 1.0, xyzw.w);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, g);\\r\\n}\\r\\n\",\"subdivide.height\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideHeight(vec4 xyzw) {\\r\\n  float x = xyzw.y;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  return sampleData(vec4(xyzw.x, i + g, xyzw.zw));\\r\\n}\\r\\n\",\"subdivide.height.lerp\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideHeightLerp(vec4 xyzw) {\\r\\n  float x = xyzw.y;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  vec4 xyzw1 = vec4(xyzw.x, i, xyzw.zw);\\r\\n  vec4 xyzw2 = vec4(xyzw.x, i + 1.0, xyzw.zw);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, g);\\r\\n}\\r\\n\",\"subdivide.items\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideItems(vec4 xyzw) {\\r\\n  float x = xyzw.w;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  return sampleData(vec4(xyzw.xyz, i + g));\\r\\n}\\r\\n\",\"subdivide.items.lerp\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideItemsLerp(vec4 xyzw) {\\r\\n  float x = xyzw.w;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  vec4 xyzw1 = vec4(xyzw.xyz, i);\\r\\n  vec4 xyzw2 = vec4(xyzw.xyz, i + 1.0);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, g);\\r\\n}\\r\\n\",\"subdivide.width\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideWidth(vec4 xyzw) {\\r\\n  float x = xyzw.x;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  return sampleData(vec4(i + g, xyzw.yzw));\\r\\n}\\r\\n\",\"subdivide.width.lerp\":\"uniform float subdivideBevel;\\r\\n\\r\\n// External\\r\\nvec4 sampleData(vec4 xyzw);\\r\\n\\r\\nvec4 subdivideWidthLerp(vec4 xyzw) {\\r\\n  float x = xyzw.x;\\r\\n  float i = floor(x);\\r\\n  float f = x - i;\\r\\n\\r\\n  float minf = subdivideBevel * min(f, 1.0 - f);\\r\\n  float g = (f > 0.5) ? 1.0 - minf : (f < 0.5) ? minf : 0.5;\\r\\n\\r\\n  vec4 xyzw1 = vec4(i, xyzw.yzw);\\r\\n  vec4 xyzw2 = vec4(i + 1.0, xyzw.yzw);\\r\\n  \\r\\n  vec4 a = sampleData(xyzw1);\\r\\n  vec4 b = sampleData(xyzw2);\\r\\n\\r\\n  return mix(a, b, g);\\r\\n}\\r\\n\",\"surface.mask.hollow\":\"attribute vec4 position4;\\r\\n\\r\\nfloat getSurfaceHollowMask(vec4 xyzw) {\\r\\n  vec4 df = abs(fract(position4) - .5);\\r\\n  vec2 df2 = min(df.xy, df.zw);\\r\\n  float df3 = min(df2.x, df2.y);\\r\\n  return df3;\\r\\n}\",\"surface.position\":\"uniform vec4 geometryClip;\\r\\nuniform vec4 geometryResolution;\\r\\nuniform vec4 mapSize;\\r\\n\\r\\nattribute vec4 position4;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvec3 getSurfacePosition() {\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n\\r\\n#ifdef SURFACE_CLOSED_X\\r\\n  if (p.x == geometryClip.x) p.x = 0.0;\\r\\n#endif\\r\\n#ifdef SURFACE_CLOSED_Y\\r\\n  if (p.y == geometryClip.y) p.y = 0.0;\\r\\n#endif\\r\\n\\r\\n  vec3 xyz = getPosition(p, 1.0);\\r\\n\\r\\n  // Overwrite UVs\\r\\n#ifdef POSITION_UV\\r\\n#ifdef POSITION_UV_INT\\r\\n  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;\\r\\n#else\\r\\n  vUV = position4.xy * geometryResolution.xy;\\r\\n#endif\\r\\n#endif\\r\\n\\r\\n  return xyz;\\r\\n}\\r\\n\",\"surface.position.normal\":\"uniform vec4 mapSize;\\r\\nuniform vec4 geometryResolution;\\r\\nuniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\nvec3 getNormal(vec4 xyzw);\\r\\n\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vLight;\\r\\nvarying vec3 vPosition;\\r\\n\\r\\nvec3 getSurfacePositionNormal() {\\r\\n\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n#ifdef SURFACE_CLOSED_X\\r\\n  if (p.x == geometryClip.x) p.x = 0.0;\\r\\n#endif\\r\\n#ifdef SURFACE_CLOSED_Y\\r\\n  if (p.y == geometryClip.y) p.y = 0.0;\\r\\n#endif\\r\\n\\r\\n  vec3 center = getPosition(p, 1.0);\\r\\n  vNormal   = normalMatrix * normalize(getNormal(p));\\r\\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz); // hardcoded directional light\\r\\n  vPosition = -center;\\r\\n\\r\\n#ifdef POSITION_UV\\r\\n#ifdef POSITION_UV_INT\\r\\n  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;\\r\\n#else\\r\\n  vUV = position4.xy * geometryResolution.xy;\\r\\n#endif\\r\\n#endif\\r\\n  \\r\\n  return center;\\r\\n}\\r\\n\",\"surface.position.shaded\":\"uniform vec4 mapSize;\\r\\nuniform vec4 geometryResolution;\\r\\nuniform vec4 geometryClip;\\r\\nattribute vec4 position4;\\r\\n\\r\\n// External\\r\\nvec3 getPosition(vec4 xyzw, float canonical);\\r\\n\\r\\nvec4 wrapAround(vec4 xyzw) {\\r\\n#ifdef SURFACE_CLOSED_X\\r\\n  float gx = geometryClip.x;\\r\\n  if (xyzw.x < 0.0) xyzw.x += gx;\\r\\n  if (xyzw.x >= gx) xyzw.x -= gx;\\r\\n#endif\\r\\n#ifdef SURFACE_CLOSED_Y\\r\\n  float gy = geometryClip.y;\\r\\n  if (xyzw.y < 0.0) xyzw.y += gy;\\r\\n  if (xyzw.y >= gy) xyzw.y -= gy;\\r\\n#endif\\r\\n  return xyzw;\\r\\n}\\r\\n\\r\\nvoid getSurfaceGeometry(vec4 xyzw, float edgeX, float edgeY, out vec3 left, out vec3 center, out vec3 right, out vec3 up, out vec3 down) {\\r\\n  vec4 deltaX = vec4(1.0, 0.0, 0.0, 0.0);\\r\\n  vec4 deltaY = vec4(0.0, 1.0, 0.0, 0.0);\\r\\n\\r\\n  center =                  getPosition(xyzw, 1.0);\\r\\n  left   =                  center;\\r\\n  down   =                  center;\\r\\n  right  = (edgeX < 0.5)  ? getPosition(wrapAround(xyzw + deltaX), 0.0) : (2.0 * center - getPosition(xyzw - deltaX, 0.0));\\r\\n  up     = (edgeY < 0.5)  ? getPosition(wrapAround(xyzw + deltaY), 0.0) : (2.0 * center - getPosition(xyzw - deltaY, 0.0));\\r\\n}\\r\\n\\r\\nvec3 getSurfaceNormal(vec3 left, vec3 center, vec3 right, vec3 up, vec3 down) {\\r\\n  vec3 dx = right - left;\\r\\n  vec3 dy = up    - down;\\r\\n  vec3 n = cross(dy, dx);\\r\\n  if (length(n) > 0.0) {\\r\\n    return normalize(n);\\r\\n  }\\r\\n  return vec3(0.0, 1.0, 0.0);\\r\\n}\\r\\n\\r\\nvarying vec3 vNormal;\\r\\nvarying vec3 vLight;\\r\\nvarying vec3 vPosition;\\r\\n\\r\\nvec3 getSurfacePositionShaded() {\\r\\n  vec3 left, center, right, up, down;\\r\\n\\r\\n  vec4 p = min(geometryClip, position4);\\r\\n  vec2 surface = vec2(0.0);\\r\\n#ifdef SURFACE_CLOSED_X\\r\\n  if (p.x == geometryClip.x) p.x = 0.0;\\r\\n#else\\r\\n  if (p.x == geometryClip.x) surface.x = 1.0;\\r\\n  //if (p.x == 0.0) surface.x = -1.0;\\r\\n#endif\\r\\n#ifdef SURFACE_CLOSED_Y\\r\\n  if (p.y == geometryClip.y) p.y = 0.0;\\r\\n#else\\r\\n  if (p.y == geometryClip.y) surface.y = 1.0;\\r\\n  //if (p.y == 0.0) surface.y = -1.0;\\r\\n#endif\\r\\n\\r\\n  getSurfaceGeometry(p, surface.x, surface.y, left, center, right, up, down);\\r\\n  vNormal   = getSurfaceNormal(left, center, right, up, down);\\r\\n  vLight    = normalize((viewMatrix * vec4(1.0, 2.0, 2.0, 0.0)).xyz); // hardcoded directional light\\r\\n  vPosition = -center;\\r\\n\\r\\n#ifdef POSITION_UV\\r\\n#ifdef POSITION_UV_INT\\r\\n  vUV = -.5 + (position4.xy * geometryResolution.xy) * mapSize.xy;\\r\\n#else\\r\\n  vUV = position4.xy * geometryResolution.xy;\\r\\n#endif\\r\\n#endif\\r\\n  \\r\\n  return center;\\r\\n}\\r\\n\",\"ticks.position\":\"uniform float worldUnit;\\r\\nuniform float focusDepth;\\r\\nuniform float tickSize;\\r\\nuniform float tickEpsilon;\\r\\nuniform vec3  tickNormal;\\r\\nuniform vec2  tickStrip;\\r\\n\\r\\nvec4 getSample(vec4 xyzw);\\r\\n\\r\\nvec3 transformPosition(vec4 position, in vec4 stpqIn, out vec4 stpqOut);\\r\\n\\r\\nvec3 getTickPosition(vec4 xyzw, in vec4 stpqIn, out vec4 stpqOut) {\\r\\n  float epsilon = tickEpsilon;\\r\\n\\r\\n  // determine tick direction\\r\\n  float leftX  = max(tickStrip.x, xyzw.y - 1.0);\\r\\n  float rightX = min(tickStrip.y, xyzw.y + 1.0);\\r\\n  \\r\\n  vec4 left    = getSample(vec4(leftX,  xyzw.zw, 0.0));\\r\\n  vec4 right   = getSample(vec4(rightX, xyzw.zw, 0.0));\\r\\n  vec4 diff    = right - left;\\r\\n\\r\\n  vec3 normal  = cross(normalize(diff.xyz + vec3(diff.w)), tickNormal);\\r\\n  float bias   = max(0.0, 1.0 - length(normal) * 2.0);\\r\\n       normal  = mix(normal, tickNormal.yzx, bias * bias);\\r\\n  \\r\\n  // transform (point) and (point + delta)\\r\\n  vec4 center  = getSample(vec4(xyzw.yzw, 0.0));\\r\\n  vec4 delta   = vec4(normal, 0.0) * epsilon;\\r\\n\\r\\n  vec4 a = center;\\r\\n  vec4 b = center + delta;\\r\\n\\r\\n  vec4 _;\\r\\n  vec3 c = transformPosition(a, stpqIn, stpqOut);\\r\\n  vec3 d = transformPosition(b, stpqIn, _);\\r\\n  \\r\\n  // sample on either side to create line\\r\\n  float line = xyzw.x - .5;\\r\\n  vec3  mid  = c;\\r\\n  vec3  side = normalize(d - c);\\r\\n\\r\\n  return mid + side * line * tickSize * worldUnit * focusDepth;\\r\\n}\\r\\n\",\"transform3.position\":\"uniform mat4 transformMatrix;\\r\\n\\r\\nvec4 transformPosition(vec4 position, inout vec4 stpq) {\\r\\n  return transformMatrix * vec4(position.xyz, 1.0);\\r\\n}\\r\\n\",\"transform4.position\":\"uniform mat4 transformMatrix;\\r\\nuniform vec4 transformOffset;\\r\\n\\r\\nvec4 transformPosition(vec4 position, inout vec4 stpq) {\\r\\n  return transformMatrix * position + transformOffset;\\r\\n}\\r\\n\",\"view.position\":\"// Implicit three.js uniform\\r\\n// uniform mat4 viewMatrix;\\r\\n\\r\\nvec4 getViewPosition(vec4 position, inout vec4 stpq) {\\r\\n  return (viewMatrix * vec4(position.xyz, 1.0));\\r\\n}\\r\\n\"}");
	
	/***/ }),
	/* 233 */
	/***/ (function(module, exports, __webpack_require__) {
	
	exports.Animator = __webpack_require__(234);
	
	exports.API = __webpack_require__(235);
	
	exports.Controller = __webpack_require__(236);
	
	
	/***/ }),
	/* 234 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Animation, Animator, Ease;
	
	Ease = __webpack_require__(0).Ease;
	
	Animator = (function() {
		function Animator(context) {
			this.context = context;
			this.anims = [];
		}
	
		Animator.prototype.make = function(type, options) {
			var anim;
			anim = new Animation(this, this.context.time, type, options);
			this.anims.push(anim);
			return anim;
		};
	
		Animator.prototype.unmake = function(anim) {
			var a;
			return this.anims = (function() {
				var i, len, ref, results;
				ref = this.anims;
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					a = ref[i];
					if (a !== anim) {
						results.push(a);
					}
				}
				return results;
			}).call(this);
		};
	
		Animator.prototype.update = function() {
			var anim, time;
			time = this.context.time;
			return this.anims = (function() {
				var i, len, ref, results;
				ref = this.anims;
				results = [];
				for (i = 0, len = ref.length; i < len; i++) {
					anim = ref[i];
					if (anim.update(time) !== false) {
						results.push(anim);
					}
				}
				return results;
			}).call(this);
		};
	
		Animator.prototype.lerp = function(type, from, to, f, value) {
			var emitter, fromE, lerp, toE;
			if (value == null) {
				value = type.make();
			}
			if (type.lerp) {
				value = type.lerp(from, to, value, f);
			} else if (type.emitter) {
				fromE = from.emitterFrom;
				toE = to.emitterTo;
				if ((fromE != null) && (toE != null) && fromE === toE) {
					fromE.lerp(f);
					return fromE;
				} else {
					emitter = type.emitter(from, to);
					from.emitterFrom = emitter;
					to.emitterTo = emitter;
					emitter.lerp(f);
					return emitter;
				}
			} else if (type.op) {
				lerp = function(a, b) {
					if (a === +a && b === +b) {
						return a + (b - a) * f;
					} else {
						if (f > .5) {
							return b;
						} else {
							return a;
						}
					}
				};
				value = type.op(from, to, value, lerp);
			} else {
				value = f > .5 ? to : from;
			}
			return value;
		};
	
		return Animator;
	
	})();
	
	Animation = (function() {
		function Animation(animator, time1, type1, options1) {
			this.animator = animator;
			this.time = time1;
			this.type = type1;
			this.options = options1;
			this.value = this.type.make();
			this.target = this.type.make();
			this.queue = [];
		}
	
		Animation.prototype.dispose = function() {
			return this.animator.unmake(this);
		};
	
		Animation.prototype.set = function() {
			var invalid, target, value;
			target = this.target;
			value = arguments.length > 1 ? [].slice.call(arguments) : arguments[0];
			invalid = false;
			value = this.type.validate(value, target, function() {
				return invalid = true;
			});
			if (!invalid) {
				target = value;
			}
			this.cancel();
			this.target = this.value;
			this.value = target;
			return this.notify();
		};
	
		Animation.prototype.getTime = function() {
			var clock, time;
			clock = this.options.clock;
			time = clock ? clock.getTime() : this.time;
			if (this.options.realtime) {
				return time.time;
			} else {
				return time.clock;
			}
		};
	
		Animation.prototype.cancel = function(from) {
			var base, cancelled, i, len, queue, stage;
			if (from == null) {
				from = this.getTime();
			}
			queue = this.queue;
			cancelled = (function() {
				var i, len, results;
				results = [];
				for (i = 0, len = queue.length; i < len; i++) {
					stage = queue[i];
					if (stage.end >= from) {
						results.push(stage);
					}
				}
				return results;
			})();
			this.queue = (function() {
				var i, len, results;
				results = [];
				for (i = 0, len = queue.length; i < len; i++) {
					stage = queue[i];
					if (stage.end < from) {
						results.push(stage);
					}
				}
				return results;
			})();
			for (i = 0, len = cancelled.length; i < len; i++) {
				stage = cancelled[i];
				if (typeof stage.complete === "function") {
					stage.complete(false);
				}
			}
			if (typeof (base = this.options).complete === "function") {
				base.complete(false);
			}
		};
	
		Animation.prototype.notify = function() {
			var base;
			return typeof (base = this.options).step === "function" ? base.step(this.value) : void 0;
		};
	
		Animation.prototype.immediate = function(value, options) {
			var complete, delay, duration, ease, end, invalid, start, step, target, time;
			duration = options.duration, delay = options.delay, ease = options.ease, step = options.step, complete = options.complete;
			time = this.getTime();
			start = time + delay;
			end = start + duration;
			invalid = false;
			target = this.type.make();
			value = this.type.validate(value, target, function() {
				invalid = true;
				return null;
			});
			if (value !== void 0) {
				target = value;
			}
			this.cancel(start);
			return this.queue.push({
				from: null,
				to: target,
				start: start,
				end: end,
				ease: ease,
				step: step,
				complete: complete
			});
		};
	
		Animation.prototype.update = function(time1) {
			var active, base, clock, complete, ease, end, f, from, method, queue, ref, ref1, stage, start, step, to, value;
			this.time = time1;
			if (this.queue.length === 0) {
				return true;
			}
			clock = this.getTime();
			ref = this, value = ref.value, queue = ref.queue;
			active = false;
			while (!active) {
				ref1 = stage = queue[0], from = ref1.from, to = ref1.to, start = ref1.start, end = ref1.end, step = ref1.step, complete = ref1.complete, ease = ref1.ease;
				if (from == null) {
					from = stage.from = this.type.clone(this.value);
				}
				f = Ease.clamp(((clock - start) / Math.max(0.00001, end - start)) || 0, 0, 1);
				if (f === 0) {
					return;
				}
				method = (function() {
					switch (ease) {
						case 'linear':
						case 0:
							return null;
						case 'cosine':
						case 1:
							return Ease.cosine;
						case 'binary':
						case 2:
							return Ease.binary;
						case 'hold':
						case 3:
							return Ease.hold;
						default:
							return Ease.cosine;
					}
				})();
				if (method != null) {
					f = method(f);
				}
				active = f < 1;
				value = active ? this.animator.lerp(this.type, from, to, f, value) : to;
				if (typeof step === "function") {
					step(value);
				}
				if (!active) {
					if (typeof complete === "function") {
						complete(true);
					}
					if (typeof (base = this.options).complete === "function") {
						base.complete(true);
					}
					queue.shift();
					if (queue.length === 0) {
						break;
					}
				}
			}
			this.value = value;
			return this.notify();
		};
	
		return Animation;
	
	})();
	
	module.exports = Animator;
	
	
	/***/ }),
	/* 235 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var API, Util;
	
	Util = __webpack_require__(0);
	
	API = (function() {
		API.prototype.v2 = function() {
			return this;
		};
	
		function API(_context, _up, _targets) {
			var i, j, l, len, len1, ref, ref1, root, t, type;
			this._context = _context;
			this._up = _up;
			this._targets = _targets;
			root = this._context.controller.getRoot();
			if (this._targets == null) {
				this._targets = [root];
			}
			this.isRoot = this._targets.length === 1 && this._targets[0] === root;
			this.isLeaf = this._targets.length === 1 && (this._targets[0].children == null);
			ref = this._targets;
			for (i = j = 0, len = ref.length; j < len; i = ++j) {
				t = ref[i];
				this[i] = t;
			}
			this.length = this._targets.length;
			ref1 = this._context.controller.getTypes();
			for (l = 0, len1 = ref1.length; l < len1; l++) {
				type = ref1[l];
				if (type !== 'root') {
					(function(_this) {
						return (function(type) {
							return _this[type] = function(options, binds) {
								return _this.add(type, options, binds);
							};
						});
					})(this)(type);
				}
			}
		}
	
		API.prototype.select = function(selector) {
			var targets;
			targets = this._context.model.select(selector, !this.isRoot ? this._targets : null);
			return this._push(targets);
		};
	
		API.prototype.eq = function(index) {
			if (this._targets.length > index) {
				return this._push([this._targets[index]]);
			}
			return this._push([]);
		};
	
		API.prototype.filter = function(callback) {
			var matcher;
			if (typeof callback === 'string') {
				matcher = this._context.model._matcher(callback);
				callback = function(x) {
					return matcher(x);
				};
			}
			return this._push(this._targets.filter(callback));
		};
	
		API.prototype.map = function(callback) {
			var i, j, ref, results;
			results = [];
			for (i = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
				results.push(callback(this[i], i, this));
			}
			return results;
		};
	
		API.prototype.each = function(callback) {
			var i, j, ref;
			for (i = j = 0, ref = this.length; 0 <= ref ? j < ref : j > ref; i = 0 <= ref ? ++j : --j) {
				callback(this[i], i, this);
			}
			return this;
		};
	
		API.prototype.add = function(type, options, binds) {
			var controller, j, len, node, nodes, ref, target;
			controller = this._context.controller;
			if (this.isLeaf) {
				return this._pop().add(type, options, binds);
			}
			nodes = [];
			ref = this._targets;
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				node = controller.make(type, options, binds);
				controller.add(node, target);
				nodes.push(node);
			}
			return this._push(nodes);
		};
	
		API.prototype.remove = function(selector) {
			var j, len, ref, target;
			if (selector) {
				return this.select(selector).remove();
			}
			ref = this._targets.slice().reverse();
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				this._context.controller.remove(target);
			}
			return this._pop();
		};
	
		API.prototype.set = function(key, value) {
			var j, len, ref, target;
			ref = this._targets;
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				this._context.controller.set(target, key, value);
			}
			return this;
		};
	
		API.prototype.getAll = function(key) {
			var j, len, ref, results, target;
			ref = this._targets;
			results = [];
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				results.push(this._context.controller.get(target, key));
			}
			return results;
		};
	
		API.prototype.get = function(key) {
			var ref;
			return (ref = this._targets[0]) != null ? ref.get(key) : void 0;
		};
	
		API.prototype.evaluate = function(key, time) {
			var ref;
			return (ref = this._targets[0]) != null ? ref.evaluate(key, time) : void 0;
		};
	
		API.prototype.bind = function(key, value) {
			var j, len, ref, target;
			ref = this._targets;
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				this._context.controller.bind(target, key, value);
			}
			return this;
		};
	
		API.prototype.unbind = function(key) {
			var j, len, ref, target;
			ref = this._targets;
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				this._context.controller.unbind(target, key);
			}
			return this;
		};
	
		API.prototype.end = function() {
			return (this.isLeaf ? this._pop() : this)._pop();
		};
	
		API.prototype._push = function(targets) {
			return new API(this._context, this, targets);
		};
	
		API.prototype._pop = function() {
			var ref;
			return (ref = this._up) != null ? ref : this;
		};
	
		API.prototype._reset = function() {
			var ref, ref1;
			return (ref = (ref1 = this._up) != null ? ref1.reset() : void 0) != null ? ref : this;
		};
	
		API.prototype.map = function(callback) {
			return this._targets.map(callback);
		};
	
		API.prototype["on"] = function() {
			var args;
			args = arguments;
			this._targets.map(function(x) {
				return x.on.apply(x, args);
			});
			return this;
		};
	
		API.prototype["off"] = function() {
			var args;
			args = arguments;
			this._targets.map(function(x) {
				return x.off.apply(x, args);
			});
			return this;
		};
	
		API.prototype.toString = function() {
			var tags;
			tags = this._targets.map(function(x) {
				return x.toString();
			});
			if (this._targets.length > 1) {
				return "[" + (tags.join(", ")) + "]";
			} else {
				return tags[0];
			}
		};
	
		API.prototype.toMarkup = function() {
			var tags;
			tags = this._targets.map(function(x) {
				return x.toMarkup();
			});
			return tags.join("\n\n");
		};
	
		API.prototype.print = function() {
			Util.Pretty.print(this._targets.map(function(x) {
				return x.toMarkup();
			}).join("\n\n"));
			return this;
		};
	
		API.prototype.debug = function() {
			var getName, info, j, len, name, ref, shader, shaders;
			info = this.inspect();
			console.log('Renderables: ', info.renderables);
			console.log('Renders: ', info.renders);
			console.log('Shaders: ', info.shaders);
			getName = function(owner) {
				return owner.constructor.toString().match('function +([^(]*)')[1];
			};
			shaders = [];
			ref = info.shaders;
			for (j = 0, len = ref.length; j < len; j++) {
				shader = ref[j];
				name = getName(shader.owner);
				shaders.push(name + " - Vertex");
				shaders.push(shader.vertex);
				shaders.push(name + " - Fragment");
				shaders.push(shader.fragment);
			}
			return ShaderGraph.inspect(shaders);
		};
	
		API.prototype.inspect = function(selector, trait, print) {
			var _info, flatten, info, j, k, len, make, map, recurse, ref, renderables, self, target;
			if (typeof trait === 'boolean') {
				print = trait;
				trait = null;
			}
			if (print == null) {
				print = true;
			}
			map = function(node) {
				var ref, ref1;
				return (ref = (ref1 = node.controller) != null ? ref1.objects : void 0) != null ? ref : [];
			};
			recurse = self = function(node, list) {
				var child, j, len, ref;
				if (list == null) {
					list = [];
				}
				if (!trait || node.traits.hash[trait]) {
					list.push(map(node));
				}
				if (node.children != null) {
					ref = node.children;
					for (j = 0, len = ref.length; j < len; j++) {
						child = ref[j];
						self(child, list);
					}
				}
				return list;
			};
			flatten = function(list) {
				list = list.reduce((function(a, b) {
					return a.concat(b);
				}), []);
				return list = list.filter(function(x, i) {
					return (x != null) && list.indexOf(x) === i;
				});
			};
			make = function(renderable, render) {
				var d;
				d = {};
				d.owner = renderable;
				d.geometry = render.geometry;
				d.material = render.material;
				d.vertex = render.material.vertexGraph;
				d.fragment = render.material.fragmentGraph;
				return d;
			};
			info = {
				nodes: this._targets.slice(),
				renderables: [],
				renders: [],
				shaders: []
			};
			ref = this._targets;
			for (j = 0, len = ref.length; j < len; j++) {
				target = ref[j];
				if (print) {
					target.print(selector, 'info');
				}
				_info = {
					renderables: renderables = flatten(recurse(target)),
					renders: flatten(renderables.map(function(x) {
						return x.renders;
					})),
					shaders: flatten(renderables.map(function(x) {
						var ref1;
						return (ref1 = x.renders) != null ? ref1.map(function(r) {
							return make(x, r);
						}) : void 0;
					}))
				};
				for (k in _info) {
					info[k] = info[k].concat(_info[k]);
				}
			}
			return info;
		};
	
		return API;
	
	})();
	
	module.exports = API;
	
	
	/***/ }),
	/* 236 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var Controller, Util;
	
	Util = __webpack_require__(0);
	
	Controller = (function() {
		function Controller(model, primitives) {
			this.model = model;
			this.primitives = primitives;
		}
	
		Controller.prototype.getRoot = function() {
			return this.model.getRoot();
		};
	
		Controller.prototype.getTypes = function() {
			return this.primitives.getTypes();
		};
	
		Controller.prototype.make = function(type, options, binds) {
			return this.primitives.make(type, options, binds);
		};
	
		Controller.prototype.get = function(node, key) {
			return node.get(key);
		};
	
		Controller.prototype.set = function(node, key, value) {
			var e;
			try {
				return node.set(key, value);
			} catch (error) {
				e = error;
				node.print(null, 'warn');
				return console.error(e);
			}
		};
	
		Controller.prototype.bind = function(node, key, expr) {
			var e;
			try {
				return node.bind(key, expr);
			} catch (error) {
				e = error;
				node.print(null, 'warn');
				return console.error(e);
			}
		};
	
		Controller.prototype.unbind = function(node, key) {
			var e;
			try {
				return node.unbind(key);
			} catch (error) {
				e = error;
				node.print(null, 'warn');
				return console.error(e);
			}
		};
	
		Controller.prototype.add = function(node, target) {
			if (target == null) {
				target = this.model.getRoot();
			}
			return target.add(node);
		};
	
		Controller.prototype.remove = function(node) {
			var target;
			target = node.parent;
			if (target) {
				return target.remove(node);
			}
		};
	
		return Controller;
	
	})();
	
	module.exports = Controller;
	
	
	/***/ }),
	/* 237 */
	/***/ (function(module, exports, __webpack_require__) {
	
	var THREE;
	
	THREE = __webpack_require__(1);
	
	THREE.Bootstrap.registerPlugin('splash', {
		defaults: {
			color: 'mono',
			fancy: true
		},
		listen: ['ready', 'mathbox/init:init', 'mathbox/progress:progress', 'mathbox/destroy:destroy'],
		uninstall: function() {
			return this.destroy();
		},
		ready: function(event, three) {
			if (three.MathBox && !this.div) {
				return init(event, three);
			}
		},
		init: function(event, three) {
			var color, div, html, l, x, y, z;
			this.destroy();
			color = this.options.color;
			html = "<div class=\"mathbox-loader mathbox-splash-" + color + "\">\n  <div class=\"mathbox-logo\">\n    <div> <div></div><div></div><div></div> </div>\n    <div> <div></div><div></div><div></div> </div>\n  </div>\n  <div class=\"mathbox-progress\"><div></div></div>\n</div>";
			this.div = div = document.createElement('div');
			div.innerHTML = html;
			three.element.appendChild(div);
			x = Math.random() * 2 - 1;
			y = Math.random() * 2 - 1;
			z = Math.random() * 2 - 1;
			l = 1 / Math.sqrt(x * x + y * y + z * z);
			this.loader = div.querySelector('.mathbox-loader');
			this.bar = div.querySelector('.mathbox-progress > div');
			this.gyro = div.querySelectorAll('.mathbox-logo > div');
			this.transforms = ["rotateZ(22deg) rotateX(24deg) rotateY(30deg)", "rotateZ(11deg) rotateX(12deg) rotateY(15deg) scale3d(.6, .6, .6)"];
			this.random = [x * l, y * l, z * l];
			this.start = three.Time.now;
			return this.timer = null;
		},
		progress: function(event, three) {
			var current, el, f, i, increment, k, len, ref, results, t, total, visible, weights, width;
			if (!this.div) {
				return;
			}
			current = event.current, total = event.total;
			visible = current < total;
			clearTimeout(this.timer);
			if (visible) {
				this.loader.classList.remove('mathbox-exit');
				this.loader.style.display = 'block';
			} else {
				this.loader.classList.add('mathbox-exit');
				this.timer = setTimeout(((function(_this) {
					return function() {
						return _this.loader.style.display = 'none';
					};
				})(this)), 150);
			}
			width = current < total ? (Math.round(1000 * current / total) * .1) + '%' : '100%';
			this.bar.style.width = width;
			if (this.options.fancy) {
				weights = this.random;
				f = Math.max(0, Math.min(1, three.Time.now - this.start));
				increment = function(transform, j) {
					if (j == null) {
						j = 0;
					}
					return transform.replace(/(-?[0-9.e]+)deg/g, function(_, n) {
						return (+n + weights[j++] * f * three.Time.step * 60) + 'deg';
					});
				};
				ref = this.gyro;
				results = [];
				for (i = k = 0, len = ref.length; k < len; i = ++k) {
					el = ref[i];
					this.transforms[i] = t = increment(this.transforms[i]);
					results.push(el.style.transform = el.style.WebkitTransform = t);
				}
				return results;
			}
		},
		destroy: function() {
			var ref;
			if ((ref = this.div) != null) {
				ref.remove();
			}
			return this.div = null;
		}
	});
	
	
	/***/ })
	/******/ ]);